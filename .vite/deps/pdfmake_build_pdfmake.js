import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// node_modules/pdfmake/build/pdfmake.js
var require_pdfmake = __commonJS({
  "node_modules/pdfmake/build/pdfmake.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else {
        var a = factory();
        for (var i in a) (typeof exports === "object" ? exports : root)[i] = a[i];
      }
    })(Object(typeof self !== "undefined" ? self : exports), () => {
      return (
        /******/
        (() => {
          var __webpack_modules__ = {
            /***/
            78(module2) {
              "use strict";
              module2.exports = Function.prototype.call;
            },
            /***/
            182(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              function ownKeys(object, enumerableOnly) {
                var keys = Object.keys(object);
                if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(object);
                  enumerableOnly && (symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  })), keys.push.apply(keys, symbols);
                }
                return keys;
              }
              function _objectSpread(target) {
                for (var i = 1; i < arguments.length; i++) {
                  var source = null != arguments[i] ? arguments[i] : {};
                  i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
                    _defineProperty(target, key, source[key]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
                return target;
              }
              function _defineProperty(obj, key, value) {
                key = _toPropertyKey(key);
                if (key in obj) {
                  Object.defineProperty(obj, key, {
                    value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                  });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                }
              }
              function _createClass(Constructor, protoProps, staticProps) {
                if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                if (staticProps) _defineProperties(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", {
                  writable: false
                });
                return Constructor;
              }
              function _toPropertyKey(arg) {
                var key = _toPrimitive(arg, "string");
                return typeof key === "symbol" ? key : String(key);
              }
              function _toPrimitive(input, hint) {
                if (typeof input !== "object" || input === null) return input;
                var prim = input[Symbol.toPrimitive];
                if (prim !== void 0) {
                  var res = prim.call(input, hint || "default");
                  if (typeof res !== "object") return res;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return (hint === "string" ? String : Number)(input);
              }
              var _require = __webpack_require__2(783), Buffer = _require.Buffer;
              var _require2 = __webpack_require__2(3779), inspect = _require2.inspect;
              var custom = inspect && inspect.custom || "inspect";
              function copyBuffer(src, target, offset) {
                Buffer.prototype.copy.call(src, target, offset);
              }
              module2.exports = function() {
                function BufferList() {
                  _classCallCheck(this, BufferList);
                  this.head = null;
                  this.tail = null;
                  this.length = 0;
                }
                _createClass(BufferList, [{
                  key: "push",
                  value: function push(v) {
                    var entry = {
                      data: v,
                      next: null
                    };
                    if (this.length > 0) this.tail.next = entry;
                    else this.head = entry;
                    this.tail = entry;
                    ++this.length;
                  }
                }, {
                  key: "unshift",
                  value: function unshift(v) {
                    var entry = {
                      data: v,
                      next: this.head
                    };
                    if (this.length === 0) this.tail = entry;
                    this.head = entry;
                    ++this.length;
                  }
                }, {
                  key: "shift",
                  value: function shift() {
                    if (this.length === 0) return;
                    var ret = this.head.data;
                    if (this.length === 1) this.head = this.tail = null;
                    else this.head = this.head.next;
                    --this.length;
                    return ret;
                  }
                }, {
                  key: "clear",
                  value: function clear() {
                    this.head = this.tail = null;
                    this.length = 0;
                  }
                }, {
                  key: "join",
                  value: function join(s) {
                    if (this.length === 0) return "";
                    var p = this.head;
                    var ret = "" + p.data;
                    while (p = p.next) ret += s + p.data;
                    return ret;
                  }
                }, {
                  key: "concat",
                  value: function concat(n) {
                    if (this.length === 0) return Buffer.alloc(0);
                    var ret = Buffer.allocUnsafe(n >>> 0);
                    var p = this.head;
                    var i = 0;
                    while (p) {
                      copyBuffer(p.data, ret, i);
                      i += p.data.length;
                      p = p.next;
                    }
                    return ret;
                  }
                  // Consumes a specified amount of bytes or characters from the buffered data.
                }, {
                  key: "consume",
                  value: function consume(n, hasStrings) {
                    var ret;
                    if (n < this.head.data.length) {
                      ret = this.head.data.slice(0, n);
                      this.head.data = this.head.data.slice(n);
                    } else if (n === this.head.data.length) {
                      ret = this.shift();
                    } else {
                      ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                    }
                    return ret;
                  }
                }, {
                  key: "first",
                  value: function first() {
                    return this.head.data;
                  }
                  // Consumes a specified amount of characters from the buffered data.
                }, {
                  key: "_getString",
                  value: function _getString(n) {
                    var p = this.head;
                    var c = 1;
                    var ret = p.data;
                    n -= ret.length;
                    while (p = p.next) {
                      var str = p.data;
                      var nb = n > str.length ? str.length : n;
                      if (nb === str.length) ret += str;
                      else ret += str.slice(0, n);
                      n -= nb;
                      if (n === 0) {
                        if (nb === str.length) {
                          ++c;
                          if (p.next) this.head = p.next;
                          else this.head = this.tail = null;
                        } else {
                          this.head = p;
                          p.data = str.slice(nb);
                        }
                        break;
                      }
                      ++c;
                    }
                    this.length -= c;
                    return ret;
                  }
                  // Consumes a specified amount of bytes from the buffered data.
                }, {
                  key: "_getBuffer",
                  value: function _getBuffer(n) {
                    var ret = Buffer.allocUnsafe(n);
                    var p = this.head;
                    var c = 1;
                    p.data.copy(ret);
                    n -= p.data.length;
                    while (p = p.next) {
                      var buf = p.data;
                      var nb = n > buf.length ? buf.length : n;
                      buf.copy(ret, ret.length - n, 0, nb);
                      n -= nb;
                      if (n === 0) {
                        if (nb === buf.length) {
                          ++c;
                          if (p.next) this.head = p.next;
                          else this.head = this.tail = null;
                        } else {
                          this.head = p;
                          p.data = buf.slice(nb);
                        }
                        break;
                      }
                      ++c;
                    }
                    this.length -= c;
                    return ret;
                  }
                  // Make sure the linked list only shows the minimal necessary information.
                }, {
                  key: custom,
                  value: function value(_, options) {
                    return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
                      // Only inspect one level.
                      depth: 0,
                      // It should not recurse.
                      customInspect: false
                    }));
                  }
                }]);
                return BufferList;
              }();
            },
            /***/
            290(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var call = __webpack_require__2(8993);
              var isCallable = __webpack_require__2(8681);
              var isObject = __webpack_require__2(3598);
              var $TypeError = TypeError;
              module2.exports = function(input, pref) {
                var fn, val;
                if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
                if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
                if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
                throw new $TypeError("Can't convert object to primitive value");
              };
            },
            /***/
            299(module2) {
              "use strict";
              module2.exports = function(exec) {
                try {
                  return !!exec();
                } catch (error) {
                  return true;
                }
              };
            },
            /***/
            321(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function(Math2) {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var WordArray = C_lib.WordArray;
                  var Hasher = C_lib.Hasher;
                  var C_algo = C.algo;
                  var H = [];
                  var K = [];
                  (function() {
                    function isPrime(n2) {
                      var sqrtN = Math2.sqrt(n2);
                      for (var factor = 2; factor <= sqrtN; factor++) {
                        if (!(n2 % factor)) {
                          return false;
                        }
                      }
                      return true;
                    }
                    function getFractionalBits(n2) {
                      return (n2 - (n2 | 0)) * 4294967296 | 0;
                    }
                    var n = 2;
                    var nPrime = 0;
                    while (nPrime < 64) {
                      if (isPrime(n)) {
                        if (nPrime < 8) {
                          H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
                        }
                        K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
                        nPrime++;
                      }
                      n++;
                    }
                  })();
                  var W = [];
                  var SHA256 = C_algo.SHA256 = Hasher.extend({
                    _doReset: function() {
                      this._hash = new WordArray.init(H.slice(0));
                    },
                    _doProcessBlock: function(M, offset) {
                      var H2 = this._hash.words;
                      var a = H2[0];
                      var b = H2[1];
                      var c = H2[2];
                      var d = H2[3];
                      var e = H2[4];
                      var f = H2[5];
                      var g = H2[6];
                      var h = H2[7];
                      for (var i = 0; i < 64; i++) {
                        if (i < 16) {
                          W[i] = M[offset + i] | 0;
                        } else {
                          var gamma0x = W[i - 15];
                          var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                          var gamma1x = W[i - 2];
                          var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                          W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                        }
                        var ch = e & f ^ ~e & g;
                        var maj = a & b ^ a & c ^ b & c;
                        var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
                        var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
                        var t1 = h + sigma1 + ch + K[i] + W[i];
                        var t2 = sigma0 + maj;
                        h = g;
                        g = f;
                        f = e;
                        e = d + t1 | 0;
                        d = c;
                        c = b;
                        b = a;
                        a = t1 + t2 | 0;
                      }
                      H2[0] = H2[0] + a | 0;
                      H2[1] = H2[1] + b | 0;
                      H2[2] = H2[2] + c | 0;
                      H2[3] = H2[3] + d | 0;
                      H2[4] = H2[4] + e | 0;
                      H2[5] = H2[5] + f | 0;
                      H2[6] = H2[6] + g | 0;
                      H2[7] = H2[7] + h | 0;
                    },
                    _doFinalize: function() {
                      var data = this._data;
                      var dataWords = data.words;
                      var nBitsTotal = this._nDataBytes * 8;
                      var nBitsLeft = data.sigBytes * 8;
                      dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                      dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
                      dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                      data.sigBytes = dataWords.length * 4;
                      this._process();
                      return this._hash;
                    },
                    clone: function() {
                      var clone = Hasher.clone.call(this);
                      clone._hash = this._hash.clone();
                      return clone;
                    }
                  });
                  C.SHA256 = Hasher._createHelper(SHA256);
                  C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
                })(Math);
                return CryptoJS.SHA256;
              });
            },
            /***/
            336(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var Buffer = __webpack_require__2(783)["Buffer"];
              const fs = __webpack_require__2(2416);
              const zlib = __webpack_require__2(6729);
              module2.exports = class PNG {
                static decode(path, fn) {
                  return fs.readFile(path, function(err, file) {
                    const png = new PNG(file);
                    return png.decode((pixels) => fn(pixels));
                  });
                }
                static load(path) {
                  const file = fs.readFileSync(path);
                  return new PNG(file);
                }
                constructor(data) {
                  let i;
                  this.data = data;
                  this.pos = 8;
                  this.palette = [];
                  this.imgData = [];
                  this.transparency = {};
                  this.text = {};
                  while (true) {
                    const chunkSize = this.readUInt32();
                    let section = "";
                    for (i = 0; i < 4; i++) {
                      section += String.fromCharCode(this.data[this.pos++]);
                    }
                    switch (section) {
                      case "IHDR":
                        this.width = this.readUInt32();
                        this.height = this.readUInt32();
                        this.bits = this.data[this.pos++];
                        this.colorType = this.data[this.pos++];
                        this.compressionMethod = this.data[this.pos++];
                        this.filterMethod = this.data[this.pos++];
                        this.interlaceMethod = this.data[this.pos++];
                        break;
                      case "PLTE":
                        this.palette = this.read(chunkSize);
                        break;
                      case "IDAT":
                        for (i = 0; i < chunkSize; i++) {
                          this.imgData.push(this.data[this.pos++]);
                        }
                        break;
                      case "tRNS":
                        this.transparency = {};
                        switch (this.colorType) {
                          case 3:
                            this.transparency.indexed = this.read(chunkSize);
                            var short = 255 - this.transparency.indexed.length;
                            if (short > 0) {
                              for (i = 0; i < short; i++) {
                                this.transparency.indexed.push(255);
                              }
                            }
                            break;
                          case 0:
                            this.transparency.grayscale = this.read(chunkSize)[0];
                            break;
                          case 2:
                            this.transparency.rgb = this.read(chunkSize);
                            break;
                        }
                        break;
                      case "tEXt":
                        var text = this.read(chunkSize);
                        var index = text.indexOf(0);
                        var key = String.fromCharCode.apply(String, text.slice(0, index));
                        this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));
                        break;
                      case "IEND":
                        switch (this.colorType) {
                          case 0:
                          case 3:
                          case 4:
                            this.colors = 1;
                            break;
                          case 2:
                          case 6:
                            this.colors = 3;
                            break;
                        }
                        this.hasAlphaChannel = [4, 6].includes(this.colorType);
                        var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
                        this.pixelBitlength = this.bits * colors;
                        switch (this.colors) {
                          case 1:
                            this.colorSpace = "DeviceGray";
                            break;
                          case 3:
                            this.colorSpace = "DeviceRGB";
                            break;
                        }
                        this.imgData = new Buffer(this.imgData);
                        return;
                      default:
                        this.pos += chunkSize;
                    }
                    this.pos += 4;
                    if (this.pos > this.data.length) {
                      throw new Error("Incomplete or corrupt PNG file");
                    }
                  }
                }
                read(bytes) {
                  const result = new Array(bytes);
                  for (let i = 0; i < bytes; i++) {
                    result[i] = this.data[this.pos++];
                  }
                  return result;
                }
                readUInt32() {
                  const b1 = this.data[this.pos++] << 24;
                  const b2 = this.data[this.pos++] << 16;
                  const b3 = this.data[this.pos++] << 8;
                  const b4 = this.data[this.pos++];
                  return b1 | b2 | b3 | b4;
                }
                readUInt16() {
                  const b1 = this.data[this.pos++] << 8;
                  const b2 = this.data[this.pos++];
                  return b1 | b2;
                }
                decodePixels(fn) {
                  return zlib.inflate(this.imgData, (err, data) => {
                    if (err) {
                      throw err;
                    }
                    const {
                      width,
                      height
                    } = this;
                    const pixelBytes = this.pixelBitlength / 8;
                    const pixels = new Buffer(width * height * pixelBytes);
                    const {
                      length
                    } = data;
                    let pos = 0;
                    function pass(x0, y0, dx, dy, singlePass) {
                      if (singlePass === void 0) {
                        singlePass = false;
                      }
                      const w = Math.ceil((width - x0) / dx);
                      const h = Math.ceil((height - y0) / dy);
                      const scanlineLength = pixelBytes * w;
                      const buffer = singlePass ? pixels : new Buffer(scanlineLength * h);
                      let row = 0;
                      let c = 0;
                      while (row < h && pos < length) {
                        var byte, col, i, left, upper;
                        switch (data[pos++]) {
                          case 0:
                            for (i = 0; i < scanlineLength; i++) {
                              buffer[c++] = data[pos++];
                            }
                            break;
                          case 1:
                            for (i = 0; i < scanlineLength; i++) {
                              byte = data[pos++];
                              left = i < pixelBytes ? 0 : buffer[c - pixelBytes];
                              buffer[c++] = (byte + left) % 256;
                            }
                            break;
                          case 2:
                            for (i = 0; i < scanlineLength; i++) {
                              byte = data[pos++];
                              col = (i - i % pixelBytes) / pixelBytes;
                              upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                              buffer[c++] = (upper + byte) % 256;
                            }
                            break;
                          case 3:
                            for (i = 0; i < scanlineLength; i++) {
                              byte = data[pos++];
                              col = (i - i % pixelBytes) / pixelBytes;
                              left = i < pixelBytes ? 0 : buffer[c - pixelBytes];
                              upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                              buffer[c++] = (byte + Math.floor((left + upper) / 2)) % 256;
                            }
                            break;
                          case 4:
                            for (i = 0; i < scanlineLength; i++) {
                              var paeth, upperLeft;
                              byte = data[pos++];
                              col = (i - i % pixelBytes) / pixelBytes;
                              left = i < pixelBytes ? 0 : buffer[c - pixelBytes];
                              if (row === 0) {
                                upper = upperLeft = 0;
                              } else {
                                upper = buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                                upperLeft = col && buffer[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];
                              }
                              const p = left + upper - upperLeft;
                              const pa = Math.abs(p - left);
                              const pb = Math.abs(p - upper);
                              const pc = Math.abs(p - upperLeft);
                              if (pa <= pb && pa <= pc) {
                                paeth = left;
                              } else if (pb <= pc) {
                                paeth = upper;
                              } else {
                                paeth = upperLeft;
                              }
                              buffer[c++] = (byte + paeth) % 256;
                            }
                            break;
                          default:
                            throw new Error(`Invalid filter algorithm: ${data[pos - 1]}`);
                        }
                        if (!singlePass) {
                          let pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;
                          let bufferPos = row * scanlineLength;
                          for (i = 0; i < w; i++) {
                            for (let j = 0; j < pixelBytes; j++) pixels[pixelsPos++] = buffer[bufferPos++];
                            pixelsPos += (dx - 1) * pixelBytes;
                          }
                        }
                        row++;
                      }
                    }
                    if (this.interlaceMethod === 1) {
                      pass(0, 0, 8, 8);
                      pass(4, 0, 8, 8);
                      pass(0, 4, 4, 8);
                      pass(2, 0, 4, 4);
                      pass(0, 2, 2, 4);
                      pass(1, 0, 2, 2);
                      pass(0, 1, 1, 2);
                    } else {
                      pass(0, 0, 1, 1, true);
                    }
                    return fn(pixels);
                  });
                }
                decodePalette() {
                  const {
                    palette
                  } = this;
                  const {
                    length
                  } = palette;
                  const transparency = this.transparency.indexed || [];
                  const ret = new Buffer(transparency.length + length);
                  let pos = 0;
                  let c = 0;
                  for (let i = 0; i < length; i += 3) {
                    var left;
                    ret[pos++] = palette[i];
                    ret[pos++] = palette[i + 1];
                    ret[pos++] = palette[i + 2];
                    ret[pos++] = (left = transparency[c++]) != null ? left : 255;
                  }
                  return ret;
                }
                copyToImageData(imageData, pixels) {
                  let j, k;
                  let {
                    colors
                  } = this;
                  let palette = null;
                  let alpha = this.hasAlphaChannel;
                  if (this.palette.length) {
                    palette = this._decodedPalette || (this._decodedPalette = this.decodePalette());
                    colors = 4;
                    alpha = true;
                  }
                  const data = imageData.data || imageData;
                  const {
                    length
                  } = data;
                  const input = palette || pixels;
                  let i = j = 0;
                  if (colors === 1) {
                    while (i < length) {
                      k = palette ? pixels[i / 4] * 4 : j;
                      const v = input[k++];
                      data[i++] = v;
                      data[i++] = v;
                      data[i++] = v;
                      data[i++] = alpha ? input[k++] : 255;
                      j = k;
                    }
                  } else {
                    while (i < length) {
                      k = palette ? pixels[i / 4] * 4 : j;
                      data[i++] = input[k++];
                      data[i++] = input[k++];
                      data[i++] = input[k++];
                      data[i++] = alpha ? input[k++] : 255;
                      j = k;
                    }
                  }
                }
                decode(fn) {
                  const ret = new Buffer(this.width * this.height * 4);
                  return this.decodePixels((pixels) => {
                    this.copyToImageData(ret, pixels);
                    return fn(ret);
                  });
                }
              };
            },
            /***/
            378(module2) {
              module2.exports = function() {
                throw new Error("Readable.from is not available in the browser");
              };
            },
            /***/
            443(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var uncurryThisAccessor = __webpack_require__2(4494);
              var isObject = __webpack_require__2(3598);
              var requireObjectCoercible = __webpack_require__2(5034);
              var aPossiblePrototype = __webpack_require__2(7222);
              module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
                var CORRECT_SETTER = false;
                var test = {};
                var setter;
                try {
                  setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
                  setter(test, []);
                  CORRECT_SETTER = test instanceof Array;
                } catch (error) {
                }
                return function setPrototypeOf(O, proto) {
                  requireObjectCoercible(O);
                  aPossiblePrototype(proto);
                  if (!isObject(O)) return O;
                  if (CORRECT_SETTER) setter(O, proto);
                  else O.__proto__ = proto;
                  return O;
                };
              }() : void 0);
            },
            /***/
            453(module2) {
              "use strict";
              module2.exports = function equal(a, b) {
                if (a === b) return true;
                if (a && b && typeof a == "object" && typeof b == "object") {
                  if (a.constructor !== b.constructor) return false;
                  var length, i, keys;
                  if (Array.isArray(a)) {
                    length = a.length;
                    if (length != b.length) return false;
                    for (i = length; i-- !== 0; )
                      if (!equal(a[i], b[i])) return false;
                    return true;
                  }
                  if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
                  if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
                  if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
                  keys = Object.keys(a);
                  length = keys.length;
                  if (length !== Object.keys(b).length) return false;
                  for (i = length; i-- !== 0; )
                    if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
                  for (i = length; i-- !== 0; ) {
                    var key = keys[i];
                    if (!equal(a[key], b[key])) return false;
                  }
                  return true;
                }
                return a !== a && b !== b;
              };
            },
            /***/
            477() {
            },
            /***/
            517(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(3144), __webpack_require__2(8692));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function() {
                  var C = CryptoJS;
                  var C_x64 = C.x64;
                  var X64Word = C_x64.Word;
                  var X64WordArray = C_x64.WordArray;
                  var C_algo = C.algo;
                  var SHA512 = C_algo.SHA512;
                  var SHA384 = C_algo.SHA384 = SHA512.extend({
                    _doReset: function() {
                      this._hash = new X64WordArray.init([new X64Word.init(3418070365, 3238371032), new X64Word.init(1654270250, 914150663), new X64Word.init(2438529370, 812702999), new X64Word.init(355462360, 4144912697), new X64Word.init(1731405415, 4290775857), new X64Word.init(2394180231, 1750603025), new X64Word.init(3675008525, 1694076839), new X64Word.init(1203062813, 3204075428)]);
                    },
                    _doFinalize: function() {
                      var hash = SHA512._doFinalize.call(this);
                      hash.sigBytes -= 16;
                      return hash;
                    }
                  });
                  C.SHA384 = SHA512._createHelper(SHA384);
                  C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
                })();
                return CryptoJS.SHA384;
              });
            },
            /***/
            614(__unused_webpack_module, exports2, __webpack_require__2) {
              var data = __webpack_require__2(4543);
              exports2.init = function() {
                exports2.dictionary = data.init();
              };
              exports2.offsetsByLength = new Uint32Array([
                0,
                0,
                0,
                0,
                0,
                4096,
                9216,
                21504,
                35840,
                44032,
                53248,
                63488,
                74752,
                87040,
                93696,
                100864,
                104704,
                106752,
                108928,
                113536,
                115968,
                118528,
                119872,
                121280,
                122016
              ]);
              exports2.sizeBitsByLength = new Uint8Array([
                0,
                0,
                0,
                0,
                10,
                10,
                11,
                11,
                10,
                10,
                10,
                10,
                10,
                9,
                9,
                8,
                7,
                7,
                8,
                7,
                7,
                6,
                6,
                5,
                5
              ]);
              exports2.minDictionaryWordLength = 4;
              exports2.maxDictionaryWordLength = 24;
            },
            /***/
            644(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var arraySlice = __webpack_require__2(2740);
              var floor = Math.floor;
              var sort = function(array, comparefn) {
                var length = array.length;
                if (length < 8) {
                  var i = 1;
                  var element, j;
                  while (i < length) {
                    j = i;
                    element = array[i];
                    while (j && comparefn(array[j - 1], element) > 0) {
                      array[j] = array[--j];
                    }
                    if (j !== i++) array[j] = element;
                  }
                } else {
                  var middle = floor(length / 2);
                  var left = sort(arraySlice(array, 0, middle), comparefn);
                  var right = sort(arraySlice(array, middle), comparefn);
                  var llength = left.length;
                  var rlength = right.length;
                  var lindex = 0;
                  var rindex = 0;
                  while (lindex < llength || rindex < rlength) {
                    array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
                  }
                }
                return array;
              };
              module2.exports = sort;
            },
            /***/
            713(module2) {
              "use strict";
              module2.exports = Number.isNaN || function isNaN2(a) {
                return a !== a;
              };
            },
            /***/
            716(module2) {
              "use strict";
              module2.exports = Math.abs;
            },
            /***/
            783(__unused_webpack_module, exports2, __webpack_require__2) {
              "use strict";
              __webpack_require__2(8376);
              __webpack_require__2(6401);
              __webpack_require__2(2017);
              const base64 = __webpack_require__2(2504);
              const ieee754 = __webpack_require__2(9029);
              const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
              exports2.Buffer = Buffer;
              exports2.SlowBuffer = SlowBuffer;
              exports2.INSPECT_MAX_BYTES = 50;
              const K_MAX_LENGTH = 2147483647;
              exports2.kMaxLength = K_MAX_LENGTH;
              Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
              if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
                console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
              }
              function typedArraySupport() {
                try {
                  const arr = new Uint8Array(1);
                  const proto = {
                    foo: function() {
                      return 42;
                    }
                  };
                  Object.setPrototypeOf(proto, Uint8Array.prototype);
                  Object.setPrototypeOf(arr, proto);
                  return arr.foo() === 42;
                } catch (e) {
                  return false;
                }
              }
              Object.defineProperty(Buffer.prototype, "parent", {
                enumerable: true,
                get: function() {
                  if (!Buffer.isBuffer(this)) return void 0;
                  return this.buffer;
                }
              });
              Object.defineProperty(Buffer.prototype, "offset", {
                enumerable: true,
                get: function() {
                  if (!Buffer.isBuffer(this)) return void 0;
                  return this.byteOffset;
                }
              });
              function createBuffer(length) {
                if (length > K_MAX_LENGTH) {
                  throw new RangeError('The value "' + length + '" is invalid for option "size"');
                }
                const buf = new Uint8Array(length);
                Object.setPrototypeOf(buf, Buffer.prototype);
                return buf;
              }
              function Buffer(arg, encodingOrOffset, length) {
                if (typeof arg === "number") {
                  if (typeof encodingOrOffset === "string") {
                    throw new TypeError('The "string" argument must be of type string. Received type number');
                  }
                  return allocUnsafe(arg);
                }
                return from(arg, encodingOrOffset, length);
              }
              Buffer.poolSize = 8192;
              function from(value, encodingOrOffset, length) {
                if (typeof value === "string") {
                  return fromString(value, encodingOrOffset);
                }
                if (ArrayBuffer.isView(value)) {
                  return fromArrayView(value);
                }
                if (value == null) {
                  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
                }
                if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
                  return fromArrayBuffer(value, encodingOrOffset, length);
                }
                if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
                  return fromArrayBuffer(value, encodingOrOffset, length);
                }
                if (typeof value === "number") {
                  throw new TypeError('The "value" argument must not be of type number. Received type number');
                }
                const valueOf = value.valueOf && value.valueOf();
                if (valueOf != null && valueOf !== value) {
                  return Buffer.from(valueOf, encodingOrOffset, length);
                }
                const b = fromObject(value);
                if (b) return b;
                if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
                  return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
                }
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
              }
              Buffer.from = function(value, encodingOrOffset, length) {
                return from(value, encodingOrOffset, length);
              };
              Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
              Object.setPrototypeOf(Buffer, Uint8Array);
              function assertSize(size) {
                if (typeof size !== "number") {
                  throw new TypeError('"size" argument must be of type number');
                } else if (size < 0) {
                  throw new RangeError('The value "' + size + '" is invalid for option "size"');
                }
              }
              function alloc(size, fill, encoding) {
                assertSize(size);
                if (size <= 0) {
                  return createBuffer(size);
                }
                if (fill !== void 0) {
                  return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
                }
                return createBuffer(size);
              }
              Buffer.alloc = function(size, fill, encoding) {
                return alloc(size, fill, encoding);
              };
              function allocUnsafe(size) {
                assertSize(size);
                return createBuffer(size < 0 ? 0 : checked(size) | 0);
              }
              Buffer.allocUnsafe = function(size) {
                return allocUnsafe(size);
              };
              Buffer.allocUnsafeSlow = function(size) {
                return allocUnsafe(size);
              };
              function fromString(string, encoding) {
                if (typeof encoding !== "string" || encoding === "") {
                  encoding = "utf8";
                }
                if (!Buffer.isEncoding(encoding)) {
                  throw new TypeError("Unknown encoding: " + encoding);
                }
                const length = byteLength(string, encoding) | 0;
                let buf = createBuffer(length);
                const actual = buf.write(string, encoding);
                if (actual !== length) {
                  buf = buf.slice(0, actual);
                }
                return buf;
              }
              function fromArrayLike(array) {
                const length = array.length < 0 ? 0 : checked(array.length) | 0;
                const buf = createBuffer(length);
                for (let i = 0; i < length; i += 1) {
                  buf[i] = array[i] & 255;
                }
                return buf;
              }
              function fromArrayView(arrayView) {
                if (isInstance(arrayView, Uint8Array)) {
                  const copy = new Uint8Array(arrayView);
                  return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
                }
                return fromArrayLike(arrayView);
              }
              function fromArrayBuffer(array, byteOffset, length) {
                if (byteOffset < 0 || array.byteLength < byteOffset) {
                  throw new RangeError('"offset" is outside of buffer bounds');
                }
                if (array.byteLength < byteOffset + (length || 0)) {
                  throw new RangeError('"length" is outside of buffer bounds');
                }
                let buf;
                if (byteOffset === void 0 && length === void 0) {
                  buf = new Uint8Array(array);
                } else if (length === void 0) {
                  buf = new Uint8Array(array, byteOffset);
                } else {
                  buf = new Uint8Array(array, byteOffset, length);
                }
                Object.setPrototypeOf(buf, Buffer.prototype);
                return buf;
              }
              function fromObject(obj) {
                if (Buffer.isBuffer(obj)) {
                  const len = checked(obj.length) | 0;
                  const buf = createBuffer(len);
                  if (buf.length === 0) {
                    return buf;
                  }
                  obj.copy(buf, 0, 0, len);
                  return buf;
                }
                if (obj.length !== void 0) {
                  if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                    return createBuffer(0);
                  }
                  return fromArrayLike(obj);
                }
                if (obj.type === "Buffer" && Array.isArray(obj.data)) {
                  return fromArrayLike(obj.data);
                }
              }
              function checked(length) {
                if (length >= K_MAX_LENGTH) {
                  throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
                }
                return length | 0;
              }
              function SlowBuffer(length) {
                if (+length != length) {
                  length = 0;
                }
                return Buffer.alloc(+length);
              }
              Buffer.isBuffer = function isBuffer(b) {
                return b != null && b._isBuffer === true && b !== Buffer.prototype;
              };
              Buffer.compare = function compare(a, b) {
                if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
                if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
                if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                  throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                }
                if (a === b) return 0;
                let x = a.length;
                let y = b.length;
                for (let i = 0, len = Math.min(x, y); i < len; ++i) {
                  if (a[i] !== b[i]) {
                    x = a[i];
                    y = b[i];
                    break;
                  }
                }
                if (x < y) return -1;
                if (y < x) return 1;
                return 0;
              };
              Buffer.isEncoding = function isEncoding(encoding) {
                switch (String(encoding).toLowerCase()) {
                  case "hex":
                  case "utf8":
                  case "utf-8":
                  case "ascii":
                  case "latin1":
                  case "binary":
                  case "base64":
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return true;
                  default:
                    return false;
                }
              };
              Buffer.concat = function concat(list, length) {
                if (!Array.isArray(list)) {
                  throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (list.length === 0) {
                  return Buffer.alloc(0);
                }
                let i;
                if (length === void 0) {
                  length = 0;
                  for (i = 0; i < list.length; ++i) {
                    length += list[i].length;
                  }
                }
                const buffer = Buffer.allocUnsafe(length);
                let pos = 0;
                for (i = 0; i < list.length; ++i) {
                  let buf = list[i];
                  if (isInstance(buf, Uint8Array)) {
                    if (pos + buf.length > buffer.length) {
                      if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                      buf.copy(buffer, pos);
                    } else {
                      Uint8Array.prototype.set.call(buffer, buf, pos);
                    }
                  } else if (!Buffer.isBuffer(buf)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                  } else {
                    buf.copy(buffer, pos);
                  }
                  pos += buf.length;
                }
                return buffer;
              };
              function byteLength(string, encoding) {
                if (Buffer.isBuffer(string)) {
                  return string.length;
                }
                if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                  return string.byteLength;
                }
                if (typeof string !== "string") {
                  throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
                }
                const len = string.length;
                const mustMatch = arguments.length > 2 && arguments[2] === true;
                if (!mustMatch && len === 0) return 0;
                let loweredCase = false;
                for (; ; ) {
                  switch (encoding) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                      return len;
                    case "utf8":
                    case "utf-8":
                      return utf8ToBytes(string).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return len * 2;
                    case "hex":
                      return len >>> 1;
                    case "base64":
                      return base64ToBytes(string).length;
                    default:
                      if (loweredCase) {
                        return mustMatch ? -1 : utf8ToBytes(string).length;
                      }
                      encoding = ("" + encoding).toLowerCase();
                      loweredCase = true;
                  }
                }
              }
              Buffer.byteLength = byteLength;
              function slowToString(encoding, start, end) {
                let loweredCase = false;
                if (start === void 0 || start < 0) {
                  start = 0;
                }
                if (start > this.length) {
                  return "";
                }
                if (end === void 0 || end > this.length) {
                  end = this.length;
                }
                if (end <= 0) {
                  return "";
                }
                end >>>= 0;
                start >>>= 0;
                if (end <= start) {
                  return "";
                }
                if (!encoding) encoding = "utf8";
                while (true) {
                  switch (encoding) {
                    case "hex":
                      return hexSlice(this, start, end);
                    case "utf8":
                    case "utf-8":
                      return utf8Slice(this, start, end);
                    case "ascii":
                      return asciiSlice(this, start, end);
                    case "latin1":
                    case "binary":
                      return latin1Slice(this, start, end);
                    case "base64":
                      return base64Slice(this, start, end);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return utf16leSlice(this, start, end);
                    default:
                      if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                      encoding = (encoding + "").toLowerCase();
                      loweredCase = true;
                  }
                }
              }
              Buffer.prototype._isBuffer = true;
              function swap(b, n, m) {
                const i = b[n];
                b[n] = b[m];
                b[m] = i;
              }
              Buffer.prototype.swap16 = function swap16() {
                const len = this.length;
                if (len % 2 !== 0) {
                  throw new RangeError("Buffer size must be a multiple of 16-bits");
                }
                for (let i = 0; i < len; i += 2) {
                  swap(this, i, i + 1);
                }
                return this;
              };
              Buffer.prototype.swap32 = function swap32() {
                const len = this.length;
                if (len % 4 !== 0) {
                  throw new RangeError("Buffer size must be a multiple of 32-bits");
                }
                for (let i = 0; i < len; i += 4) {
                  swap(this, i, i + 3);
                  swap(this, i + 1, i + 2);
                }
                return this;
              };
              Buffer.prototype.swap64 = function swap64() {
                const len = this.length;
                if (len % 8 !== 0) {
                  throw new RangeError("Buffer size must be a multiple of 64-bits");
                }
                for (let i = 0; i < len; i += 8) {
                  swap(this, i, i + 7);
                  swap(this, i + 1, i + 6);
                  swap(this, i + 2, i + 5);
                  swap(this, i + 3, i + 4);
                }
                return this;
              };
              Buffer.prototype.toString = function toString() {
                const length = this.length;
                if (length === 0) return "";
                if (arguments.length === 0) return utf8Slice(this, 0, length);
                return slowToString.apply(this, arguments);
              };
              Buffer.prototype.toLocaleString = Buffer.prototype.toString;
              Buffer.prototype.equals = function equals(b) {
                if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
                if (this === b) return true;
                return Buffer.compare(this, b) === 0;
              };
              Buffer.prototype.inspect = function inspect() {
                let str = "";
                const max = exports2.INSPECT_MAX_BYTES;
                str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
                if (this.length > max) str += " ... ";
                return "<Buffer " + str + ">";
              };
              if (customInspectSymbol) {
                Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
              }
              Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                if (isInstance(target, Uint8Array)) {
                  target = Buffer.from(target, target.offset, target.byteLength);
                }
                if (!Buffer.isBuffer(target)) {
                  throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
                }
                if (start === void 0) {
                  start = 0;
                }
                if (end === void 0) {
                  end = target ? target.length : 0;
                }
                if (thisStart === void 0) {
                  thisStart = 0;
                }
                if (thisEnd === void 0) {
                  thisEnd = this.length;
                }
                if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                  throw new RangeError("out of range index");
                }
                if (thisStart >= thisEnd && start >= end) {
                  return 0;
                }
                if (thisStart >= thisEnd) {
                  return -1;
                }
                if (start >= end) {
                  return 1;
                }
                start >>>= 0;
                end >>>= 0;
                thisStart >>>= 0;
                thisEnd >>>= 0;
                if (this === target) return 0;
                let x = thisEnd - thisStart;
                let y = end - start;
                const len = Math.min(x, y);
                const thisCopy = this.slice(thisStart, thisEnd);
                const targetCopy = target.slice(start, end);
                for (let i = 0; i < len; ++i) {
                  if (thisCopy[i] !== targetCopy[i]) {
                    x = thisCopy[i];
                    y = targetCopy[i];
                    break;
                  }
                }
                if (x < y) return -1;
                if (y < x) return 1;
                return 0;
              };
              function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                if (buffer.length === 0) return -1;
                if (typeof byteOffset === "string") {
                  encoding = byteOffset;
                  byteOffset = 0;
                } else if (byteOffset > 2147483647) {
                  byteOffset = 2147483647;
                } else if (byteOffset < -2147483648) {
                  byteOffset = -2147483648;
                }
                byteOffset = +byteOffset;
                if (numberIsNaN(byteOffset)) {
                  byteOffset = dir ? 0 : buffer.length - 1;
                }
                if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
                if (byteOffset >= buffer.length) {
                  if (dir) return -1;
                  else byteOffset = buffer.length - 1;
                } else if (byteOffset < 0) {
                  if (dir) byteOffset = 0;
                  else return -1;
                }
                if (typeof val === "string") {
                  val = Buffer.from(val, encoding);
                }
                if (Buffer.isBuffer(val)) {
                  if (val.length === 0) {
                    return -1;
                  }
                  return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                } else if (typeof val === "number") {
                  val = val & 255;
                  if (typeof Uint8Array.prototype.indexOf === "function") {
                    if (dir) {
                      return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                    } else {
                      return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                    }
                  }
                  return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
                }
                throw new TypeError("val must be string, number or Buffer");
              }
              function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                let indexSize = 1;
                let arrLength = arr.length;
                let valLength = val.length;
                if (encoding !== void 0) {
                  encoding = String(encoding).toLowerCase();
                  if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                    if (arr.length < 2 || val.length < 2) {
                      return -1;
                    }
                    indexSize = 2;
                    arrLength /= 2;
                    valLength /= 2;
                    byteOffset /= 2;
                  }
                }
                function read(buf, i2) {
                  if (indexSize === 1) {
                    return buf[i2];
                  } else {
                    return buf.readUInt16BE(i2 * indexSize);
                  }
                }
                let i;
                if (dir) {
                  let foundIndex = -1;
                  for (i = byteOffset; i < arrLength; i++) {
                    if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                      if (foundIndex === -1) foundIndex = i;
                      if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                    } else {
                      if (foundIndex !== -1) i -= i - foundIndex;
                      foundIndex = -1;
                    }
                  }
                } else {
                  if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                  for (i = byteOffset; i >= 0; i--) {
                    let found = true;
                    for (let j = 0; j < valLength; j++) {
                      if (read(arr, i + j) !== read(val, j)) {
                        found = false;
                        break;
                      }
                    }
                    if (found) return i;
                  }
                }
                return -1;
              }
              Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
                return this.indexOf(val, byteOffset, encoding) !== -1;
              };
              Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
              };
              Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
              };
              function hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0;
                const remaining = buf.length - offset;
                if (!length) {
                  length = remaining;
                } else {
                  length = Number(length);
                  if (length > remaining) {
                    length = remaining;
                  }
                }
                const strLen = string.length;
                if (length > strLen / 2) {
                  length = strLen / 2;
                }
                let i;
                for (i = 0; i < length; ++i) {
                  const parsed = parseInt(string.substr(i * 2, 2), 16);
                  if (numberIsNaN(parsed)) return i;
                  buf[offset + i] = parsed;
                }
                return i;
              }
              function utf8Write(buf, string, offset, length) {
                return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
              }
              function asciiWrite(buf, string, offset, length) {
                return blitBuffer(asciiToBytes(string), buf, offset, length);
              }
              function base64Write(buf, string, offset, length) {
                return blitBuffer(base64ToBytes(string), buf, offset, length);
              }
              function ucs2Write(buf, string, offset, length) {
                return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
              }
              Buffer.prototype.write = function write(string, offset, length, encoding) {
                if (offset === void 0) {
                  encoding = "utf8";
                  length = this.length;
                  offset = 0;
                } else if (length === void 0 && typeof offset === "string") {
                  encoding = offset;
                  length = this.length;
                  offset = 0;
                } else if (isFinite(offset)) {
                  offset = offset >>> 0;
                  if (isFinite(length)) {
                    length = length >>> 0;
                    if (encoding === void 0) encoding = "utf8";
                  } else {
                    encoding = length;
                    length = void 0;
                  }
                } else {
                  throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                }
                const remaining = this.length - offset;
                if (length === void 0 || length > remaining) length = remaining;
                if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                  throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!encoding) encoding = "utf8";
                let loweredCase = false;
                for (; ; ) {
                  switch (encoding) {
                    case "hex":
                      return hexWrite(this, string, offset, length);
                    case "utf8":
                    case "utf-8":
                      return utf8Write(this, string, offset, length);
                    case "ascii":
                    case "latin1":
                    case "binary":
                      return asciiWrite(this, string, offset, length);
                    case "base64":
                      return base64Write(this, string, offset, length);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return ucs2Write(this, string, offset, length);
                    default:
                      if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                      encoding = ("" + encoding).toLowerCase();
                      loweredCase = true;
                  }
                }
              };
              Buffer.prototype.toJSON = function toJSON() {
                return {
                  type: "Buffer",
                  data: Array.prototype.slice.call(this._arr || this, 0)
                };
              };
              function base64Slice(buf, start, end) {
                if (start === 0 && end === buf.length) {
                  return base64.fromByteArray(buf);
                } else {
                  return base64.fromByteArray(buf.slice(start, end));
                }
              }
              function utf8Slice(buf, start, end) {
                end = Math.min(buf.length, end);
                const res = [];
                let i = start;
                while (i < end) {
                  const firstByte = buf[i];
                  let codePoint = null;
                  let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                  if (i + bytesPerSequence <= end) {
                    let secondByte, thirdByte, fourthByte, tempCodePoint;
                    switch (bytesPerSequence) {
                      case 1:
                        if (firstByte < 128) {
                          codePoint = firstByte;
                        }
                        break;
                      case 2:
                        secondByte = buf[i + 1];
                        if ((secondByte & 192) === 128) {
                          tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                          if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                          }
                        }
                        break;
                      case 3:
                        secondByte = buf[i + 1];
                        thirdByte = buf[i + 2];
                        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                          tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                          if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                          }
                        }
                        break;
                      case 4:
                        secondByte = buf[i + 1];
                        thirdByte = buf[i + 2];
                        fourthByte = buf[i + 3];
                        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                          tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                          if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                          }
                        }
                    }
                  }
                  if (codePoint === null) {
                    codePoint = 65533;
                    bytesPerSequence = 1;
                  } else if (codePoint > 65535) {
                    codePoint -= 65536;
                    res.push(codePoint >>> 10 & 1023 | 55296);
                    codePoint = 56320 | codePoint & 1023;
                  }
                  res.push(codePoint);
                  i += bytesPerSequence;
                }
                return decodeCodePointsArray(res);
              }
              const MAX_ARGUMENTS_LENGTH = 4096;
              function decodeCodePointsArray(codePoints) {
                const len = codePoints.length;
                if (len <= MAX_ARGUMENTS_LENGTH) {
                  return String.fromCharCode.apply(String, codePoints);
                }
                let res = "";
                let i = 0;
                while (i < len) {
                  res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
                }
                return res;
              }
              function asciiSlice(buf, start, end) {
                let ret = "";
                end = Math.min(buf.length, end);
                for (let i = start; i < end; ++i) {
                  ret += String.fromCharCode(buf[i] & 127);
                }
                return ret;
              }
              function latin1Slice(buf, start, end) {
                let ret = "";
                end = Math.min(buf.length, end);
                for (let i = start; i < end; ++i) {
                  ret += String.fromCharCode(buf[i]);
                }
                return ret;
              }
              function hexSlice(buf, start, end) {
                const len = buf.length;
                if (!start || start < 0) start = 0;
                if (!end || end < 0 || end > len) end = len;
                let out = "";
                for (let i = start; i < end; ++i) {
                  out += hexSliceLookupTable[buf[i]];
                }
                return out;
              }
              function utf16leSlice(buf, start, end) {
                const bytes = buf.slice(start, end);
                let res = "";
                for (let i = 0; i < bytes.length - 1; i += 2) {
                  res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
                }
                return res;
              }
              Buffer.prototype.slice = function slice(start, end) {
                const len = this.length;
                start = ~~start;
                end = end === void 0 ? len : ~~end;
                if (start < 0) {
                  start += len;
                  if (start < 0) start = 0;
                } else if (start > len) {
                  start = len;
                }
                if (end < 0) {
                  end += len;
                  if (end < 0) end = 0;
                } else if (end > len) {
                  end = len;
                }
                if (end < start) end = start;
                const newBuf = this.subarray(start, end);
                Object.setPrototypeOf(newBuf, Buffer.prototype);
                return newBuf;
              };
              function checkOffset(offset, ext, length) {
                if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
                if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
              }
              Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
                offset = offset >>> 0;
                byteLength2 = byteLength2 >>> 0;
                if (!noAssert) checkOffset(offset, byteLength2, this.length);
                let val = this[offset];
                let mul = 1;
                let i = 0;
                while (++i < byteLength2 && (mul *= 256)) {
                  val += this[offset + i] * mul;
                }
                return val;
              };
              Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
                offset = offset >>> 0;
                byteLength2 = byteLength2 >>> 0;
                if (!noAssert) {
                  checkOffset(offset, byteLength2, this.length);
                }
                let val = this[offset + --byteLength2];
                let mul = 1;
                while (byteLength2 > 0 && (mul *= 256)) {
                  val += this[offset + --byteLength2] * mul;
                }
                return val;
              };
              Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 1, this.length);
                return this[offset];
              };
              Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                return this[offset] | this[offset + 1] << 8;
              };
              Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                return this[offset] << 8 | this[offset + 1];
              };
              Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
              };
              Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
              };
              Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
                offset = offset >>> 0;
                validateNumber(offset, "offset");
                const first = this[offset];
                const last = this[offset + 7];
                if (first === void 0 || last === void 0) {
                  boundsError(offset, this.length - 8);
                }
                const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
                const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
                return BigInt(lo) + (BigInt(hi) << BigInt(32));
              });
              Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
                offset = offset >>> 0;
                validateNumber(offset, "offset");
                const first = this[offset];
                const last = this[offset + 7];
                if (first === void 0 || last === void 0) {
                  boundsError(offset, this.length - 8);
                }
                const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
                const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
                return (BigInt(hi) << BigInt(32)) + BigInt(lo);
              });
              Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
                offset = offset >>> 0;
                byteLength2 = byteLength2 >>> 0;
                if (!noAssert) checkOffset(offset, byteLength2, this.length);
                let val = this[offset];
                let mul = 1;
                let i = 0;
                while (++i < byteLength2 && (mul *= 256)) {
                  val += this[offset + i] * mul;
                }
                mul *= 128;
                if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
                return val;
              };
              Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
                offset = offset >>> 0;
                byteLength2 = byteLength2 >>> 0;
                if (!noAssert) checkOffset(offset, byteLength2, this.length);
                let i = byteLength2;
                let mul = 1;
                let val = this[offset + --i];
                while (i > 0 && (mul *= 256)) {
                  val += this[offset + --i] * mul;
                }
                mul *= 128;
                if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
                return val;
              };
              Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 1, this.length);
                if (!(this[offset] & 128)) return this[offset];
                return (255 - this[offset] + 1) * -1;
              };
              Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                const val = this[offset] | this[offset + 1] << 8;
                return val & 32768 ? val | 4294901760 : val;
              };
              Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                const val = this[offset + 1] | this[offset] << 8;
                return val & 32768 ? val | 4294901760 : val;
              };
              Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
              };
              Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
              };
              Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
                offset = offset >>> 0;
                validateNumber(offset, "offset");
                const first = this[offset];
                const last = this[offset + 7];
                if (first === void 0 || last === void 0) {
                  boundsError(offset, this.length - 8);
                }
                const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
                return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
              });
              Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
                offset = offset >>> 0;
                validateNumber(offset, "offset");
                const first = this[offset];
                const last = this[offset + 7];
                if (first === void 0 || last === void 0) {
                  boundsError(offset, this.length - 8);
                }
                const val = (first << 24) + // Overflow
                this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
                return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
              });
              Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return ieee754.read(this, offset, true, 23, 4);
              };
              Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return ieee754.read(this, offset, false, 23, 4);
              };
              Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 8, this.length);
                return ieee754.read(this, offset, true, 52, 8);
              };
              Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 8, this.length);
                return ieee754.read(this, offset, false, 52, 8);
              };
              function checkInt(buf, value, offset, ext, max, min) {
                if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
                if (offset + ext > buf.length) throw new RangeError("Index out of range");
              }
              Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset >>> 0;
                byteLength2 = byteLength2 >>> 0;
                if (!noAssert) {
                  const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                  checkInt(this, value, offset, byteLength2, maxBytes, 0);
                }
                let mul = 1;
                let i = 0;
                this[offset] = value & 255;
                while (++i < byteLength2 && (mul *= 256)) {
                  this[offset + i] = value / mul & 255;
                }
                return offset + byteLength2;
              };
              Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset >>> 0;
                byteLength2 = byteLength2 >>> 0;
                if (!noAssert) {
                  const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                  checkInt(this, value, offset, byteLength2, maxBytes, 0);
                }
                let i = byteLength2 - 1;
                let mul = 1;
                this[offset + i] = value & 255;
                while (--i >= 0 && (mul *= 256)) {
                  this[offset + i] = value / mul & 255;
                }
                return offset + byteLength2;
              };
              Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
                this[offset] = value & 255;
                return offset + 1;
              };
              Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
                this[offset] = value & 255;
                this[offset + 1] = value >>> 8;
                return offset + 2;
              };
              Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
                this[offset] = value >>> 8;
                this[offset + 1] = value & 255;
                return offset + 2;
              };
              Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
                this[offset + 3] = value >>> 24;
                this[offset + 2] = value >>> 16;
                this[offset + 1] = value >>> 8;
                this[offset] = value & 255;
                return offset + 4;
              };
              Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = value & 255;
                return offset + 4;
              };
              function wrtBigUInt64LE(buf, value, offset, min, max) {
                checkIntBI(value, min, max, buf, offset, 7);
                let lo = Number(value & BigInt(4294967295));
                buf[offset++] = lo;
                lo = lo >> 8;
                buf[offset++] = lo;
                lo = lo >> 8;
                buf[offset++] = lo;
                lo = lo >> 8;
                buf[offset++] = lo;
                let hi = Number(value >> BigInt(32) & BigInt(4294967295));
                buf[offset++] = hi;
                hi = hi >> 8;
                buf[offset++] = hi;
                hi = hi >> 8;
                buf[offset++] = hi;
                hi = hi >> 8;
                buf[offset++] = hi;
                return offset;
              }
              function wrtBigUInt64BE(buf, value, offset, min, max) {
                checkIntBI(value, min, max, buf, offset, 7);
                let lo = Number(value & BigInt(4294967295));
                buf[offset + 7] = lo;
                lo = lo >> 8;
                buf[offset + 6] = lo;
                lo = lo >> 8;
                buf[offset + 5] = lo;
                lo = lo >> 8;
                buf[offset + 4] = lo;
                let hi = Number(value >> BigInt(32) & BigInt(4294967295));
                buf[offset + 3] = hi;
                hi = hi >> 8;
                buf[offset + 2] = hi;
                hi = hi >> 8;
                buf[offset + 1] = hi;
                hi = hi >> 8;
                buf[offset] = hi;
                return offset + 8;
              }
              Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset) {
                if (offset === void 0) {
                  offset = 0;
                }
                return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
              });
              Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset) {
                if (offset === void 0) {
                  offset = 0;
                }
                return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
              });
              Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                  const limit = Math.pow(2, 8 * byteLength2 - 1);
                  checkInt(this, value, offset, byteLength2, limit - 1, -limit);
                }
                let i = 0;
                let mul = 1;
                let sub = 0;
                this[offset] = value & 255;
                while (++i < byteLength2 && (mul *= 256)) {
                  if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                    sub = 1;
                  }
                  this[offset + i] = (value / mul >> 0) - sub & 255;
                }
                return offset + byteLength2;
              };
              Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                  const limit = Math.pow(2, 8 * byteLength2 - 1);
                  checkInt(this, value, offset, byteLength2, limit - 1, -limit);
                }
                let i = byteLength2 - 1;
                let mul = 1;
                let sub = 0;
                this[offset + i] = value & 255;
                while (--i >= 0 && (mul *= 256)) {
                  if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                    sub = 1;
                  }
                  this[offset + i] = (value / mul >> 0) - sub & 255;
                }
                return offset + byteLength2;
              };
              Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
                if (value < 0) value = 255 + value + 1;
                this[offset] = value & 255;
                return offset + 1;
              };
              Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
                this[offset] = value & 255;
                this[offset + 1] = value >>> 8;
                return offset + 2;
              };
              Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
                this[offset] = value >>> 8;
                this[offset + 1] = value & 255;
                return offset + 2;
              };
              Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
                this[offset] = value & 255;
                this[offset + 1] = value >>> 8;
                this[offset + 2] = value >>> 16;
                this[offset + 3] = value >>> 24;
                return offset + 4;
              };
              Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
                if (value < 0) value = 4294967295 + value + 1;
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = value & 255;
                return offset + 4;
              };
              Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset) {
                if (offset === void 0) {
                  offset = 0;
                }
                return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
              });
              Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset) {
                if (offset === void 0) {
                  offset = 0;
                }
                return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
              });
              function checkIEEE754(buf, value, offset, ext, max, min) {
                if (offset + ext > buf.length) throw new RangeError("Index out of range");
                if (offset < 0) throw new RangeError("Index out of range");
              }
              function writeFloat(buf, value, offset, littleEndian, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                  checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
                }
                ieee754.write(buf, value, offset, littleEndian, 23, 4);
                return offset + 4;
              }
              Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                return writeFloat(this, value, offset, true, noAssert);
              };
              Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                return writeFloat(this, value, offset, false, noAssert);
              };
              function writeDouble(buf, value, offset, littleEndian, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                  checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
                }
                ieee754.write(buf, value, offset, littleEndian, 52, 8);
                return offset + 8;
              }
              Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                return writeDouble(this, value, offset, true, noAssert);
              };
              Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                return writeDouble(this, value, offset, false, noAssert);
              };
              Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
                if (!start) start = 0;
                if (!end && end !== 0) end = this.length;
                if (targetStart >= target.length) targetStart = target.length;
                if (!targetStart) targetStart = 0;
                if (end > 0 && end < start) end = start;
                if (end === start) return 0;
                if (target.length === 0 || this.length === 0) return 0;
                if (targetStart < 0) {
                  throw new RangeError("targetStart out of bounds");
                }
                if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
                if (end < 0) throw new RangeError("sourceEnd out of bounds");
                if (end > this.length) end = this.length;
                if (target.length - targetStart < end - start) {
                  end = target.length - targetStart + start;
                }
                const len = end - start;
                if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
                  this.copyWithin(targetStart, start, end);
                } else {
                  Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
                }
                return len;
              };
              Buffer.prototype.fill = function fill(val, start, end, encoding) {
                if (typeof val === "string") {
                  if (typeof start === "string") {
                    encoding = start;
                    start = 0;
                    end = this.length;
                  } else if (typeof end === "string") {
                    encoding = end;
                    end = this.length;
                  }
                  if (encoding !== void 0 && typeof encoding !== "string") {
                    throw new TypeError("encoding must be a string");
                  }
                  if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
                    throw new TypeError("Unknown encoding: " + encoding);
                  }
                  if (val.length === 1) {
                    const code = val.charCodeAt(0);
                    if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                      val = code;
                    }
                  }
                } else if (typeof val === "number") {
                  val = val & 255;
                } else if (typeof val === "boolean") {
                  val = Number(val);
                }
                if (start < 0 || this.length < start || this.length < end) {
                  throw new RangeError("Out of range index");
                }
                if (end <= start) {
                  return this;
                }
                start = start >>> 0;
                end = end === void 0 ? this.length : end >>> 0;
                if (!val) val = 0;
                let i;
                if (typeof val === "number") {
                  for (i = start; i < end; ++i) {
                    this[i] = val;
                  }
                } else {
                  const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
                  const len = bytes.length;
                  if (len === 0) {
                    throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                  }
                  for (i = 0; i < end - start; ++i) {
                    this[i + start] = bytes[i % len];
                  }
                }
                return this;
              };
              const errors = {};
              function E(sym, getMessage, Base) {
                errors[sym] = class NodeError extends Base {
                  constructor() {
                    super();
                    Object.defineProperty(this, "message", {
                      value: getMessage.apply(this, arguments),
                      writable: true,
                      configurable: true
                    });
                    this.name = `${this.name} [${sym}]`;
                    this.stack;
                    delete this.name;
                  }
                  get code() {
                    return sym;
                  }
                  set code(value) {
                    Object.defineProperty(this, "code", {
                      configurable: true,
                      enumerable: true,
                      value,
                      writable: true
                    });
                  }
                  toString() {
                    return `${this.name} [${sym}]: ${this.message}`;
                  }
                };
              }
              E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
                if (name) {
                  return `${name} is outside of buffer bounds`;
                }
                return "Attempt to access memory outside buffer bounds";
              }, RangeError);
              E("ERR_INVALID_ARG_TYPE", function(name, actual) {
                return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
              }, TypeError);
              E("ERR_OUT_OF_RANGE", function(str, range, input) {
                let msg = `The value of "${str}" is out of range.`;
                let received = input;
                if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
                  received = addNumericalSeparator(String(input));
                } else if (typeof input === "bigint") {
                  received = String(input);
                  if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
                    received = addNumericalSeparator(received);
                  }
                  received += "n";
                }
                msg += ` It must be ${range}. Received ${received}`;
                return msg;
              }, RangeError);
              function addNumericalSeparator(val) {
                let res = "";
                let i = val.length;
                const start = val[0] === "-" ? 1 : 0;
                for (; i >= start + 4; i -= 3) {
                  res = `_${val.slice(i - 3, i)}${res}`;
                }
                return `${val.slice(0, i)}${res}`;
              }
              function checkBounds(buf, offset, byteLength2) {
                validateNumber(offset, "offset");
                if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
                  boundsError(offset, buf.length - (byteLength2 + 1));
                }
              }
              function checkIntBI(value, min, max, buf, offset, byteLength2) {
                if (value > max || value < min) {
                  const n = typeof min === "bigint" ? "n" : "";
                  let range;
                  if (byteLength2 > 3) {
                    if (min === 0 || min === BigInt(0)) {
                      range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
                    } else {
                      range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
                    }
                  } else {
                    range = `>= ${min}${n} and <= ${max}${n}`;
                  }
                  throw new errors.ERR_OUT_OF_RANGE("value", range, value);
                }
                checkBounds(buf, offset, byteLength2);
              }
              function validateNumber(value, name) {
                if (typeof value !== "number") {
                  throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
                }
              }
              function boundsError(value, length, type) {
                if (Math.floor(value) !== value) {
                  validateNumber(value, type);
                  throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
                }
                if (length < 0) {
                  throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
                }
                throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
              }
              const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
              function base64clean(str) {
                str = str.split("=")[0];
                str = str.trim().replace(INVALID_BASE64_RE, "");
                if (str.length < 2) return "";
                while (str.length % 4 !== 0) {
                  str = str + "=";
                }
                return str;
              }
              function utf8ToBytes(string, units) {
                units = units || Infinity;
                let codePoint;
                const length = string.length;
                let leadSurrogate = null;
                const bytes = [];
                for (let i = 0; i < length; ++i) {
                  codePoint = string.charCodeAt(i);
                  if (codePoint > 55295 && codePoint < 57344) {
                    if (!leadSurrogate) {
                      if (codePoint > 56319) {
                        if ((units -= 3) > -1) bytes.push(239, 191, 189);
                        continue;
                      } else if (i + 1 === length) {
                        if ((units -= 3) > -1) bytes.push(239, 191, 189);
                        continue;
                      }
                      leadSurrogate = codePoint;
                      continue;
                    }
                    if (codePoint < 56320) {
                      if ((units -= 3) > -1) bytes.push(239, 191, 189);
                      leadSurrogate = codePoint;
                      continue;
                    }
                    codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                  } else if (leadSurrogate) {
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                  }
                  leadSurrogate = null;
                  if (codePoint < 128) {
                    if ((units -= 1) < 0) break;
                    bytes.push(codePoint);
                  } else if (codePoint < 2048) {
                    if ((units -= 2) < 0) break;
                    bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
                  } else if (codePoint < 65536) {
                    if ((units -= 3) < 0) break;
                    bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                  } else if (codePoint < 1114112) {
                    if ((units -= 4) < 0) break;
                    bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                  } else {
                    throw new Error("Invalid code point");
                  }
                }
                return bytes;
              }
              function asciiToBytes(str) {
                const byteArray = [];
                for (let i = 0; i < str.length; ++i) {
                  byteArray.push(str.charCodeAt(i) & 255);
                }
                return byteArray;
              }
              function utf16leToBytes(str, units) {
                let c, hi, lo;
                const byteArray = [];
                for (let i = 0; i < str.length; ++i) {
                  if ((units -= 2) < 0) break;
                  c = str.charCodeAt(i);
                  hi = c >> 8;
                  lo = c % 256;
                  byteArray.push(lo);
                  byteArray.push(hi);
                }
                return byteArray;
              }
              function base64ToBytes(str) {
                return base64.toByteArray(base64clean(str));
              }
              function blitBuffer(src, dst, offset, length) {
                let i;
                for (i = 0; i < length; ++i) {
                  if (i + offset >= dst.length || i >= src.length) break;
                  dst[i + offset] = src[i];
                }
                return i;
              }
              function isInstance(obj, type) {
                return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
              }
              function numberIsNaN(obj) {
                return obj !== obj;
              }
              const hexSliceLookupTable = function() {
                const alphabet = "0123456789abcdef";
                const table = new Array(256);
                for (let i = 0; i < 16; ++i) {
                  const i16 = i * 16;
                  for (let j = 0; j < 16; ++j) {
                    table[i16 + j] = alphabet[i] + alphabet[j];
                  }
                }
                return table;
              }();
              function defineBigIntMethod(fn) {
                return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
              }
              function BufferBigIntNotDefined() {
                throw new Error("BigInt not supported");
              }
            },
            /***/
            821(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var possibleNames = __webpack_require__2(884);
              var g = typeof globalThis === "undefined" ? __webpack_require__2.g : globalThis;
              module2.exports = function availableTypedArrays() {
                var out = [];
                for (var i = 0; i < possibleNames.length; i++) {
                  if (typeof g[possibleNames[i]] === "function") {
                    out[out.length] = possibleNames[i];
                  }
                }
                return out;
              };
            },
            /***/
            884(module2) {
              "use strict";
              module2.exports = [
                "Float16Array",
                "Float32Array",
                "Float64Array",
                "Int8Array",
                "Int16Array",
                "Int32Array",
                "Uint8Array",
                "Uint8ClampedArray",
                "Uint16Array",
                "Uint32Array",
                "BigInt64Array",
                "BigUint64Array"
              ];
            },
            /***/
            890(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var hasOwn = __webpack_require__2(6341);
              var isArray = __webpack_require__2(8468);
              var isForced = __webpack_require__2(5888);
              var shared = __webpack_require__2(3793);
              var data = isForced.data;
              var normalize = isForced.normalize;
              var USE_FUNCTION_CONSTRUCTOR = "USE_FUNCTION_CONSTRUCTOR";
              var ASYNC_ITERATOR_PROTOTYPE = "AsyncIteratorPrototype";
              var setAggressivenessLevel = function(object, constant) {
                if (isArray(object)) for (var i = 0; i < object.length; i++) data[normalize(object[i])] = constant;
              };
              module2.exports = function(options) {
                if (typeof options == "object") {
                  setAggressivenessLevel(options.useNative, isForced.NATIVE);
                  setAggressivenessLevel(options.usePolyfill, isForced.POLYFILL);
                  setAggressivenessLevel(options.useFeatureDetection, null);
                  if (hasOwn(options, USE_FUNCTION_CONSTRUCTOR)) {
                    shared[USE_FUNCTION_CONSTRUCTOR] = !!options[USE_FUNCTION_CONSTRUCTOR];
                  }
                  if (hasOwn(options, ASYNC_ITERATOR_PROTOTYPE)) {
                    shared[ASYNC_ITERATOR_PROTOTYPE] = options[ASYNC_ITERATOR_PROTOTYPE];
                  }
                }
              };
            },
            /***/
            980(__unused_webpack_module, exports2, __webpack_require__2) {
              var __webpack_unused_export__;
              var BrotliInput = __webpack_require__2(8197).z;
              var BrotliOutput = __webpack_require__2(8197).y;
              var BrotliBitReader = __webpack_require__2(4097);
              var BrotliDictionary = __webpack_require__2(614);
              var HuffmanCode = __webpack_require__2(1561).z;
              var BrotliBuildHuffmanTable = __webpack_require__2(1561).u;
              var Context = __webpack_require__2(7043);
              var Prefix = __webpack_require__2(2210);
              var Transform = __webpack_require__2(7984);
              var kDefaultCodeLength = 8;
              var kCodeLengthRepeatCode = 16;
              var kNumLiteralCodes = 256;
              var kNumInsertAndCopyCodes = 704;
              var kNumBlockLengthCodes = 26;
              var kLiteralContextBits = 6;
              var kDistanceContextBits = 2;
              var HUFFMAN_TABLE_BITS = 8;
              var HUFFMAN_TABLE_MASK = 255;
              var HUFFMAN_MAX_TABLE_SIZE = 1080;
              var CODE_LENGTH_CODES = 18;
              var kCodeLengthCodeOrder = new Uint8Array([
                1,
                2,
                3,
                4,
                0,
                5,
                17,
                6,
                16,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
              ]);
              var NUM_DISTANCE_SHORT_CODES = 16;
              var kDistanceShortCodeIndexOffset = new Uint8Array([
                3,
                2,
                1,
                0,
                3,
                3,
                3,
                3,
                3,
                3,
                2,
                2,
                2,
                2,
                2,
                2
              ]);
              var kDistanceShortCodeValueOffset = new Int8Array([
                0,
                0,
                0,
                0,
                -1,
                1,
                -2,
                2,
                -3,
                3,
                -1,
                1,
                -2,
                2,
                -3,
                3
              ]);
              var kMaxHuffmanTableSize = new Uint16Array([
                256,
                402,
                436,
                468,
                500,
                534,
                566,
                598,
                630,
                662,
                694,
                726,
                758,
                790,
                822,
                854,
                886,
                920,
                952,
                984,
                1016,
                1048,
                1080
              ]);
              function DecodeWindowBits(br) {
                var n;
                if (br.readBits(1) === 0) {
                  return 16;
                }
                n = br.readBits(3);
                if (n > 0) {
                  return 17 + n;
                }
                n = br.readBits(3);
                if (n > 0) {
                  return 8 + n;
                }
                return 17;
              }
              function DecodeVarLenUint8(br) {
                if (br.readBits(1)) {
                  var nbits = br.readBits(3);
                  if (nbits === 0) {
                    return 1;
                  } else {
                    return br.readBits(nbits) + (1 << nbits);
                  }
                }
                return 0;
              }
              function MetaBlockLength() {
                this.meta_block_length = 0;
                this.input_end = 0;
                this.is_uncompressed = 0;
                this.is_metadata = false;
              }
              function DecodeMetaBlockLength(br) {
                var out = new MetaBlockLength();
                var size_nibbles;
                var size_bytes;
                var i;
                out.input_end = br.readBits(1);
                if (out.input_end && br.readBits(1)) {
                  return out;
                }
                size_nibbles = br.readBits(2) + 4;
                if (size_nibbles === 7) {
                  out.is_metadata = true;
                  if (br.readBits(1) !== 0)
                    throw new Error("Invalid reserved bit");
                  size_bytes = br.readBits(2);
                  if (size_bytes === 0)
                    return out;
                  for (i = 0; i < size_bytes; i++) {
                    var next_byte = br.readBits(8);
                    if (i + 1 === size_bytes && size_bytes > 1 && next_byte === 0)
                      throw new Error("Invalid size byte");
                    out.meta_block_length |= next_byte << i * 8;
                  }
                } else {
                  for (i = 0; i < size_nibbles; ++i) {
                    var next_nibble = br.readBits(4);
                    if (i + 1 === size_nibbles && size_nibbles > 4 && next_nibble === 0)
                      throw new Error("Invalid size nibble");
                    out.meta_block_length |= next_nibble << i * 4;
                  }
                }
                ++out.meta_block_length;
                if (!out.input_end && !out.is_metadata) {
                  out.is_uncompressed = br.readBits(1);
                }
                return out;
              }
              function ReadSymbol(table, index, br) {
                var start_index = index;
                var nbits;
                br.fillBitWindow();
                index += br.val_ >>> br.bit_pos_ & HUFFMAN_TABLE_MASK;
                nbits = table[index].bits - HUFFMAN_TABLE_BITS;
                if (nbits > 0) {
                  br.bit_pos_ += HUFFMAN_TABLE_BITS;
                  index += table[index].value;
                  index += br.val_ >>> br.bit_pos_ & (1 << nbits) - 1;
                }
                br.bit_pos_ += table[index].bits;
                return table[index].value;
              }
              function ReadHuffmanCodeLengths(code_length_code_lengths, num_symbols, code_lengths, br) {
                var symbol = 0;
                var prev_code_len = kDefaultCodeLength;
                var repeat = 0;
                var repeat_code_len = 0;
                var space = 32768;
                var table = [];
                for (var i = 0; i < 32; i++)
                  table.push(new HuffmanCode(0, 0));
                BrotliBuildHuffmanTable(table, 0, 5, code_length_code_lengths, CODE_LENGTH_CODES);
                while (symbol < num_symbols && space > 0) {
                  var p = 0;
                  var code_len;
                  br.readMoreInput();
                  br.fillBitWindow();
                  p += br.val_ >>> br.bit_pos_ & 31;
                  br.bit_pos_ += table[p].bits;
                  code_len = table[p].value & 255;
                  if (code_len < kCodeLengthRepeatCode) {
                    repeat = 0;
                    code_lengths[symbol++] = code_len;
                    if (code_len !== 0) {
                      prev_code_len = code_len;
                      space -= 32768 >> code_len;
                    }
                  } else {
                    var extra_bits = code_len - 14;
                    var old_repeat;
                    var repeat_delta;
                    var new_len = 0;
                    if (code_len === kCodeLengthRepeatCode) {
                      new_len = prev_code_len;
                    }
                    if (repeat_code_len !== new_len) {
                      repeat = 0;
                      repeat_code_len = new_len;
                    }
                    old_repeat = repeat;
                    if (repeat > 0) {
                      repeat -= 2;
                      repeat <<= extra_bits;
                    }
                    repeat += br.readBits(extra_bits) + 3;
                    repeat_delta = repeat - old_repeat;
                    if (symbol + repeat_delta > num_symbols) {
                      throw new Error("[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols");
                    }
                    for (var x = 0; x < repeat_delta; x++)
                      code_lengths[symbol + x] = repeat_code_len;
                    symbol += repeat_delta;
                    if (repeat_code_len !== 0) {
                      space -= repeat_delta << 15 - repeat_code_len;
                    }
                  }
                }
                if (space !== 0) {
                  throw new Error("[ReadHuffmanCodeLengths] space = " + space);
                }
                for (; symbol < num_symbols; symbol++)
                  code_lengths[symbol] = 0;
              }
              function ReadHuffmanCode(alphabet_size, tables, table, br) {
                var table_size = 0;
                var simple_code_or_skip;
                var code_lengths = new Uint8Array(alphabet_size);
                br.readMoreInput();
                simple_code_or_skip = br.readBits(2);
                if (simple_code_or_skip === 1) {
                  var i;
                  var max_bits_counter = alphabet_size - 1;
                  var max_bits = 0;
                  var symbols = new Int32Array(4);
                  var num_symbols = br.readBits(2) + 1;
                  while (max_bits_counter) {
                    max_bits_counter >>= 1;
                    ++max_bits;
                  }
                  for (i = 0; i < num_symbols; ++i) {
                    symbols[i] = br.readBits(max_bits) % alphabet_size;
                    code_lengths[symbols[i]] = 2;
                  }
                  code_lengths[symbols[0]] = 1;
                  switch (num_symbols) {
                    case 1:
                      break;
                    case 3:
                      if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[1] === symbols[2]) {
                        throw new Error("[ReadHuffmanCode] invalid symbols");
                      }
                      break;
                    case 2:
                      if (symbols[0] === symbols[1]) {
                        throw new Error("[ReadHuffmanCode] invalid symbols");
                      }
                      code_lengths[symbols[1]] = 1;
                      break;
                    case 4:
                      if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[0] === symbols[3] || symbols[1] === symbols[2] || symbols[1] === symbols[3] || symbols[2] === symbols[3]) {
                        throw new Error("[ReadHuffmanCode] invalid symbols");
                      }
                      if (br.readBits(1)) {
                        code_lengths[symbols[2]] = 3;
                        code_lengths[symbols[3]] = 3;
                      } else {
                        code_lengths[symbols[0]] = 2;
                      }
                      break;
                  }
                } else {
                  var i;
                  var code_length_code_lengths = new Uint8Array(CODE_LENGTH_CODES);
                  var space = 32;
                  var num_codes = 0;
                  var huff = [
                    new HuffmanCode(2, 0),
                    new HuffmanCode(2, 4),
                    new HuffmanCode(2, 3),
                    new HuffmanCode(3, 2),
                    new HuffmanCode(2, 0),
                    new HuffmanCode(2, 4),
                    new HuffmanCode(2, 3),
                    new HuffmanCode(4, 1),
                    new HuffmanCode(2, 0),
                    new HuffmanCode(2, 4),
                    new HuffmanCode(2, 3),
                    new HuffmanCode(3, 2),
                    new HuffmanCode(2, 0),
                    new HuffmanCode(2, 4),
                    new HuffmanCode(2, 3),
                    new HuffmanCode(4, 5)
                  ];
                  for (i = simple_code_or_skip; i < CODE_LENGTH_CODES && space > 0; ++i) {
                    var code_len_idx = kCodeLengthCodeOrder[i];
                    var p = 0;
                    var v;
                    br.fillBitWindow();
                    p += br.val_ >>> br.bit_pos_ & 15;
                    br.bit_pos_ += huff[p].bits;
                    v = huff[p].value;
                    code_length_code_lengths[code_len_idx] = v;
                    if (v !== 0) {
                      space -= 32 >> v;
                      ++num_codes;
                    }
                  }
                  if (!(num_codes === 1 || space === 0))
                    throw new Error("[ReadHuffmanCode] invalid num_codes or space");
                  ReadHuffmanCodeLengths(code_length_code_lengths, alphabet_size, code_lengths, br);
                }
                table_size = BrotliBuildHuffmanTable(tables, table, HUFFMAN_TABLE_BITS, code_lengths, alphabet_size);
                if (table_size === 0) {
                  throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");
                }
                return table_size;
              }
              function ReadBlockLength(table, index, br) {
                var code;
                var nbits;
                code = ReadSymbol(table, index, br);
                nbits = Prefix.kBlockLengthPrefixCode[code].nbits;
                return Prefix.kBlockLengthPrefixCode[code].offset + br.readBits(nbits);
              }
              function TranslateShortCodes(code, ringbuffer, index) {
                var val;
                if (code < NUM_DISTANCE_SHORT_CODES) {
                  index += kDistanceShortCodeIndexOffset[code];
                  index &= 3;
                  val = ringbuffer[index] + kDistanceShortCodeValueOffset[code];
                } else {
                  val = code - NUM_DISTANCE_SHORT_CODES + 1;
                }
                return val;
              }
              function MoveToFront(v, index) {
                var value = v[index];
                var i = index;
                for (; i; --i) v[i] = v[i - 1];
                v[0] = value;
              }
              function InverseMoveToFrontTransform(v, v_len) {
                var mtf = new Uint8Array(256);
                var i;
                for (i = 0; i < 256; ++i) {
                  mtf[i] = i;
                }
                for (i = 0; i < v_len; ++i) {
                  var index = v[i];
                  v[i] = mtf[index];
                  if (index) MoveToFront(mtf, index);
                }
              }
              function HuffmanTreeGroup(alphabet_size, num_htrees) {
                this.alphabet_size = alphabet_size;
                this.num_htrees = num_htrees;
                this.codes = new Array(num_htrees + num_htrees * kMaxHuffmanTableSize[alphabet_size + 31 >>> 5]);
                this.htrees = new Uint32Array(num_htrees);
              }
              HuffmanTreeGroup.prototype.decode = function(br) {
                var i;
                var table_size;
                var next = 0;
                for (i = 0; i < this.num_htrees; ++i) {
                  this.htrees[i] = next;
                  table_size = ReadHuffmanCode(this.alphabet_size, this.codes, next, br);
                  next += table_size;
                }
              };
              function DecodeContextMap(context_map_size, br) {
                var out = { num_htrees: null, context_map: null };
                var use_rle_for_zeros;
                var max_run_length_prefix = 0;
                var table;
                var i;
                br.readMoreInput();
                var num_htrees = out.num_htrees = DecodeVarLenUint8(br) + 1;
                var context_map = out.context_map = new Uint8Array(context_map_size);
                if (num_htrees <= 1) {
                  return out;
                }
                use_rle_for_zeros = br.readBits(1);
                if (use_rle_for_zeros) {
                  max_run_length_prefix = br.readBits(4) + 1;
                }
                table = [];
                for (i = 0; i < HUFFMAN_MAX_TABLE_SIZE; i++) {
                  table[i] = new HuffmanCode(0, 0);
                }
                ReadHuffmanCode(num_htrees + max_run_length_prefix, table, 0, br);
                for (i = 0; i < context_map_size; ) {
                  var code;
                  br.readMoreInput();
                  code = ReadSymbol(table, 0, br);
                  if (code === 0) {
                    context_map[i] = 0;
                    ++i;
                  } else if (code <= max_run_length_prefix) {
                    var reps = 1 + (1 << code) + br.readBits(code);
                    while (--reps) {
                      if (i >= context_map_size) {
                        throw new Error("[DecodeContextMap] i >= context_map_size");
                      }
                      context_map[i] = 0;
                      ++i;
                    }
                  } else {
                    context_map[i] = code - max_run_length_prefix;
                    ++i;
                  }
                }
                if (br.readBits(1)) {
                  InverseMoveToFrontTransform(context_map, context_map_size);
                }
                return out;
              }
              function DecodeBlockType(max_block_type, trees, tree_type, block_types, ringbuffers, indexes, br) {
                var ringbuffer = tree_type * 2;
                var index = tree_type;
                var type_code = ReadSymbol(trees, tree_type * HUFFMAN_MAX_TABLE_SIZE, br);
                var block_type;
                if (type_code === 0) {
                  block_type = ringbuffers[ringbuffer + (indexes[index] & 1)];
                } else if (type_code === 1) {
                  block_type = ringbuffers[ringbuffer + (indexes[index] - 1 & 1)] + 1;
                } else {
                  block_type = type_code - 2;
                }
                if (block_type >= max_block_type) {
                  block_type -= max_block_type;
                }
                block_types[tree_type] = block_type;
                ringbuffers[ringbuffer + (indexes[index] & 1)] = block_type;
                ++indexes[index];
              }
              function CopyUncompressedBlockToOutput(output, len, pos, ringbuffer, ringbuffer_mask, br) {
                var rb_size = ringbuffer_mask + 1;
                var rb_pos = pos & ringbuffer_mask;
                var br_pos = br.pos_ & BrotliBitReader.IBUF_MASK;
                var nbytes;
                if (len < 8 || br.bit_pos_ + (len << 3) < br.bit_end_pos_) {
                  while (len-- > 0) {
                    br.readMoreInput();
                    ringbuffer[rb_pos++] = br.readBits(8);
                    if (rb_pos === rb_size) {
                      output.write(ringbuffer, rb_size);
                      rb_pos = 0;
                    }
                  }
                  return;
                }
                if (br.bit_end_pos_ < 32) {
                  throw new Error("[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32");
                }
                while (br.bit_pos_ < 32) {
                  ringbuffer[rb_pos] = br.val_ >>> br.bit_pos_;
                  br.bit_pos_ += 8;
                  ++rb_pos;
                  --len;
                }
                nbytes = br.bit_end_pos_ - br.bit_pos_ >> 3;
                if (br_pos + nbytes > BrotliBitReader.IBUF_MASK) {
                  var tail = BrotliBitReader.IBUF_MASK + 1 - br_pos;
                  for (var x = 0; x < tail; x++)
                    ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
                  nbytes -= tail;
                  rb_pos += tail;
                  len -= tail;
                  br_pos = 0;
                }
                for (var x = 0; x < nbytes; x++)
                  ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
                rb_pos += nbytes;
                len -= nbytes;
                if (rb_pos >= rb_size) {
                  output.write(ringbuffer, rb_size);
                  rb_pos -= rb_size;
                  for (var x = 0; x < rb_pos; x++)
                    ringbuffer[x] = ringbuffer[rb_size + x];
                }
                while (rb_pos + len >= rb_size) {
                  nbytes = rb_size - rb_pos;
                  if (br.input_.read(ringbuffer, rb_pos, nbytes) < nbytes) {
                    throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
                  }
                  output.write(ringbuffer, rb_size);
                  len -= nbytes;
                  rb_pos = 0;
                }
                if (br.input_.read(ringbuffer, rb_pos, len) < len) {
                  throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
                }
                br.reset();
              }
              function JumpToByteBoundary(br) {
                var new_bit_pos = br.bit_pos_ + 7 & ~7;
                var pad_bits = br.readBits(new_bit_pos - br.bit_pos_);
                return pad_bits == 0;
              }
              function BrotliDecompressedSize(buffer) {
                var input = new BrotliInput(buffer);
                var br = new BrotliBitReader(input);
                DecodeWindowBits(br);
                var out = DecodeMetaBlockLength(br);
                return out.meta_block_length;
              }
              __webpack_unused_export__ = BrotliDecompressedSize;
              function BrotliDecompressBuffer(buffer, output_size) {
                var input = new BrotliInput(buffer);
                if (output_size == null) {
                  output_size = BrotliDecompressedSize(buffer);
                }
                var output_buffer = new Uint8Array(output_size);
                var output = new BrotliOutput(output_buffer);
                BrotliDecompress(input, output);
                if (output.pos < output.buffer.length) {
                  output.buffer = output.buffer.subarray(0, output.pos);
                }
                return output.buffer;
              }
              exports2.BrotliDecompressBuffer = BrotliDecompressBuffer;
              function BrotliDecompress(input, output) {
                var i;
                var pos = 0;
                var input_end = 0;
                var window_bits = 0;
                var max_backward_distance;
                var max_distance = 0;
                var ringbuffer_size;
                var ringbuffer_mask;
                var ringbuffer;
                var ringbuffer_end;
                var dist_rb = [16, 15, 11, 4];
                var dist_rb_idx = 0;
                var prev_byte1 = 0;
                var prev_byte2 = 0;
                var hgroup = [new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0)];
                var block_type_trees;
                var block_len_trees;
                var br;
                var kRingBufferWriteAheadSlack = 128 + BrotliBitReader.READ_SIZE;
                br = new BrotliBitReader(input);
                window_bits = DecodeWindowBits(br);
                max_backward_distance = (1 << window_bits) - 16;
                ringbuffer_size = 1 << window_bits;
                ringbuffer_mask = ringbuffer_size - 1;
                ringbuffer = new Uint8Array(ringbuffer_size + kRingBufferWriteAheadSlack + BrotliDictionary.maxDictionaryWordLength);
                ringbuffer_end = ringbuffer_size;
                block_type_trees = [];
                block_len_trees = [];
                for (var x = 0; x < 3 * HUFFMAN_MAX_TABLE_SIZE; x++) {
                  block_type_trees[x] = new HuffmanCode(0, 0);
                  block_len_trees[x] = new HuffmanCode(0, 0);
                }
                while (!input_end) {
                  var meta_block_remaining_len = 0;
                  var is_uncompressed;
                  var block_length = [1 << 28, 1 << 28, 1 << 28];
                  var block_type = [0];
                  var num_block_types = [1, 1, 1];
                  var block_type_rb = [0, 1, 0, 1, 0, 1];
                  var block_type_rb_index = [0];
                  var distance_postfix_bits;
                  var num_direct_distance_codes;
                  var distance_postfix_mask;
                  var num_distance_codes;
                  var context_map = null;
                  var context_modes = null;
                  var num_literal_htrees;
                  var dist_context_map = null;
                  var num_dist_htrees;
                  var context_offset = 0;
                  var context_map_slice = null;
                  var literal_htree_index = 0;
                  var dist_context_offset = 0;
                  var dist_context_map_slice = null;
                  var dist_htree_index = 0;
                  var context_lookup_offset1 = 0;
                  var context_lookup_offset2 = 0;
                  var context_mode;
                  var htree_command;
                  for (i = 0; i < 3; ++i) {
                    hgroup[i].codes = null;
                    hgroup[i].htrees = null;
                  }
                  br.readMoreInput();
                  var _out = DecodeMetaBlockLength(br);
                  meta_block_remaining_len = _out.meta_block_length;
                  if (pos + meta_block_remaining_len > output.buffer.length) {
                    var tmp = new Uint8Array(pos + meta_block_remaining_len);
                    tmp.set(output.buffer);
                    output.buffer = tmp;
                  }
                  input_end = _out.input_end;
                  is_uncompressed = _out.is_uncompressed;
                  if (_out.is_metadata) {
                    JumpToByteBoundary(br);
                    for (; meta_block_remaining_len > 0; --meta_block_remaining_len) {
                      br.readMoreInput();
                      br.readBits(8);
                    }
                    continue;
                  }
                  if (meta_block_remaining_len === 0) {
                    continue;
                  }
                  if (is_uncompressed) {
                    br.bit_pos_ = br.bit_pos_ + 7 & ~7;
                    CopyUncompressedBlockToOutput(
                      output,
                      meta_block_remaining_len,
                      pos,
                      ringbuffer,
                      ringbuffer_mask,
                      br
                    );
                    pos += meta_block_remaining_len;
                    continue;
                  }
                  for (i = 0; i < 3; ++i) {
                    num_block_types[i] = DecodeVarLenUint8(br) + 1;
                    if (num_block_types[i] >= 2) {
                      ReadHuffmanCode(num_block_types[i] + 2, block_type_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
                      ReadHuffmanCode(kNumBlockLengthCodes, block_len_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
                      block_length[i] = ReadBlockLength(block_len_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
                      block_type_rb_index[i] = 1;
                    }
                  }
                  br.readMoreInput();
                  distance_postfix_bits = br.readBits(2);
                  num_direct_distance_codes = NUM_DISTANCE_SHORT_CODES + (br.readBits(4) << distance_postfix_bits);
                  distance_postfix_mask = (1 << distance_postfix_bits) - 1;
                  num_distance_codes = num_direct_distance_codes + (48 << distance_postfix_bits);
                  context_modes = new Uint8Array(num_block_types[0]);
                  for (i = 0; i < num_block_types[0]; ++i) {
                    br.readMoreInput();
                    context_modes[i] = br.readBits(2) << 1;
                  }
                  var _o1 = DecodeContextMap(num_block_types[0] << kLiteralContextBits, br);
                  num_literal_htrees = _o1.num_htrees;
                  context_map = _o1.context_map;
                  var _o2 = DecodeContextMap(num_block_types[2] << kDistanceContextBits, br);
                  num_dist_htrees = _o2.num_htrees;
                  dist_context_map = _o2.context_map;
                  hgroup[0] = new HuffmanTreeGroup(kNumLiteralCodes, num_literal_htrees);
                  hgroup[1] = new HuffmanTreeGroup(kNumInsertAndCopyCodes, num_block_types[1]);
                  hgroup[2] = new HuffmanTreeGroup(num_distance_codes, num_dist_htrees);
                  for (i = 0; i < 3; ++i) {
                    hgroup[i].decode(br);
                  }
                  context_map_slice = 0;
                  dist_context_map_slice = 0;
                  context_mode = context_modes[block_type[0]];
                  context_lookup_offset1 = Context.lookupOffsets[context_mode];
                  context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
                  htree_command = hgroup[1].htrees[0];
                  while (meta_block_remaining_len > 0) {
                    var cmd_code;
                    var range_idx;
                    var insert_code;
                    var copy_code;
                    var insert_length;
                    var copy_length;
                    var distance_code;
                    var distance;
                    var context;
                    var j;
                    var copy_dst;
                    br.readMoreInput();
                    if (block_length[1] === 0) {
                      DecodeBlockType(
                        num_block_types[1],
                        block_type_trees,
                        1,
                        block_type,
                        block_type_rb,
                        block_type_rb_index,
                        br
                      );
                      block_length[1] = ReadBlockLength(block_len_trees, HUFFMAN_MAX_TABLE_SIZE, br);
                      htree_command = hgroup[1].htrees[block_type[1]];
                    }
                    --block_length[1];
                    cmd_code = ReadSymbol(hgroup[1].codes, htree_command, br);
                    range_idx = cmd_code >> 6;
                    if (range_idx >= 2) {
                      range_idx -= 2;
                      distance_code = -1;
                    } else {
                      distance_code = 0;
                    }
                    insert_code = Prefix.kInsertRangeLut[range_idx] + (cmd_code >> 3 & 7);
                    copy_code = Prefix.kCopyRangeLut[range_idx] + (cmd_code & 7);
                    insert_length = Prefix.kInsertLengthPrefixCode[insert_code].offset + br.readBits(Prefix.kInsertLengthPrefixCode[insert_code].nbits);
                    copy_length = Prefix.kCopyLengthPrefixCode[copy_code].offset + br.readBits(Prefix.kCopyLengthPrefixCode[copy_code].nbits);
                    prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
                    prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
                    for (j = 0; j < insert_length; ++j) {
                      br.readMoreInput();
                      if (block_length[0] === 0) {
                        DecodeBlockType(
                          num_block_types[0],
                          block_type_trees,
                          0,
                          block_type,
                          block_type_rb,
                          block_type_rb_index,
                          br
                        );
                        block_length[0] = ReadBlockLength(block_len_trees, 0, br);
                        context_offset = block_type[0] << kLiteralContextBits;
                        context_map_slice = context_offset;
                        context_mode = context_modes[block_type[0]];
                        context_lookup_offset1 = Context.lookupOffsets[context_mode];
                        context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
                      }
                      context = Context.lookup[context_lookup_offset1 + prev_byte1] | Context.lookup[context_lookup_offset2 + prev_byte2];
                      literal_htree_index = context_map[context_map_slice + context];
                      --block_length[0];
                      prev_byte2 = prev_byte1;
                      prev_byte1 = ReadSymbol(hgroup[0].codes, hgroup[0].htrees[literal_htree_index], br);
                      ringbuffer[pos & ringbuffer_mask] = prev_byte1;
                      if ((pos & ringbuffer_mask) === ringbuffer_mask) {
                        output.write(ringbuffer, ringbuffer_size);
                      }
                      ++pos;
                    }
                    meta_block_remaining_len -= insert_length;
                    if (meta_block_remaining_len <= 0) break;
                    if (distance_code < 0) {
                      var context;
                      br.readMoreInput();
                      if (block_length[2] === 0) {
                        DecodeBlockType(
                          num_block_types[2],
                          block_type_trees,
                          2,
                          block_type,
                          block_type_rb,
                          block_type_rb_index,
                          br
                        );
                        block_length[2] = ReadBlockLength(block_len_trees, 2 * HUFFMAN_MAX_TABLE_SIZE, br);
                        dist_context_offset = block_type[2] << kDistanceContextBits;
                        dist_context_map_slice = dist_context_offset;
                      }
                      --block_length[2];
                      context = (copy_length > 4 ? 3 : copy_length - 2) & 255;
                      dist_htree_index = dist_context_map[dist_context_map_slice + context];
                      distance_code = ReadSymbol(hgroup[2].codes, hgroup[2].htrees[dist_htree_index], br);
                      if (distance_code >= num_direct_distance_codes) {
                        var nbits;
                        var postfix;
                        var offset;
                        distance_code -= num_direct_distance_codes;
                        postfix = distance_code & distance_postfix_mask;
                        distance_code >>= distance_postfix_bits;
                        nbits = (distance_code >> 1) + 1;
                        offset = (2 + (distance_code & 1) << nbits) - 4;
                        distance_code = num_direct_distance_codes + (offset + br.readBits(nbits) << distance_postfix_bits) + postfix;
                      }
                    }
                    distance = TranslateShortCodes(distance_code, dist_rb, dist_rb_idx);
                    if (distance < 0) {
                      throw new Error("[BrotliDecompress] invalid distance");
                    }
                    if (pos < max_backward_distance && max_distance !== max_backward_distance) {
                      max_distance = pos;
                    } else {
                      max_distance = max_backward_distance;
                    }
                    copy_dst = pos & ringbuffer_mask;
                    if (distance > max_distance) {
                      if (copy_length >= BrotliDictionary.minDictionaryWordLength && copy_length <= BrotliDictionary.maxDictionaryWordLength) {
                        var offset = BrotliDictionary.offsetsByLength[copy_length];
                        var word_id = distance - max_distance - 1;
                        var shift = BrotliDictionary.sizeBitsByLength[copy_length];
                        var mask = (1 << shift) - 1;
                        var word_idx = word_id & mask;
                        var transform_idx = word_id >> shift;
                        offset += word_idx * copy_length;
                        if (transform_idx < Transform.kNumTransforms) {
                          var len = Transform.transformDictionaryWord(ringbuffer, copy_dst, offset, copy_length, transform_idx);
                          copy_dst += len;
                          pos += len;
                          meta_block_remaining_len -= len;
                          if (copy_dst >= ringbuffer_end) {
                            output.write(ringbuffer, ringbuffer_size);
                            for (var _x = 0; _x < copy_dst - ringbuffer_end; _x++)
                              ringbuffer[_x] = ringbuffer[ringbuffer_end + _x];
                          }
                        } else {
                          throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
                        }
                      } else {
                        throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
                      }
                    } else {
                      if (distance_code > 0) {
                        dist_rb[dist_rb_idx & 3] = distance;
                        ++dist_rb_idx;
                      }
                      if (copy_length > meta_block_remaining_len) {
                        throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
                      }
                      for (j = 0; j < copy_length; ++j) {
                        ringbuffer[pos & ringbuffer_mask] = ringbuffer[pos - distance & ringbuffer_mask];
                        if ((pos & ringbuffer_mask) === ringbuffer_mask) {
                          output.write(ringbuffer, ringbuffer_size);
                        }
                        ++pos;
                        --meta_block_remaining_len;
                      }
                    }
                    prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
                    prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
                  }
                  pos &= 1073741823;
                }
                output.write(ringbuffer, pos & ringbuffer_mask);
              }
              __webpack_unused_export__ = BrotliDecompress;
              BrotliDictionary.init();
            },
            /***/
            997(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var store = __webpack_require__2(3793);
              module2.exports = function(key, value) {
                return store[key] || (store[key] = value || {});
              };
            },
            /***/
            1078(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var isCallable = __webpack_require__2(8681);
              var tryToString = __webpack_require__2(8819);
              var $TypeError = TypeError;
              module2.exports = function(argument) {
                if (isCallable(argument)) return argument;
                throw new $TypeError(tryToString(argument) + " is not a function");
              };
            },
            /***/
            1182(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var makeBuiltIn = __webpack_require__2(3383);
              var defineProperty = __webpack_require__2(2333);
              module2.exports = function(target, name, descriptor) {
                if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
                if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
                return defineProperty.f(target, name, descriptor);
              };
            },
            /***/
            1194(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var globalThis2 = __webpack_require__2(7756);
              var isCallable = __webpack_require__2(8681);
              var WeakMap2 = globalThis2.WeakMap;
              module2.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
            },
            /***/
            1199(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function() {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var WordArray = C_lib.WordArray;
                  var C_enc = C.enc;
                  var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
                    /**
                     * Converts a word array to a UTF-16 BE string.
                     *
                     * @param {WordArray} wordArray The word array.
                     *
                     * @return {string} The UTF-16 BE string.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
                     */
                    stringify: function(wordArray) {
                      var words = wordArray.words;
                      var sigBytes = wordArray.sigBytes;
                      var utf16Chars = [];
                      for (var i = 0; i < sigBytes; i += 2) {
                        var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
                        utf16Chars.push(String.fromCharCode(codePoint));
                      }
                      return utf16Chars.join("");
                    },
                    /**
                     * Converts a UTF-16 BE string to a word array.
                     *
                     * @param {string} utf16Str The UTF-16 BE string.
                     *
                     * @return {WordArray} The word array.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
                     */
                    parse: function(utf16Str) {
                      var utf16StrLength = utf16Str.length;
                      var words = [];
                      for (var i = 0; i < utf16StrLength; i++) {
                        words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
                      }
                      return WordArray.create(words, utf16StrLength * 2);
                    }
                  };
                  C_enc.Utf16LE = {
                    /**
                     * Converts a word array to a UTF-16 LE string.
                     *
                     * @param {WordArray} wordArray The word array.
                     *
                     * @return {string} The UTF-16 LE string.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
                     */
                    stringify: function(wordArray) {
                      var words = wordArray.words;
                      var sigBytes = wordArray.sigBytes;
                      var utf16Chars = [];
                      for (var i = 0; i < sigBytes; i += 2) {
                        var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
                        utf16Chars.push(String.fromCharCode(codePoint));
                      }
                      return utf16Chars.join("");
                    },
                    /**
                     * Converts a UTF-16 LE string to a word array.
                     *
                     * @param {string} utf16Str The UTF-16 LE string.
                     *
                     * @return {WordArray} The word array.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
                     */
                    parse: function(utf16Str) {
                      var utf16StrLength = utf16Str.length;
                      var words = [];
                      for (var i = 0; i < utf16StrLength; i++) {
                        words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
                      }
                      return WordArray.create(words, utf16StrLength * 2);
                    }
                  };
                  function swapEndian(word) {
                    return word << 8 & 4278255360 | word >>> 8 & 16711935;
                  }
                })();
                return CryptoJS.enc.Utf16;
              });
            },
            /***/
            1201(module2) {
              module2.exports = function isBuffer(arg) {
                return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
              };
            },
            /***/
            1212(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var NATIVE_BIND = __webpack_require__2(1676);
              var FunctionPrototype = Function.prototype;
              var call = FunctionPrototype.call;
              var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
              module2.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
                return function() {
                  return call.apply(fn, arguments);
                };
              };
            },
            /***/
            1220(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(2858));
                } else {
                }
              })(void 0, function(CryptoJS) {
                CryptoJS.mode.CTRGladman = function() {
                  var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
                  function incWord(word) {
                    if ((word >> 24 & 255) === 255) {
                      var b1 = word >> 16 & 255;
                      var b2 = word >> 8 & 255;
                      var b3 = word & 255;
                      if (b1 === 255) {
                        b1 = 0;
                        if (b2 === 255) {
                          b2 = 0;
                          if (b3 === 255) {
                            b3 = 0;
                          } else {
                            ++b3;
                          }
                        } else {
                          ++b2;
                        }
                      } else {
                        ++b1;
                      }
                      word = 0;
                      word += b1 << 16;
                      word += b2 << 8;
                      word += b3;
                    } else {
                      word += 1 << 24;
                    }
                    return word;
                  }
                  function incCounter(counter) {
                    if ((counter[0] = incWord(counter[0])) === 0) {
                      counter[1] = incWord(counter[1]);
                    }
                    return counter;
                  }
                  var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
                    processBlock: function(words, offset) {
                      var cipher = this._cipher;
                      var blockSize = cipher.blockSize;
                      var iv = this._iv;
                      var counter = this._counter;
                      if (iv) {
                        counter = this._counter = iv.slice(0);
                        this._iv = void 0;
                      }
                      incCounter(counter);
                      var keystream = counter.slice(0);
                      cipher.encryptBlock(keystream, 0);
                      for (var i = 0; i < blockSize; i++) {
                        words[offset + i] ^= keystream[i];
                      }
                    }
                  });
                  CTRGladman.Decryptor = Encryptor;
                  return CTRGladman;
                }();
                return CryptoJS.mode.CTRGladman;
              });
            },
            /***/
            1320(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var implementation = __webpack_require__2(2621);
              module2.exports = function getPolyfill() {
                if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
                  return Number.isNaN;
                }
                return implementation;
              };
            },
            /***/
            1413(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var toPrimitive = __webpack_require__2(3301);
              var isSymbol = __webpack_require__2(5985);
              module2.exports = function(argument) {
                var key = toPrimitive(argument, "string");
                return isSymbol(key) ? key : key + "";
              };
            },
            /***/
            1561(__unused_webpack_module, exports2) {
              function HuffmanCode(bits, value) {
                this.bits = bits;
                this.value = value;
              }
              exports2.z = HuffmanCode;
              var MAX_LENGTH = 15;
              function GetNextKey(key, len) {
                var step = 1 << len - 1;
                while (key & step) {
                  step >>= 1;
                }
                return (key & step - 1) + step;
              }
              function ReplicateValue(table, i, step, end, code) {
                do {
                  end -= step;
                  table[i + end] = new HuffmanCode(code.bits, code.value);
                } while (end > 0);
              }
              function NextTableBitSize(count, len, root_bits) {
                var left = 1 << len - root_bits;
                while (len < MAX_LENGTH) {
                  left -= count[len];
                  if (left <= 0) break;
                  ++len;
                  left <<= 1;
                }
                return len - root_bits;
              }
              exports2.u = function(root_table, table, root_bits, code_lengths, code_lengths_size) {
                var start_table = table;
                var code;
                var len;
                var symbol;
                var key;
                var step;
                var low;
                var mask;
                var table_bits;
                var table_size;
                var total_size;
                var sorted;
                var count = new Int32Array(MAX_LENGTH + 1);
                var offset = new Int32Array(MAX_LENGTH + 1);
                sorted = new Int32Array(code_lengths_size);
                for (symbol = 0; symbol < code_lengths_size; symbol++) {
                  count[code_lengths[symbol]]++;
                }
                offset[1] = 0;
                for (len = 1; len < MAX_LENGTH; len++) {
                  offset[len + 1] = offset[len] + count[len];
                }
                for (symbol = 0; symbol < code_lengths_size; symbol++) {
                  if (code_lengths[symbol] !== 0) {
                    sorted[offset[code_lengths[symbol]]++] = symbol;
                  }
                }
                table_bits = root_bits;
                table_size = 1 << table_bits;
                total_size = table_size;
                if (offset[MAX_LENGTH] === 1) {
                  for (key = 0; key < total_size; ++key) {
                    root_table[table + key] = new HuffmanCode(0, sorted[0] & 65535);
                  }
                  return total_size;
                }
                key = 0;
                symbol = 0;
                for (len = 1, step = 2; len <= root_bits; ++len, step <<= 1) {
                  for (; count[len] > 0; --count[len]) {
                    code = new HuffmanCode(len & 255, sorted[symbol++] & 65535);
                    ReplicateValue(root_table, table + key, step, table_size, code);
                    key = GetNextKey(key, len);
                  }
                }
                mask = total_size - 1;
                low = -1;
                for (len = root_bits + 1, step = 2; len <= MAX_LENGTH; ++len, step <<= 1) {
                  for (; count[len] > 0; --count[len]) {
                    if ((key & mask) !== low) {
                      table += table_size;
                      table_bits = NextTableBitSize(count, len, root_bits);
                      table_size = 1 << table_bits;
                      total_size += table_size;
                      low = key & mask;
                      root_table[start_table + low] = new HuffmanCode(table_bits + root_bits & 255, table - start_table - low & 65535);
                    }
                    code = new HuffmanCode(len - root_bits & 255, sorted[symbol++] & 65535);
                    ReplicateValue(root_table, table + (key >> root_bits), step, table_size, code);
                    key = GetNextKey(key, len);
                  }
                }
                return total_size;
              };
            },
            /***/
            1607(module2) {
              "use strict";
              module2.exports = {
                /* Allowed flush values; see deflate() and inflate() below for details */
                Z_NO_FLUSH: 0,
                Z_PARTIAL_FLUSH: 1,
                Z_SYNC_FLUSH: 2,
                Z_FULL_FLUSH: 3,
                Z_FINISH: 4,
                Z_BLOCK: 5,
                Z_TREES: 6,
                /* Return codes for the compression/decompression functions. Negative values
                * are errors, positive values are used for special but normal events.
                */
                Z_OK: 0,
                Z_STREAM_END: 1,
                Z_NEED_DICT: 2,
                Z_ERRNO: -1,
                Z_STREAM_ERROR: -2,
                Z_DATA_ERROR: -3,
                //Z_MEM_ERROR:     -4,
                Z_BUF_ERROR: -5,
                //Z_VERSION_ERROR: -6,
                /* compression levels */
                Z_NO_COMPRESSION: 0,
                Z_BEST_SPEED: 1,
                Z_BEST_COMPRESSION: 9,
                Z_DEFAULT_COMPRESSION: -1,
                Z_FILTERED: 1,
                Z_HUFFMAN_ONLY: 2,
                Z_RLE: 3,
                Z_FIXED: 4,
                Z_DEFAULT_STRATEGY: 0,
                /* Possible values of the data_type field (though see inflate()) */
                Z_BINARY: 0,
                Z_TEXT: 1,
                //Z_ASCII:                1, // = Z_TEXT (deprecated)
                Z_UNKNOWN: 2,
                /* The deflate compression method */
                Z_DEFLATED: 8
                //Z_NULL:                 null // Use -1 or null inline, depending on var type
              };
            },
            /***/
            1613(module2, __unused_webpack_exports, __webpack_require__2) {
              var Buffer = __webpack_require__2(783)["Buffer"];
              var clone = function() {
                "use strict";
                function _instanceof(obj, type) {
                  return type != null && obj instanceof type;
                }
                var nativeMap;
                try {
                  nativeMap = Map;
                } catch (_) {
                  nativeMap = function() {
                  };
                }
                var nativeSet;
                try {
                  nativeSet = Set;
                } catch (_) {
                  nativeSet = function() {
                  };
                }
                var nativePromise;
                try {
                  nativePromise = Promise;
                } catch (_) {
                  nativePromise = function() {
                  };
                }
                function clone2(parent, circular, depth, prototype, includeNonEnumerable) {
                  if (typeof circular === "object") {
                    depth = circular.depth;
                    prototype = circular.prototype;
                    includeNonEnumerable = circular.includeNonEnumerable;
                    circular = circular.circular;
                  }
                  var allParents = [];
                  var allChildren = [];
                  var useBuffer = typeof Buffer != "undefined";
                  if (typeof circular == "undefined")
                    circular = true;
                  if (typeof depth == "undefined")
                    depth = Infinity;
                  function _clone(parent2, depth2) {
                    if (parent2 === null)
                      return null;
                    if (depth2 === 0)
                      return parent2;
                    var child;
                    var proto;
                    if (typeof parent2 != "object") {
                      return parent2;
                    }
                    if (_instanceof(parent2, nativeMap)) {
                      child = new nativeMap();
                    } else if (_instanceof(parent2, nativeSet)) {
                      child = new nativeSet();
                    } else if (_instanceof(parent2, nativePromise)) {
                      child = new nativePromise(function(resolve, reject) {
                        parent2.then(function(value) {
                          resolve(_clone(value, depth2 - 1));
                        }, function(err) {
                          reject(_clone(err, depth2 - 1));
                        });
                      });
                    } else if (clone2.__isArray(parent2)) {
                      child = [];
                    } else if (clone2.__isRegExp(parent2)) {
                      child = new RegExp(parent2.source, __getRegExpFlags(parent2));
                      if (parent2.lastIndex) child.lastIndex = parent2.lastIndex;
                    } else if (clone2.__isDate(parent2)) {
                      child = new Date(parent2.getTime());
                    } else if (useBuffer && Buffer.isBuffer(parent2)) {
                      if (Buffer.allocUnsafe) {
                        child = Buffer.allocUnsafe(parent2.length);
                      } else {
                        child = new Buffer(parent2.length);
                      }
                      parent2.copy(child);
                      return child;
                    } else if (_instanceof(parent2, Error)) {
                      child = Object.create(parent2);
                    } else {
                      if (typeof prototype == "undefined") {
                        proto = Object.getPrototypeOf(parent2);
                        child = Object.create(proto);
                      } else {
                        child = Object.create(prototype);
                        proto = prototype;
                      }
                    }
                    if (circular) {
                      var index = allParents.indexOf(parent2);
                      if (index != -1) {
                        return allChildren[index];
                      }
                      allParents.push(parent2);
                      allChildren.push(child);
                    }
                    if (_instanceof(parent2, nativeMap)) {
                      parent2.forEach(function(value, key) {
                        var keyChild = _clone(key, depth2 - 1);
                        var valueChild = _clone(value, depth2 - 1);
                        child.set(keyChild, valueChild);
                      });
                    }
                    if (_instanceof(parent2, nativeSet)) {
                      parent2.forEach(function(value) {
                        var entryChild = _clone(value, depth2 - 1);
                        child.add(entryChild);
                      });
                    }
                    for (var i in parent2) {
                      var attrs;
                      if (proto) {
                        attrs = Object.getOwnPropertyDescriptor(proto, i);
                      }
                      if (attrs && attrs.set == null) {
                        continue;
                      }
                      child[i] = _clone(parent2[i], depth2 - 1);
                    }
                    if (Object.getOwnPropertySymbols) {
                      var symbols = Object.getOwnPropertySymbols(parent2);
                      for (var i = 0; i < symbols.length; i++) {
                        var symbol = symbols[i];
                        var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
                        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                          continue;
                        }
                        child[symbol] = _clone(parent2[symbol], depth2 - 1);
                        if (!descriptor.enumerable) {
                          Object.defineProperty(child, symbol, {
                            enumerable: false
                          });
                        }
                      }
                    }
                    if (includeNonEnumerable) {
                      var allPropertyNames = Object.getOwnPropertyNames(parent2);
                      for (var i = 0; i < allPropertyNames.length; i++) {
                        var propertyName = allPropertyNames[i];
                        var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
                        if (descriptor && descriptor.enumerable) {
                          continue;
                        }
                        child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
                        Object.defineProperty(child, propertyName, {
                          enumerable: false
                        });
                      }
                    }
                    return child;
                  }
                  return _clone(parent, depth);
                }
                clone2.clonePrototype = function clonePrototype(parent) {
                  if (parent === null)
                    return null;
                  var c = function() {
                  };
                  c.prototype = parent;
                  return new c();
                };
                function __objToStr(o) {
                  return Object.prototype.toString.call(o);
                }
                clone2.__objToStr = __objToStr;
                function __isDate(o) {
                  return typeof o === "object" && __objToStr(o) === "[object Date]";
                }
                clone2.__isDate = __isDate;
                function __isArray(o) {
                  return typeof o === "object" && __objToStr(o) === "[object Array]";
                }
                clone2.__isArray = __isArray;
                function __isRegExp(o) {
                  return typeof o === "object" && __objToStr(o) === "[object RegExp]";
                }
                clone2.__isRegExp = __isRegExp;
                function __getRegExpFlags(re) {
                  var flags = "";
                  if (re.global) flags += "g";
                  if (re.ignoreCase) flags += "i";
                  if (re.multiline) flags += "m";
                  return flags;
                }
                clone2.__getRegExpFlags = __getRegExpFlags;
                return clone2;
              }();
              if (module2.exports) {
                module2.exports = clone;
              }
            },
            /***/
            1635(__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) {
              "use strict";
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                __decorate: () => (
                  /* binding */
                  __decorate
                )
                /* harmony export */
              });
              var extendStatics = function(d, b) {
                extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                  d2.__proto__ = b2;
                } || function(d2, b2) {
                  for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
                };
                return extendStatics(d, b);
              };
              function __extends(d, b) {
                if (typeof b !== "function" && b !== null)
                  throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              }
              var __assign = function() {
                __assign = Object.assign || function __assign2(t) {
                  for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                  }
                  return t;
                };
                return __assign.apply(this, arguments);
              };
              function __rest(s, e) {
                var t = {};
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                  t[p] = s[p];
                if (s != null && typeof Object.getOwnPropertySymbols === "function")
                  for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                      t[p[i]] = s[p[i]];
                  }
                return t;
              }
              function __decorate(decorators, target, key, desc) {
                var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
              }
              function __param(paramIndex, decorator) {
                return function(target, key) {
                  decorator(target, key, paramIndex);
                };
              }
              function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
                function accept(f) {
                  if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
                  return f;
                }
                var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
                var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
                var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
                var _, done = false;
                for (var i = decorators.length - 1; i >= 0; i--) {
                  var context = {};
                  for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
                  for (var p in contextIn.access) context.access[p] = contextIn.access[p];
                  context.addInitializer = function(f) {
                    if (done) throw new TypeError("Cannot add initializers after decoration has completed");
                    extraInitializers.push(accept(f || null));
                  };
                  var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
                  if (kind === "accessor") {
                    if (result === void 0) continue;
                    if (result === null || typeof result !== "object") throw new TypeError("Object expected");
                    if (_ = accept(result.get)) descriptor.get = _;
                    if (_ = accept(result.set)) descriptor.set = _;
                    if (_ = accept(result.init)) initializers.unshift(_);
                  } else if (_ = accept(result)) {
                    if (kind === "field") initializers.unshift(_);
                    else descriptor[key] = _;
                  }
                }
                if (target) Object.defineProperty(target, contextIn.name, descriptor);
                done = true;
              }
              ;
              function __runInitializers(thisArg, initializers, value) {
                var useValue = arguments.length > 2;
                for (var i = 0; i < initializers.length; i++) {
                  value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
                }
                return useValue ? value : void 0;
              }
              ;
              function __propKey(x) {
                return typeof x === "symbol" ? x : "".concat(x);
              }
              ;
              function __setFunctionName(f, name, prefix) {
                if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
                return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
              }
              ;
              function __metadata(metadataKey, metadataValue) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
              }
              function __awaiter(thisArg, _arguments, P, generator) {
                function adopt(value) {
                  return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                  });
                }
                return new (P || (P = Promise))(function(resolve, reject) {
                  function fulfilled(value) {
                    try {
                      step(generator.next(value));
                    } catch (e) {
                      reject(e);
                    }
                  }
                  function rejected(value) {
                    try {
                      step(generator["throw"](value));
                    } catch (e) {
                      reject(e);
                    }
                  }
                  function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
              }
              function __generator(thisArg, body) {
                var _ = { label: 0, sent: function() {
                  if (t[0] & 1) throw t[1];
                  return t[1];
                }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
                return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
                  return this;
                }), g;
                function verb(n) {
                  return function(v) {
                    return step([n, v]);
                  };
                }
                function step(op) {
                  if (f) throw new TypeError("Generator is already executing.");
                  while (g && (g = 0, op[0] && (_ = 0)), _) try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                    if (y = 0, t) op = [op[0] & 2, t.value];
                    switch (op[0]) {
                      case 0:
                      case 1:
                        t = op;
                        break;
                      case 4:
                        _.label++;
                        return { value: op[1], done: false };
                      case 5:
                        _.label++;
                        y = op[1];
                        op = [0];
                        continue;
                      case 7:
                        op = _.ops.pop();
                        _.trys.pop();
                        continue;
                      default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                          _ = 0;
                          continue;
                        }
                        if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                          _.label = op[1];
                          break;
                        }
                        if (op[0] === 6 && _.label < t[1]) {
                          _.label = t[1];
                          t = op;
                          break;
                        }
                        if (t && _.label < t[2]) {
                          _.label = t[2];
                          _.ops.push(op);
                          break;
                        }
                        if (t[2]) _.ops.pop();
                        _.trys.pop();
                        continue;
                    }
                    op = body.call(thisArg, _);
                  } catch (e) {
                    op = [6, e];
                    y = 0;
                  } finally {
                    f = t = 0;
                  }
                  if (op[0] & 5) throw op[1];
                  return { value: op[0] ? op[1] : void 0, done: true };
                }
              }
              var __createBinding = Object.create ? function(o, m, k, k2) {
                if (k2 === void 0) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                  desc = { enumerable: true, get: function() {
                    return m[k];
                  } };
                }
                Object.defineProperty(o, k2, desc);
              } : function(o, m, k, k2) {
                if (k2 === void 0) k2 = k;
                o[k2] = m[k];
              };
              function __exportStar(m, o) {
                for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
              }
              function __values(o) {
                var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
                if (m) return m.call(o);
                if (o && typeof o.length === "number") return {
                  next: function() {
                    if (o && i >= o.length) o = void 0;
                    return { value: o && o[i++], done: !o };
                  }
                };
                throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
              }
              function __read(o, n) {
                var m = typeof Symbol === "function" && o[Symbol.iterator];
                if (!m) return o;
                var i = m.call(o), r, ar = [], e;
                try {
                  while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
                } catch (error) {
                  e = { error };
                } finally {
                  try {
                    if (r && !r.done && (m = i["return"])) m.call(i);
                  } finally {
                    if (e) throw e.error;
                  }
                }
                return ar;
              }
              function __spread() {
                for (var ar = [], i = 0; i < arguments.length; i++)
                  ar = ar.concat(__read(arguments[i]));
                return ar;
              }
              function __spreadArrays() {
                for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
                for (var r = Array(s), k = 0, i = 0; i < il; i++)
                  for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                    r[k] = a[j];
                return r;
              }
              function __spreadArray(to, from, pack) {
                if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
                  if (ar || !(i in from)) {
                    if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                  }
                }
                return to.concat(ar || Array.prototype.slice.call(from));
              }
              function __await(v) {
                return this instanceof __await ? (this.v = v, this) : new __await(v);
              }
              function __asyncGenerator(thisArg, _arguments, generator) {
                if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                var g = generator.apply(thisArg, _arguments || []), i, q = [];
                return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
                  return this;
                }, i;
                function awaitReturn(f) {
                  return function(v) {
                    return Promise.resolve(v).then(f, reject);
                  };
                }
                function verb(n, f) {
                  if (g[n]) {
                    i[n] = function(v) {
                      return new Promise(function(a, b) {
                        q.push([n, v, a, b]) > 1 || resume(n, v);
                      });
                    };
                    if (f) i[n] = f(i[n]);
                  }
                }
                function resume(n, v) {
                  try {
                    step(g[n](v));
                  } catch (e) {
                    settle(q[0][3], e);
                  }
                }
                function step(r) {
                  r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
                }
                function fulfill(value) {
                  resume("next", value);
                }
                function reject(value) {
                  resume("throw", value);
                }
                function settle(f, v) {
                  if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
                }
              }
              function __asyncDelegator(o) {
                var i, p;
                return i = {}, verb("next"), verb("throw", function(e) {
                  throw e;
                }), verb("return"), i[Symbol.iterator] = function() {
                  return this;
                }, i;
                function verb(n, f) {
                  i[n] = o[n] ? function(v) {
                    return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
                  } : f;
                }
              }
              function __asyncValues(o) {
                if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                var m = o[Symbol.asyncIterator], i;
                return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                  return this;
                }, i);
                function verb(n) {
                  i[n] = o[n] && function(v) {
                    return new Promise(function(resolve, reject) {
                      v = o[n](v), settle(resolve, reject, v.done, v.value);
                    });
                  };
                }
                function settle(resolve, reject, d, v) {
                  Promise.resolve(v).then(function(v2) {
                    resolve({ value: v2, done: d });
                  }, reject);
                }
              }
              function __makeTemplateObject(cooked, raw) {
                if (Object.defineProperty) {
                  Object.defineProperty(cooked, "raw", { value: raw });
                } else {
                  cooked.raw = raw;
                }
                return cooked;
              }
              ;
              var __setModuleDefault = Object.create ? function(o, v) {
                Object.defineProperty(o, "default", { enumerable: true, value: v });
              } : function(o, v) {
                o["default"] = v;
              };
              var ownKeys = function(o) {
                ownKeys = Object.getOwnPropertyNames || function(o2) {
                  var ar = [];
                  for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
                  return ar;
                };
                return ownKeys(o);
              };
              function __importStar(mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (mod != null) {
                  for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
                }
                __setModuleDefault(result, mod);
                return result;
              }
              function __importDefault(mod) {
                return mod && mod.__esModule ? mod : { default: mod };
              }
              function __classPrivateFieldGet(receiver, state, kind, f) {
                if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
                if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
              }
              function __classPrivateFieldSet(receiver, state, value, kind, f) {
                if (kind === "m") throw new TypeError("Private method is not writable");
                if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
                if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
              }
              function __classPrivateFieldIn(state, receiver) {
                if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
                return typeof state === "function" ? receiver === state : state.has(receiver);
              }
              function __addDisposableResource(env, value, async) {
                if (value !== null && value !== void 0) {
                  if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
                  var dispose, inner;
                  if (async) {
                    if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
                    dispose = value[Symbol.asyncDispose];
                  }
                  if (dispose === void 0) {
                    if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
                    dispose = value[Symbol.dispose];
                    if (async) inner = dispose;
                  }
                  if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
                  if (inner) dispose = function() {
                    try {
                      inner.call(this);
                    } catch (e) {
                      return Promise.reject(e);
                    }
                  };
                  env.stack.push({ value, dispose, async });
                } else if (async) {
                  env.stack.push({ async: true });
                }
                return value;
              }
              var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
                var e = new Error(message);
                return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
              };
              function __disposeResources(env) {
                function fail(e) {
                  env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
                  env.hasError = true;
                }
                var r, s = 0;
                function next() {
                  while (r = env.stack.pop()) {
                    try {
                      if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                      if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                          fail(e);
                          return next();
                        });
                      } else s |= 1;
                    } catch (e) {
                      fail(e);
                    }
                  }
                  if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
                  if (env.hasError) throw env.error;
                }
                return next();
              }
              function __rewriteRelativeImportExtension(path, preserveJsx) {
                if (typeof path === "string" && /^\.\.?\//.test(path)) {
                  return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
                    return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
                  });
                }
                return path;
              }
              var __WEBPACK_DEFAULT_EXPORT__ = {
                __extends,
                __assign,
                __rest,
                __decorate,
                __param,
                __esDecorate,
                __runInitializers,
                __propKey,
                __setFunctionName,
                __metadata,
                __awaiter,
                __generator,
                __createBinding,
                __exportStar,
                __values,
                __read,
                __spread,
                __spreadArrays,
                __spreadArray,
                __await,
                __asyncGenerator,
                __asyncDelegator,
                __asyncValues,
                __makeTemplateObject,
                __importStar,
                __importDefault,
                __classPrivateFieldGet,
                __classPrivateFieldSet,
                __classPrivateFieldIn,
                __addDisposableResource,
                __disposeResources,
                __rewriteRelativeImportExtension
              };
            },
            /***/
            1676(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var fails = __webpack_require__2(299);
              module2.exports = !fails(function() {
                var test = (function() {
                }).bind();
                return typeof test != "function" || test.hasOwnProperty("prototype");
              });
            },
            /***/
            1689(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var callBound = __webpack_require__2(2774);
              var hasToStringTag = __webpack_require__2(6626)();
              var hasOwn = __webpack_require__2(5215);
              var gOPD = __webpack_require__2(8109);
              var fn;
              if (hasToStringTag) {
                var $exec = callBound("RegExp.prototype.exec");
                var isRegexMarker = {};
                var throwRegexMarker = function() {
                  throw isRegexMarker;
                };
                var badStringifier = {
                  toString: throwRegexMarker,
                  valueOf: throwRegexMarker
                };
                if (typeof Symbol.toPrimitive === "symbol") {
                  badStringifier[Symbol.toPrimitive] = throwRegexMarker;
                }
                fn = function isRegex(value) {
                  if (!value || typeof value !== "object") {
                    return false;
                  }
                  var descriptor = (
                    /** @type {NonNullable<typeof gOPD>} */
                    gOPD(
                      /** @type {{ lastIndex?: unknown }} */
                      value,
                      "lastIndex"
                    )
                  );
                  var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
                  if (!hasLastIndexDataProperty) {
                    return false;
                  }
                  try {
                    $exec(
                      value,
                      /** @type {string} */
                      /** @type {unknown} */
                      badStringifier
                    );
                  } catch (e) {
                    return e === isRegexMarker;
                  }
                };
              } else {
                var $toString = callBound("Object.prototype.toString");
                var regexClass = "[object RegExp]";
                fn = function isRegex(value) {
                  if (!value || typeof value !== "object" && typeof value !== "function") {
                    return false;
                  }
                  return $toString(value) === regexClass;
                };
              }
              module2.exports = fn;
            },
            /***/
            1715(module2, __unused_webpack_exports, __webpack_require__2) {
              var $gfJaN$restructure = __webpack_require__2(5233);
              var $gfJaN$swchelperscjs_define_propertycjs = __webpack_require__2(4415);
              var $gfJaN$swchelperscjs_ts_decoratecjs = __webpack_require__2(8395);
              var $gfJaN$fastdeepequal = __webpack_require__2(453);
              var $gfJaN$unicodeproperties = __webpack_require__2(4766);
              var $gfJaN$unicodetrie = __webpack_require__2(7571);
              var $gfJaN$dfa = __webpack_require__2(4406);
              var $gfJaN$clone = __webpack_require__2(1613);
              var $gfJaN$tinyinflate = __webpack_require__2(3483);
              var $gfJaN$brotlidecompressjs = __webpack_require__2(4460);
              function $parcel$exportWildcard(dest, source) {
                Object.keys(source).forEach(function(key) {
                  if (key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(dest, key)) {
                    return;
                  }
                  Object.defineProperty(dest, key, {
                    enumerable: true,
                    get: function get() {
                      return source[key];
                    }
                  });
                });
                return dest;
              }
              function $parcel$export(e, n, v, s) {
                Object.defineProperty(e, n, { get: v, set: s, enumerable: true, configurable: true });
              }
              function $parcel$interopDefault(a) {
                return a && a.__esModule ? a.default : a;
              }
              var $59aa4ed98453e1d4$exports = {};
              $parcel$export($59aa4ed98453e1d4$exports, "logErrors", () => $59aa4ed98453e1d4$export$bd5c5d8b8dcafd78);
              $parcel$export($59aa4ed98453e1d4$exports, "registerFormat", () => $59aa4ed98453e1d4$export$36b2f24e97d43be);
              $parcel$export($59aa4ed98453e1d4$exports, "create", () => $59aa4ed98453e1d4$export$185802fd694ee1f5);
              $parcel$export($59aa4ed98453e1d4$exports, "defaultLanguage", () => $59aa4ed98453e1d4$export$42940898df819940);
              $parcel$export($59aa4ed98453e1d4$exports, "setDefaultLanguage", () => $59aa4ed98453e1d4$export$5157e7780d44cc36);
              let $59aa4ed98453e1d4$export$bd5c5d8b8dcafd78 = false;
              let $59aa4ed98453e1d4$var$formats = [];
              function $59aa4ed98453e1d4$export$36b2f24e97d43be(format) {
                $59aa4ed98453e1d4$var$formats.push(format);
              }
              function $59aa4ed98453e1d4$export$185802fd694ee1f5(buffer, postscriptName) {
                for (let i = 0; i < $59aa4ed98453e1d4$var$formats.length; i++) {
                  let format = $59aa4ed98453e1d4$var$formats[i];
                  if (format.probe(buffer)) {
                    let font = new format(new (0, $gfJaN$restructure.DecodeStream)(buffer));
                    if (postscriptName) return font.getFont(postscriptName);
                    return font;
                  }
                }
                throw new Error("Unknown font format");
              }
              let $59aa4ed98453e1d4$export$42940898df819940 = "en";
              function $59aa4ed98453e1d4$export$5157e7780d44cc36(lang = "en") {
                $59aa4ed98453e1d4$export$42940898df819940 = lang;
              }
              function $3bda6911913b43f0$export$69a3209f1a06c04d(target, key, descriptor) {
                if (descriptor.get) {
                  let get = descriptor.get;
                  descriptor.get = function() {
                    let value = get.call(this);
                    Object.defineProperty(this, key, {
                      value
                    });
                    return value;
                  };
                } else if (typeof descriptor.value === "function") {
                  let fn = descriptor.value;
                  return {
                    get() {
                      let cache = /* @__PURE__ */ new Map();
                      function memoized(...args) {
                        let key2 = args.length > 0 ? args[0] : "value";
                        if (cache.has(key2)) return cache.get(key2);
                        let result = fn.apply(this, args);
                        cache.set(key2, result);
                        return result;
                      }
                      Object.defineProperty(this, key, {
                        value: memoized
                      });
                      return memoized;
                    }
                  };
                }
              }
              let $e4ae0436c91af89f$var$SubHeader = new $gfJaN$restructure.Struct({
                firstCode: $gfJaN$restructure.uint16,
                entryCount: $gfJaN$restructure.uint16,
                idDelta: $gfJaN$restructure.int16,
                idRangeOffset: $gfJaN$restructure.uint16
              });
              let $e4ae0436c91af89f$var$CmapGroup = new $gfJaN$restructure.Struct({
                startCharCode: $gfJaN$restructure.uint32,
                endCharCode: $gfJaN$restructure.uint32,
                glyphID: $gfJaN$restructure.uint32
              });
              let $e4ae0436c91af89f$var$UnicodeValueRange = new $gfJaN$restructure.Struct({
                startUnicodeValue: $gfJaN$restructure.uint24,
                additionalCount: $gfJaN$restructure.uint8
              });
              let $e4ae0436c91af89f$var$UVSMapping = new $gfJaN$restructure.Struct({
                unicodeValue: $gfJaN$restructure.uint24,
                glyphID: $gfJaN$restructure.uint16
              });
              let $e4ae0436c91af89f$var$DefaultUVS = new $gfJaN$restructure.Array($e4ae0436c91af89f$var$UnicodeValueRange, $gfJaN$restructure.uint32);
              let $e4ae0436c91af89f$var$NonDefaultUVS = new $gfJaN$restructure.Array($e4ae0436c91af89f$var$UVSMapping, $gfJaN$restructure.uint32);
              let $e4ae0436c91af89f$var$VarSelectorRecord = new $gfJaN$restructure.Struct({
                varSelector: $gfJaN$restructure.uint24,
                defaultUVS: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, $e4ae0436c91af89f$var$DefaultUVS, {
                  type: "parent"
                }),
                nonDefaultUVS: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, $e4ae0436c91af89f$var$NonDefaultUVS, {
                  type: "parent"
                })
              });
              let $e4ae0436c91af89f$var$CmapSubtable = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint16, {
                0: {
                  length: $gfJaN$restructure.uint16,
                  language: $gfJaN$restructure.uint16,
                  codeMap: new $gfJaN$restructure.LazyArray($gfJaN$restructure.uint8, 256)
                },
                2: {
                  length: $gfJaN$restructure.uint16,
                  language: $gfJaN$restructure.uint16,
                  subHeaderKeys: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, 256),
                  subHeaderCount: (t) => Math.max.apply(Math, t.subHeaderKeys),
                  subHeaders: new $gfJaN$restructure.LazyArray($e4ae0436c91af89f$var$SubHeader, "subHeaderCount"),
                  glyphIndexArray: new $gfJaN$restructure.LazyArray($gfJaN$restructure.uint16, "subHeaderCount")
                },
                4: {
                  length: $gfJaN$restructure.uint16,
                  language: $gfJaN$restructure.uint16,
                  segCountX2: $gfJaN$restructure.uint16,
                  segCount: (t) => t.segCountX2 >> 1,
                  searchRange: $gfJaN$restructure.uint16,
                  entrySelector: $gfJaN$restructure.uint16,
                  rangeShift: $gfJaN$restructure.uint16,
                  endCode: new $gfJaN$restructure.LazyArray($gfJaN$restructure.uint16, "segCount"),
                  reservedPad: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint16),
                  startCode: new $gfJaN$restructure.LazyArray($gfJaN$restructure.uint16, "segCount"),
                  idDelta: new $gfJaN$restructure.LazyArray($gfJaN$restructure.int16, "segCount"),
                  idRangeOffset: new $gfJaN$restructure.LazyArray($gfJaN$restructure.uint16, "segCount"),
                  glyphIndexArray: new $gfJaN$restructure.LazyArray($gfJaN$restructure.uint16, (t) => (t.length - t._currentOffset) / 2)
                },
                6: {
                  length: $gfJaN$restructure.uint16,
                  language: $gfJaN$restructure.uint16,
                  firstCode: $gfJaN$restructure.uint16,
                  entryCount: $gfJaN$restructure.uint16,
                  glyphIndices: new $gfJaN$restructure.LazyArray($gfJaN$restructure.uint16, "entryCount")
                },
                8: {
                  reserved: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint16),
                  length: $gfJaN$restructure.uint32,
                  language: $gfJaN$restructure.uint16,
                  is32: new $gfJaN$restructure.LazyArray($gfJaN$restructure.uint8, 8192),
                  nGroups: $gfJaN$restructure.uint32,
                  groups: new $gfJaN$restructure.LazyArray($e4ae0436c91af89f$var$CmapGroup, "nGroups")
                },
                10: {
                  reserved: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint16),
                  length: $gfJaN$restructure.uint32,
                  language: $gfJaN$restructure.uint32,
                  firstCode: $gfJaN$restructure.uint32,
                  entryCount: $gfJaN$restructure.uint32,
                  glyphIndices: new $gfJaN$restructure.LazyArray($gfJaN$restructure.uint16, "numChars")
                },
                12: {
                  reserved: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint16),
                  length: $gfJaN$restructure.uint32,
                  language: $gfJaN$restructure.uint32,
                  nGroups: $gfJaN$restructure.uint32,
                  groups: new $gfJaN$restructure.LazyArray($e4ae0436c91af89f$var$CmapGroup, "nGroups")
                },
                13: {
                  reserved: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint16),
                  length: $gfJaN$restructure.uint32,
                  language: $gfJaN$restructure.uint32,
                  nGroups: $gfJaN$restructure.uint32,
                  groups: new $gfJaN$restructure.LazyArray($e4ae0436c91af89f$var$CmapGroup, "nGroups")
                },
                14: {
                  length: $gfJaN$restructure.uint32,
                  numRecords: $gfJaN$restructure.uint32,
                  varSelectors: new $gfJaN$restructure.LazyArray($e4ae0436c91af89f$var$VarSelectorRecord, "numRecords")
                }
              });
              let $e4ae0436c91af89f$var$CmapEntry = new $gfJaN$restructure.Struct({
                platformID: $gfJaN$restructure.uint16,
                encodingID: $gfJaN$restructure.uint16,
                table: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, $e4ae0436c91af89f$var$CmapSubtable, {
                  type: "parent",
                  lazy: true
                })
              });
              var $e4ae0436c91af89f$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.uint16,
                numSubtables: $gfJaN$restructure.uint16,
                tables: new $gfJaN$restructure.Array($e4ae0436c91af89f$var$CmapEntry, "numSubtables")
              });
              var $55a60976afb7c261$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.int32,
                revision: $gfJaN$restructure.int32,
                checkSumAdjustment: $gfJaN$restructure.uint32,
                magicNumber: $gfJaN$restructure.uint32,
                flags: $gfJaN$restructure.uint16,
                unitsPerEm: $gfJaN$restructure.uint16,
                created: new $gfJaN$restructure.Array($gfJaN$restructure.int32, 2),
                modified: new $gfJaN$restructure.Array($gfJaN$restructure.int32, 2),
                xMin: $gfJaN$restructure.int16,
                yMin: $gfJaN$restructure.int16,
                xMax: $gfJaN$restructure.int16,
                yMax: $gfJaN$restructure.int16,
                macStyle: new $gfJaN$restructure.Bitfield($gfJaN$restructure.uint16, [
                  "bold",
                  "italic",
                  "underline",
                  "outline",
                  "shadow",
                  "condensed",
                  "extended"
                ]),
                lowestRecPPEM: $gfJaN$restructure.uint16,
                fontDirectionHint: $gfJaN$restructure.int16,
                indexToLocFormat: $gfJaN$restructure.int16,
                glyphDataFormat: $gfJaN$restructure.int16
                // 0 for current format
              });
              var $dde72b7b5b650596$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.int32,
                ascent: $gfJaN$restructure.int16,
                descent: $gfJaN$restructure.int16,
                lineGap: $gfJaN$restructure.int16,
                advanceWidthMax: $gfJaN$restructure.uint16,
                minLeftSideBearing: $gfJaN$restructure.int16,
                minRightSideBearing: $gfJaN$restructure.int16,
                xMaxExtent: $gfJaN$restructure.int16,
                caretSlopeRise: $gfJaN$restructure.int16,
                caretSlopeRun: $gfJaN$restructure.int16,
                caretOffset: $gfJaN$restructure.int16,
                reserved: new $gfJaN$restructure.Reserved($gfJaN$restructure.int16, 4),
                metricDataFormat: $gfJaN$restructure.int16,
                numberOfMetrics: $gfJaN$restructure.uint16
                // Number of advance widths in 'hmtx' table
              });
              let $a7c40184072c9a5b$var$HmtxEntry = new $gfJaN$restructure.Struct({
                advance: $gfJaN$restructure.uint16,
                bearing: $gfJaN$restructure.int16
              });
              var $a7c40184072c9a5b$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                metrics: new $gfJaN$restructure.LazyArray($a7c40184072c9a5b$var$HmtxEntry, (t) => t.parent.hhea.numberOfMetrics),
                bearings: new $gfJaN$restructure.LazyArray($gfJaN$restructure.int16, (t) => t.parent.maxp.numGlyphs - t.parent.hhea.numberOfMetrics)
              });
              var $521197722369f691$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.int32,
                numGlyphs: $gfJaN$restructure.uint16,
                maxPoints: $gfJaN$restructure.uint16,
                maxContours: $gfJaN$restructure.uint16,
                maxComponentPoints: $gfJaN$restructure.uint16,
                maxComponentContours: $gfJaN$restructure.uint16,
                maxZones: $gfJaN$restructure.uint16,
                maxTwilightPoints: $gfJaN$restructure.uint16,
                maxStorage: $gfJaN$restructure.uint16,
                maxFunctionDefs: $gfJaN$restructure.uint16,
                maxInstructionDefs: $gfJaN$restructure.uint16,
                maxStackElements: $gfJaN$restructure.uint16,
                maxSizeOfInstructions: $gfJaN$restructure.uint16,
                maxComponentElements: $gfJaN$restructure.uint16,
                maxComponentDepth: $gfJaN$restructure.uint16
                // Maximum levels of recursion; 1 for simple components
              });
              function $e2613b812f052cbe$export$badc544e0651b6b1(platformID, encodingID, languageID = 0) {
                if (platformID === 1 && $e2613b812f052cbe$export$479e671907f486d1[languageID]) return $e2613b812f052cbe$export$479e671907f486d1[languageID];
                return $e2613b812f052cbe$export$6fef87b7618bdf0b[platformID][encodingID];
              }
              const $e2613b812f052cbe$var$SINGLE_BYTE_ENCODINGS = /* @__PURE__ */ new Set([
                "x-mac-roman",
                "x-mac-cyrillic",
                "iso-8859-6",
                "iso-8859-8"
              ]);
              const $e2613b812f052cbe$var$MAC_ENCODINGS = {
                "x-mac-croatian": " ",
                "x-mac-gaelic": " ",
                "x-mac-greek": " ",
                "x-mac-icelandic": " ",
                "x-mac-inuit": " ",
                "x-mac-ce": " ",
                "x-mac-romanian": " ",
                "x-mac-turkish": " "
              };
              const $e2613b812f052cbe$var$encodingCache = /* @__PURE__ */ new Map();
              function $e2613b812f052cbe$export$1dceb3c14ed68bee(encoding) {
                let cached = $e2613b812f052cbe$var$encodingCache.get(encoding);
                if (cached) return cached;
                let mapping = $e2613b812f052cbe$var$MAC_ENCODINGS[encoding];
                if (mapping) {
                  let res = /* @__PURE__ */ new Map();
                  for (let i = 0; i < mapping.length; i++) res.set(mapping.charCodeAt(i), 128 + i);
                  $e2613b812f052cbe$var$encodingCache.set(encoding, res);
                  return res;
                }
                if ($e2613b812f052cbe$var$SINGLE_BYTE_ENCODINGS.has(encoding)) {
                  let decoder = new TextDecoder(encoding);
                  let mapping2 = new Uint8Array(128);
                  for (let i = 0; i < 128; i++) mapping2[i] = 128 + i;
                  let res = /* @__PURE__ */ new Map();
                  let s = decoder.decode(mapping2);
                  for (let i = 0; i < 128; i++) res.set(s.charCodeAt(i), 128 + i);
                  $e2613b812f052cbe$var$encodingCache.set(encoding, res);
                  return res;
                }
              }
              const $e2613b812f052cbe$export$6fef87b7618bdf0b = [
                // unicode
                [
                  "utf-16be",
                  "utf-16be",
                  "utf-16be",
                  "utf-16be",
                  "utf-16be",
                  "utf-16be",
                  "utf-16be"
                ],
                // macintosh
                // Mappings available at http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/
                // 0	Roman                 17	Malayalam
                // 1	Japanese	            18	Sinhalese
                // 2	Traditional Chinese	  19	Burmese
                // 3	Korean	              20	Khmer
                // 4	Arabic	              21	Thai
                // 5	Hebrew	              22	Laotian
                // 6	Greek	                23	Georgian
                // 7	Russian	              24	Armenian
                // 8	RSymbol	              25	Simplified Chinese
                // 9	Devanagari	          26	Tibetan
                // 10	Gurmukhi	            27	Mongolian
                // 11	Gujarati	            28	Geez
                // 12	Oriya	                29	Slavic
                // 13	Bengali	              30	Vietnamese
                // 14	Tamil	                31	Sindhi
                // 15	Telugu	              32	(Uninterpreted)
                // 16	Kannada
                [
                  "x-mac-roman",
                  "shift-jis",
                  "big5",
                  "euc-kr",
                  "iso-8859-6",
                  "iso-8859-8",
                  "x-mac-greek",
                  "x-mac-cyrillic",
                  "x-mac-symbol",
                  "x-mac-devanagari",
                  "x-mac-gurmukhi",
                  "x-mac-gujarati",
                  "Oriya",
                  "Bengali",
                  "Tamil",
                  "Telugu",
                  "Kannada",
                  "Malayalam",
                  "Sinhalese",
                  "Burmese",
                  "Khmer",
                  "iso-8859-11",
                  "Laotian",
                  "Georgian",
                  "Armenian",
                  "gbk",
                  "Tibetan",
                  "Mongolian",
                  "Geez",
                  "x-mac-ce",
                  "Vietnamese",
                  "Sindhi"
                ],
                // ISO (deprecated)
                [
                  "ascii",
                  null,
                  "iso-8859-1"
                ],
                // windows
                // Docs here: http://msdn.microsoft.com/en-us/library/system.text.encoding(v=vs.110).aspx
                [
                  "symbol",
                  "utf-16be",
                  "shift-jis",
                  "gb18030",
                  "big5",
                  "euc-kr",
                  "johab",
                  null,
                  null,
                  null,
                  "utf-16be"
                ]
              ];
              const $e2613b812f052cbe$export$479e671907f486d1 = {
                15: "x-mac-icelandic",
                17: "x-mac-turkish",
                18: "x-mac-croatian",
                24: "x-mac-ce",
                25: "x-mac-ce",
                26: "x-mac-ce",
                27: "x-mac-ce",
                28: "x-mac-ce",
                30: "x-mac-icelandic",
                37: "x-mac-romanian",
                38: "x-mac-ce",
                39: "x-mac-ce",
                40: "x-mac-ce",
                143: "x-mac-inuit",
                146: "x-mac-gaelic"
              };
              const $e2613b812f052cbe$export$2092376fd002e13 = [
                // unicode
                [],
                {
                  0: "en",
                  30: "fo",
                  60: "ks",
                  90: "rw",
                  1: "fr",
                  31: "fa",
                  61: "ku",
                  91: "rn",
                  2: "de",
                  32: "ru",
                  62: "sd",
                  92: "ny",
                  3: "it",
                  33: "zh",
                  63: "bo",
                  93: "mg",
                  4: "nl",
                  34: "nl-BE",
                  64: "ne",
                  94: "eo",
                  5: "sv",
                  35: "ga",
                  65: "sa",
                  128: "cy",
                  6: "es",
                  36: "sq",
                  66: "mr",
                  129: "eu",
                  7: "da",
                  37: "ro",
                  67: "bn",
                  130: "ca",
                  8: "pt",
                  38: "cz",
                  68: "as",
                  131: "la",
                  9: "no",
                  39: "sk",
                  69: "gu",
                  132: "qu",
                  10: "he",
                  40: "si",
                  70: "pa",
                  133: "gn",
                  11: "ja",
                  41: "yi",
                  71: "or",
                  134: "ay",
                  12: "ar",
                  42: "sr",
                  72: "ml",
                  135: "tt",
                  13: "fi",
                  43: "mk",
                  73: "kn",
                  136: "ug",
                  14: "el",
                  44: "bg",
                  74: "ta",
                  137: "dz",
                  15: "is",
                  45: "uk",
                  75: "te",
                  138: "jv",
                  16: "mt",
                  46: "be",
                  76: "si",
                  139: "su",
                  17: "tr",
                  47: "uz",
                  77: "my",
                  140: "gl",
                  18: "hr",
                  48: "kk",
                  78: "km",
                  141: "af",
                  19: "zh-Hant",
                  49: "az-Cyrl",
                  79: "lo",
                  142: "br",
                  20: "ur",
                  50: "az-Arab",
                  80: "vi",
                  143: "iu",
                  21: "hi",
                  51: "hy",
                  81: "id",
                  144: "gd",
                  22: "th",
                  52: "ka",
                  82: "tl",
                  145: "gv",
                  23: "ko",
                  53: "mo",
                  83: "ms",
                  146: "ga",
                  24: "lt",
                  54: "ky",
                  84: "ms-Arab",
                  147: "to",
                  25: "pl",
                  55: "tg",
                  85: "am",
                  148: "el-polyton",
                  26: "hu",
                  56: "tk",
                  86: "ti",
                  149: "kl",
                  27: "es",
                  57: "mn-CN",
                  87: "om",
                  150: "az",
                  28: "lv",
                  58: "mn",
                  88: "so",
                  151: "nn",
                  29: "se",
                  59: "ps",
                  89: "sw"
                },
                // ISO (deprecated)
                [],
                {
                  1078: "af",
                  16393: "en-IN",
                  1159: "rw",
                  1074: "tn",
                  1052: "sq",
                  6153: "en-IE",
                  1089: "sw",
                  1115: "si",
                  1156: "gsw",
                  8201: "en-JM",
                  1111: "kok",
                  1051: "sk",
                  1118: "am",
                  17417: "en-MY",
                  1042: "ko",
                  1060: "sl",
                  5121: "ar-DZ",
                  5129: "en-NZ",
                  1088: "ky",
                  11274: "es-AR",
                  15361: "ar-BH",
                  13321: "en-PH",
                  1108: "lo",
                  16394: "es-BO",
                  3073: "ar",
                  18441: "en-SG",
                  1062: "lv",
                  13322: "es-CL",
                  2049: "ar-IQ",
                  7177: "en-ZA",
                  1063: "lt",
                  9226: "es-CO",
                  11265: "ar-JO",
                  11273: "en-TT",
                  2094: "dsb",
                  5130: "es-CR",
                  13313: "ar-KW",
                  2057: "en-GB",
                  1134: "lb",
                  7178: "es-DO",
                  12289: "ar-LB",
                  1033: "en",
                  1071: "mk",
                  12298: "es-EC",
                  4097: "ar-LY",
                  12297: "en-ZW",
                  2110: "ms-BN",
                  17418: "es-SV",
                  6145: "ary",
                  1061: "et",
                  1086: "ms",
                  4106: "es-GT",
                  8193: "ar-OM",
                  1080: "fo",
                  1100: "ml",
                  18442: "es-HN",
                  16385: "ar-QA",
                  1124: "fil",
                  1082: "mt",
                  2058: "es-MX",
                  1025: "ar-SA",
                  1035: "fi",
                  1153: "mi",
                  19466: "es-NI",
                  10241: "ar-SY",
                  2060: "fr-BE",
                  1146: "arn",
                  6154: "es-PA",
                  7169: "aeb",
                  3084: "fr-CA",
                  1102: "mr",
                  15370: "es-PY",
                  14337: "ar-AE",
                  1036: "fr",
                  1148: "moh",
                  10250: "es-PE",
                  9217: "ar-YE",
                  5132: "fr-LU",
                  1104: "mn",
                  20490: "es-PR",
                  1067: "hy",
                  6156: "fr-MC",
                  2128: "mn-CN",
                  3082: "es",
                  1101: "as",
                  4108: "fr-CH",
                  1121: "ne",
                  1034: "es",
                  2092: "az-Cyrl",
                  1122: "fy",
                  1044: "nb",
                  21514: "es-US",
                  1068: "az",
                  1110: "gl",
                  2068: "nn",
                  14346: "es-UY",
                  1133: "ba",
                  1079: "ka",
                  1154: "oc",
                  8202: "es-VE",
                  1069: "eu",
                  3079: "de-AT",
                  1096: "or",
                  2077: "sv-FI",
                  1059: "be",
                  1031: "de",
                  1123: "ps",
                  1053: "sv",
                  2117: "bn",
                  5127: "de-LI",
                  1045: "pl",
                  1114: "syr",
                  1093: "bn-IN",
                  4103: "de-LU",
                  1046: "pt",
                  1064: "tg",
                  8218: "bs-Cyrl",
                  2055: "de-CH",
                  2070: "pt-PT",
                  2143: "tzm",
                  5146: "bs",
                  1032: "el",
                  1094: "pa",
                  1097: "ta",
                  1150: "br",
                  1135: "kl",
                  1131: "qu-BO",
                  1092: "tt",
                  1026: "bg",
                  1095: "gu",
                  2155: "qu-EC",
                  1098: "te",
                  1027: "ca",
                  1128: "ha",
                  3179: "qu",
                  1054: "th",
                  3076: "zh-HK",
                  1037: "he",
                  1048: "ro",
                  1105: "bo",
                  5124: "zh-MO",
                  1081: "hi",
                  1047: "rm",
                  1055: "tr",
                  2052: "zh",
                  1038: "hu",
                  1049: "ru",
                  1090: "tk",
                  4100: "zh-SG",
                  1039: "is",
                  9275: "smn",
                  1152: "ug",
                  1028: "zh-TW",
                  1136: "ig",
                  4155: "smj-NO",
                  1058: "uk",
                  1155: "co",
                  1057: "id",
                  5179: "smj",
                  1070: "hsb",
                  1050: "hr",
                  1117: "iu",
                  3131: "se-FI",
                  1056: "ur",
                  4122: "hr-BA",
                  2141: "iu-Latn",
                  1083: "se",
                  2115: "uz-Cyrl",
                  1029: "cs",
                  2108: "ga",
                  2107: "se-SE",
                  1091: "uz",
                  1030: "da",
                  1076: "xh",
                  8251: "sms",
                  1066: "vi",
                  1164: "prs",
                  1077: "zu",
                  6203: "sma-NO",
                  1106: "cy",
                  1125: "dv",
                  1040: "it",
                  7227: "sms",
                  1160: "wo",
                  2067: "nl-BE",
                  2064: "it-CH",
                  1103: "sa",
                  1157: "sah",
                  1043: "nl",
                  1041: "ja",
                  7194: "sr-Cyrl-BA",
                  1144: "ii",
                  3081: "en-AU",
                  1099: "kn",
                  3098: "sr",
                  1130: "yo",
                  10249: "en-BZ",
                  1087: "kk",
                  6170: "sr-Latn-BA",
                  4105: "en-CA",
                  1107: "km",
                  2074: "sr-Latn",
                  9225: "en-029",
                  1158: "quc",
                  1132: "nso"
                }
              ];
              let $51a9f4feb3a3b2b1$var$NameRecord = new $gfJaN$restructure.Struct({
                platformID: $gfJaN$restructure.uint16,
                encodingID: $gfJaN$restructure.uint16,
                languageID: $gfJaN$restructure.uint16,
                nameID: $gfJaN$restructure.uint16,
                length: $gfJaN$restructure.uint16,
                string: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, new $gfJaN$restructure.String("length", (t) => (0, $e2613b812f052cbe$export$badc544e0651b6b1)(t.platformID, t.encodingID, t.languageID)), {
                  type: "parent",
                  relativeTo: (ctx) => ctx.parent.stringOffset,
                  allowNull: false
                })
              });
              let $51a9f4feb3a3b2b1$var$LangTagRecord = new $gfJaN$restructure.Struct({
                length: $gfJaN$restructure.uint16,
                tag: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, new $gfJaN$restructure.String("length", "utf16be"), {
                  type: "parent",
                  relativeTo: (ctx) => ctx.stringOffset
                })
              });
              var $51a9f4feb3a3b2b1$var$NameTable = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint16, {
                0: {
                  count: $gfJaN$restructure.uint16,
                  stringOffset: $gfJaN$restructure.uint16,
                  records: new $gfJaN$restructure.Array($51a9f4feb3a3b2b1$var$NameRecord, "count")
                },
                1: {
                  count: $gfJaN$restructure.uint16,
                  stringOffset: $gfJaN$restructure.uint16,
                  records: new $gfJaN$restructure.Array($51a9f4feb3a3b2b1$var$NameRecord, "count"),
                  langTagCount: $gfJaN$restructure.uint16,
                  langTags: new $gfJaN$restructure.Array($51a9f4feb3a3b2b1$var$LangTagRecord, "langTagCount")
                }
              });
              var $51a9f4feb3a3b2b1$export$2e2bcd8739ae039 = $51a9f4feb3a3b2b1$var$NameTable;
              const $51a9f4feb3a3b2b1$var$NAMES = [
                "copyright",
                "fontFamily",
                "fontSubfamily",
                "uniqueSubfamily",
                "fullName",
                "version",
                "postscriptName",
                "trademark",
                "manufacturer",
                "designer",
                "description",
                "vendorURL",
                "designerURL",
                "license",
                "licenseURL",
                null,
                "preferredFamily",
                "preferredSubfamily",
                "compatibleFull",
                "sampleText",
                "postscriptCIDFontName",
                "wwsFamilyName",
                "wwsSubfamilyName"
              ];
              $51a9f4feb3a3b2b1$var$NameTable.process = function(stream) {
                var records = {};
                for (let record of this.records) {
                  let language = (0, $e2613b812f052cbe$export$2092376fd002e13)[record.platformID][record.languageID];
                  if (language == null && this.langTags != null && record.languageID >= 32768) language = this.langTags[record.languageID - 32768].tag;
                  if (language == null) language = record.platformID + "-" + record.languageID;
                  let key = record.nameID >= 256 ? "fontFeatures" : $51a9f4feb3a3b2b1$var$NAMES[record.nameID] || record.nameID;
                  if (records[key] == null) records[key] = {};
                  let obj = records[key];
                  if (record.nameID >= 256) obj = obj[record.nameID] || (obj[record.nameID] = {});
                  if (typeof record.string === "string" || typeof obj[language] !== "string") obj[language] = record.string;
                }
                this.records = records;
              };
              $51a9f4feb3a3b2b1$var$NameTable.preEncode = function() {
                if (Array.isArray(this.records)) return;
                this.version = 0;
                let records = [];
                for (let key in this.records) {
                  let val = this.records[key];
                  if (key === "fontFeatures") continue;
                  records.push({
                    platformID: 3,
                    encodingID: 1,
                    languageID: 1033,
                    nameID: $51a9f4feb3a3b2b1$var$NAMES.indexOf(key),
                    length: val.en.length * 2,
                    string: val.en
                  });
                  if (key === "postscriptName") records.push({
                    platformID: 1,
                    encodingID: 0,
                    languageID: 0,
                    nameID: $51a9f4feb3a3b2b1$var$NAMES.indexOf(key),
                    length: val.en.length,
                    string: val.en
                  });
                }
                this.records = records;
                this.count = records.length;
                this.stringOffset = $51a9f4feb3a3b2b1$var$NameTable.size(this, null, false);
              };
              var $114ea85db469b435$var$OS2 = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint16, {
                header: {
                  xAvgCharWidth: $gfJaN$restructure.int16,
                  usWeightClass: $gfJaN$restructure.uint16,
                  usWidthClass: $gfJaN$restructure.uint16,
                  fsType: new $gfJaN$restructure.Bitfield($gfJaN$restructure.uint16, [
                    null,
                    "noEmbedding",
                    "viewOnly",
                    "editable",
                    null,
                    null,
                    null,
                    null,
                    "noSubsetting",
                    "bitmapOnly"
                  ]),
                  ySubscriptXSize: $gfJaN$restructure.int16,
                  ySubscriptYSize: $gfJaN$restructure.int16,
                  ySubscriptXOffset: $gfJaN$restructure.int16,
                  ySubscriptYOffset: $gfJaN$restructure.int16,
                  ySuperscriptXSize: $gfJaN$restructure.int16,
                  ySuperscriptYSize: $gfJaN$restructure.int16,
                  ySuperscriptXOffset: $gfJaN$restructure.int16,
                  ySuperscriptYOffset: $gfJaN$restructure.int16,
                  yStrikeoutSize: $gfJaN$restructure.int16,
                  yStrikeoutPosition: $gfJaN$restructure.int16,
                  sFamilyClass: $gfJaN$restructure.int16,
                  panose: new $gfJaN$restructure.Array($gfJaN$restructure.uint8, 10),
                  ulCharRange: new $gfJaN$restructure.Array($gfJaN$restructure.uint32, 4),
                  vendorID: new $gfJaN$restructure.String(4),
                  fsSelection: new $gfJaN$restructure.Bitfield($gfJaN$restructure.uint16, [
                    "italic",
                    "underscore",
                    "negative",
                    "outlined",
                    "strikeout",
                    "bold",
                    "regular",
                    "useTypoMetrics",
                    "wws",
                    "oblique"
                  ]),
                  usFirstCharIndex: $gfJaN$restructure.uint16,
                  usLastCharIndex: $gfJaN$restructure.uint16
                  // The maximum Unicode index in this font
                },
                // The Apple version of this table ends here, but the Microsoft one continues on...
                0: {},
                1: {
                  typoAscender: $gfJaN$restructure.int16,
                  typoDescender: $gfJaN$restructure.int16,
                  typoLineGap: $gfJaN$restructure.int16,
                  winAscent: $gfJaN$restructure.uint16,
                  winDescent: $gfJaN$restructure.uint16,
                  codePageRange: new $gfJaN$restructure.Array($gfJaN$restructure.uint32, 2)
                },
                2: {
                  // these should be common with version 1 somehow
                  typoAscender: $gfJaN$restructure.int16,
                  typoDescender: $gfJaN$restructure.int16,
                  typoLineGap: $gfJaN$restructure.int16,
                  winAscent: $gfJaN$restructure.uint16,
                  winDescent: $gfJaN$restructure.uint16,
                  codePageRange: new $gfJaN$restructure.Array($gfJaN$restructure.uint32, 2),
                  xHeight: $gfJaN$restructure.int16,
                  capHeight: $gfJaN$restructure.int16,
                  defaultChar: $gfJaN$restructure.uint16,
                  breakChar: $gfJaN$restructure.uint16,
                  maxContent: $gfJaN$restructure.uint16
                },
                5: {
                  typoAscender: $gfJaN$restructure.int16,
                  typoDescender: $gfJaN$restructure.int16,
                  typoLineGap: $gfJaN$restructure.int16,
                  winAscent: $gfJaN$restructure.uint16,
                  winDescent: $gfJaN$restructure.uint16,
                  codePageRange: new $gfJaN$restructure.Array($gfJaN$restructure.uint32, 2),
                  xHeight: $gfJaN$restructure.int16,
                  capHeight: $gfJaN$restructure.int16,
                  defaultChar: $gfJaN$restructure.uint16,
                  breakChar: $gfJaN$restructure.uint16,
                  maxContent: $gfJaN$restructure.uint16,
                  usLowerOpticalPointSize: $gfJaN$restructure.uint16,
                  usUpperOpticalPointSize: $gfJaN$restructure.uint16
                }
              });
              let $114ea85db469b435$var$versions = $114ea85db469b435$var$OS2.versions;
              $114ea85db469b435$var$versions[3] = $114ea85db469b435$var$versions[4] = $114ea85db469b435$var$versions[2];
              var $114ea85db469b435$export$2e2bcd8739ae039 = $114ea85db469b435$var$OS2;
              var $f93b30299e1ea0f5$export$2e2bcd8739ae039 = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.fixed32, {
                header: {
                  italicAngle: $gfJaN$restructure.fixed32,
                  underlinePosition: $gfJaN$restructure.int16,
                  underlineThickness: $gfJaN$restructure.int16,
                  isFixedPitch: $gfJaN$restructure.uint32,
                  minMemType42: $gfJaN$restructure.uint32,
                  maxMemType42: $gfJaN$restructure.uint32,
                  minMemType1: $gfJaN$restructure.uint32,
                  maxMemType1: $gfJaN$restructure.uint32
                  // Maximum memory usage when a TrueType font is downloaded as a Type 1 font
                },
                1: {},
                2: {
                  numberOfGlyphs: $gfJaN$restructure.uint16,
                  glyphNameIndex: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, "numberOfGlyphs"),
                  names: new $gfJaN$restructure.Array(new $gfJaN$restructure.String($gfJaN$restructure.uint8))
                },
                2.5: {
                  numberOfGlyphs: $gfJaN$restructure.uint16,
                  offsets: new $gfJaN$restructure.Array($gfJaN$restructure.uint8, "numberOfGlyphs")
                },
                3: {},
                4: {
                  map: new $gfJaN$restructure.Array($gfJaN$restructure.uint32, (t) => t.parent.maxp.numGlyphs)
                }
              });
              var $8fb09b0f473d61a0$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                controlValues: new $gfJaN$restructure.Array($gfJaN$restructure.int16)
              });
              var $873d79fea57d3161$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                instructions: new $gfJaN$restructure.Array($gfJaN$restructure.uint8)
              });
              let $83c4155666d50c37$var$loca = new $gfJaN$restructure.VersionedStruct("head.indexToLocFormat", {
                0: {
                  offsets: new $gfJaN$restructure.Array($gfJaN$restructure.uint16)
                },
                1: {
                  offsets: new $gfJaN$restructure.Array($gfJaN$restructure.uint32)
                }
              });
              $83c4155666d50c37$var$loca.process = function() {
                if (this.version === 0 && !this._processed) {
                  for (let i = 0; i < this.offsets.length; i++) this.offsets[i] <<= 1;
                  this._processed = true;
                }
              };
              $83c4155666d50c37$var$loca.preEncode = function() {
                if (this.version === 0 && this._processed !== false) {
                  for (let i = 0; i < this.offsets.length; i++) this.offsets[i] >>>= 1;
                  this._processed = false;
                }
              };
              var $83c4155666d50c37$export$2e2bcd8739ae039 = $83c4155666d50c37$var$loca;
              var $b12598db7cdf7042$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                controlValueProgram: new $gfJaN$restructure.Array($gfJaN$restructure.uint8)
              });
              var $7707bdf21a3d89cc$export$2e2bcd8739ae039 = new $gfJaN$restructure.Array(new $gfJaN$restructure.Buffer());
              class $9eaea3754914a290$export$2e2bcd8739ae039 {
                getCFFVersion(ctx) {
                  while (ctx && !ctx.hdrSize) ctx = ctx.parent;
                  return ctx ? ctx.version : -1;
                }
                decode(stream, parent) {
                  let version = this.getCFFVersion(parent);
                  let count = version >= 2 ? stream.readUInt32BE() : stream.readUInt16BE();
                  if (count === 0) return [];
                  let offSize = stream.readUInt8();
                  let offsetType;
                  if (offSize === 1) offsetType = $gfJaN$restructure.uint8;
                  else if (offSize === 2) offsetType = $gfJaN$restructure.uint16;
                  else if (offSize === 3) offsetType = $gfJaN$restructure.uint24;
                  else if (offSize === 4) offsetType = $gfJaN$restructure.uint32;
                  else throw new Error(`Bad offset size in CFFIndex: ${offSize} ${stream.pos}`);
                  let ret = [];
                  let startPos = stream.pos + (count + 1) * offSize - 1;
                  let start = offsetType.decode(stream);
                  for (let i = 0; i < count; i++) {
                    let end = offsetType.decode(stream);
                    if (this.type != null) {
                      let pos = stream.pos;
                      stream.pos = startPos + start;
                      parent.length = end - start;
                      ret.push(this.type.decode(stream, parent));
                      stream.pos = pos;
                    } else ret.push({
                      offset: startPos + start,
                      length: end - start
                    });
                    start = end;
                  }
                  stream.pos = startPos + start;
                  return ret;
                }
                size(arr, parent) {
                  let size = 2;
                  if (arr.length === 0) return size;
                  let type = this.type || new $gfJaN$restructure.Buffer();
                  let offset = 1;
                  for (let i = 0; i < arr.length; i++) {
                    let item = arr[i];
                    offset += type.size(item, parent);
                  }
                  let offsetType;
                  if (offset <= 255) offsetType = $gfJaN$restructure.uint8;
                  else if (offset <= 65535) offsetType = $gfJaN$restructure.uint16;
                  else if (offset <= 16777215) offsetType = $gfJaN$restructure.uint24;
                  else if (offset <= 4294967295) offsetType = $gfJaN$restructure.uint32;
                  else throw new Error("Bad offset in CFFIndex");
                  size += 1 + offsetType.size() * (arr.length + 1);
                  size += offset - 1;
                  return size;
                }
                encode(stream, arr, parent) {
                  stream.writeUInt16BE(arr.length);
                  if (arr.length === 0) return;
                  let type = this.type || new $gfJaN$restructure.Buffer();
                  let sizes = [];
                  let offset = 1;
                  for (let item of arr) {
                    let s = type.size(item, parent);
                    sizes.push(s);
                    offset += s;
                  }
                  let offsetType;
                  if (offset <= 255) offsetType = $gfJaN$restructure.uint8;
                  else if (offset <= 65535) offsetType = $gfJaN$restructure.uint16;
                  else if (offset <= 16777215) offsetType = $gfJaN$restructure.uint24;
                  else if (offset <= 4294967295) offsetType = $gfJaN$restructure.uint32;
                  else throw new Error("Bad offset in CFFIndex");
                  stream.writeUInt8(offsetType.size());
                  offset = 1;
                  offsetType.encode(stream, offset);
                  for (let size of sizes) {
                    offset += size;
                    offsetType.encode(stream, offset);
                  }
                  for (let item of arr) type.encode(stream, item, parent);
                  return;
                }
                constructor(type) {
                  this.type = type;
                }
              }
              const $f77b592c17132d70$var$FLOAT_EOF = 15;
              const $f77b592c17132d70$var$FLOAT_LOOKUP = [
                "0",
                "1",
                "2",
                "3",
                "4",
                "5",
                "6",
                "7",
                "8",
                "9",
                ".",
                "E",
                "E-",
                null,
                "-"
              ];
              const $f77b592c17132d70$var$FLOAT_ENCODE_LOOKUP = {
                ".": 10,
                "E": 11,
                "E-": 12,
                "-": 14
              };
              class $f77b592c17132d70$export$2e2bcd8739ae039 {
                static decode(stream, value) {
                  if (32 <= value && value <= 246) return value - 139;
                  if (247 <= value && value <= 250) return (value - 247) * 256 + stream.readUInt8() + 108;
                  if (251 <= value && value <= 254) return -(value - 251) * 256 - stream.readUInt8() - 108;
                  if (value === 28) return stream.readInt16BE();
                  if (value === 29) return stream.readInt32BE();
                  if (value === 30) {
                    let str = "";
                    while (true) {
                      let b = stream.readUInt8();
                      let n1 = b >> 4;
                      if (n1 === $f77b592c17132d70$var$FLOAT_EOF) break;
                      str += $f77b592c17132d70$var$FLOAT_LOOKUP[n1];
                      let n2 = b & 15;
                      if (n2 === $f77b592c17132d70$var$FLOAT_EOF) break;
                      str += $f77b592c17132d70$var$FLOAT_LOOKUP[n2];
                    }
                    return parseFloat(str);
                  }
                  return null;
                }
                static size(value) {
                  if (value.forceLarge) value = 32768;
                  if ((value | 0) !== value) {
                    let str = "" + value;
                    return 1 + Math.ceil((str.length + 1) / 2);
                  } else if (-107 <= value && value <= 107) return 1;
                  else if (108 <= value && value <= 1131 || -1131 <= value && value <= -108) return 2;
                  else if (-32768 <= value && value <= 32767) return 3;
                  else return 5;
                }
                static encode(stream, value) {
                  let val = Number(value);
                  if (value.forceLarge) {
                    stream.writeUInt8(29);
                    return stream.writeInt32BE(val);
                  } else if ((val | 0) !== val) {
                    stream.writeUInt8(30);
                    let str = "" + val;
                    for (let i = 0; i < str.length; i += 2) {
                      let c1 = str[i];
                      let n1 = $f77b592c17132d70$var$FLOAT_ENCODE_LOOKUP[c1] || +c1;
                      if (i === str.length - 1) var n2 = $f77b592c17132d70$var$FLOAT_EOF;
                      else {
                        let c2 = str[i + 1];
                        var n2 = $f77b592c17132d70$var$FLOAT_ENCODE_LOOKUP[c2] || +c2;
                      }
                      stream.writeUInt8(n1 << 4 | n2 & 15);
                    }
                    if (n2 !== $f77b592c17132d70$var$FLOAT_EOF) return stream.writeUInt8($f77b592c17132d70$var$FLOAT_EOF << 4);
                  } else if (-107 <= val && val <= 107) return stream.writeUInt8(val + 139);
                  else if (108 <= val && val <= 1131) {
                    val -= 108;
                    stream.writeUInt8((val >> 8) + 247);
                    return stream.writeUInt8(val & 255);
                  } else if (-1131 <= val && val <= -108) {
                    val = -val - 108;
                    stream.writeUInt8((val >> 8) + 251);
                    return stream.writeUInt8(val & 255);
                  } else if (-32768 <= val && val <= 32767) {
                    stream.writeUInt8(28);
                    return stream.writeInt16BE(val);
                  } else {
                    stream.writeUInt8(29);
                    return stream.writeInt32BE(val);
                  }
                }
              }
              class $efe622f40a9c35bd$export$2e2bcd8739ae039 {
                decodeOperands(type, stream, ret, operands) {
                  if (Array.isArray(type)) return operands.map((op, i) => this.decodeOperands(type[i], stream, ret, [
                    op
                  ]));
                  else if (type.decode != null) return type.decode(stream, ret, operands);
                  else switch (type) {
                    case "number":
                    case "offset":
                    case "sid":
                      return operands[0];
                    case "boolean":
                      return !!operands[0];
                    default:
                      return operands;
                  }
                }
                encodeOperands(type, stream, ctx, operands) {
                  if (Array.isArray(type)) return operands.map((op, i) => this.encodeOperands(type[i], stream, ctx, op)[0]);
                  else if (type.encode != null) return type.encode(stream, operands, ctx);
                  else if (typeof operands === "number") return [
                    operands
                  ];
                  else if (typeof operands === "boolean") return [
                    +operands
                  ];
                  else if (Array.isArray(operands)) return operands;
                  else return [
                    operands
                  ];
                }
                decode(stream, parent) {
                  let end = stream.pos + parent.length;
                  let ret = {};
                  let operands = [];
                  Object.defineProperties(ret, {
                    parent: {
                      value: parent
                    },
                    _startOffset: {
                      value: stream.pos
                    }
                  });
                  for (let key in this.fields) {
                    let field = this.fields[key];
                    ret[field[1]] = field[3];
                  }
                  while (stream.pos < end) {
                    let b = stream.readUInt8();
                    if (b < 28) {
                      if (b === 12) b = b << 8 | stream.readUInt8();
                      let field = this.fields[b];
                      if (!field) throw new Error(`Unknown operator ${b}`);
                      let val = this.decodeOperands(field[2], stream, ret, operands);
                      if (val != null) {
                        if (val instanceof (0, $gfJaN$restructure.PropertyDescriptor)) Object.defineProperty(ret, field[1], val);
                        else ret[field[1]] = val;
                      }
                      operands = [];
                    } else operands.push((0, $f77b592c17132d70$export$2e2bcd8739ae039).decode(stream, b));
                  }
                  return ret;
                }
                size(dict, parent, includePointers = true) {
                  let ctx = {
                    parent,
                    val: dict,
                    pointerSize: 0,
                    startOffset: parent.startOffset || 0
                  };
                  let len = 0;
                  for (let k in this.fields) {
                    let field = this.fields[k];
                    let val = dict[field[1]];
                    if (val == null || (0, $parcel$interopDefault($gfJaN$fastdeepequal))(val, field[3])) continue;
                    let operands = this.encodeOperands(field[2], null, ctx, val);
                    for (let op of operands) len += (0, $f77b592c17132d70$export$2e2bcd8739ae039).size(op);
                    let key = Array.isArray(field[0]) ? field[0] : [
                      field[0]
                    ];
                    len += key.length;
                  }
                  if (includePointers) len += ctx.pointerSize;
                  return len;
                }
                encode(stream, dict, parent) {
                  let ctx = {
                    pointers: [],
                    startOffset: stream.pos,
                    parent,
                    val: dict,
                    pointerSize: 0
                  };
                  ctx.pointerOffset = stream.pos + this.size(dict, ctx, false);
                  for (let field of this.ops) {
                    let val = dict[field[1]];
                    if (val == null || (0, $parcel$interopDefault($gfJaN$fastdeepequal))(val, field[3])) continue;
                    let operands = this.encodeOperands(field[2], stream, ctx, val);
                    for (let op of operands) (0, $f77b592c17132d70$export$2e2bcd8739ae039).encode(stream, op);
                    let key = Array.isArray(field[0]) ? field[0] : [
                      field[0]
                    ];
                    for (let op of key) stream.writeUInt8(op);
                  }
                  let i = 0;
                  while (i < ctx.pointers.length) {
                    let ptr = ctx.pointers[i++];
                    ptr.type.encode(stream, ptr.val, ptr.parent);
                  }
                  return;
                }
                constructor(ops = []) {
                  this.ops = ops;
                  this.fields = {};
                  for (let field of ops) {
                    let key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];
                    this.fields[key] = field;
                  }
                }
              }
              class $4aa1b0749c2770f8$export$2e2bcd8739ae039 extends $gfJaN$restructure.Pointer {
                decode(stream, parent, operands) {
                  this.offsetType = {
                    decode: () => operands[0]
                  };
                  return super.decode(stream, parent, operands);
                }
                encode(stream, value, ctx) {
                  if (!stream) {
                    this.offsetType = {
                      size: () => 0
                    };
                    this.size(value, ctx);
                    return [
                      new $4aa1b0749c2770f8$var$Ptr(0)
                    ];
                  }
                  let ptr = null;
                  this.offsetType = {
                    encode: (stream2, val) => ptr = val
                  };
                  super.encode(stream, value, ctx);
                  return [
                    new $4aa1b0749c2770f8$var$Ptr(ptr)
                  ];
                }
                constructor(type, options = {}) {
                  if (options.type == null) options.type = "global";
                  super(null, type, options);
                }
              }
              class $4aa1b0749c2770f8$var$Ptr {
                valueOf() {
                  return this.val;
                }
                constructor(val) {
                  this.val = val;
                  this.forceLarge = true;
                }
              }
              class $15a0cbb3d09cf7ee$var$CFFBlendOp {
                static decode(stream, parent, operands) {
                  let numBlends = operands.pop();
                  while (operands.length > numBlends) operands.pop();
                }
              }
              var $15a0cbb3d09cf7ee$export$2e2bcd8739ae039 = new (0, $efe622f40a9c35bd$export$2e2bcd8739ae039)([
                // key       name                    type                                          default
                [
                  6,
                  "BlueValues",
                  "delta",
                  null
                ],
                [
                  7,
                  "OtherBlues",
                  "delta",
                  null
                ],
                [
                  8,
                  "FamilyBlues",
                  "delta",
                  null
                ],
                [
                  9,
                  "FamilyOtherBlues",
                  "delta",
                  null
                ],
                [
                  [
                    12,
                    9
                  ],
                  "BlueScale",
                  "number",
                  0.039625
                ],
                [
                  [
                    12,
                    10
                  ],
                  "BlueShift",
                  "number",
                  7
                ],
                [
                  [
                    12,
                    11
                  ],
                  "BlueFuzz",
                  "number",
                  1
                ],
                [
                  10,
                  "StdHW",
                  "number",
                  null
                ],
                [
                  11,
                  "StdVW",
                  "number",
                  null
                ],
                [
                  [
                    12,
                    12
                  ],
                  "StemSnapH",
                  "delta",
                  null
                ],
                [
                  [
                    12,
                    13
                  ],
                  "StemSnapV",
                  "delta",
                  null
                ],
                [
                  [
                    12,
                    14
                  ],
                  "ForceBold",
                  "boolean",
                  false
                ],
                [
                  [
                    12,
                    17
                  ],
                  "LanguageGroup",
                  "number",
                  0
                ],
                [
                  [
                    12,
                    18
                  ],
                  "ExpansionFactor",
                  "number",
                  0.06
                ],
                [
                  [
                    12,
                    19
                  ],
                  "initialRandomSeed",
                  "number",
                  0
                ],
                [
                  20,
                  "defaultWidthX",
                  "number",
                  0
                ],
                [
                  21,
                  "nominalWidthX",
                  "number",
                  0
                ],
                [
                  22,
                  "vsindex",
                  "number",
                  0
                ],
                [
                  23,
                  "blend",
                  $15a0cbb3d09cf7ee$var$CFFBlendOp,
                  null
                ],
                [
                  19,
                  "Subrs",
                  new (0, $4aa1b0749c2770f8$export$2e2bcd8739ae039)(new (0, $9eaea3754914a290$export$2e2bcd8739ae039)(), {
                    type: "local"
                  }),
                  null
                ]
              ]);
              var $860d3574d7fa3a51$export$2e2bcd8739ae039 = [
                ".notdef",
                "space",
                "exclam",
                "quotedbl",
                "numbersign",
                "dollar",
                "percent",
                "ampersand",
                "quoteright",
                "parenleft",
                "parenright",
                "asterisk",
                "plus",
                "comma",
                "hyphen",
                "period",
                "slash",
                "zero",
                "one",
                "two",
                "three",
                "four",
                "five",
                "six",
                "seven",
                "eight",
                "nine",
                "colon",
                "semicolon",
                "less",
                "equal",
                "greater",
                "question",
                "at",
                "A",
                "B",
                "C",
                "D",
                "E",
                "F",
                "G",
                "H",
                "I",
                "J",
                "K",
                "L",
                "M",
                "N",
                "O",
                "P",
                "Q",
                "R",
                "S",
                "T",
                "U",
                "V",
                "W",
                "X",
                "Y",
                "Z",
                "bracketleft",
                "backslash",
                "bracketright",
                "asciicircum",
                "underscore",
                "quoteleft",
                "a",
                "b",
                "c",
                "d",
                "e",
                "f",
                "g",
                "h",
                "i",
                "j",
                "k",
                "l",
                "m",
                "n",
                "o",
                "p",
                "q",
                "r",
                "s",
                "t",
                "u",
                "v",
                "w",
                "x",
                "y",
                "z",
                "braceleft",
                "bar",
                "braceright",
                "asciitilde",
                "exclamdown",
                "cent",
                "sterling",
                "fraction",
                "yen",
                "florin",
                "section",
                "currency",
                "quotesingle",
                "quotedblleft",
                "guillemotleft",
                "guilsinglleft",
                "guilsinglright",
                "fi",
                "fl",
                "endash",
                "dagger",
                "daggerdbl",
                "periodcentered",
                "paragraph",
                "bullet",
                "quotesinglbase",
                "quotedblbase",
                "quotedblright",
                "guillemotright",
                "ellipsis",
                "perthousand",
                "questiondown",
                "grave",
                "acute",
                "circumflex",
                "tilde",
                "macron",
                "breve",
                "dotaccent",
                "dieresis",
                "ring",
                "cedilla",
                "hungarumlaut",
                "ogonek",
                "caron",
                "emdash",
                "AE",
                "ordfeminine",
                "Lslash",
                "Oslash",
                "OE",
                "ordmasculine",
                "ae",
                "dotlessi",
                "lslash",
                "oslash",
                "oe",
                "germandbls",
                "onesuperior",
                "logicalnot",
                "mu",
                "trademark",
                "Eth",
                "onehalf",
                "plusminus",
                "Thorn",
                "onequarter",
                "divide",
                "brokenbar",
                "degree",
                "thorn",
                "threequarters",
                "twosuperior",
                "registered",
                "minus",
                "eth",
                "multiply",
                "threesuperior",
                "copyright",
                "Aacute",
                "Acircumflex",
                "Adieresis",
                "Agrave",
                "Aring",
                "Atilde",
                "Ccedilla",
                "Eacute",
                "Ecircumflex",
                "Edieresis",
                "Egrave",
                "Iacute",
                "Icircumflex",
                "Idieresis",
                "Igrave",
                "Ntilde",
                "Oacute",
                "Ocircumflex",
                "Odieresis",
                "Ograve",
                "Otilde",
                "Scaron",
                "Uacute",
                "Ucircumflex",
                "Udieresis",
                "Ugrave",
                "Yacute",
                "Ydieresis",
                "Zcaron",
                "aacute",
                "acircumflex",
                "adieresis",
                "agrave",
                "aring",
                "atilde",
                "ccedilla",
                "eacute",
                "ecircumflex",
                "edieresis",
                "egrave",
                "iacute",
                "icircumflex",
                "idieresis",
                "igrave",
                "ntilde",
                "oacute",
                "ocircumflex",
                "odieresis",
                "ograve",
                "otilde",
                "scaron",
                "uacute",
                "ucircumflex",
                "udieresis",
                "ugrave",
                "yacute",
                "ydieresis",
                "zcaron",
                "exclamsmall",
                "Hungarumlautsmall",
                "dollaroldstyle",
                "dollarsuperior",
                "ampersandsmall",
                "Acutesmall",
                "parenleftsuperior",
                "parenrightsuperior",
                "twodotenleader",
                "onedotenleader",
                "zerooldstyle",
                "oneoldstyle",
                "twooldstyle",
                "threeoldstyle",
                "fouroldstyle",
                "fiveoldstyle",
                "sixoldstyle",
                "sevenoldstyle",
                "eightoldstyle",
                "nineoldstyle",
                "commasuperior",
                "threequartersemdash",
                "periodsuperior",
                "questionsmall",
                "asuperior",
                "bsuperior",
                "centsuperior",
                "dsuperior",
                "esuperior",
                "isuperior",
                "lsuperior",
                "msuperior",
                "nsuperior",
                "osuperior",
                "rsuperior",
                "ssuperior",
                "tsuperior",
                "ff",
                "ffi",
                "ffl",
                "parenleftinferior",
                "parenrightinferior",
                "Circumflexsmall",
                "hyphensuperior",
                "Gravesmall",
                "Asmall",
                "Bsmall",
                "Csmall",
                "Dsmall",
                "Esmall",
                "Fsmall",
                "Gsmall",
                "Hsmall",
                "Ismall",
                "Jsmall",
                "Ksmall",
                "Lsmall",
                "Msmall",
                "Nsmall",
                "Osmall",
                "Psmall",
                "Qsmall",
                "Rsmall",
                "Ssmall",
                "Tsmall",
                "Usmall",
                "Vsmall",
                "Wsmall",
                "Xsmall",
                "Ysmall",
                "Zsmall",
                "colonmonetary",
                "onefitted",
                "rupiah",
                "Tildesmall",
                "exclamdownsmall",
                "centoldstyle",
                "Lslashsmall",
                "Scaronsmall",
                "Zcaronsmall",
                "Dieresissmall",
                "Brevesmall",
                "Caronsmall",
                "Dotaccentsmall",
                "Macronsmall",
                "figuredash",
                "hypheninferior",
                "Ogoneksmall",
                "Ringsmall",
                "Cedillasmall",
                "questiondownsmall",
                "oneeighth",
                "threeeighths",
                "fiveeighths",
                "seveneighths",
                "onethird",
                "twothirds",
                "zerosuperior",
                "foursuperior",
                "fivesuperior",
                "sixsuperior",
                "sevensuperior",
                "eightsuperior",
                "ninesuperior",
                "zeroinferior",
                "oneinferior",
                "twoinferior",
                "threeinferior",
                "fourinferior",
                "fiveinferior",
                "sixinferior",
                "seveninferior",
                "eightinferior",
                "nineinferior",
                "centinferior",
                "dollarinferior",
                "periodinferior",
                "commainferior",
                "Agravesmall",
                "Aacutesmall",
                "Acircumflexsmall",
                "Atildesmall",
                "Adieresissmall",
                "Aringsmall",
                "AEsmall",
                "Ccedillasmall",
                "Egravesmall",
                "Eacutesmall",
                "Ecircumflexsmall",
                "Edieresissmall",
                "Igravesmall",
                "Iacutesmall",
                "Icircumflexsmall",
                "Idieresissmall",
                "Ethsmall",
                "Ntildesmall",
                "Ogravesmall",
                "Oacutesmall",
                "Ocircumflexsmall",
                "Otildesmall",
                "Odieresissmall",
                "OEsmall",
                "Oslashsmall",
                "Ugravesmall",
                "Uacutesmall",
                "Ucircumflexsmall",
                "Udieresissmall",
                "Yacutesmall",
                "Thornsmall",
                "Ydieresissmall",
                "001.000",
                "001.001",
                "001.002",
                "001.003",
                "Black",
                "Bold",
                "Book",
                "Light",
                "Medium",
                "Regular",
                "Roman",
                "Semibold"
              ];
              let $c4ffe47cba1d7f36$export$dee0027060fa13bd = [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "space",
                "exclam",
                "quotedbl",
                "numbersign",
                "dollar",
                "percent",
                "ampersand",
                "quoteright",
                "parenleft",
                "parenright",
                "asterisk",
                "plus",
                "comma",
                "hyphen",
                "period",
                "slash",
                "zero",
                "one",
                "two",
                "three",
                "four",
                "five",
                "six",
                "seven",
                "eight",
                "nine",
                "colon",
                "semicolon",
                "less",
                "equal",
                "greater",
                "question",
                "at",
                "A",
                "B",
                "C",
                "D",
                "E",
                "F",
                "G",
                "H",
                "I",
                "J",
                "K",
                "L",
                "M",
                "N",
                "O",
                "P",
                "Q",
                "R",
                "S",
                "T",
                "U",
                "V",
                "W",
                "X",
                "Y",
                "Z",
                "bracketleft",
                "backslash",
                "bracketright",
                "asciicircum",
                "underscore",
                "quoteleft",
                "a",
                "b",
                "c",
                "d",
                "e",
                "f",
                "g",
                "h",
                "i",
                "j",
                "k",
                "l",
                "m",
                "n",
                "o",
                "p",
                "q",
                "r",
                "s",
                "t",
                "u",
                "v",
                "w",
                "x",
                "y",
                "z",
                "braceleft",
                "bar",
                "braceright",
                "asciitilde",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "exclamdown",
                "cent",
                "sterling",
                "fraction",
                "yen",
                "florin",
                "section",
                "currency",
                "quotesingle",
                "quotedblleft",
                "guillemotleft",
                "guilsinglleft",
                "guilsinglright",
                "fi",
                "fl",
                "",
                "endash",
                "dagger",
                "daggerdbl",
                "periodcentered",
                "",
                "paragraph",
                "bullet",
                "quotesinglbase",
                "quotedblbase",
                "quotedblright",
                "guillemotright",
                "ellipsis",
                "perthousand",
                "",
                "questiondown",
                "",
                "grave",
                "acute",
                "circumflex",
                "tilde",
                "macron",
                "breve",
                "dotaccent",
                "dieresis",
                "",
                "ring",
                "cedilla",
                "",
                "hungarumlaut",
                "ogonek",
                "caron",
                "emdash",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "AE",
                "",
                "ordfeminine",
                "",
                "",
                "",
                "",
                "Lslash",
                "Oslash",
                "OE",
                "ordmasculine",
                "",
                "",
                "",
                "",
                "",
                "ae",
                "",
                "",
                "",
                "dotlessi",
                "",
                "",
                "lslash",
                "oslash",
                "oe",
                "germandbls"
              ];
              let $c4ffe47cba1d7f36$export$4f58f497e14a53c3 = [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "space",
                "exclamsmall",
                "Hungarumlautsmall",
                "",
                "dollaroldstyle",
                "dollarsuperior",
                "ampersandsmall",
                "Acutesmall",
                "parenleftsuperior",
                "parenrightsuperior",
                "twodotenleader",
                "onedotenleader",
                "comma",
                "hyphen",
                "period",
                "fraction",
                "zerooldstyle",
                "oneoldstyle",
                "twooldstyle",
                "threeoldstyle",
                "fouroldstyle",
                "fiveoldstyle",
                "sixoldstyle",
                "sevenoldstyle",
                "eightoldstyle",
                "nineoldstyle",
                "colon",
                "semicolon",
                "commasuperior",
                "threequartersemdash",
                "periodsuperior",
                "questionsmall",
                "",
                "asuperior",
                "bsuperior",
                "centsuperior",
                "dsuperior",
                "esuperior",
                "",
                "",
                "isuperior",
                "",
                "",
                "lsuperior",
                "msuperior",
                "nsuperior",
                "osuperior",
                "",
                "",
                "rsuperior",
                "ssuperior",
                "tsuperior",
                "",
                "ff",
                "fi",
                "fl",
                "ffi",
                "ffl",
                "parenleftinferior",
                "",
                "parenrightinferior",
                "Circumflexsmall",
                "hyphensuperior",
                "Gravesmall",
                "Asmall",
                "Bsmall",
                "Csmall",
                "Dsmall",
                "Esmall",
                "Fsmall",
                "Gsmall",
                "Hsmall",
                "Ismall",
                "Jsmall",
                "Ksmall",
                "Lsmall",
                "Msmall",
                "Nsmall",
                "Osmall",
                "Psmall",
                "Qsmall",
                "Rsmall",
                "Ssmall",
                "Tsmall",
                "Usmall",
                "Vsmall",
                "Wsmall",
                "Xsmall",
                "Ysmall",
                "Zsmall",
                "colonmonetary",
                "onefitted",
                "rupiah",
                "Tildesmall",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "exclamdownsmall",
                "centoldstyle",
                "Lslashsmall",
                "",
                "",
                "Scaronsmall",
                "Zcaronsmall",
                "Dieresissmall",
                "Brevesmall",
                "Caronsmall",
                "",
                "Dotaccentsmall",
                "",
                "",
                "Macronsmall",
                "",
                "",
                "figuredash",
                "hypheninferior",
                "",
                "",
                "Ogoneksmall",
                "Ringsmall",
                "Cedillasmall",
                "",
                "",
                "",
                "onequarter",
                "onehalf",
                "threequarters",
                "questiondownsmall",
                "oneeighth",
                "threeeighths",
                "fiveeighths",
                "seveneighths",
                "onethird",
                "twothirds",
                "",
                "",
                "zerosuperior",
                "onesuperior",
                "twosuperior",
                "threesuperior",
                "foursuperior",
                "fivesuperior",
                "sixsuperior",
                "sevensuperior",
                "eightsuperior",
                "ninesuperior",
                "zeroinferior",
                "oneinferior",
                "twoinferior",
                "threeinferior",
                "fourinferior",
                "fiveinferior",
                "sixinferior",
                "seveninferior",
                "eightinferior",
                "nineinferior",
                "centinferior",
                "dollarinferior",
                "periodinferior",
                "commainferior",
                "Agravesmall",
                "Aacutesmall",
                "Acircumflexsmall",
                "Atildesmall",
                "Adieresissmall",
                "Aringsmall",
                "AEsmall",
                "Ccedillasmall",
                "Egravesmall",
                "Eacutesmall",
                "Ecircumflexsmall",
                "Edieresissmall",
                "Igravesmall",
                "Iacutesmall",
                "Icircumflexsmall",
                "Idieresissmall",
                "Ethsmall",
                "Ntildesmall",
                "Ogravesmall",
                "Oacutesmall",
                "Ocircumflexsmall",
                "Otildesmall",
                "Odieresissmall",
                "OEsmall",
                "Oslashsmall",
                "Ugravesmall",
                "Uacutesmall",
                "Ucircumflexsmall",
                "Udieresissmall",
                "Yacutesmall",
                "Thornsmall",
                "Ydieresissmall"
              ];
              let $1e7c7c16984e4427$export$c33b50336c234f16 = [
                ".notdef",
                "space",
                "exclam",
                "quotedbl",
                "numbersign",
                "dollar",
                "percent",
                "ampersand",
                "quoteright",
                "parenleft",
                "parenright",
                "asterisk",
                "plus",
                "comma",
                "hyphen",
                "period",
                "slash",
                "zero",
                "one",
                "two",
                "three",
                "four",
                "five",
                "six",
                "seven",
                "eight",
                "nine",
                "colon",
                "semicolon",
                "less",
                "equal",
                "greater",
                "question",
                "at",
                "A",
                "B",
                "C",
                "D",
                "E",
                "F",
                "G",
                "H",
                "I",
                "J",
                "K",
                "L",
                "M",
                "N",
                "O",
                "P",
                "Q",
                "R",
                "S",
                "T",
                "U",
                "V",
                "W",
                "X",
                "Y",
                "Z",
                "bracketleft",
                "backslash",
                "bracketright",
                "asciicircum",
                "underscore",
                "quoteleft",
                "a",
                "b",
                "c",
                "d",
                "e",
                "f",
                "g",
                "h",
                "i",
                "j",
                "k",
                "l",
                "m",
                "n",
                "o",
                "p",
                "q",
                "r",
                "s",
                "t",
                "u",
                "v",
                "w",
                "x",
                "y",
                "z",
                "braceleft",
                "bar",
                "braceright",
                "asciitilde",
                "exclamdown",
                "cent",
                "sterling",
                "fraction",
                "yen",
                "florin",
                "section",
                "currency",
                "quotesingle",
                "quotedblleft",
                "guillemotleft",
                "guilsinglleft",
                "guilsinglright",
                "fi",
                "fl",
                "endash",
                "dagger",
                "daggerdbl",
                "periodcentered",
                "paragraph",
                "bullet",
                "quotesinglbase",
                "quotedblbase",
                "quotedblright",
                "guillemotright",
                "ellipsis",
                "perthousand",
                "questiondown",
                "grave",
                "acute",
                "circumflex",
                "tilde",
                "macron",
                "breve",
                "dotaccent",
                "dieresis",
                "ring",
                "cedilla",
                "hungarumlaut",
                "ogonek",
                "caron",
                "emdash",
                "AE",
                "ordfeminine",
                "Lslash",
                "Oslash",
                "OE",
                "ordmasculine",
                "ae",
                "dotlessi",
                "lslash",
                "oslash",
                "oe",
                "germandbls",
                "onesuperior",
                "logicalnot",
                "mu",
                "trademark",
                "Eth",
                "onehalf",
                "plusminus",
                "Thorn",
                "onequarter",
                "divide",
                "brokenbar",
                "degree",
                "thorn",
                "threequarters",
                "twosuperior",
                "registered",
                "minus",
                "eth",
                "multiply",
                "threesuperior",
                "copyright",
                "Aacute",
                "Acircumflex",
                "Adieresis",
                "Agrave",
                "Aring",
                "Atilde",
                "Ccedilla",
                "Eacute",
                "Ecircumflex",
                "Edieresis",
                "Egrave",
                "Iacute",
                "Icircumflex",
                "Idieresis",
                "Igrave",
                "Ntilde",
                "Oacute",
                "Ocircumflex",
                "Odieresis",
                "Ograve",
                "Otilde",
                "Scaron",
                "Uacute",
                "Ucircumflex",
                "Udieresis",
                "Ugrave",
                "Yacute",
                "Ydieresis",
                "Zcaron",
                "aacute",
                "acircumflex",
                "adieresis",
                "agrave",
                "aring",
                "atilde",
                "ccedilla",
                "eacute",
                "ecircumflex",
                "edieresis",
                "egrave",
                "iacute",
                "icircumflex",
                "idieresis",
                "igrave",
                "ntilde",
                "oacute",
                "ocircumflex",
                "odieresis",
                "ograve",
                "otilde",
                "scaron",
                "uacute",
                "ucircumflex",
                "udieresis",
                "ugrave",
                "yacute",
                "ydieresis",
                "zcaron"
              ];
              let $1e7c7c16984e4427$export$3ed0f9e1fee8d489 = [
                ".notdef",
                "space",
                "exclamsmall",
                "Hungarumlautsmall",
                "dollaroldstyle",
                "dollarsuperior",
                "ampersandsmall",
                "Acutesmall",
                "parenleftsuperior",
                "parenrightsuperior",
                "twodotenleader",
                "onedotenleader",
                "comma",
                "hyphen",
                "period",
                "fraction",
                "zerooldstyle",
                "oneoldstyle",
                "twooldstyle",
                "threeoldstyle",
                "fouroldstyle",
                "fiveoldstyle",
                "sixoldstyle",
                "sevenoldstyle",
                "eightoldstyle",
                "nineoldstyle",
                "colon",
                "semicolon",
                "commasuperior",
                "threequartersemdash",
                "periodsuperior",
                "questionsmall",
                "asuperior",
                "bsuperior",
                "centsuperior",
                "dsuperior",
                "esuperior",
                "isuperior",
                "lsuperior",
                "msuperior",
                "nsuperior",
                "osuperior",
                "rsuperior",
                "ssuperior",
                "tsuperior",
                "ff",
                "fi",
                "fl",
                "ffi",
                "ffl",
                "parenleftinferior",
                "parenrightinferior",
                "Circumflexsmall",
                "hyphensuperior",
                "Gravesmall",
                "Asmall",
                "Bsmall",
                "Csmall",
                "Dsmall",
                "Esmall",
                "Fsmall",
                "Gsmall",
                "Hsmall",
                "Ismall",
                "Jsmall",
                "Ksmall",
                "Lsmall",
                "Msmall",
                "Nsmall",
                "Osmall",
                "Psmall",
                "Qsmall",
                "Rsmall",
                "Ssmall",
                "Tsmall",
                "Usmall",
                "Vsmall",
                "Wsmall",
                "Xsmall",
                "Ysmall",
                "Zsmall",
                "colonmonetary",
                "onefitted",
                "rupiah",
                "Tildesmall",
                "exclamdownsmall",
                "centoldstyle",
                "Lslashsmall",
                "Scaronsmall",
                "Zcaronsmall",
                "Dieresissmall",
                "Brevesmall",
                "Caronsmall",
                "Dotaccentsmall",
                "Macronsmall",
                "figuredash",
                "hypheninferior",
                "Ogoneksmall",
                "Ringsmall",
                "Cedillasmall",
                "onequarter",
                "onehalf",
                "threequarters",
                "questiondownsmall",
                "oneeighth",
                "threeeighths",
                "fiveeighths",
                "seveneighths",
                "onethird",
                "twothirds",
                "zerosuperior",
                "onesuperior",
                "twosuperior",
                "threesuperior",
                "foursuperior",
                "fivesuperior",
                "sixsuperior",
                "sevensuperior",
                "eightsuperior",
                "ninesuperior",
                "zeroinferior",
                "oneinferior",
                "twoinferior",
                "threeinferior",
                "fourinferior",
                "fiveinferior",
                "sixinferior",
                "seveninferior",
                "eightinferior",
                "nineinferior",
                "centinferior",
                "dollarinferior",
                "periodinferior",
                "commainferior",
                "Agravesmall",
                "Aacutesmall",
                "Acircumflexsmall",
                "Atildesmall",
                "Adieresissmall",
                "Aringsmall",
                "AEsmall",
                "Ccedillasmall",
                "Egravesmall",
                "Eacutesmall",
                "Ecircumflexsmall",
                "Edieresissmall",
                "Igravesmall",
                "Iacutesmall",
                "Icircumflexsmall",
                "Idieresissmall",
                "Ethsmall",
                "Ntildesmall",
                "Ogravesmall",
                "Oacutesmall",
                "Ocircumflexsmall",
                "Otildesmall",
                "Odieresissmall",
                "OEsmall",
                "Oslashsmall",
                "Ugravesmall",
                "Uacutesmall",
                "Ucircumflexsmall",
                "Udieresissmall",
                "Yacutesmall",
                "Thornsmall",
                "Ydieresissmall"
              ];
              let $1e7c7c16984e4427$export$dc28be11139d4120 = [
                ".notdef",
                "space",
                "dollaroldstyle",
                "dollarsuperior",
                "parenleftsuperior",
                "parenrightsuperior",
                "twodotenleader",
                "onedotenleader",
                "comma",
                "hyphen",
                "period",
                "fraction",
                "zerooldstyle",
                "oneoldstyle",
                "twooldstyle",
                "threeoldstyle",
                "fouroldstyle",
                "fiveoldstyle",
                "sixoldstyle",
                "sevenoldstyle",
                "eightoldstyle",
                "nineoldstyle",
                "colon",
                "semicolon",
                "commasuperior",
                "threequartersemdash",
                "periodsuperior",
                "asuperior",
                "bsuperior",
                "centsuperior",
                "dsuperior",
                "esuperior",
                "isuperior",
                "lsuperior",
                "msuperior",
                "nsuperior",
                "osuperior",
                "rsuperior",
                "ssuperior",
                "tsuperior",
                "ff",
                "fi",
                "fl",
                "ffi",
                "ffl",
                "parenleftinferior",
                "parenrightinferior",
                "hyphensuperior",
                "colonmonetary",
                "onefitted",
                "rupiah",
                "centoldstyle",
                "figuredash",
                "hypheninferior",
                "onequarter",
                "onehalf",
                "threequarters",
                "oneeighth",
                "threeeighths",
                "fiveeighths",
                "seveneighths",
                "onethird",
                "twothirds",
                "zerosuperior",
                "onesuperior",
                "twosuperior",
                "threesuperior",
                "foursuperior",
                "fivesuperior",
                "sixsuperior",
                "sevensuperior",
                "eightsuperior",
                "ninesuperior",
                "zeroinferior",
                "oneinferior",
                "twoinferior",
                "threeinferior",
                "fourinferior",
                "fiveinferior",
                "sixinferior",
                "seveninferior",
                "eightinferior",
                "nineinferior",
                "centinferior",
                "dollarinferior",
                "periodinferior",
                "commainferior"
              ];
              let $b6dd765146ad212a$var$LangSysTable = new $gfJaN$restructure.Struct({
                reserved: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint16),
                reqFeatureIndex: $gfJaN$restructure.uint16,
                featureCount: $gfJaN$restructure.uint16,
                featureIndexes: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, "featureCount")
              });
              let $b6dd765146ad212a$var$LangSysRecord = new $gfJaN$restructure.Struct({
                tag: new $gfJaN$restructure.String(4),
                langSys: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$var$LangSysTable, {
                  type: "parent"
                })
              });
              let $b6dd765146ad212a$var$Script = new $gfJaN$restructure.Struct({
                defaultLangSys: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$var$LangSysTable),
                count: $gfJaN$restructure.uint16,
                langSysRecords: new $gfJaN$restructure.Array($b6dd765146ad212a$var$LangSysRecord, "count")
              });
              let $b6dd765146ad212a$var$ScriptRecord = new $gfJaN$restructure.Struct({
                tag: new $gfJaN$restructure.String(4),
                script: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$var$Script, {
                  type: "parent"
                })
              });
              let $b6dd765146ad212a$export$3e15fc05ce864229 = new $gfJaN$restructure.Array($b6dd765146ad212a$var$ScriptRecord, $gfJaN$restructure.uint16);
              let $b6dd765146ad212a$var$FeatureParams = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.uint16,
                nameID: $gfJaN$restructure.uint16
              });
              let $b6dd765146ad212a$export$6e91cf7616333d5 = new $gfJaN$restructure.Struct({
                featureParams: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$var$FeatureParams),
                lookupCount: $gfJaN$restructure.uint16,
                lookupListIndexes: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, "lookupCount")
              });
              let $b6dd765146ad212a$var$FeatureRecord = new $gfJaN$restructure.Struct({
                tag: new $gfJaN$restructure.String(4),
                feature: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$export$6e91cf7616333d5, {
                  type: "parent"
                })
              });
              let $b6dd765146ad212a$export$aa18130def4b6cb4 = new $gfJaN$restructure.Array($b6dd765146ad212a$var$FeatureRecord, $gfJaN$restructure.uint16);
              let $b6dd765146ad212a$var$LookupFlags = new $gfJaN$restructure.Struct({
                markAttachmentType: $gfJaN$restructure.uint8,
                flags: new $gfJaN$restructure.Bitfield($gfJaN$restructure.uint8, [
                  "rightToLeft",
                  "ignoreBaseGlyphs",
                  "ignoreLigatures",
                  "ignoreMarks",
                  "useMarkFilteringSet"
                ])
              });
              function $b6dd765146ad212a$export$df0008c6ff2da22a(SubTable) {
                let Lookup = new $gfJaN$restructure.Struct({
                  lookupType: $gfJaN$restructure.uint16,
                  flags: $b6dd765146ad212a$var$LookupFlags,
                  subTableCount: $gfJaN$restructure.uint16,
                  subTables: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, SubTable), "subTableCount"),
                  markFilteringSet: new $gfJaN$restructure.Optional($gfJaN$restructure.uint16, (t) => t.flags.flags.useMarkFilteringSet)
                });
                return new $gfJaN$restructure.LazyArray(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, Lookup), $gfJaN$restructure.uint16);
              }
              let $b6dd765146ad212a$var$RangeRecord = new $gfJaN$restructure.Struct({
                start: $gfJaN$restructure.uint16,
                end: $gfJaN$restructure.uint16,
                startCoverageIndex: $gfJaN$restructure.uint16
              });
              let $b6dd765146ad212a$export$17608c3f81a6111 = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint16, {
                1: {
                  glyphCount: $gfJaN$restructure.uint16,
                  glyphs: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, "glyphCount")
                },
                2: {
                  rangeCount: $gfJaN$restructure.uint16,
                  rangeRecords: new $gfJaN$restructure.Array($b6dd765146ad212a$var$RangeRecord, "rangeCount")
                }
              });
              let $b6dd765146ad212a$var$ClassRangeRecord = new $gfJaN$restructure.Struct({
                start: $gfJaN$restructure.uint16,
                end: $gfJaN$restructure.uint16,
                class: $gfJaN$restructure.uint16
              });
              let $b6dd765146ad212a$export$843d551fbbafef71 = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint16, {
                1: {
                  startGlyph: $gfJaN$restructure.uint16,
                  glyphCount: $gfJaN$restructure.uint16,
                  classValueArray: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, "glyphCount")
                },
                2: {
                  classRangeCount: $gfJaN$restructure.uint16,
                  classRangeRecord: new $gfJaN$restructure.Array($b6dd765146ad212a$var$ClassRangeRecord, "classRangeCount")
                }
              });
              let $b6dd765146ad212a$export$8215d14a63d9fb10 = new $gfJaN$restructure.Struct({
                a: $gfJaN$restructure.uint16,
                b: $gfJaN$restructure.uint16,
                deltaFormat: $gfJaN$restructure.uint16
              });
              let $b6dd765146ad212a$var$LookupRecord = new $gfJaN$restructure.Struct({
                sequenceIndex: $gfJaN$restructure.uint16,
                lookupListIndex: $gfJaN$restructure.uint16
              });
              let $b6dd765146ad212a$var$Rule = new $gfJaN$restructure.Struct({
                glyphCount: $gfJaN$restructure.uint16,
                lookupCount: $gfJaN$restructure.uint16,
                input: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, (t) => t.glyphCount - 1),
                lookupRecords: new $gfJaN$restructure.Array($b6dd765146ad212a$var$LookupRecord, "lookupCount")
              });
              let $b6dd765146ad212a$var$RuleSet = new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$var$Rule), $gfJaN$restructure.uint16);
              let $b6dd765146ad212a$var$ClassRule = new $gfJaN$restructure.Struct({
                glyphCount: $gfJaN$restructure.uint16,
                lookupCount: $gfJaN$restructure.uint16,
                classes: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, (t) => t.glyphCount - 1),
                lookupRecords: new $gfJaN$restructure.Array($b6dd765146ad212a$var$LookupRecord, "lookupCount")
              });
              let $b6dd765146ad212a$var$ClassSet = new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$var$ClassRule), $gfJaN$restructure.uint16);
              let $b6dd765146ad212a$export$841858b892ce1f4c = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint16, {
                1: {
                  coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$export$17608c3f81a6111),
                  ruleSetCount: $gfJaN$restructure.uint16,
                  ruleSets: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$var$RuleSet), "ruleSetCount")
                },
                2: {
                  coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$export$17608c3f81a6111),
                  classDef: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$export$843d551fbbafef71),
                  classSetCnt: $gfJaN$restructure.uint16,
                  classSet: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$var$ClassSet), "classSetCnt")
                },
                3: {
                  glyphCount: $gfJaN$restructure.uint16,
                  lookupCount: $gfJaN$restructure.uint16,
                  coverages: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$export$17608c3f81a6111), "glyphCount"),
                  lookupRecords: new $gfJaN$restructure.Array($b6dd765146ad212a$var$LookupRecord, "lookupCount")
                }
              });
              let $b6dd765146ad212a$var$ChainRule = new $gfJaN$restructure.Struct({
                backtrackGlyphCount: $gfJaN$restructure.uint16,
                backtrack: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, "backtrackGlyphCount"),
                inputGlyphCount: $gfJaN$restructure.uint16,
                input: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, (t) => t.inputGlyphCount - 1),
                lookaheadGlyphCount: $gfJaN$restructure.uint16,
                lookahead: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, "lookaheadGlyphCount"),
                lookupCount: $gfJaN$restructure.uint16,
                lookupRecords: new $gfJaN$restructure.Array($b6dd765146ad212a$var$LookupRecord, "lookupCount")
              });
              let $b6dd765146ad212a$var$ChainRuleSet = new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$var$ChainRule), $gfJaN$restructure.uint16);
              let $b6dd765146ad212a$export$5e6d09e6861162f6 = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint16, {
                1: {
                  coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$export$17608c3f81a6111),
                  chainCount: $gfJaN$restructure.uint16,
                  chainRuleSets: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$var$ChainRuleSet), "chainCount")
                },
                2: {
                  coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$export$17608c3f81a6111),
                  backtrackClassDef: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$export$843d551fbbafef71),
                  inputClassDef: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$export$843d551fbbafef71),
                  lookaheadClassDef: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$export$843d551fbbafef71),
                  chainCount: $gfJaN$restructure.uint16,
                  chainClassSet: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$var$ChainRuleSet), "chainCount")
                },
                3: {
                  backtrackGlyphCount: $gfJaN$restructure.uint16,
                  backtrackCoverage: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$export$17608c3f81a6111), "backtrackGlyphCount"),
                  inputGlyphCount: $gfJaN$restructure.uint16,
                  inputCoverage: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$export$17608c3f81a6111), "inputGlyphCount"),
                  lookaheadGlyphCount: $gfJaN$restructure.uint16,
                  lookaheadCoverage: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b6dd765146ad212a$export$17608c3f81a6111), "lookaheadGlyphCount"),
                  lookupCount: $gfJaN$restructure.uint16,
                  lookupRecords: new $gfJaN$restructure.Array($b6dd765146ad212a$var$LookupRecord, "lookupCount")
                }
              });
              let $2e4adcda047b3383$var$F2DOT14 = new $gfJaN$restructure.Fixed(16, "BE", 14);
              let $2e4adcda047b3383$var$RegionAxisCoordinates = new $gfJaN$restructure.Struct({
                startCoord: $2e4adcda047b3383$var$F2DOT14,
                peakCoord: $2e4adcda047b3383$var$F2DOT14,
                endCoord: $2e4adcda047b3383$var$F2DOT14
              });
              let $2e4adcda047b3383$var$VariationRegionList = new $gfJaN$restructure.Struct({
                axisCount: $gfJaN$restructure.uint16,
                regionCount: $gfJaN$restructure.uint16,
                variationRegions: new $gfJaN$restructure.Array(new $gfJaN$restructure.Array($2e4adcda047b3383$var$RegionAxisCoordinates, "axisCount"), "regionCount")
              });
              let $2e4adcda047b3383$var$DeltaSet = new $gfJaN$restructure.Struct({
                shortDeltas: new $gfJaN$restructure.Array($gfJaN$restructure.int16, (t) => t.parent.shortDeltaCount),
                regionDeltas: new $gfJaN$restructure.Array($gfJaN$restructure.int8, (t) => t.parent.regionIndexCount - t.parent.shortDeltaCount),
                deltas: (t) => t.shortDeltas.concat(t.regionDeltas)
              });
              let $2e4adcda047b3383$var$ItemVariationData = new $gfJaN$restructure.Struct({
                itemCount: $gfJaN$restructure.uint16,
                shortDeltaCount: $gfJaN$restructure.uint16,
                regionIndexCount: $gfJaN$restructure.uint16,
                regionIndexes: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, "regionIndexCount"),
                deltaSets: new $gfJaN$restructure.Array($2e4adcda047b3383$var$DeltaSet, "itemCount")
              });
              let $2e4adcda047b3383$export$fe1b122a2710f241 = new $gfJaN$restructure.Struct({
                format: $gfJaN$restructure.uint16,
                variationRegionList: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, $2e4adcda047b3383$var$VariationRegionList),
                variationDataCount: $gfJaN$restructure.uint16,
                itemVariationData: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, $2e4adcda047b3383$var$ItemVariationData), "variationDataCount")
              });
              let $2e4adcda047b3383$var$ConditionTable = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint16, {
                1: {
                  axisIndex: $gfJaN$restructure.uint16,
                  axisIndex: $gfJaN$restructure.uint16,
                  filterRangeMinValue: $2e4adcda047b3383$var$F2DOT14,
                  filterRangeMaxValue: $2e4adcda047b3383$var$F2DOT14
                }
              });
              let $2e4adcda047b3383$var$ConditionSet = new $gfJaN$restructure.Struct({
                conditionCount: $gfJaN$restructure.uint16,
                conditionTable: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, $2e4adcda047b3383$var$ConditionTable), "conditionCount")
              });
              let $2e4adcda047b3383$var$FeatureTableSubstitutionRecord = new $gfJaN$restructure.Struct({
                featureIndex: $gfJaN$restructure.uint16,
                alternateFeatureTable: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, (0, $b6dd765146ad212a$export$6e91cf7616333d5), {
                  type: "parent"
                })
              });
              let $2e4adcda047b3383$var$FeatureTableSubstitution = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.fixed32,
                substitutionCount: $gfJaN$restructure.uint16,
                substitutions: new $gfJaN$restructure.Array($2e4adcda047b3383$var$FeatureTableSubstitutionRecord, "substitutionCount")
              });
              let $2e4adcda047b3383$var$FeatureVariationRecord = new $gfJaN$restructure.Struct({
                conditionSet: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, $2e4adcda047b3383$var$ConditionSet, {
                  type: "parent"
                }),
                featureTableSubstitution: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, $2e4adcda047b3383$var$FeatureTableSubstitution, {
                  type: "parent"
                })
              });
              let $2e4adcda047b3383$export$441b70b7971dd419 = new $gfJaN$restructure.Struct({
                majorVersion: $gfJaN$restructure.uint16,
                minorVersion: $gfJaN$restructure.uint16,
                featureVariationRecordCount: $gfJaN$restructure.uint32,
                featureVariationRecords: new $gfJaN$restructure.Array($2e4adcda047b3383$var$FeatureVariationRecord, "featureVariationRecordCount")
              });
              class $5b547cf9e5da519b$var$PredefinedOp {
                decode(stream, parent, operands) {
                  if (this.predefinedOps[operands[0]]) return this.predefinedOps[operands[0]];
                  return this.type.decode(stream, parent, operands);
                }
                size(value, ctx) {
                  return this.type.size(value, ctx);
                }
                encode(stream, value, ctx) {
                  let index = this.predefinedOps.indexOf(value);
                  if (index !== -1) return index;
                  return this.type.encode(stream, value, ctx);
                }
                constructor(predefinedOps, type) {
                  this.predefinedOps = predefinedOps;
                  this.type = type;
                }
              }
              class $5b547cf9e5da519b$var$CFFEncodingVersion extends $gfJaN$restructure.Number {
                decode(stream) {
                  return $gfJaN$restructure.uint8.decode(stream) & 127;
                }
                constructor() {
                  super("UInt8");
                }
              }
              let $5b547cf9e5da519b$var$Range1 = new $gfJaN$restructure.Struct({
                first: $gfJaN$restructure.uint16,
                nLeft: $gfJaN$restructure.uint8
              });
              let $5b547cf9e5da519b$var$Range2 = new $gfJaN$restructure.Struct({
                first: $gfJaN$restructure.uint16,
                nLeft: $gfJaN$restructure.uint16
              });
              let $5b547cf9e5da519b$var$CFFCustomEncoding = new $gfJaN$restructure.VersionedStruct(new $5b547cf9e5da519b$var$CFFEncodingVersion(), {
                0: {
                  nCodes: $gfJaN$restructure.uint8,
                  codes: new $gfJaN$restructure.Array($gfJaN$restructure.uint8, "nCodes")
                },
                1: {
                  nRanges: $gfJaN$restructure.uint8,
                  ranges: new $gfJaN$restructure.Array($5b547cf9e5da519b$var$Range1, "nRanges")
                }
              });
              let $5b547cf9e5da519b$var$CFFEncoding = new $5b547cf9e5da519b$var$PredefinedOp([
                (0, $c4ffe47cba1d7f36$export$dee0027060fa13bd),
                (0, $c4ffe47cba1d7f36$export$4f58f497e14a53c3)
              ], new (0, $4aa1b0749c2770f8$export$2e2bcd8739ae039)($5b547cf9e5da519b$var$CFFCustomEncoding, {
                lazy: true
              }));
              class $5b547cf9e5da519b$var$RangeArray extends $gfJaN$restructure.Array {
                decode(stream, parent) {
                  let length = (0, $gfJaN$restructure.resolveLength)(this.length, stream, parent);
                  let count = 0;
                  let res = [];
                  while (count < length) {
                    let range = this.type.decode(stream, parent);
                    range.offset = count;
                    count += range.nLeft + 1;
                    res.push(range);
                  }
                  return res;
                }
              }
              let $5b547cf9e5da519b$var$CFFCustomCharset = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint8, {
                0: {
                  glyphs: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, (t) => t.parent.CharStrings.length - 1)
                },
                1: {
                  ranges: new $5b547cf9e5da519b$var$RangeArray($5b547cf9e5da519b$var$Range1, (t) => t.parent.CharStrings.length - 1)
                },
                2: {
                  ranges: new $5b547cf9e5da519b$var$RangeArray($5b547cf9e5da519b$var$Range2, (t) => t.parent.CharStrings.length - 1)
                }
              });
              let $5b547cf9e5da519b$var$CFFCharset = new $5b547cf9e5da519b$var$PredefinedOp([
                (0, $1e7c7c16984e4427$export$c33b50336c234f16),
                (0, $1e7c7c16984e4427$export$3ed0f9e1fee8d489),
                (0, $1e7c7c16984e4427$export$dc28be11139d4120)
              ], new (0, $4aa1b0749c2770f8$export$2e2bcd8739ae039)($5b547cf9e5da519b$var$CFFCustomCharset, {
                lazy: true
              }));
              let $5b547cf9e5da519b$var$FDRange3 = new $gfJaN$restructure.Struct({
                first: $gfJaN$restructure.uint16,
                fd: $gfJaN$restructure.uint8
              });
              let $5b547cf9e5da519b$var$FDRange4 = new $gfJaN$restructure.Struct({
                first: $gfJaN$restructure.uint32,
                fd: $gfJaN$restructure.uint16
              });
              let $5b547cf9e5da519b$var$FDSelect = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint8, {
                0: {
                  fds: new $gfJaN$restructure.Array($gfJaN$restructure.uint8, (t) => t.parent.CharStrings.length)
                },
                3: {
                  nRanges: $gfJaN$restructure.uint16,
                  ranges: new $gfJaN$restructure.Array($5b547cf9e5da519b$var$FDRange3, "nRanges"),
                  sentinel: $gfJaN$restructure.uint16
                },
                4: {
                  nRanges: $gfJaN$restructure.uint32,
                  ranges: new $gfJaN$restructure.Array($5b547cf9e5da519b$var$FDRange4, "nRanges"),
                  sentinel: $gfJaN$restructure.uint32
                }
              });
              let $5b547cf9e5da519b$var$ptr = new (0, $4aa1b0749c2770f8$export$2e2bcd8739ae039)((0, $15a0cbb3d09cf7ee$export$2e2bcd8739ae039));
              class $5b547cf9e5da519b$var$CFFPrivateOp {
                decode(stream, parent, operands) {
                  parent.length = operands[0];
                  return $5b547cf9e5da519b$var$ptr.decode(stream, parent, [
                    operands[1]
                  ]);
                }
                size(dict, ctx) {
                  return [
                    (0, $15a0cbb3d09cf7ee$export$2e2bcd8739ae039).size(dict, ctx, false),
                    $5b547cf9e5da519b$var$ptr.size(dict, ctx)[0]
                  ];
                }
                encode(stream, dict, ctx) {
                  return [
                    (0, $15a0cbb3d09cf7ee$export$2e2bcd8739ae039).size(dict, ctx, false),
                    $5b547cf9e5da519b$var$ptr.encode(stream, dict, ctx)[0]
                  ];
                }
              }
              let $5b547cf9e5da519b$var$FontDict = new (0, $efe622f40a9c35bd$export$2e2bcd8739ae039)([
                // key       name                   type(s)                                 default
                [
                  18,
                  "Private",
                  new $5b547cf9e5da519b$var$CFFPrivateOp(),
                  null
                ],
                [
                  [
                    12,
                    38
                  ],
                  "FontName",
                  "sid",
                  null
                ],
                [
                  [
                    12,
                    7
                  ],
                  "FontMatrix",
                  "array",
                  [
                    1e-3,
                    0,
                    0,
                    1e-3,
                    0,
                    0
                  ]
                ],
                [
                  [
                    12,
                    5
                  ],
                  "PaintType",
                  "number",
                  0
                ]
              ]);
              let $5b547cf9e5da519b$var$CFFTopDict = new (0, $efe622f40a9c35bd$export$2e2bcd8739ae039)([
                // key       name                   type(s)                                 default
                [
                  [
                    12,
                    30
                  ],
                  "ROS",
                  [
                    "sid",
                    "sid",
                    "number"
                  ],
                  null
                ],
                [
                  0,
                  "version",
                  "sid",
                  null
                ],
                [
                  1,
                  "Notice",
                  "sid",
                  null
                ],
                [
                  [
                    12,
                    0
                  ],
                  "Copyright",
                  "sid",
                  null
                ],
                [
                  2,
                  "FullName",
                  "sid",
                  null
                ],
                [
                  3,
                  "FamilyName",
                  "sid",
                  null
                ],
                [
                  4,
                  "Weight",
                  "sid",
                  null
                ],
                [
                  [
                    12,
                    1
                  ],
                  "isFixedPitch",
                  "boolean",
                  false
                ],
                [
                  [
                    12,
                    2
                  ],
                  "ItalicAngle",
                  "number",
                  0
                ],
                [
                  [
                    12,
                    3
                  ],
                  "UnderlinePosition",
                  "number",
                  -100
                ],
                [
                  [
                    12,
                    4
                  ],
                  "UnderlineThickness",
                  "number",
                  50
                ],
                [
                  [
                    12,
                    5
                  ],
                  "PaintType",
                  "number",
                  0
                ],
                [
                  [
                    12,
                    6
                  ],
                  "CharstringType",
                  "number",
                  2
                ],
                [
                  [
                    12,
                    7
                  ],
                  "FontMatrix",
                  "array",
                  [
                    1e-3,
                    0,
                    0,
                    1e-3,
                    0,
                    0
                  ]
                ],
                [
                  13,
                  "UniqueID",
                  "number",
                  null
                ],
                [
                  5,
                  "FontBBox",
                  "array",
                  [
                    0,
                    0,
                    0,
                    0
                  ]
                ],
                [
                  [
                    12,
                    8
                  ],
                  "StrokeWidth",
                  "number",
                  0
                ],
                [
                  14,
                  "XUID",
                  "array",
                  null
                ],
                [
                  15,
                  "charset",
                  $5b547cf9e5da519b$var$CFFCharset,
                  (0, $1e7c7c16984e4427$export$c33b50336c234f16)
                ],
                [
                  16,
                  "Encoding",
                  $5b547cf9e5da519b$var$CFFEncoding,
                  (0, $c4ffe47cba1d7f36$export$dee0027060fa13bd)
                ],
                [
                  17,
                  "CharStrings",
                  new (0, $4aa1b0749c2770f8$export$2e2bcd8739ae039)(new (0, $9eaea3754914a290$export$2e2bcd8739ae039)()),
                  null
                ],
                [
                  18,
                  "Private",
                  new $5b547cf9e5da519b$var$CFFPrivateOp(),
                  null
                ],
                [
                  [
                    12,
                    20
                  ],
                  "SyntheticBase",
                  "number",
                  null
                ],
                [
                  [
                    12,
                    21
                  ],
                  "PostScript",
                  "sid",
                  null
                ],
                [
                  [
                    12,
                    22
                  ],
                  "BaseFontName",
                  "sid",
                  null
                ],
                [
                  [
                    12,
                    23
                  ],
                  "BaseFontBlend",
                  "delta",
                  null
                ],
                // CID font specific
                [
                  [
                    12,
                    31
                  ],
                  "CIDFontVersion",
                  "number",
                  0
                ],
                [
                  [
                    12,
                    32
                  ],
                  "CIDFontRevision",
                  "number",
                  0
                ],
                [
                  [
                    12,
                    33
                  ],
                  "CIDFontType",
                  "number",
                  0
                ],
                [
                  [
                    12,
                    34
                  ],
                  "CIDCount",
                  "number",
                  8720
                ],
                [
                  [
                    12,
                    35
                  ],
                  "UIDBase",
                  "number",
                  null
                ],
                [
                  [
                    12,
                    37
                  ],
                  "FDSelect",
                  new (0, $4aa1b0749c2770f8$export$2e2bcd8739ae039)($5b547cf9e5da519b$var$FDSelect),
                  null
                ],
                [
                  [
                    12,
                    36
                  ],
                  "FDArray",
                  new (0, $4aa1b0749c2770f8$export$2e2bcd8739ae039)(new (0, $9eaea3754914a290$export$2e2bcd8739ae039)($5b547cf9e5da519b$var$FontDict)),
                  null
                ],
                [
                  [
                    12,
                    38
                  ],
                  "FontName",
                  "sid",
                  null
                ]
              ]);
              let $5b547cf9e5da519b$var$VariationStore = new $gfJaN$restructure.Struct({
                length: $gfJaN$restructure.uint16,
                itemVariationStore: (0, $2e4adcda047b3383$export$fe1b122a2710f241)
              });
              let $5b547cf9e5da519b$var$CFF2TopDict = new (0, $efe622f40a9c35bd$export$2e2bcd8739ae039)([
                [
                  [
                    12,
                    7
                  ],
                  "FontMatrix",
                  "array",
                  [
                    1e-3,
                    0,
                    0,
                    1e-3,
                    0,
                    0
                  ]
                ],
                [
                  17,
                  "CharStrings",
                  new (0, $4aa1b0749c2770f8$export$2e2bcd8739ae039)(new (0, $9eaea3754914a290$export$2e2bcd8739ae039)()),
                  null
                ],
                [
                  [
                    12,
                    37
                  ],
                  "FDSelect",
                  new (0, $4aa1b0749c2770f8$export$2e2bcd8739ae039)($5b547cf9e5da519b$var$FDSelect),
                  null
                ],
                [
                  [
                    12,
                    36
                  ],
                  "FDArray",
                  new (0, $4aa1b0749c2770f8$export$2e2bcd8739ae039)(new (0, $9eaea3754914a290$export$2e2bcd8739ae039)($5b547cf9e5da519b$var$FontDict)),
                  null
                ],
                [
                  24,
                  "vstore",
                  new (0, $4aa1b0749c2770f8$export$2e2bcd8739ae039)($5b547cf9e5da519b$var$VariationStore),
                  null
                ],
                [
                  25,
                  "maxstack",
                  "number",
                  193
                ]
              ]);
              let $5b547cf9e5da519b$var$CFFTop = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.fixed16, {
                1: {
                  hdrSize: $gfJaN$restructure.uint8,
                  offSize: $gfJaN$restructure.uint8,
                  nameIndex: new (0, $9eaea3754914a290$export$2e2bcd8739ae039)(new $gfJaN$restructure.String("length")),
                  topDictIndex: new (0, $9eaea3754914a290$export$2e2bcd8739ae039)($5b547cf9e5da519b$var$CFFTopDict),
                  stringIndex: new (0, $9eaea3754914a290$export$2e2bcd8739ae039)(new $gfJaN$restructure.String("length")),
                  globalSubrIndex: new (0, $9eaea3754914a290$export$2e2bcd8739ae039)()
                },
                2: {
                  hdrSize: $gfJaN$restructure.uint8,
                  length: $gfJaN$restructure.uint16,
                  topDict: $5b547cf9e5da519b$var$CFF2TopDict,
                  globalSubrIndex: new (0, $9eaea3754914a290$export$2e2bcd8739ae039)()
                }
              });
              var $5b547cf9e5da519b$export$2e2bcd8739ae039 = $5b547cf9e5da519b$var$CFFTop;
              class $f717432b360040c7$var$CFFFont {
                static decode(stream) {
                  return new $f717432b360040c7$var$CFFFont(stream);
                }
                decode() {
                  let start = this.stream.pos;
                  let top = (0, $5b547cf9e5da519b$export$2e2bcd8739ae039).decode(this.stream);
                  for (let key in top) {
                    let val = top[key];
                    this[key] = val;
                  }
                  if (this.version < 2) {
                    if (this.topDictIndex.length !== 1) throw new Error("Only a single font is allowed in CFF");
                    this.topDict = this.topDictIndex[0];
                  }
                  this.isCIDFont = this.topDict.ROS != null;
                  return this;
                }
                string(sid) {
                  if (this.version >= 2) return null;
                  if (sid < (0, $860d3574d7fa3a51$export$2e2bcd8739ae039).length) return (0, $860d3574d7fa3a51$export$2e2bcd8739ae039)[sid];
                  return this.stringIndex[sid - (0, $860d3574d7fa3a51$export$2e2bcd8739ae039).length];
                }
                get postscriptName() {
                  if (this.version < 2) return this.nameIndex[0];
                  return null;
                }
                get fullName() {
                  return this.string(this.topDict.FullName);
                }
                get familyName() {
                  return this.string(this.topDict.FamilyName);
                }
                getCharString(glyph) {
                  this.stream.pos = this.topDict.CharStrings[glyph].offset;
                  return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);
                }
                getGlyphName(gid) {
                  if (this.version >= 2) return null;
                  if (this.isCIDFont) return null;
                  let { charset } = this.topDict;
                  if (Array.isArray(charset)) return charset[gid];
                  if (gid === 0) return ".notdef";
                  gid -= 1;
                  switch (charset.version) {
                    case 0:
                      return this.string(charset.glyphs[gid]);
                    case 1:
                    case 2:
                      for (let i = 0; i < charset.ranges.length; i++) {
                        let range = charset.ranges[i];
                        if (range.offset <= gid && gid <= range.offset + range.nLeft) return this.string(range.first + (gid - range.offset));
                      }
                      break;
                  }
                  return null;
                }
                fdForGlyph(gid) {
                  if (!this.topDict.FDSelect) return null;
                  switch (this.topDict.FDSelect.version) {
                    case 0:
                      return this.topDict.FDSelect.fds[gid];
                    case 3:
                    case 4:
                      let { ranges } = this.topDict.FDSelect;
                      let low = 0;
                      let high = ranges.length - 1;
                      while (low <= high) {
                        let mid = low + high >> 1;
                        if (gid < ranges[mid].first) high = mid - 1;
                        else if (mid < high && gid >= ranges[mid + 1].first) low = mid + 1;
                        else return ranges[mid].fd;
                      }
                    default:
                      throw new Error(`Unknown FDSelect version: ${this.topDict.FDSelect.version}`);
                  }
                }
                privateDictForGlyph(gid) {
                  if (this.topDict.FDSelect) {
                    let fd = this.fdForGlyph(gid);
                    if (this.topDict.FDArray[fd]) return this.topDict.FDArray[fd].Private;
                    return null;
                  }
                  if (this.version < 2) return this.topDict.Private;
                  return this.topDict.FDArray[0].Private;
                }
                constructor(stream) {
                  this.stream = stream;
                  this.decode();
                }
              }
              var $f717432b360040c7$export$2e2bcd8739ae039 = $f717432b360040c7$var$CFFFont;
              let $8cb7ae73ed7aa7d8$var$VerticalOrigin = new $gfJaN$restructure.Struct({
                glyphIndex: $gfJaN$restructure.uint16,
                vertOriginY: $gfJaN$restructure.int16
              });
              var $8cb7ae73ed7aa7d8$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                majorVersion: $gfJaN$restructure.uint16,
                minorVersion: $gfJaN$restructure.uint16,
                defaultVertOriginY: $gfJaN$restructure.int16,
                numVertOriginYMetrics: $gfJaN$restructure.uint16,
                metrics: new $gfJaN$restructure.Array($8cb7ae73ed7aa7d8$var$VerticalOrigin, "numVertOriginYMetrics")
              });
              let $20e0c7bbecb76d75$export$16b227cb15d716a0 = new $gfJaN$restructure.Struct({
                height: $gfJaN$restructure.uint8,
                width: $gfJaN$restructure.uint8,
                horiBearingX: $gfJaN$restructure.int8,
                horiBearingY: $gfJaN$restructure.int8,
                horiAdvance: $gfJaN$restructure.uint8,
                vertBearingX: $gfJaN$restructure.int8,
                vertBearingY: $gfJaN$restructure.int8,
                vertAdvance: $gfJaN$restructure.uint8
              });
              let $20e0c7bbecb76d75$export$62c53e75f69bfe12 = new $gfJaN$restructure.Struct({
                height: $gfJaN$restructure.uint8,
                width: $gfJaN$restructure.uint8,
                bearingX: $gfJaN$restructure.int8,
                bearingY: $gfJaN$restructure.int8,
                advance: $gfJaN$restructure.uint8
              });
              let $20e0c7bbecb76d75$var$EBDTComponent = new $gfJaN$restructure.Struct({
                glyph: $gfJaN$restructure.uint16,
                xOffset: $gfJaN$restructure.int8,
                yOffset: $gfJaN$restructure.int8
              });
              class $20e0c7bbecb76d75$var$ByteAligned {
              }
              class $20e0c7bbecb76d75$var$BitAligned {
              }
              let $20e0c7bbecb76d75$export$f1f5ddeb20d14f = new $gfJaN$restructure.VersionedStruct("version", {
                1: {
                  metrics: $20e0c7bbecb76d75$export$62c53e75f69bfe12,
                  data: $20e0c7bbecb76d75$var$ByteAligned
                },
                2: {
                  metrics: $20e0c7bbecb76d75$export$62c53e75f69bfe12,
                  data: $20e0c7bbecb76d75$var$BitAligned
                },
                // format 3 is deprecated
                // format 4 is not supported by Microsoft
                5: {
                  data: $20e0c7bbecb76d75$var$BitAligned
                },
                6: {
                  metrics: $20e0c7bbecb76d75$export$16b227cb15d716a0,
                  data: $20e0c7bbecb76d75$var$ByteAligned
                },
                7: {
                  metrics: $20e0c7bbecb76d75$export$16b227cb15d716a0,
                  data: $20e0c7bbecb76d75$var$BitAligned
                },
                8: {
                  metrics: $20e0c7bbecb76d75$export$62c53e75f69bfe12,
                  pad: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint8),
                  numComponents: $gfJaN$restructure.uint16,
                  components: new $gfJaN$restructure.Array($20e0c7bbecb76d75$var$EBDTComponent, "numComponents")
                },
                9: {
                  metrics: $20e0c7bbecb76d75$export$16b227cb15d716a0,
                  pad: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint8),
                  numComponents: $gfJaN$restructure.uint16,
                  components: new $gfJaN$restructure.Array($20e0c7bbecb76d75$var$EBDTComponent, "numComponents")
                },
                17: {
                  metrics: $20e0c7bbecb76d75$export$62c53e75f69bfe12,
                  dataLen: $gfJaN$restructure.uint32,
                  data: new $gfJaN$restructure.Buffer("dataLen")
                },
                18: {
                  metrics: $20e0c7bbecb76d75$export$16b227cb15d716a0,
                  dataLen: $gfJaN$restructure.uint32,
                  data: new $gfJaN$restructure.Buffer("dataLen")
                },
                19: {
                  dataLen: $gfJaN$restructure.uint32,
                  data: new $gfJaN$restructure.Buffer("dataLen")
                }
              });
              let $035bb95c0cdb1f6d$var$SBitLineMetrics = new $gfJaN$restructure.Struct({
                ascender: $gfJaN$restructure.int8,
                descender: $gfJaN$restructure.int8,
                widthMax: $gfJaN$restructure.uint8,
                caretSlopeNumerator: $gfJaN$restructure.int8,
                caretSlopeDenominator: $gfJaN$restructure.int8,
                caretOffset: $gfJaN$restructure.int8,
                minOriginSB: $gfJaN$restructure.int8,
                minAdvanceSB: $gfJaN$restructure.int8,
                maxBeforeBL: $gfJaN$restructure.int8,
                minAfterBL: $gfJaN$restructure.int8,
                pad: new $gfJaN$restructure.Reserved($gfJaN$restructure.int8, 2)
              });
              let $035bb95c0cdb1f6d$var$CodeOffsetPair = new $gfJaN$restructure.Struct({
                glyphCode: $gfJaN$restructure.uint16,
                offset: $gfJaN$restructure.uint16
              });
              let $035bb95c0cdb1f6d$var$IndexSubtable = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint16, {
                header: {
                  imageFormat: $gfJaN$restructure.uint16,
                  imageDataOffset: $gfJaN$restructure.uint32
                },
                1: {
                  offsetArray: new $gfJaN$restructure.Array($gfJaN$restructure.uint32, (t) => t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1)
                },
                2: {
                  imageSize: $gfJaN$restructure.uint32,
                  bigMetrics: (0, $20e0c7bbecb76d75$export$16b227cb15d716a0)
                },
                3: {
                  offsetArray: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, (t) => t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1)
                },
                4: {
                  numGlyphs: $gfJaN$restructure.uint32,
                  glyphArray: new $gfJaN$restructure.Array($035bb95c0cdb1f6d$var$CodeOffsetPair, (t) => t.numGlyphs + 1)
                },
                5: {
                  imageSize: $gfJaN$restructure.uint32,
                  bigMetrics: (0, $20e0c7bbecb76d75$export$16b227cb15d716a0),
                  numGlyphs: $gfJaN$restructure.uint32,
                  glyphCodeArray: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, "numGlyphs")
                }
              });
              let $035bb95c0cdb1f6d$var$IndexSubtableArray = new $gfJaN$restructure.Struct({
                firstGlyphIndex: $gfJaN$restructure.uint16,
                lastGlyphIndex: $gfJaN$restructure.uint16,
                subtable: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, $035bb95c0cdb1f6d$var$IndexSubtable)
              });
              let $035bb95c0cdb1f6d$var$BitmapSizeTable = new $gfJaN$restructure.Struct({
                indexSubTableArray: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, new $gfJaN$restructure.Array($035bb95c0cdb1f6d$var$IndexSubtableArray, 1), {
                  type: "parent"
                }),
                indexTablesSize: $gfJaN$restructure.uint32,
                numberOfIndexSubTables: $gfJaN$restructure.uint32,
                colorRef: $gfJaN$restructure.uint32,
                hori: $035bb95c0cdb1f6d$var$SBitLineMetrics,
                vert: $035bb95c0cdb1f6d$var$SBitLineMetrics,
                startGlyphIndex: $gfJaN$restructure.uint16,
                endGlyphIndex: $gfJaN$restructure.uint16,
                ppemX: $gfJaN$restructure.uint8,
                ppemY: $gfJaN$restructure.uint8,
                bitDepth: $gfJaN$restructure.uint8,
                flags: new $gfJaN$restructure.Bitfield($gfJaN$restructure.uint8, [
                  "horizontal",
                  "vertical"
                ])
              });
              var $035bb95c0cdb1f6d$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.uint32,
                numSizes: $gfJaN$restructure.uint32,
                sizes: new $gfJaN$restructure.Array($035bb95c0cdb1f6d$var$BitmapSizeTable, "numSizes")
              });
              let $73d13900b55a3c0c$var$ImageTable = new $gfJaN$restructure.Struct({
                ppem: $gfJaN$restructure.uint16,
                resolution: $gfJaN$restructure.uint16,
                imageOffsets: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, "void"), (t) => t.parent.parent.maxp.numGlyphs + 1)
              });
              var $73d13900b55a3c0c$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.uint16,
                flags: new $gfJaN$restructure.Bitfield($gfJaN$restructure.uint16, [
                  "renderOutlines"
                ]),
                numImgTables: $gfJaN$restructure.uint32,
                imageTables: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, $73d13900b55a3c0c$var$ImageTable), "numImgTables")
              });
              let $97f6b8be3a347a8f$var$LayerRecord = new $gfJaN$restructure.Struct({
                gid: $gfJaN$restructure.uint16,
                paletteIndex: $gfJaN$restructure.uint16
                // Index value to use in the appropriate palette. This value must
              });
              let $97f6b8be3a347a8f$var$BaseGlyphRecord = new $gfJaN$restructure.Struct({
                gid: $gfJaN$restructure.uint16,
                // and is not rendered for color.
                firstLayerIndex: $gfJaN$restructure.uint16,
                // There will be numLayers consecutive entries for this base glyph.
                numLayers: $gfJaN$restructure.uint16
              });
              var $97f6b8be3a347a8f$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.uint16,
                numBaseGlyphRecords: $gfJaN$restructure.uint16,
                baseGlyphRecord: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, new $gfJaN$restructure.Array($97f6b8be3a347a8f$var$BaseGlyphRecord, "numBaseGlyphRecords")),
                layerRecords: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, new $gfJaN$restructure.Array($97f6b8be3a347a8f$var$LayerRecord, "numLayerRecords"), {
                  lazy: true
                }),
                numLayerRecords: $gfJaN$restructure.uint16
              });
              let $16ca60ecbdee30ea$var$ColorRecord = new $gfJaN$restructure.Struct({
                blue: $gfJaN$restructure.uint8,
                green: $gfJaN$restructure.uint8,
                red: $gfJaN$restructure.uint8,
                alpha: $gfJaN$restructure.uint8
              });
              var $16ca60ecbdee30ea$export$2e2bcd8739ae039 = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint16, {
                header: {
                  numPaletteEntries: $gfJaN$restructure.uint16,
                  numPalettes: $gfJaN$restructure.uint16,
                  numColorRecords: $gfJaN$restructure.uint16,
                  colorRecords: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, new $gfJaN$restructure.Array($16ca60ecbdee30ea$var$ColorRecord, "numColorRecords")),
                  colorRecordIndices: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, "numPalettes")
                },
                0: {},
                1: {
                  offsetPaletteTypeArray: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, new $gfJaN$restructure.Array($gfJaN$restructure.uint32, "numPalettes")),
                  offsetPaletteLabelArray: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, new $gfJaN$restructure.Array($gfJaN$restructure.uint16, "numPalettes")),
                  offsetPaletteEntryLabelArray: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, new $gfJaN$restructure.Array($gfJaN$restructure.uint16, "numPaletteEntries"))
                }
              });
              let $7327e41706f9d5c7$var$BaseCoord = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint16, {
                1: {
                  coordinate: $gfJaN$restructure.int16
                  // X or Y value, in design units
                },
                2: {
                  coordinate: $gfJaN$restructure.int16,
                  referenceGlyph: $gfJaN$restructure.uint16,
                  baseCoordPoint: $gfJaN$restructure.uint16
                  // Index of contour point on the referenceGlyph
                },
                3: {
                  coordinate: $gfJaN$restructure.int16,
                  deviceTable: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$8215d14a63d9fb10))
                  // Device table for X or Y value
                }
              });
              let $7327e41706f9d5c7$var$BaseValues = new $gfJaN$restructure.Struct({
                defaultIndex: $gfJaN$restructure.uint16,
                baseCoordCount: $gfJaN$restructure.uint16,
                baseCoords: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7327e41706f9d5c7$var$BaseCoord), "baseCoordCount")
              });
              let $7327e41706f9d5c7$var$FeatMinMaxRecord = new $gfJaN$restructure.Struct({
                tag: new $gfJaN$restructure.String(4),
                minCoord: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7327e41706f9d5c7$var$BaseCoord, {
                  type: "parent"
                }),
                maxCoord: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7327e41706f9d5c7$var$BaseCoord, {
                  type: "parent"
                })
                // May be NULL
              });
              let $7327e41706f9d5c7$var$MinMax = new $gfJaN$restructure.Struct({
                minCoord: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7327e41706f9d5c7$var$BaseCoord),
                maxCoord: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7327e41706f9d5c7$var$BaseCoord),
                featMinMaxCount: $gfJaN$restructure.uint16,
                featMinMaxRecords: new $gfJaN$restructure.Array($7327e41706f9d5c7$var$FeatMinMaxRecord, "featMinMaxCount")
                // In alphabetical order
              });
              let $7327e41706f9d5c7$var$BaseLangSysRecord = new $gfJaN$restructure.Struct({
                tag: new $gfJaN$restructure.String(4),
                minMax: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7327e41706f9d5c7$var$MinMax, {
                  type: "parent"
                })
              });
              let $7327e41706f9d5c7$var$BaseScript = new $gfJaN$restructure.Struct({
                baseValues: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7327e41706f9d5c7$var$BaseValues),
                defaultMinMax: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7327e41706f9d5c7$var$MinMax),
                baseLangSysCount: $gfJaN$restructure.uint16,
                baseLangSysRecords: new $gfJaN$restructure.Array($7327e41706f9d5c7$var$BaseLangSysRecord, "baseLangSysCount")
                // in alphabetical order by BaseLangSysTag
              });
              let $7327e41706f9d5c7$var$BaseScriptRecord = new $gfJaN$restructure.Struct({
                tag: new $gfJaN$restructure.String(4),
                script: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7327e41706f9d5c7$var$BaseScript, {
                  type: "parent"
                })
              });
              let $7327e41706f9d5c7$var$BaseScriptList = new $gfJaN$restructure.Array($7327e41706f9d5c7$var$BaseScriptRecord, $gfJaN$restructure.uint16);
              let $7327e41706f9d5c7$var$BaseTagList = new $gfJaN$restructure.Array(new $gfJaN$restructure.String(4), $gfJaN$restructure.uint16);
              let $7327e41706f9d5c7$var$Axis = new $gfJaN$restructure.Struct({
                baseTagList: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7327e41706f9d5c7$var$BaseTagList),
                baseScriptList: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7327e41706f9d5c7$var$BaseScriptList)
              });
              var $7327e41706f9d5c7$export$2e2bcd8739ae039 = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint32, {
                header: {
                  horizAxis: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7327e41706f9d5c7$var$Axis),
                  vertAxis: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7327e41706f9d5c7$var$Axis)
                  // May be NULL
                },
                65536: {},
                65537: {
                  itemVariationStore: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, (0, $2e4adcda047b3383$export$fe1b122a2710f241))
                }
              });
              let $7e48bbe9e5345664$var$AttachPoint = new $gfJaN$restructure.Array($gfJaN$restructure.uint16, $gfJaN$restructure.uint16);
              let $7e48bbe9e5345664$var$AttachList = new $gfJaN$restructure.Struct({
                coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                glyphCount: $gfJaN$restructure.uint16,
                attachPoints: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7e48bbe9e5345664$var$AttachPoint), "glyphCount")
              });
              let $7e48bbe9e5345664$var$CaretValue = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint16, {
                1: {
                  coordinate: $gfJaN$restructure.int16
                },
                2: {
                  caretValuePoint: $gfJaN$restructure.uint16
                },
                3: {
                  coordinate: $gfJaN$restructure.int16,
                  deviceTable: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$8215d14a63d9fb10))
                }
              });
              let $7e48bbe9e5345664$var$LigGlyph = new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7e48bbe9e5345664$var$CaretValue), $gfJaN$restructure.uint16);
              let $7e48bbe9e5345664$var$LigCaretList = new $gfJaN$restructure.Struct({
                coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                ligGlyphCount: $gfJaN$restructure.uint16,
                ligGlyphs: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7e48bbe9e5345664$var$LigGlyph), "ligGlyphCount")
              });
              let $7e48bbe9e5345664$var$MarkGlyphSetsDef = new $gfJaN$restructure.Struct({
                markSetTableFormat: $gfJaN$restructure.uint16,
                markSetCount: $gfJaN$restructure.uint16,
                coverage: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, (0, $b6dd765146ad212a$export$17608c3f81a6111)), "markSetCount")
              });
              var $7e48bbe9e5345664$export$2e2bcd8739ae039 = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint32, {
                header: {
                  glyphClassDef: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$843d551fbbafef71)),
                  attachList: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7e48bbe9e5345664$var$AttachList),
                  ligCaretList: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7e48bbe9e5345664$var$LigCaretList),
                  markAttachClassDef: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$843d551fbbafef71))
                },
                65536: {},
                65538: {
                  markGlyphSetsDef: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7e48bbe9e5345664$var$MarkGlyphSetsDef)
                },
                65539: {
                  markGlyphSetsDef: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $7e48bbe9e5345664$var$MarkGlyphSetsDef),
                  itemVariationStore: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, (0, $2e4adcda047b3383$export$fe1b122a2710f241))
                }
              });
              let $b687332511a4da75$var$ValueFormat = new $gfJaN$restructure.Bitfield($gfJaN$restructure.uint16, [
                "xPlacement",
                "yPlacement",
                "xAdvance",
                "yAdvance",
                "xPlaDevice",
                "yPlaDevice",
                "xAdvDevice",
                "yAdvDevice"
              ]);
              let $b687332511a4da75$var$types = {
                xPlacement: $gfJaN$restructure.int16,
                yPlacement: $gfJaN$restructure.int16,
                xAdvance: $gfJaN$restructure.int16,
                yAdvance: $gfJaN$restructure.int16,
                xPlaDevice: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$8215d14a63d9fb10), {
                  type: "global",
                  relativeTo: (ctx) => ctx.rel
                }),
                yPlaDevice: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$8215d14a63d9fb10), {
                  type: "global",
                  relativeTo: (ctx) => ctx.rel
                }),
                xAdvDevice: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$8215d14a63d9fb10), {
                  type: "global",
                  relativeTo: (ctx) => ctx.rel
                }),
                yAdvDevice: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$8215d14a63d9fb10), {
                  type: "global",
                  relativeTo: (ctx) => ctx.rel
                })
              };
              class $b687332511a4da75$var$ValueRecord {
                buildStruct(parent) {
                  let struct = parent;
                  while (!struct[this.key] && struct.parent) struct = struct.parent;
                  if (!struct[this.key]) return;
                  let fields = {};
                  fields.rel = () => struct._startOffset;
                  let format = struct[this.key];
                  for (let key in format) if (format[key]) fields[key] = $b687332511a4da75$var$types[key];
                  return new $gfJaN$restructure.Struct(fields);
                }
                size(val, ctx) {
                  return this.buildStruct(ctx).size(val, ctx);
                }
                decode(stream, parent) {
                  let res = this.buildStruct(parent).decode(stream, parent);
                  delete res.rel;
                  return res;
                }
                constructor(key = "valueFormat") {
                  this.key = key;
                }
              }
              let $b687332511a4da75$var$PairValueRecord = new $gfJaN$restructure.Struct({
                secondGlyph: $gfJaN$restructure.uint16,
                value1: new $b687332511a4da75$var$ValueRecord("valueFormat1"),
                value2: new $b687332511a4da75$var$ValueRecord("valueFormat2")
              });
              let $b687332511a4da75$var$PairSet = new $gfJaN$restructure.Array($b687332511a4da75$var$PairValueRecord, $gfJaN$restructure.uint16);
              let $b687332511a4da75$var$Class2Record = new $gfJaN$restructure.Struct({
                value1: new $b687332511a4da75$var$ValueRecord("valueFormat1"),
                value2: new $b687332511a4da75$var$ValueRecord("valueFormat2")
              });
              let $b687332511a4da75$var$Anchor = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint16, {
                1: {
                  xCoordinate: $gfJaN$restructure.int16,
                  yCoordinate: $gfJaN$restructure.int16
                },
                2: {
                  xCoordinate: $gfJaN$restructure.int16,
                  yCoordinate: $gfJaN$restructure.int16,
                  anchorPoint: $gfJaN$restructure.uint16
                },
                3: {
                  xCoordinate: $gfJaN$restructure.int16,
                  yCoordinate: $gfJaN$restructure.int16,
                  xDeviceTable: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$8215d14a63d9fb10)),
                  yDeviceTable: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$8215d14a63d9fb10))
                }
              });
              let $b687332511a4da75$var$EntryExitRecord = new $gfJaN$restructure.Struct({
                entryAnchor: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b687332511a4da75$var$Anchor, {
                  type: "parent"
                }),
                exitAnchor: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b687332511a4da75$var$Anchor, {
                  type: "parent"
                })
              });
              let $b687332511a4da75$var$MarkRecord = new $gfJaN$restructure.Struct({
                class: $gfJaN$restructure.uint16,
                markAnchor: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b687332511a4da75$var$Anchor, {
                  type: "parent"
                })
              });
              let $b687332511a4da75$var$MarkArray = new $gfJaN$restructure.Array($b687332511a4da75$var$MarkRecord, $gfJaN$restructure.uint16);
              let $b687332511a4da75$var$BaseRecord = new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b687332511a4da75$var$Anchor), (t) => t.parent.classCount);
              let $b687332511a4da75$var$BaseArray = new $gfJaN$restructure.Array($b687332511a4da75$var$BaseRecord, $gfJaN$restructure.uint16);
              let $b687332511a4da75$var$ComponentRecord = new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b687332511a4da75$var$Anchor), (t) => t.parent.parent.classCount);
              let $b687332511a4da75$var$LigatureAttach = new $gfJaN$restructure.Array($b687332511a4da75$var$ComponentRecord, $gfJaN$restructure.uint16);
              let $b687332511a4da75$var$LigatureArray = new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b687332511a4da75$var$LigatureAttach), $gfJaN$restructure.uint16);
              let $b687332511a4da75$export$73a8cfb19cd43a0f = new $gfJaN$restructure.VersionedStruct("lookupType", {
                1: new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint16, {
                  1: {
                    coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                    valueFormat: $b687332511a4da75$var$ValueFormat,
                    value: new $b687332511a4da75$var$ValueRecord()
                  },
                  2: {
                    coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                    valueFormat: $b687332511a4da75$var$ValueFormat,
                    valueCount: $gfJaN$restructure.uint16,
                    values: new $gfJaN$restructure.LazyArray(new $b687332511a4da75$var$ValueRecord(), "valueCount")
                  }
                }),
                2: new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint16, {
                  1: {
                    coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                    valueFormat1: $b687332511a4da75$var$ValueFormat,
                    valueFormat2: $b687332511a4da75$var$ValueFormat,
                    pairSetCount: $gfJaN$restructure.uint16,
                    pairSets: new $gfJaN$restructure.LazyArray(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b687332511a4da75$var$PairSet), "pairSetCount")
                  },
                  2: {
                    coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                    valueFormat1: $b687332511a4da75$var$ValueFormat,
                    valueFormat2: $b687332511a4da75$var$ValueFormat,
                    classDef1: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$843d551fbbafef71)),
                    classDef2: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$843d551fbbafef71)),
                    class1Count: $gfJaN$restructure.uint16,
                    class2Count: $gfJaN$restructure.uint16,
                    classRecords: new $gfJaN$restructure.LazyArray(new $gfJaN$restructure.LazyArray($b687332511a4da75$var$Class2Record, "class2Count"), "class1Count")
                  }
                }),
                3: {
                  format: $gfJaN$restructure.uint16,
                  coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                  entryExitCount: $gfJaN$restructure.uint16,
                  entryExitRecords: new $gfJaN$restructure.Array($b687332511a4da75$var$EntryExitRecord, "entryExitCount")
                },
                4: {
                  format: $gfJaN$restructure.uint16,
                  markCoverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                  baseCoverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                  classCount: $gfJaN$restructure.uint16,
                  markArray: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b687332511a4da75$var$MarkArray),
                  baseArray: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b687332511a4da75$var$BaseArray)
                },
                5: {
                  format: $gfJaN$restructure.uint16,
                  markCoverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                  ligatureCoverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                  classCount: $gfJaN$restructure.uint16,
                  markArray: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b687332511a4da75$var$MarkArray),
                  ligatureArray: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b687332511a4da75$var$LigatureArray)
                },
                6: {
                  format: $gfJaN$restructure.uint16,
                  mark1Coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                  mark2Coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                  classCount: $gfJaN$restructure.uint16,
                  mark1Array: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b687332511a4da75$var$MarkArray),
                  mark2Array: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $b687332511a4da75$var$BaseArray)
                },
                7: (0, $b6dd765146ad212a$export$841858b892ce1f4c),
                8: (0, $b6dd765146ad212a$export$5e6d09e6861162f6),
                9: {
                  posFormat: $gfJaN$restructure.uint16,
                  lookupType: $gfJaN$restructure.uint16,
                  extension: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, null)
                }
              });
              $b687332511a4da75$export$73a8cfb19cd43a0f.versions[9].extension.type = $b687332511a4da75$export$73a8cfb19cd43a0f;
              var $b687332511a4da75$export$2e2bcd8739ae039 = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint32, {
                header: {
                  scriptList: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$3e15fc05ce864229)),
                  featureList: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$aa18130def4b6cb4)),
                  lookupList: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, new (0, $b6dd765146ad212a$export$df0008c6ff2da22a)($b687332511a4da75$export$73a8cfb19cd43a0f))
                },
                65536: {},
                65537: {
                  featureVariations: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, (0, $2e4adcda047b3383$export$441b70b7971dd419))
                }
              });
              let $99ccad60b96f92fb$var$Sequence = new $gfJaN$restructure.Array($gfJaN$restructure.uint16, $gfJaN$restructure.uint16);
              let $99ccad60b96f92fb$var$AlternateSet = $99ccad60b96f92fb$var$Sequence;
              let $99ccad60b96f92fb$var$Ligature = new $gfJaN$restructure.Struct({
                glyph: $gfJaN$restructure.uint16,
                compCount: $gfJaN$restructure.uint16,
                components: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, (t) => t.compCount - 1)
              });
              let $99ccad60b96f92fb$var$LigatureSet = new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $99ccad60b96f92fb$var$Ligature), $gfJaN$restructure.uint16);
              let $99ccad60b96f92fb$var$GSUBLookup = new $gfJaN$restructure.VersionedStruct("lookupType", {
                1: new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint16, {
                  1: {
                    coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                    deltaGlyphID: $gfJaN$restructure.int16
                  },
                  2: {
                    coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                    glyphCount: $gfJaN$restructure.uint16,
                    substitute: new $gfJaN$restructure.LazyArray($gfJaN$restructure.uint16, "glyphCount")
                  }
                }),
                2: {
                  substFormat: $gfJaN$restructure.uint16,
                  coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                  count: $gfJaN$restructure.uint16,
                  sequences: new $gfJaN$restructure.LazyArray(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $99ccad60b96f92fb$var$Sequence), "count")
                },
                3: {
                  substFormat: $gfJaN$restructure.uint16,
                  coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                  count: $gfJaN$restructure.uint16,
                  alternateSet: new $gfJaN$restructure.LazyArray(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $99ccad60b96f92fb$var$AlternateSet), "count")
                },
                4: {
                  substFormat: $gfJaN$restructure.uint16,
                  coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                  count: $gfJaN$restructure.uint16,
                  ligatureSets: new $gfJaN$restructure.LazyArray(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $99ccad60b96f92fb$var$LigatureSet), "count")
                },
                5: (0, $b6dd765146ad212a$export$841858b892ce1f4c),
                6: (0, $b6dd765146ad212a$export$5e6d09e6861162f6),
                7: {
                  substFormat: $gfJaN$restructure.uint16,
                  lookupType: $gfJaN$restructure.uint16,
                  extension: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, null)
                },
                8: {
                  substFormat: $gfJaN$restructure.uint16,
                  coverage: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)),
                  backtrackCoverage: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)), "backtrackGlyphCount"),
                  lookaheadGlyphCount: $gfJaN$restructure.uint16,
                  lookaheadCoverage: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$17608c3f81a6111)), "lookaheadGlyphCount"),
                  glyphCount: $gfJaN$restructure.uint16,
                  substitutes: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, "glyphCount")
                }
              });
              $99ccad60b96f92fb$var$GSUBLookup.versions[7].extension.type = $99ccad60b96f92fb$var$GSUBLookup;
              var $99ccad60b96f92fb$export$2e2bcd8739ae039 = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint32, {
                header: {
                  scriptList: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$3e15fc05ce864229)),
                  featureList: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, (0, $b6dd765146ad212a$export$aa18130def4b6cb4)),
                  lookupList: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, new (0, $b6dd765146ad212a$export$df0008c6ff2da22a)($99ccad60b96f92fb$var$GSUBLookup))
                },
                65536: {},
                65537: {
                  featureVariations: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, (0, $2e4adcda047b3383$export$441b70b7971dd419))
                }
              });
              let $573d5042c76c4940$var$JstfGSUBModList = new $gfJaN$restructure.Array($gfJaN$restructure.uint16, $gfJaN$restructure.uint16);
              let $573d5042c76c4940$var$JstfPriority = new $gfJaN$restructure.Struct({
                shrinkageEnableGSUB: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $573d5042c76c4940$var$JstfGSUBModList),
                shrinkageDisableGSUB: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $573d5042c76c4940$var$JstfGSUBModList),
                shrinkageEnableGPOS: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $573d5042c76c4940$var$JstfGSUBModList),
                shrinkageDisableGPOS: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $573d5042c76c4940$var$JstfGSUBModList),
                shrinkageJstfMax: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, new (0, $b6dd765146ad212a$export$df0008c6ff2da22a)((0, $b687332511a4da75$export$73a8cfb19cd43a0f))),
                extensionEnableGSUB: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $573d5042c76c4940$var$JstfGSUBModList),
                extensionDisableGSUB: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $573d5042c76c4940$var$JstfGSUBModList),
                extensionEnableGPOS: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $573d5042c76c4940$var$JstfGSUBModList),
                extensionDisableGPOS: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $573d5042c76c4940$var$JstfGSUBModList),
                extensionJstfMax: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, new (0, $b6dd765146ad212a$export$df0008c6ff2da22a)((0, $b687332511a4da75$export$73a8cfb19cd43a0f)))
              });
              let $573d5042c76c4940$var$JstfLangSys = new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $573d5042c76c4940$var$JstfPriority), $gfJaN$restructure.uint16);
              let $573d5042c76c4940$var$JstfLangSysRecord = new $gfJaN$restructure.Struct({
                tag: new $gfJaN$restructure.String(4),
                jstfLangSys: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $573d5042c76c4940$var$JstfLangSys)
              });
              let $573d5042c76c4940$var$JstfScript = new $gfJaN$restructure.Struct({
                extenderGlyphs: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, new $gfJaN$restructure.Array($gfJaN$restructure.uint16, $gfJaN$restructure.uint16)),
                defaultLangSys: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $573d5042c76c4940$var$JstfLangSys),
                langSysCount: $gfJaN$restructure.uint16,
                langSysRecords: new $gfJaN$restructure.Array($573d5042c76c4940$var$JstfLangSysRecord, "langSysCount")
              });
              let $573d5042c76c4940$var$JstfScriptRecord = new $gfJaN$restructure.Struct({
                tag: new $gfJaN$restructure.String(4),
                script: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $573d5042c76c4940$var$JstfScript, {
                  type: "parent"
                })
              });
              var $573d5042c76c4940$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.uint32,
                scriptCount: $gfJaN$restructure.uint16,
                scriptList: new $gfJaN$restructure.Array($573d5042c76c4940$var$JstfScriptRecord, "scriptCount")
              });
              class $a5875b80d6087f61$var$VariableSizeNumber {
                decode(stream, parent) {
                  switch (this.size(0, parent)) {
                    case 1:
                      return stream.readUInt8();
                    case 2:
                      return stream.readUInt16BE();
                    case 3:
                      return stream.readUInt24BE();
                    case 4:
                      return stream.readUInt32BE();
                  }
                }
                size(val, parent) {
                  return (0, $gfJaN$restructure.resolveLength)(this._size, null, parent);
                }
                constructor(size) {
                  this._size = size;
                }
              }
              let $a5875b80d6087f61$var$MapDataEntry = new $gfJaN$restructure.Struct({
                entry: new $a5875b80d6087f61$var$VariableSizeNumber((t) => ((t.parent.entryFormat & 48) >> 4) + 1),
                outerIndex: (t) => t.entry >> (t.parent.entryFormat & 15) + 1,
                innerIndex: (t) => t.entry & (1 << (t.parent.entryFormat & 15) + 1) - 1
              });
              let $a5875b80d6087f61$var$DeltaSetIndexMap = new $gfJaN$restructure.Struct({
                entryFormat: $gfJaN$restructure.uint16,
                mapCount: $gfJaN$restructure.uint16,
                mapData: new $gfJaN$restructure.Array($a5875b80d6087f61$var$MapDataEntry, "mapCount")
              });
              var $a5875b80d6087f61$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                majorVersion: $gfJaN$restructure.uint16,
                minorVersion: $gfJaN$restructure.uint16,
                itemVariationStore: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, (0, $2e4adcda047b3383$export$fe1b122a2710f241)),
                advanceWidthMapping: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, $a5875b80d6087f61$var$DeltaSetIndexMap),
                LSBMapping: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, $a5875b80d6087f61$var$DeltaSetIndexMap),
                RSBMapping: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, $a5875b80d6087f61$var$DeltaSetIndexMap)
              });
              let $4423bc1ac09bbbd1$var$Signature = new $gfJaN$restructure.Struct({
                format: $gfJaN$restructure.uint32,
                length: $gfJaN$restructure.uint32,
                offset: $gfJaN$restructure.uint32
              });
              let $4423bc1ac09bbbd1$var$SignatureBlock = new $gfJaN$restructure.Struct({
                reserved: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint16, 2),
                cbSignature: $gfJaN$restructure.uint32,
                signature: new $gfJaN$restructure.Buffer("cbSignature")
              });
              var $4423bc1ac09bbbd1$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                ulVersion: $gfJaN$restructure.uint32,
                usNumSigs: $gfJaN$restructure.uint16,
                usFlag: $gfJaN$restructure.uint16,
                signatures: new $gfJaN$restructure.Array($4423bc1ac09bbbd1$var$Signature, "usNumSigs"),
                signatureBlocks: new $gfJaN$restructure.Array($4423bc1ac09bbbd1$var$SignatureBlock, "usNumSigs")
              });
              let $7b50e3f8d83263de$var$GaspRange = new $gfJaN$restructure.Struct({
                rangeMaxPPEM: $gfJaN$restructure.uint16,
                rangeGaspBehavior: new $gfJaN$restructure.Bitfield($gfJaN$restructure.uint16, [
                  "grayscale",
                  "gridfit",
                  "symmetricSmoothing",
                  "symmetricGridfit"
                  // only in version 1, for ClearType
                ])
              });
              var $7b50e3f8d83263de$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.uint16,
                numRanges: $gfJaN$restructure.uint16,
                gaspRanges: new $gfJaN$restructure.Array($7b50e3f8d83263de$var$GaspRange, "numRanges")
                // Sorted by ppem
              });
              let $7bf92ec372cd2307$var$DeviceRecord = new $gfJaN$restructure.Struct({
                pixelSize: $gfJaN$restructure.uint8,
                maximumWidth: $gfJaN$restructure.uint8,
                widths: new $gfJaN$restructure.Array($gfJaN$restructure.uint8, (t) => t.parent.parent.maxp.numGlyphs)
              });
              var $7bf92ec372cd2307$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.uint16,
                numRecords: $gfJaN$restructure.int16,
                sizeDeviceRecord: $gfJaN$restructure.int32,
                records: new $gfJaN$restructure.Array($7bf92ec372cd2307$var$DeviceRecord, "numRecords")
              });
              let $a3f544bcf76542d1$var$KernPair = new $gfJaN$restructure.Struct({
                left: $gfJaN$restructure.uint16,
                right: $gfJaN$restructure.uint16,
                value: $gfJaN$restructure.int16
              });
              let $a3f544bcf76542d1$var$ClassTable = new $gfJaN$restructure.Struct({
                firstGlyph: $gfJaN$restructure.uint16,
                nGlyphs: $gfJaN$restructure.uint16,
                offsets: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, "nGlyphs"),
                max: (t) => t.offsets.length && Math.max.apply(Math, t.offsets)
              });
              let $a3f544bcf76542d1$var$Kern2Array = new $gfJaN$restructure.Struct({
                off: (t) => t._startOffset - t.parent.parent._startOffset,
                len: (t) => ((t.parent.leftTable.max - t.off) / t.parent.rowWidth + 1) * (t.parent.rowWidth / 2),
                values: new $gfJaN$restructure.LazyArray($gfJaN$restructure.int16, "len")
              });
              let $a3f544bcf76542d1$var$KernSubtable = new $gfJaN$restructure.VersionedStruct("format", {
                0: {
                  nPairs: $gfJaN$restructure.uint16,
                  searchRange: $gfJaN$restructure.uint16,
                  entrySelector: $gfJaN$restructure.uint16,
                  rangeShift: $gfJaN$restructure.uint16,
                  pairs: new $gfJaN$restructure.Array($a3f544bcf76542d1$var$KernPair, "nPairs")
                },
                2: {
                  rowWidth: $gfJaN$restructure.uint16,
                  leftTable: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $a3f544bcf76542d1$var$ClassTable, {
                    type: "parent"
                  }),
                  rightTable: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $a3f544bcf76542d1$var$ClassTable, {
                    type: "parent"
                  }),
                  array: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $a3f544bcf76542d1$var$Kern2Array, {
                    type: "parent"
                  })
                },
                3: {
                  glyphCount: $gfJaN$restructure.uint16,
                  kernValueCount: $gfJaN$restructure.uint8,
                  leftClassCount: $gfJaN$restructure.uint8,
                  rightClassCount: $gfJaN$restructure.uint8,
                  flags: $gfJaN$restructure.uint8,
                  kernValue: new $gfJaN$restructure.Array($gfJaN$restructure.int16, "kernValueCount"),
                  leftClass: new $gfJaN$restructure.Array($gfJaN$restructure.uint8, "glyphCount"),
                  rightClass: new $gfJaN$restructure.Array($gfJaN$restructure.uint8, "glyphCount"),
                  kernIndex: new $gfJaN$restructure.Array($gfJaN$restructure.uint8, (t) => t.leftClassCount * t.rightClassCount)
                }
              });
              let $a3f544bcf76542d1$var$KernTable = new $gfJaN$restructure.VersionedStruct("version", {
                0: {
                  subVersion: $gfJaN$restructure.uint16,
                  length: $gfJaN$restructure.uint16,
                  format: $gfJaN$restructure.uint8,
                  coverage: new $gfJaN$restructure.Bitfield($gfJaN$restructure.uint8, [
                    "horizontal",
                    "minimum",
                    "crossStream",
                    "override"
                    // If set to 1 the value in this table replaces the accumulated value
                  ]),
                  subtable: $a3f544bcf76542d1$var$KernSubtable,
                  padding: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint8, (t) => t.length - t._currentOffset)
                },
                1: {
                  length: $gfJaN$restructure.uint32,
                  coverage: new $gfJaN$restructure.Bitfield($gfJaN$restructure.uint8, [
                    null,
                    null,
                    null,
                    null,
                    null,
                    "variation",
                    "crossStream",
                    "vertical"
                    // Set if table has vertical kerning values
                  ]),
                  format: $gfJaN$restructure.uint8,
                  tupleIndex: $gfJaN$restructure.uint16,
                  subtable: $a3f544bcf76542d1$var$KernSubtable,
                  padding: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint8, (t) => t.length - t._currentOffset)
                }
              });
              var $a3f544bcf76542d1$export$2e2bcd8739ae039 = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint16, {
                0: {
                  nTables: $gfJaN$restructure.uint16,
                  tables: new $gfJaN$restructure.Array($a3f544bcf76542d1$var$KernTable, "nTables")
                },
                1: {
                  reserved: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint16),
                  nTables: $gfJaN$restructure.uint32,
                  tables: new $gfJaN$restructure.Array($a3f544bcf76542d1$var$KernTable, "nTables")
                }
              });
              var $86687befb45925d0$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.uint16,
                numGlyphs: $gfJaN$restructure.uint16,
                yPels: new $gfJaN$restructure.Array($gfJaN$restructure.uint8, "numGlyphs")
              });
              var $91429006e51e0fe8$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.uint16,
                fontNumber: $gfJaN$restructure.uint32,
                pitch: $gfJaN$restructure.uint16,
                xHeight: $gfJaN$restructure.uint16,
                style: $gfJaN$restructure.uint16,
                typeFamily: $gfJaN$restructure.uint16,
                capHeight: $gfJaN$restructure.uint16,
                symbolSet: $gfJaN$restructure.uint16,
                typeface: new $gfJaN$restructure.String(16),
                characterComplement: new $gfJaN$restructure.String(8),
                fileName: new $gfJaN$restructure.String(6),
                strokeWeight: new $gfJaN$restructure.String(1),
                widthType: new $gfJaN$restructure.String(1),
                serifStyle: $gfJaN$restructure.uint8,
                reserved: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint8)
              });
              let $627850fc9deed59a$var$Ratio = new $gfJaN$restructure.Struct({
                bCharSet: $gfJaN$restructure.uint8,
                xRatio: $gfJaN$restructure.uint8,
                yStartRatio: $gfJaN$restructure.uint8,
                yEndRatio: $gfJaN$restructure.uint8
                // Ending y-Ratio value
              });
              let $627850fc9deed59a$var$vTable = new $gfJaN$restructure.Struct({
                yPelHeight: $gfJaN$restructure.uint16,
                yMax: $gfJaN$restructure.int16,
                yMin: $gfJaN$restructure.int16
                // Minimum value (in pels) for this yPelHeight
              });
              let $627850fc9deed59a$var$VdmxGroup = new $gfJaN$restructure.Struct({
                recs: $gfJaN$restructure.uint16,
                startsz: $gfJaN$restructure.uint8,
                endsz: $gfJaN$restructure.uint8,
                entries: new $gfJaN$restructure.Array($627850fc9deed59a$var$vTable, "recs")
                // The VDMX records
              });
              var $627850fc9deed59a$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.uint16,
                numRecs: $gfJaN$restructure.uint16,
                numRatios: $gfJaN$restructure.uint16,
                ratioRanges: new $gfJaN$restructure.Array($627850fc9deed59a$var$Ratio, "numRatios"),
                offsets: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, "numRatios"),
                groups: new $gfJaN$restructure.Array($627850fc9deed59a$var$VdmxGroup, "numRecs")
                // The actual VDMX groupings
              });
              var $65c33f5f068fc77f$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.uint16,
                ascent: $gfJaN$restructure.int16,
                descent: $gfJaN$restructure.int16,
                lineGap: $gfJaN$restructure.int16,
                advanceHeightMax: $gfJaN$restructure.int16,
                minTopSideBearing: $gfJaN$restructure.int16,
                minBottomSideBearing: $gfJaN$restructure.int16,
                yMaxExtent: $gfJaN$restructure.int16,
                caretSlopeRise: $gfJaN$restructure.int16,
                caretSlopeRun: $gfJaN$restructure.int16,
                caretOffset: $gfJaN$restructure.int16,
                reserved: new $gfJaN$restructure.Reserved($gfJaN$restructure.int16, 4),
                metricDataFormat: $gfJaN$restructure.int16,
                numberOfMetrics: $gfJaN$restructure.uint16
                // Number of advance heights in the Vertical Metrics table
              });
              let $597d739523b65bb3$var$VmtxEntry = new $gfJaN$restructure.Struct({
                advance: $gfJaN$restructure.uint16,
                bearing: $gfJaN$restructure.int16
                // The top sidebearing of the glyph
              });
              var $597d739523b65bb3$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                metrics: new $gfJaN$restructure.LazyArray($597d739523b65bb3$var$VmtxEntry, (t) => t.parent.vhea.numberOfMetrics),
                bearings: new $gfJaN$restructure.LazyArray($gfJaN$restructure.int16, (t) => t.parent.maxp.numGlyphs - t.parent.vhea.numberOfMetrics)
              });
              let $35aa0c87d9c3d3a0$var$shortFrac = new $gfJaN$restructure.Fixed(16, "BE", 14);
              let $35aa0c87d9c3d3a0$var$Correspondence = new $gfJaN$restructure.Struct({
                fromCoord: $35aa0c87d9c3d3a0$var$shortFrac,
                toCoord: $35aa0c87d9c3d3a0$var$shortFrac
              });
              let $35aa0c87d9c3d3a0$var$Segment = new $gfJaN$restructure.Struct({
                pairCount: $gfJaN$restructure.uint16,
                correspondence: new $gfJaN$restructure.Array($35aa0c87d9c3d3a0$var$Correspondence, "pairCount")
              });
              var $35aa0c87d9c3d3a0$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.fixed32,
                axisCount: $gfJaN$restructure.uint32,
                segment: new $gfJaN$restructure.Array($35aa0c87d9c3d3a0$var$Segment, "axisCount")
              });
              class $22801616bd931ca3$var$UnboundedArrayAccessor {
                getItem(index) {
                  if (this._items[index] == null) {
                    let pos = this.stream.pos;
                    this.stream.pos = this.base + this.type.size(null, this.parent) * index;
                    this._items[index] = this.type.decode(this.stream, this.parent);
                    this.stream.pos = pos;
                  }
                  return this._items[index];
                }
                inspect() {
                  return `[UnboundedArray ${this.type.constructor.name}]`;
                }
                constructor(type, stream, parent) {
                  this.type = type;
                  this.stream = stream;
                  this.parent = parent;
                  this.base = this.stream.pos;
                  this._items = [];
                }
              }
              class $22801616bd931ca3$export$c5af1eebc882e39a extends $gfJaN$restructure.Array {
                decode(stream, parent) {
                  return new $22801616bd931ca3$var$UnboundedArrayAccessor(this.type, stream, parent);
                }
                constructor(type) {
                  super(type, 0);
                }
              }
              let $22801616bd931ca3$export$8351f8c2ae2f103c = function(ValueType = $gfJaN$restructure.uint16) {
                class Shadow {
                  decode(stream, ctx) {
                    ctx = ctx.parent.parent;
                    return this.type.decode(stream, ctx);
                  }
                  size(val, ctx) {
                    ctx = ctx.parent.parent;
                    return this.type.size(val, ctx);
                  }
                  encode(stream, val, ctx) {
                    ctx = ctx.parent.parent;
                    return this.type.encode(stream, val, ctx);
                  }
                  constructor(type) {
                    this.type = type;
                  }
                }
                ValueType = new Shadow(ValueType);
                let BinarySearchHeader = new $gfJaN$restructure.Struct({
                  unitSize: $gfJaN$restructure.uint16,
                  nUnits: $gfJaN$restructure.uint16,
                  searchRange: $gfJaN$restructure.uint16,
                  entrySelector: $gfJaN$restructure.uint16,
                  rangeShift: $gfJaN$restructure.uint16
                });
                let LookupSegmentSingle = new $gfJaN$restructure.Struct({
                  lastGlyph: $gfJaN$restructure.uint16,
                  firstGlyph: $gfJaN$restructure.uint16,
                  value: ValueType
                });
                let LookupSegmentArray = new $gfJaN$restructure.Struct({
                  lastGlyph: $gfJaN$restructure.uint16,
                  firstGlyph: $gfJaN$restructure.uint16,
                  values: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, new $gfJaN$restructure.Array(ValueType, (t) => t.lastGlyph - t.firstGlyph + 1), {
                    type: "parent"
                  })
                });
                let LookupSingle = new $gfJaN$restructure.Struct({
                  glyph: $gfJaN$restructure.uint16,
                  value: ValueType
                });
                return new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint16, {
                  0: {
                    values: new $22801616bd931ca3$export$c5af1eebc882e39a(ValueType)
                    // length == number of glyphs maybe?
                  },
                  2: {
                    binarySearchHeader: BinarySearchHeader,
                    segments: new $gfJaN$restructure.Array(LookupSegmentSingle, (t) => t.binarySearchHeader.nUnits)
                  },
                  4: {
                    binarySearchHeader: BinarySearchHeader,
                    segments: new $gfJaN$restructure.Array(LookupSegmentArray, (t) => t.binarySearchHeader.nUnits)
                  },
                  6: {
                    binarySearchHeader: BinarySearchHeader,
                    segments: new $gfJaN$restructure.Array(LookupSingle, (t) => t.binarySearchHeader.nUnits)
                  },
                  8: {
                    firstGlyph: $gfJaN$restructure.uint16,
                    count: $gfJaN$restructure.uint16,
                    values: new $gfJaN$restructure.Array(ValueType, "count")
                  }
                });
              };
              function $22801616bd931ca3$export$79f7d93d790934ba(entryData = {}, lookupType = $gfJaN$restructure.uint16) {
                let entry = Object.assign({
                  newState: $gfJaN$restructure.uint16,
                  flags: $gfJaN$restructure.uint16
                }, entryData);
                let Entry = new $gfJaN$restructure.Struct(entry);
                let StateArray = new $22801616bd931ca3$export$c5af1eebc882e39a(new $gfJaN$restructure.Array($gfJaN$restructure.uint16, (t) => t.nClasses));
                let StateHeader = new $gfJaN$restructure.Struct({
                  nClasses: $gfJaN$restructure.uint32,
                  classTable: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, new $22801616bd931ca3$export$8351f8c2ae2f103c(lookupType)),
                  stateArray: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, StateArray),
                  entryTable: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, new $22801616bd931ca3$export$c5af1eebc882e39a(Entry))
                });
                return StateHeader;
              }
              function $22801616bd931ca3$export$105027425199cc51(entryData = {}, lookupType = $gfJaN$restructure.uint16) {
                let ClassLookupTable = new $gfJaN$restructure.Struct({
                  version() {
                    return 8;
                  },
                  firstGlyph: $gfJaN$restructure.uint16,
                  values: new $gfJaN$restructure.Array($gfJaN$restructure.uint8, $gfJaN$restructure.uint16)
                });
                let entry = Object.assign({
                  newStateOffset: $gfJaN$restructure.uint16,
                  // convert offset to stateArray index
                  newState: (t) => (t.newStateOffset - (t.parent.stateArray.base - t.parent._startOffset)) / t.parent.nClasses,
                  flags: $gfJaN$restructure.uint16
                }, entryData);
                let Entry = new $gfJaN$restructure.Struct(entry);
                let StateArray = new $22801616bd931ca3$export$c5af1eebc882e39a(new $gfJaN$restructure.Array($gfJaN$restructure.uint8, (t) => t.nClasses));
                let StateHeader1 = new $gfJaN$restructure.Struct({
                  nClasses: $gfJaN$restructure.uint16,
                  classTable: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, ClassLookupTable),
                  stateArray: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, StateArray),
                  entryTable: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, new $22801616bd931ca3$export$c5af1eebc882e39a(Entry))
                });
                return StateHeader1;
              }
              let $3a5ca96d3e3aaf20$var$BslnSubtable = new $gfJaN$restructure.VersionedStruct("format", {
                0: {
                  deltas: new $gfJaN$restructure.Array($gfJaN$restructure.int16, 32)
                },
                1: {
                  deltas: new $gfJaN$restructure.Array($gfJaN$restructure.int16, 32),
                  mappingData: new (0, $22801616bd931ca3$export$8351f8c2ae2f103c)($gfJaN$restructure.uint16)
                },
                2: {
                  standardGlyph: $gfJaN$restructure.uint16,
                  controlPoints: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, 32)
                },
                3: {
                  standardGlyph: $gfJaN$restructure.uint16,
                  controlPoints: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, 32),
                  mappingData: new (0, $22801616bd931ca3$export$8351f8c2ae2f103c)($gfJaN$restructure.uint16)
                }
              });
              var $3a5ca96d3e3aaf20$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.fixed32,
                format: $gfJaN$restructure.uint16,
                defaultBaseline: $gfJaN$restructure.uint16,
                subtable: $3a5ca96d3e3aaf20$var$BslnSubtable
              });
              let $8d4241d96b2b0589$var$Setting = new $gfJaN$restructure.Struct({
                setting: $gfJaN$restructure.uint16,
                nameIndex: $gfJaN$restructure.int16,
                name: (t) => t.parent.parent.parent.name.records.fontFeatures[t.nameIndex]
              });
              let $8d4241d96b2b0589$var$FeatureName = new $gfJaN$restructure.Struct({
                feature: $gfJaN$restructure.uint16,
                nSettings: $gfJaN$restructure.uint16,
                settingTable: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, new $gfJaN$restructure.Array($8d4241d96b2b0589$var$Setting, "nSettings"), {
                  type: "parent"
                }),
                featureFlags: new $gfJaN$restructure.Bitfield($gfJaN$restructure.uint8, [
                  null,
                  null,
                  null,
                  null,
                  null,
                  null,
                  "hasDefault",
                  "exclusive"
                ]),
                defaultSetting: $gfJaN$restructure.uint8,
                nameIndex: $gfJaN$restructure.int16,
                name: (t) => t.parent.parent.name.records.fontFeatures[t.nameIndex]
              });
              var $8d4241d96b2b0589$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.fixed32,
                featureNameCount: $gfJaN$restructure.uint16,
                reserved1: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint16),
                reserved2: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint32),
                featureNames: new $gfJaN$restructure.Array($8d4241d96b2b0589$var$FeatureName, "featureNameCount")
              });
              let $a79cd5132b1cf476$var$Axis = new $gfJaN$restructure.Struct({
                axisTag: new $gfJaN$restructure.String(4),
                minValue: $gfJaN$restructure.fixed32,
                defaultValue: $gfJaN$restructure.fixed32,
                maxValue: $gfJaN$restructure.fixed32,
                flags: $gfJaN$restructure.uint16,
                nameID: $gfJaN$restructure.uint16,
                name: (t) => t.parent.parent.name.records.fontFeatures[t.nameID]
              });
              let $a79cd5132b1cf476$var$Instance = new $gfJaN$restructure.Struct({
                nameID: $gfJaN$restructure.uint16,
                name: (t) => t.parent.parent.name.records.fontFeatures[t.nameID],
                flags: $gfJaN$restructure.uint16,
                coord: new $gfJaN$restructure.Array($gfJaN$restructure.fixed32, (t) => t.parent.axisCount),
                postscriptNameID: new $gfJaN$restructure.Optional($gfJaN$restructure.uint16, (t) => t.parent.instanceSize - t._currentOffset > 0)
              });
              var $a79cd5132b1cf476$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.fixed32,
                offsetToData: $gfJaN$restructure.uint16,
                countSizePairs: $gfJaN$restructure.uint16,
                axisCount: $gfJaN$restructure.uint16,
                axisSize: $gfJaN$restructure.uint16,
                instanceCount: $gfJaN$restructure.uint16,
                instanceSize: $gfJaN$restructure.uint16,
                axis: new $gfJaN$restructure.Array($a79cd5132b1cf476$var$Axis, "axisCount"),
                instance: new $gfJaN$restructure.Array($a79cd5132b1cf476$var$Instance, "instanceCount")
              });
              let $3f36f1a5e6989457$var$shortFrac = new $gfJaN$restructure.Fixed(16, "BE", 14);
              class $3f36f1a5e6989457$var$Offset {
                static decode(stream, parent) {
                  return parent.flags ? stream.readUInt32BE() : stream.readUInt16BE() * 2;
                }
              }
              let $3f36f1a5e6989457$var$gvar = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.uint16,
                reserved: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint16),
                axisCount: $gfJaN$restructure.uint16,
                globalCoordCount: $gfJaN$restructure.uint16,
                globalCoords: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, new $gfJaN$restructure.Array(new $gfJaN$restructure.Array($3f36f1a5e6989457$var$shortFrac, "axisCount"), "globalCoordCount")),
                glyphCount: $gfJaN$restructure.uint16,
                flags: $gfJaN$restructure.uint16,
                offsetToData: $gfJaN$restructure.uint32,
                offsets: new $gfJaN$restructure.Array(new $gfJaN$restructure.Pointer($3f36f1a5e6989457$var$Offset, "void", {
                  relativeTo: (ctx) => ctx.offsetToData,
                  allowNull: false
                }), (t) => t.glyphCount + 1)
              });
              var $3f36f1a5e6989457$export$2e2bcd8739ae039 = $3f36f1a5e6989457$var$gvar;
              let $0bd8fe7a6d1d9fb4$var$ClassTable = new $gfJaN$restructure.Struct({
                length: $gfJaN$restructure.uint16,
                coverage: $gfJaN$restructure.uint16,
                subFeatureFlags: $gfJaN$restructure.uint32,
                stateTable: new (0, $22801616bd931ca3$export$105027425199cc51)()
              });
              let $0bd8fe7a6d1d9fb4$var$WidthDeltaRecord = new $gfJaN$restructure.Struct({
                justClass: $gfJaN$restructure.uint32,
                beforeGrowLimit: $gfJaN$restructure.fixed32,
                beforeShrinkLimit: $gfJaN$restructure.fixed32,
                afterGrowLimit: $gfJaN$restructure.fixed32,
                afterShrinkLimit: $gfJaN$restructure.fixed32,
                growFlags: $gfJaN$restructure.uint16,
                shrinkFlags: $gfJaN$restructure.uint16
              });
              let $0bd8fe7a6d1d9fb4$var$WidthDeltaCluster = new $gfJaN$restructure.Array($0bd8fe7a6d1d9fb4$var$WidthDeltaRecord, $gfJaN$restructure.uint32);
              let $0bd8fe7a6d1d9fb4$var$ActionData = new $gfJaN$restructure.VersionedStruct("actionType", {
                0: {
                  lowerLimit: $gfJaN$restructure.fixed32,
                  upperLimit: $gfJaN$restructure.fixed32,
                  order: $gfJaN$restructure.uint16,
                  glyphs: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, $gfJaN$restructure.uint16)
                },
                1: {
                  addGlyph: $gfJaN$restructure.uint16
                },
                2: {
                  substThreshold: $gfJaN$restructure.fixed32,
                  addGlyph: $gfJaN$restructure.uint16,
                  substGlyph: $gfJaN$restructure.uint16
                },
                3: {},
                4: {
                  variationAxis: $gfJaN$restructure.uint32,
                  minimumLimit: $gfJaN$restructure.fixed32,
                  noStretchValue: $gfJaN$restructure.fixed32,
                  maximumLimit: $gfJaN$restructure.fixed32
                },
                5: {
                  flags: $gfJaN$restructure.uint16,
                  glyph: $gfJaN$restructure.uint16
                }
              });
              let $0bd8fe7a6d1d9fb4$var$Action = new $gfJaN$restructure.Struct({
                actionClass: $gfJaN$restructure.uint16,
                actionType: $gfJaN$restructure.uint16,
                actionLength: $gfJaN$restructure.uint32,
                actionData: $0bd8fe7a6d1d9fb4$var$ActionData,
                padding: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint8, (t) => t.actionLength - t._currentOffset)
              });
              let $0bd8fe7a6d1d9fb4$var$PostcompensationAction = new $gfJaN$restructure.Array($0bd8fe7a6d1d9fb4$var$Action, $gfJaN$restructure.uint32);
              let $0bd8fe7a6d1d9fb4$var$PostCompensationTable = new $gfJaN$restructure.Struct({
                lookupTable: new (0, $22801616bd931ca3$export$8351f8c2ae2f103c)(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $0bd8fe7a6d1d9fb4$var$PostcompensationAction))
              });
              let $0bd8fe7a6d1d9fb4$var$JustificationTable = new $gfJaN$restructure.Struct({
                classTable: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $0bd8fe7a6d1d9fb4$var$ClassTable, {
                  type: "parent"
                }),
                wdcOffset: $gfJaN$restructure.uint16,
                postCompensationTable: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $0bd8fe7a6d1d9fb4$var$PostCompensationTable, {
                  type: "parent"
                }),
                widthDeltaClusters: new (0, $22801616bd931ca3$export$8351f8c2ae2f103c)(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $0bd8fe7a6d1d9fb4$var$WidthDeltaCluster, {
                  type: "parent",
                  relativeTo: (ctx) => ctx.wdcOffset
                }))
              });
              var $0bd8fe7a6d1d9fb4$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.uint32,
                format: $gfJaN$restructure.uint16,
                horizontal: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $0bd8fe7a6d1d9fb4$var$JustificationTable),
                vertical: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $0bd8fe7a6d1d9fb4$var$JustificationTable)
              });
              let $ef40c6dc80fd50a2$var$LigatureData = {
                action: $gfJaN$restructure.uint16
              };
              let $ef40c6dc80fd50a2$var$ContextualData = {
                markIndex: $gfJaN$restructure.uint16,
                currentIndex: $gfJaN$restructure.uint16
              };
              let $ef40c6dc80fd50a2$var$InsertionData = {
                currentInsertIndex: $gfJaN$restructure.uint16,
                markedInsertIndex: $gfJaN$restructure.uint16
              };
              let $ef40c6dc80fd50a2$var$SubstitutionTable = new $gfJaN$restructure.Struct({
                items: new (0, $22801616bd931ca3$export$c5af1eebc882e39a)(new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, new (0, $22801616bd931ca3$export$8351f8c2ae2f103c)()))
              });
              let $ef40c6dc80fd50a2$var$SubtableData = new $gfJaN$restructure.VersionedStruct("type", {
                0: {
                  stateTable: new (0, $22801616bd931ca3$export$79f7d93d790934ba)()
                },
                1: {
                  stateTable: new (0, $22801616bd931ca3$export$79f7d93d790934ba)($ef40c6dc80fd50a2$var$ContextualData),
                  substitutionTable: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, $ef40c6dc80fd50a2$var$SubstitutionTable)
                },
                2: {
                  stateTable: new (0, $22801616bd931ca3$export$79f7d93d790934ba)($ef40c6dc80fd50a2$var$LigatureData),
                  ligatureActions: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, new (0, $22801616bd931ca3$export$c5af1eebc882e39a)($gfJaN$restructure.uint32)),
                  components: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, new (0, $22801616bd931ca3$export$c5af1eebc882e39a)($gfJaN$restructure.uint16)),
                  ligatureList: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, new (0, $22801616bd931ca3$export$c5af1eebc882e39a)($gfJaN$restructure.uint16))
                },
                4: {
                  lookupTable: new (0, $22801616bd931ca3$export$8351f8c2ae2f103c)()
                },
                5: {
                  stateTable: new (0, $22801616bd931ca3$export$79f7d93d790934ba)($ef40c6dc80fd50a2$var$InsertionData),
                  insertionActions: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, new (0, $22801616bd931ca3$export$c5af1eebc882e39a)($gfJaN$restructure.uint16))
                }
              });
              let $ef40c6dc80fd50a2$var$Subtable = new $gfJaN$restructure.Struct({
                length: $gfJaN$restructure.uint32,
                coverage: $gfJaN$restructure.uint24,
                type: $gfJaN$restructure.uint8,
                subFeatureFlags: $gfJaN$restructure.uint32,
                table: $ef40c6dc80fd50a2$var$SubtableData,
                padding: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint8, (t) => t.length - t._currentOffset)
              });
              let $ef40c6dc80fd50a2$var$FeatureEntry = new $gfJaN$restructure.Struct({
                featureType: $gfJaN$restructure.uint16,
                featureSetting: $gfJaN$restructure.uint16,
                enableFlags: $gfJaN$restructure.uint32,
                disableFlags: $gfJaN$restructure.uint32
              });
              let $ef40c6dc80fd50a2$var$MorxChain = new $gfJaN$restructure.Struct({
                defaultFlags: $gfJaN$restructure.uint32,
                chainLength: $gfJaN$restructure.uint32,
                nFeatureEntries: $gfJaN$restructure.uint32,
                nSubtables: $gfJaN$restructure.uint32,
                features: new $gfJaN$restructure.Array($ef40c6dc80fd50a2$var$FeatureEntry, "nFeatureEntries"),
                subtables: new $gfJaN$restructure.Array($ef40c6dc80fd50a2$var$Subtable, "nSubtables")
              });
              var $ef40c6dc80fd50a2$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.uint16,
                unused: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint16),
                nChains: $gfJaN$restructure.uint32,
                chains: new $gfJaN$restructure.Array($ef40c6dc80fd50a2$var$MorxChain, "nChains")
              });
              let $ab24dea08b58a7cc$var$OpticalBounds = new $gfJaN$restructure.Struct({
                left: $gfJaN$restructure.int16,
                top: $gfJaN$restructure.int16,
                right: $gfJaN$restructure.int16,
                bottom: $gfJaN$restructure.int16
              });
              var $ab24dea08b58a7cc$export$2e2bcd8739ae039 = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.fixed32,
                format: $gfJaN$restructure.uint16,
                lookupTable: new (0, $22801616bd931ca3$export$8351f8c2ae2f103c)($ab24dea08b58a7cc$var$OpticalBounds)
              });
              let $5825c04ce8f7102d$var$tables = {};
              var $5825c04ce8f7102d$export$2e2bcd8739ae039 = $5825c04ce8f7102d$var$tables;
              $5825c04ce8f7102d$var$tables.cmap = (0, $e4ae0436c91af89f$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.head = (0, $55a60976afb7c261$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.hhea = (0, $dde72b7b5b650596$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.hmtx = (0, $a7c40184072c9a5b$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.maxp = (0, $521197722369f691$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.name = (0, $51a9f4feb3a3b2b1$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables["OS/2"] = (0, $114ea85db469b435$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.post = (0, $f93b30299e1ea0f5$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.fpgm = (0, $873d79fea57d3161$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.loca = (0, $83c4155666d50c37$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.prep = (0, $b12598db7cdf7042$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables["cvt "] = (0, $8fb09b0f473d61a0$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.glyf = (0, $7707bdf21a3d89cc$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables["CFF "] = (0, $f717432b360040c7$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables["CFF2"] = (0, $f717432b360040c7$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.VORG = (0, $8cb7ae73ed7aa7d8$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.EBLC = (0, $035bb95c0cdb1f6d$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.CBLC = $5825c04ce8f7102d$var$tables.EBLC;
              $5825c04ce8f7102d$var$tables.sbix = (0, $73d13900b55a3c0c$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.COLR = (0, $97f6b8be3a347a8f$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.CPAL = (0, $16ca60ecbdee30ea$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.BASE = (0, $7327e41706f9d5c7$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.GDEF = (0, $7e48bbe9e5345664$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.GPOS = (0, $b687332511a4da75$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.GSUB = (0, $99ccad60b96f92fb$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.JSTF = (0, $573d5042c76c4940$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.HVAR = (0, $a5875b80d6087f61$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.DSIG = (0, $4423bc1ac09bbbd1$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.gasp = (0, $7b50e3f8d83263de$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.hdmx = (0, $7bf92ec372cd2307$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.kern = (0, $a3f544bcf76542d1$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.LTSH = (0, $86687befb45925d0$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.PCLT = (0, $91429006e51e0fe8$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.VDMX = (0, $627850fc9deed59a$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.vhea = (0, $65c33f5f068fc77f$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.vmtx = (0, $597d739523b65bb3$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.avar = (0, $35aa0c87d9c3d3a0$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.bsln = (0, $3a5ca96d3e3aaf20$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.feat = (0, $8d4241d96b2b0589$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.fvar = (0, $a79cd5132b1cf476$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.gvar = (0, $3f36f1a5e6989457$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.just = (0, $0bd8fe7a6d1d9fb4$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.morx = (0, $ef40c6dc80fd50a2$export$2e2bcd8739ae039);
              $5825c04ce8f7102d$var$tables.opbd = (0, $ab24dea08b58a7cc$export$2e2bcd8739ae039);
              let $df50e1efe10a1247$var$TableEntry = new $gfJaN$restructure.Struct({
                tag: new $gfJaN$restructure.String(4),
                checkSum: $gfJaN$restructure.uint32,
                offset: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, "void", {
                  type: "global"
                }),
                length: $gfJaN$restructure.uint32
              });
              let $df50e1efe10a1247$var$Directory = new $gfJaN$restructure.Struct({
                tag: new $gfJaN$restructure.String(4),
                numTables: $gfJaN$restructure.uint16,
                searchRange: $gfJaN$restructure.uint16,
                entrySelector: $gfJaN$restructure.uint16,
                rangeShift: $gfJaN$restructure.uint16,
                tables: new $gfJaN$restructure.Array($df50e1efe10a1247$var$TableEntry, "numTables")
              });
              $df50e1efe10a1247$var$Directory.process = function() {
                let tables = {};
                for (let table of this.tables) tables[table.tag] = table;
                this.tables = tables;
              };
              $df50e1efe10a1247$var$Directory.preEncode = function() {
                if (!Array.isArray(this.tables)) {
                  let tables = [];
                  for (let tag in this.tables) {
                    let table = this.tables[tag];
                    if (table) tables.push({
                      tag,
                      checkSum: 0,
                      offset: new $gfJaN$restructure.VoidPointer((0, $5825c04ce8f7102d$export$2e2bcd8739ae039)[tag], table),
                      length: (0, $5825c04ce8f7102d$export$2e2bcd8739ae039)[tag].size(table)
                    });
                  }
                  this.tables = tables;
                }
                this.tag = "true";
                this.numTables = this.tables.length;
                let maxExponentFor2 = Math.floor(Math.log(this.numTables) / Math.LN2);
                let maxPowerOf2 = Math.pow(2, maxExponentFor2);
                this.searchRange = maxPowerOf2 * 16;
                this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;
                this.rangeShift = this.numTables * 16 - this.searchRange;
              };
              var $df50e1efe10a1247$export$2e2bcd8739ae039 = $df50e1efe10a1247$var$Directory;
              function $66a5b9fb5318558a$export$2e0ae67339d5f1ac(arr, cmp) {
                let min = 0;
                let max = arr.length - 1;
                while (min <= max) {
                  let mid = min + max >> 1;
                  let res = cmp(arr[mid]);
                  if (res < 0) max = mid - 1;
                  else if (res > 0) min = mid + 1;
                  else return mid;
                }
                return -1;
              }
              function $66a5b9fb5318558a$export$d02631cccf789723(index, end) {
                let range = [];
                while (index < end) range.push(index++);
                return range;
              }
              const $66a5b9fb5318558a$export$3d28c1996ced1f14 = new TextDecoder("ascii");
              const $66a5b9fb5318558a$var$CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
              const $66a5b9fb5318558a$var$LOOKUP = new Uint8Array(256);
              for (let i = 0; i < $66a5b9fb5318558a$var$CHARS.length; i++) $66a5b9fb5318558a$var$LOOKUP[$66a5b9fb5318558a$var$CHARS.charCodeAt(i)] = i;
              function $66a5b9fb5318558a$export$94fdf11bafc8de6b(base64) {
                let bufferLength = base64.length * 0.75;
                if (base64[base64.length - 1] === "=") {
                  bufferLength--;
                  if (base64[base64.length - 2] === "=") bufferLength--;
                }
                let bytes = new Uint8Array(bufferLength);
                let p = 0;
                for (let i = 0, len = base64.length; i < len; i += 4) {
                  let encoded1 = $66a5b9fb5318558a$var$LOOKUP[base64.charCodeAt(i)];
                  let encoded2 = $66a5b9fb5318558a$var$LOOKUP[base64.charCodeAt(i + 1)];
                  let encoded3 = $66a5b9fb5318558a$var$LOOKUP[base64.charCodeAt(i + 2)];
                  let encoded4 = $66a5b9fb5318558a$var$LOOKUP[base64.charCodeAt(i + 3)];
                  bytes[p++] = encoded1 << 2 | encoded2 >> 4;
                  bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
                  bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
                }
                return bytes;
              }
              class $0d6e160064c86e50$export$2e2bcd8739ae039 {
                findSubtable(cmapTable, pairs) {
                  for (let [platformID, encodingID] of pairs) for (let cmap of cmapTable.tables) {
                    if (cmap.platformID === platformID && cmap.encodingID === encodingID) return cmap.table;
                  }
                  return null;
                }
                lookup(codepoint, variationSelector) {
                  if (this.encoding) codepoint = this.encoding.get(codepoint) || codepoint;
                  else if (variationSelector) {
                    let gid = this.getVariationSelector(codepoint, variationSelector);
                    if (gid) return gid;
                  }
                  let cmap = this.cmap;
                  switch (cmap.version) {
                    case 0:
                      return cmap.codeMap.get(codepoint) || 0;
                    case 4: {
                      let min = 0;
                      let max = cmap.segCount - 1;
                      while (min <= max) {
                        let mid = min + max >> 1;
                        if (codepoint < cmap.startCode.get(mid)) max = mid - 1;
                        else if (codepoint > cmap.endCode.get(mid)) min = mid + 1;
                        else {
                          let rangeOffset = cmap.idRangeOffset.get(mid);
                          let gid;
                          if (rangeOffset === 0) gid = codepoint + cmap.idDelta.get(mid);
                          else {
                            let index = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);
                            gid = cmap.glyphIndexArray.get(index) || 0;
                            if (gid !== 0) gid += cmap.idDelta.get(mid);
                          }
                          return gid & 65535;
                        }
                      }
                      return 0;
                    }
                    case 8:
                      throw new Error("TODO: cmap format 8");
                    case 6:
                    case 10:
                      return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;
                    case 12:
                    case 13: {
                      let min = 0;
                      let max = cmap.nGroups - 1;
                      while (min <= max) {
                        let mid = min + max >> 1;
                        let group = cmap.groups.get(mid);
                        if (codepoint < group.startCharCode) max = mid - 1;
                        else if (codepoint > group.endCharCode) min = mid + 1;
                        else {
                          if (cmap.version === 12) return group.glyphID + (codepoint - group.startCharCode);
                          else return group.glyphID;
                        }
                      }
                      return 0;
                    }
                    case 14:
                      throw new Error("TODO: cmap format 14");
                    default:
                      throw new Error(`Unknown cmap format ${cmap.version}`);
                  }
                }
                getVariationSelector(codepoint, variationSelector) {
                  if (!this.uvs) return 0;
                  let selectors = this.uvs.varSelectors.toArray();
                  let i = (0, $66a5b9fb5318558a$export$2e0ae67339d5f1ac)(selectors, (x) => variationSelector - x.varSelector);
                  let sel = selectors[i];
                  if (i !== -1 && sel.defaultUVS) i = (0, $66a5b9fb5318558a$export$2e0ae67339d5f1ac)(sel.defaultUVS, (x) => codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? 1 : 0);
                  if (i !== -1 && sel.nonDefaultUVS) {
                    i = (0, $66a5b9fb5318558a$export$2e0ae67339d5f1ac)(sel.nonDefaultUVS, (x) => codepoint - x.unicodeValue);
                    if (i !== -1) return sel.nonDefaultUVS[i].glyphID;
                  }
                  return 0;
                }
                getCharacterSet() {
                  let cmap = this.cmap;
                  switch (cmap.version) {
                    case 0:
                      return (0, $66a5b9fb5318558a$export$d02631cccf789723)(0, cmap.codeMap.length);
                    case 4: {
                      let res = [];
                      let endCodes = cmap.endCode.toArray();
                      for (let i = 0; i < endCodes.length; i++) {
                        let tail = endCodes[i] + 1;
                        let start = cmap.startCode.get(i);
                        res.push(...(0, $66a5b9fb5318558a$export$d02631cccf789723)(start, tail));
                      }
                      return res;
                    }
                    case 8:
                      throw new Error("TODO: cmap format 8");
                    case 6:
                    case 10:
                      return (0, $66a5b9fb5318558a$export$d02631cccf789723)(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);
                    case 12:
                    case 13: {
                      let res = [];
                      for (let group of cmap.groups.toArray()) res.push(...(0, $66a5b9fb5318558a$export$d02631cccf789723)(group.startCharCode, group.endCharCode + 1));
                      return res;
                    }
                    case 14:
                      throw new Error("TODO: cmap format 14");
                    default:
                      throw new Error(`Unknown cmap format ${cmap.version}`);
                  }
                }
                codePointsForGlyph(gid) {
                  let cmap = this.cmap;
                  switch (cmap.version) {
                    case 0: {
                      let res = [];
                      for (let i = 0; i < 256; i++) if (cmap.codeMap.get(i) === gid) res.push(i);
                      return res;
                    }
                    case 4: {
                      let res = [];
                      for (let i = 0; i < cmap.segCount; i++) {
                        let end = cmap.endCode.get(i);
                        let start = cmap.startCode.get(i);
                        let rangeOffset = cmap.idRangeOffset.get(i);
                        let delta = cmap.idDelta.get(i);
                        for (var c = start; c <= end; c++) {
                          let g = 0;
                          if (rangeOffset === 0) g = c + delta;
                          else {
                            let index = rangeOffset / 2 + (c - start) - (cmap.segCount - i);
                            g = cmap.glyphIndexArray.get(index) || 0;
                            if (g !== 0) g += delta;
                          }
                          if (g === gid) res.push(c);
                        }
                      }
                      return res;
                    }
                    case 12: {
                      let res = [];
                      for (let group of cmap.groups.toArray()) if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode)) res.push(group.startCharCode + (gid - group.glyphID));
                      return res;
                    }
                    case 13: {
                      let res = [];
                      for (let group of cmap.groups.toArray()) if (gid === group.glyphID) res.push(...(0, $66a5b9fb5318558a$export$d02631cccf789723)(group.startCharCode, group.endCharCode + 1));
                      return res;
                    }
                    default:
                      throw new Error(`Unknown cmap format ${cmap.version}`);
                  }
                }
                constructor(cmapTable) {
                  this.encoding = null;
                  this.cmap = this.findSubtable(cmapTable, [
                    // 32-bit subtables
                    [
                      3,
                      10
                    ],
                    [
                      0,
                      6
                    ],
                    [
                      0,
                      4
                    ],
                    // 16-bit subtables
                    [
                      3,
                      1
                    ],
                    [
                      0,
                      3
                    ],
                    [
                      0,
                      2
                    ],
                    [
                      0,
                      1
                    ],
                    [
                      0,
                      0
                    ]
                  ]);
                  if (!this.cmap) for (let cmap of cmapTable.tables) {
                    let encoding = (0, $e2613b812f052cbe$export$badc544e0651b6b1)(cmap.platformID, cmap.encodingID, cmap.table.language - 1);
                    let mapping = (0, $e2613b812f052cbe$export$1dceb3c14ed68bee)(encoding);
                    if (mapping) {
                      this.cmap = cmap.table;
                      this.encoding = mapping;
                    }
                  }
                  if (!this.cmap) throw new Error("Could not find a supported cmap table");
                  this.uvs = this.findSubtable(cmapTable, [
                    [
                      0,
                      5
                    ]
                  ]);
                  if (this.uvs && this.uvs.version !== 14) this.uvs = null;
                }
              }
              (0, $gfJaN$swchelperscjs_ts_decoratecjs._)([
                (0, $3bda6911913b43f0$export$69a3209f1a06c04d)
              ], $0d6e160064c86e50$export$2e2bcd8739ae039.prototype, "getCharacterSet", null);
              (0, $gfJaN$swchelperscjs_ts_decoratecjs._)([
                (0, $3bda6911913b43f0$export$69a3209f1a06c04d)
              ], $0d6e160064c86e50$export$2e2bcd8739ae039.prototype, "codePointsForGlyph", null);
              class $4646d52c2a559cdb$export$2e2bcd8739ae039 {
                process(glyphs, positions) {
                  for (let glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {
                    let left = glyphs[glyphIndex].id;
                    let right = glyphs[glyphIndex + 1].id;
                    positions[glyphIndex].xAdvance += this.getKerning(left, right);
                  }
                }
                getKerning(left, right) {
                  let res = 0;
                  for (let table of this.kern.tables) {
                    if (table.coverage.crossStream) continue;
                    switch (table.version) {
                      case 0:
                        if (!table.coverage.horizontal) continue;
                        break;
                      case 1:
                        if (table.coverage.vertical || table.coverage.variation) continue;
                        break;
                      default:
                        throw new Error(`Unsupported kerning table version ${table.version}`);
                    }
                    let val = 0;
                    let s = table.subtable;
                    switch (table.format) {
                      case 0:
                        let pairIdx = (0, $66a5b9fb5318558a$export$2e0ae67339d5f1ac)(s.pairs, function(pair) {
                          return left - pair.left || right - pair.right;
                        });
                        if (pairIdx >= 0) val = s.pairs[pairIdx].value;
                        break;
                      case 2:
                        let leftOffset = 0, rightOffset = 0;
                        if (left >= s.leftTable.firstGlyph && left < s.leftTable.firstGlyph + s.leftTable.nGlyphs) leftOffset = s.leftTable.offsets[left - s.leftTable.firstGlyph];
                        else leftOffset = s.array.off;
                        if (right >= s.rightTable.firstGlyph && right < s.rightTable.firstGlyph + s.rightTable.nGlyphs) rightOffset = s.rightTable.offsets[right - s.rightTable.firstGlyph];
                        let index = (leftOffset + rightOffset - s.array.off) / 2;
                        val = s.array.values.get(index);
                        break;
                      case 3:
                        if (left >= s.glyphCount || right >= s.glyphCount) return 0;
                        val = s.kernValue[s.kernIndex[s.leftClass[left] * s.rightClassCount + s.rightClass[right]]];
                        break;
                      default:
                        throw new Error(`Unsupported kerning sub-table format ${table.format}`);
                    }
                    if (table.coverage.override) res = val;
                    else res += val;
                  }
                  return res;
                }
                constructor(font) {
                  this.kern = font.kern;
                }
              }
              class $a57a26817cd35108$export$2e2bcd8739ae039 {
                positionGlyphs(glyphs, positions) {
                  let clusterStart = 0;
                  let clusterEnd = 0;
                  for (let index = 0; index < glyphs.length; index++) {
                    let glyph = glyphs[index];
                    if (glyph.isMark) clusterEnd = index;
                    else {
                      if (clusterStart !== clusterEnd) this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
                      clusterStart = clusterEnd = index;
                    }
                  }
                  if (clusterStart !== clusterEnd) this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
                  return positions;
                }
                positionCluster(glyphs, positions, clusterStart, clusterEnd) {
                  let base = glyphs[clusterStart];
                  let baseBox = base.cbox.copy();
                  if (base.codePoints.length > 1)
                    baseBox.minX += (base.codePoints.length - 1) * baseBox.width / base.codePoints.length;
                  let xOffset = -positions[clusterStart].xAdvance;
                  let yOffset = 0;
                  let yGap = this.font.unitsPerEm / 16;
                  for (let index = clusterStart + 1; index <= clusterEnd; index++) {
                    let mark = glyphs[index];
                    let markBox = mark.cbox;
                    let position = positions[index];
                    let combiningClass = this.getCombiningClass(mark.codePoints[0]);
                    if (combiningClass !== "Not_Reordered") {
                      position.xOffset = position.yOffset = 0;
                      switch (combiningClass) {
                        case "Double_Above":
                        case "Double_Below":
                          position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;
                          break;
                        case "Attached_Below_Left":
                        case "Below_Left":
                        case "Above_Left":
                          position.xOffset += baseBox.minX - markBox.minX;
                          break;
                        case "Attached_Above_Right":
                        case "Below_Right":
                        case "Above_Right":
                          position.xOffset += baseBox.maxX - markBox.width - markBox.minX;
                          break;
                        default:
                          position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;
                      }
                      switch (combiningClass) {
                        case "Double_Below":
                        case "Below_Left":
                        case "Below":
                        case "Below_Right":
                        case "Attached_Below_Left":
                        case "Attached_Below":
                          if (combiningClass === "Attached_Below_Left" || combiningClass === "Attached_Below") baseBox.minY += yGap;
                          position.yOffset = -baseBox.minY - markBox.maxY;
                          baseBox.minY += markBox.height;
                          break;
                        case "Double_Above":
                        case "Above_Left":
                        case "Above":
                        case "Above_Right":
                        case "Attached_Above":
                        case "Attached_Above_Right":
                          if (combiningClass === "Attached_Above" || combiningClass === "Attached_Above_Right") baseBox.maxY += yGap;
                          position.yOffset = baseBox.maxY - markBox.minY;
                          baseBox.maxY += markBox.height;
                          break;
                      }
                      position.xAdvance = position.yAdvance = 0;
                      position.xOffset += xOffset;
                      position.yOffset += yOffset;
                    } else {
                      xOffset -= position.xAdvance;
                      yOffset -= position.yAdvance;
                    }
                  }
                  return;
                }
                getCombiningClass(codePoint) {
                  let combiningClass = (0, $gfJaN$unicodeproperties.getCombiningClass)(codePoint);
                  if ((codePoint & -256) === 3584) {
                    if (combiningClass === "Not_Reordered") switch (codePoint) {
                      case 3633:
                      case 3636:
                      case 3637:
                      case 3638:
                      case 3639:
                      case 3655:
                      case 3660:
                      case 3645:
                      case 3662:
                        return "Above_Right";
                      case 3761:
                      case 3764:
                      case 3765:
                      case 3766:
                      case 3767:
                      case 3771:
                      case 3788:
                      case 3789:
                        return "Above";
                      case 3772:
                        return "Below";
                    }
                    else if (codePoint === 3642) return "Below_Right";
                  }
                  switch (combiningClass) {
                    case "CCC10":
                    case "CCC11":
                    case "CCC12":
                    case "CCC13":
                    case "CCC14":
                    case "CCC15":
                    case "CCC16":
                    case "CCC17":
                    case "CCC18":
                    case "CCC20":
                    case "CCC22":
                      return "Below";
                    case "CCC23":
                      return "Attached_Above";
                    case "CCC24":
                      return "Above_Right";
                    case "CCC25":
                    case "CCC19":
                      return "Above_Left";
                    case "CCC26":
                      return "Above";
                    case "CCC21":
                      break;
                    case "CCC27":
                    case "CCC28":
                    case "CCC30":
                    case "CCC31":
                    case "CCC33":
                    case "CCC34":
                    case "CCC35":
                    case "CCC36":
                      return "Above";
                    case "CCC29":
                    case "CCC32":
                      return "Below";
                    case "CCC103":
                      return "Below_Right";
                    case "CCC107":
                      return "Above_Right";
                    case "CCC118":
                      return "Below";
                    case "CCC122":
                      return "Above";
                    case "CCC129":
                    case "CCC132":
                      return "Below";
                    case "CCC130":
                      return "Above";
                  }
                  return combiningClass;
                }
                constructor(font) {
                  this.font = font;
                }
              }
              class $0e2da1c4ce69e8ad$export$2e2bcd8739ae039 {
                /**
                * The width of the bounding box
                * @type {number}
                */
                get width() {
                  return this.maxX - this.minX;
                }
                /**
                * The height of the bounding box
                * @type {number}
                */
                get height() {
                  return this.maxY - this.minY;
                }
                addPoint(x, y) {
                  if (Math.abs(x) !== Infinity) {
                    if (x < this.minX) this.minX = x;
                    if (x > this.maxX) this.maxX = x;
                  }
                  if (Math.abs(y) !== Infinity) {
                    if (y < this.minY) this.minY = y;
                    if (y > this.maxY) this.maxY = y;
                  }
                }
                copy() {
                  return new $0e2da1c4ce69e8ad$export$2e2bcd8739ae039(this.minX, this.minY, this.maxX, this.maxY);
                }
                constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
                  this.minX = minX;
                  this.minY = minY;
                  this.maxX = maxX;
                  this.maxY = maxY;
                }
              }
              const $e38a1a895f6aeb54$var$UNICODE_SCRIPTS = {
                Caucasian_Albanian: "aghb",
                Arabic: "arab",
                Imperial_Aramaic: "armi",
                Armenian: "armn",
                Avestan: "avst",
                Balinese: "bali",
                Bamum: "bamu",
                Bassa_Vah: "bass",
                Batak: "batk",
                Bengali: [
                  "bng2",
                  "beng"
                ],
                Bopomofo: "bopo",
                Brahmi: "brah",
                Braille: "brai",
                Buginese: "bugi",
                Buhid: "buhd",
                Chakma: "cakm",
                Canadian_Aboriginal: "cans",
                Carian: "cari",
                Cham: "cham",
                Cherokee: "cher",
                Coptic: "copt",
                Cypriot: "cprt",
                Cyrillic: "cyrl",
                Devanagari: [
                  "dev2",
                  "deva"
                ],
                Deseret: "dsrt",
                Duployan: "dupl",
                Egyptian_Hieroglyphs: "egyp",
                Elbasan: "elba",
                Ethiopic: "ethi",
                Georgian: "geor",
                Glagolitic: "glag",
                Gothic: "goth",
                Grantha: "gran",
                Greek: "grek",
                Gujarati: [
                  "gjr2",
                  "gujr"
                ],
                Gurmukhi: [
                  "gur2",
                  "guru"
                ],
                Hangul: "hang",
                Han: "hani",
                Hanunoo: "hano",
                Hebrew: "hebr",
                Hiragana: "hira",
                Pahawh_Hmong: "hmng",
                Katakana_Or_Hiragana: "hrkt",
                Old_Italic: "ital",
                Javanese: "java",
                Kayah_Li: "kali",
                Katakana: "kana",
                Kharoshthi: "khar",
                Khmer: "khmr",
                Khojki: "khoj",
                Kannada: [
                  "knd2",
                  "knda"
                ],
                Kaithi: "kthi",
                Tai_Tham: "lana",
                Lao: "lao ",
                Latin: "latn",
                Lepcha: "lepc",
                Limbu: "limb",
                Linear_A: "lina",
                Linear_B: "linb",
                Lisu: "lisu",
                Lycian: "lyci",
                Lydian: "lydi",
                Mahajani: "mahj",
                Mandaic: "mand",
                Manichaean: "mani",
                Mende_Kikakui: "mend",
                Meroitic_Cursive: "merc",
                Meroitic_Hieroglyphs: "mero",
                Malayalam: [
                  "mlm2",
                  "mlym"
                ],
                Modi: "modi",
                Mongolian: "mong",
                Mro: "mroo",
                Meetei_Mayek: "mtei",
                Myanmar: [
                  "mym2",
                  "mymr"
                ],
                Old_North_Arabian: "narb",
                Nabataean: "nbat",
                Nko: "nko ",
                Ogham: "ogam",
                Ol_Chiki: "olck",
                Old_Turkic: "orkh",
                Oriya: [
                  "ory2",
                  "orya"
                ],
                Osmanya: "osma",
                Palmyrene: "palm",
                Pau_Cin_Hau: "pauc",
                Old_Permic: "perm",
                Phags_Pa: "phag",
                Inscriptional_Pahlavi: "phli",
                Psalter_Pahlavi: "phlp",
                Phoenician: "phnx",
                Miao: "plrd",
                Inscriptional_Parthian: "prti",
                Rejang: "rjng",
                Runic: "runr",
                Samaritan: "samr",
                Old_South_Arabian: "sarb",
                Saurashtra: "saur",
                Shavian: "shaw",
                Sharada: "shrd",
                Siddham: "sidd",
                Khudawadi: "sind",
                Sinhala: "sinh",
                Sora_Sompeng: "sora",
                Sundanese: "sund",
                Syloti_Nagri: "sylo",
                Syriac: "syrc",
                Tagbanwa: "tagb",
                Takri: "takr",
                Tai_Le: "tale",
                New_Tai_Lue: "talu",
                Tamil: [
                  "tml2",
                  "taml"
                ],
                Tai_Viet: "tavt",
                Telugu: [
                  "tel2",
                  "telu"
                ],
                Tifinagh: "tfng",
                Tagalog: "tglg",
                Thaana: "thaa",
                Thai: "thai",
                Tibetan: "tibt",
                Tirhuta: "tirh",
                Ugaritic: "ugar",
                Vai: "vai ",
                Warang_Citi: "wara",
                Old_Persian: "xpeo",
                Cuneiform: "xsux",
                Yi: "yi  ",
                Inherited: "zinh",
                Common: "zyyy",
                Unknown: "zzzz"
              };
              const $e38a1a895f6aeb54$var$OPENTYPE_SCRIPTS = {};
              for (let script in $e38a1a895f6aeb54$var$UNICODE_SCRIPTS) {
                let tag = $e38a1a895f6aeb54$var$UNICODE_SCRIPTS[script];
                if (Array.isArray(tag)) for (let t of tag) $e38a1a895f6aeb54$var$OPENTYPE_SCRIPTS[t] = script;
                else $e38a1a895f6aeb54$var$OPENTYPE_SCRIPTS[tag] = script;
              }
              function $e38a1a895f6aeb54$export$b32f0b5f69d65e51(script) {
                return $e38a1a895f6aeb54$var$UNICODE_SCRIPTS[script];
              }
              function $e38a1a895f6aeb54$export$ce50e82f12a827a4(tag) {
                return $e38a1a895f6aeb54$var$OPENTYPE_SCRIPTS[tag];
              }
              function $e38a1a895f6aeb54$export$e5cb25e204fb8450(string) {
                let len = string.length;
                let idx = 0;
                while (idx < len) {
                  let code = string.charCodeAt(idx++);
                  if (55296 <= code && code <= 56319 && idx < len) {
                    let next = string.charCodeAt(idx);
                    if (56320 <= next && next <= 57343) {
                      idx++;
                      code = ((code & 1023) << 10) + (next & 1023) + 65536;
                    }
                  }
                  let script = (0, $gfJaN$unicodeproperties.getScript)(code);
                  if (script !== "Common" && script !== "Inherited" && script !== "Unknown") return $e38a1a895f6aeb54$var$UNICODE_SCRIPTS[script];
                }
                return $e38a1a895f6aeb54$var$UNICODE_SCRIPTS.Unknown;
              }
              function $e38a1a895f6aeb54$export$16fab0757cfc223d(codePoints) {
                for (let i = 0; i < codePoints.length; i++) {
                  let codePoint = codePoints[i];
                  let script = (0, $gfJaN$unicodeproperties.getScript)(codePoint);
                  if (script !== "Common" && script !== "Inherited" && script !== "Unknown") return $e38a1a895f6aeb54$var$UNICODE_SCRIPTS[script];
                }
                return $e38a1a895f6aeb54$var$UNICODE_SCRIPTS.Unknown;
              }
              const $e38a1a895f6aeb54$var$RTL = {
                arab: true,
                hebr: true,
                syrc: true,
                thaa: true,
                cprt: true,
                khar: true,
                phnx: true,
                "nko ": true,
                lydi: true,
                avst: true,
                armi: true,
                phli: true,
                prti: true,
                sarb: true,
                orkh: true,
                samr: true,
                mand: true,
                merc: true,
                mero: true,
                // Unicode 7.0 (not listed on http://www.microsoft.com/typography/otspec/scripttags.htm)
                mani: true,
                mend: true,
                nbat: true,
                narb: true,
                palm: true,
                phlp: true
                // Psalter Pahlavi
              };
              function $e38a1a895f6aeb54$export$9fddb9d0dd7d8a54(script) {
                if ($e38a1a895f6aeb54$var$RTL[script]) return "rtl";
                return "ltr";
              }
              class $b19c79ec7a94fa39$export$2e2bcd8739ae039 {
                /**
                * The total advance width of the run.
                * @type {number}
                */
                get advanceWidth() {
                  let width = 0;
                  for (let position of this.positions) width += position.xAdvance;
                  return width;
                }
                /**
                * The total advance height of the run.
                * @type {number}
                */
                get advanceHeight() {
                  let height = 0;
                  for (let position of this.positions) height += position.yAdvance;
                  return height;
                }
                /**
                * The bounding box containing all glyphs in the run.
                * @type {BBox}
                */
                get bbox() {
                  let bbox = new (0, $0e2da1c4ce69e8ad$export$2e2bcd8739ae039)();
                  let x = 0;
                  let y = 0;
                  for (let index = 0; index < this.glyphs.length; index++) {
                    let glyph = this.glyphs[index];
                    let p = this.positions[index];
                    let b = glyph.bbox;
                    bbox.addPoint(b.minX + x + p.xOffset, b.minY + y + p.yOffset);
                    bbox.addPoint(b.maxX + x + p.xOffset, b.maxY + y + p.yOffset);
                    x += p.xAdvance;
                    y += p.yAdvance;
                  }
                  return bbox;
                }
                constructor(glyphs, features, script, language, direction) {
                  this.glyphs = glyphs;
                  this.positions = null;
                  this.script = script;
                  this.language = language || null;
                  this.direction = direction || $e38a1a895f6aeb54$export$9fddb9d0dd7d8a54(script);
                  this.features = {};
                  if (Array.isArray(features)) for (let tag of features) this.features[tag] = true;
                  else if (typeof features === "object") this.features = features;
                }
              }
              class $9195cf1266c12ea5$export$2e2bcd8739ae039 {
                constructor(xAdvance = 0, yAdvance = 0, xOffset = 0, yOffset = 0) {
                  this.xAdvance = xAdvance;
                  this.yAdvance = yAdvance;
                  this.xOffset = xOffset;
                  this.yOffset = yOffset;
                }
              }
              const $2b7f887ebcb5888a$var$features = {
                allTypographicFeatures: {
                  code: 0,
                  exclusive: false,
                  allTypeFeatures: 0
                },
                ligatures: {
                  code: 1,
                  exclusive: false,
                  requiredLigatures: 0,
                  commonLigatures: 2,
                  rareLigatures: 4,
                  // logos: 6
                  rebusPictures: 8,
                  diphthongLigatures: 10,
                  squaredLigatures: 12,
                  abbrevSquaredLigatures: 14,
                  symbolLigatures: 16,
                  contextualLigatures: 18,
                  historicalLigatures: 20
                },
                cursiveConnection: {
                  code: 2,
                  exclusive: true,
                  unconnected: 0,
                  partiallyConnected: 1,
                  cursive: 2
                },
                letterCase: {
                  code: 3,
                  exclusive: true
                },
                // upperAndLowerCase: 0          # deprecated
                // allCaps: 1                    # deprecated
                // allLowerCase: 2               # deprecated
                // smallCaps: 3                  # deprecated
                // initialCaps: 4                # deprecated
                // initialCapsAndSmallCaps: 5    # deprecated
                verticalSubstitution: {
                  code: 4,
                  exclusive: false,
                  substituteVerticalForms: 0
                },
                linguisticRearrangement: {
                  code: 5,
                  exclusive: false,
                  linguisticRearrangement: 0
                },
                numberSpacing: {
                  code: 6,
                  exclusive: true,
                  monospacedNumbers: 0,
                  proportionalNumbers: 1,
                  thirdWidthNumbers: 2,
                  quarterWidthNumbers: 3
                },
                smartSwash: {
                  code: 8,
                  exclusive: false,
                  wordInitialSwashes: 0,
                  wordFinalSwashes: 2,
                  // lineInitialSwashes: 4
                  // lineFinalSwashes: 6
                  nonFinalSwashes: 8
                },
                diacritics: {
                  code: 9,
                  exclusive: true,
                  showDiacritics: 0,
                  hideDiacritics: 1,
                  decomposeDiacritics: 2
                },
                verticalPosition: {
                  code: 10,
                  exclusive: true,
                  normalPosition: 0,
                  superiors: 1,
                  inferiors: 2,
                  ordinals: 3,
                  scientificInferiors: 4
                },
                fractions: {
                  code: 11,
                  exclusive: true,
                  noFractions: 0,
                  verticalFractions: 1,
                  diagonalFractions: 2
                },
                overlappingCharacters: {
                  code: 13,
                  exclusive: false,
                  preventOverlap: 0
                },
                typographicExtras: {
                  code: 14,
                  exclusive: false,
                  // hyphensToEmDash: 0
                  // hyphenToEnDash: 2
                  slashedZero: 4
                },
                // formInterrobang: 6
                // smartQuotes: 8
                // periodsToEllipsis: 10
                mathematicalExtras: {
                  code: 15,
                  exclusive: false,
                  // hyphenToMinus: 0
                  // asteristoMultiply: 2
                  // slashToDivide: 4
                  // inequalityLigatures: 6
                  // exponents: 8
                  mathematicalGreek: 10
                },
                ornamentSets: {
                  code: 16,
                  exclusive: true,
                  noOrnaments: 0,
                  dingbats: 1,
                  piCharacters: 2,
                  fleurons: 3,
                  decorativeBorders: 4,
                  internationalSymbols: 5,
                  mathSymbols: 6
                },
                characterAlternatives: {
                  code: 17,
                  exclusive: true,
                  noAlternates: 0
                },
                // user defined options
                designComplexity: {
                  code: 18,
                  exclusive: true,
                  designLevel1: 0,
                  designLevel2: 1,
                  designLevel3: 2,
                  designLevel4: 3,
                  designLevel5: 4
                },
                styleOptions: {
                  code: 19,
                  exclusive: true,
                  noStyleOptions: 0,
                  displayText: 1,
                  engravedText: 2,
                  illuminatedCaps: 3,
                  titlingCaps: 4,
                  tallCaps: 5
                },
                characterShape: {
                  code: 20,
                  exclusive: true,
                  traditionalCharacters: 0,
                  simplifiedCharacters: 1,
                  JIS1978Characters: 2,
                  JIS1983Characters: 3,
                  JIS1990Characters: 4,
                  traditionalAltOne: 5,
                  traditionalAltTwo: 6,
                  traditionalAltThree: 7,
                  traditionalAltFour: 8,
                  traditionalAltFive: 9,
                  expertCharacters: 10,
                  JIS2004Characters: 11,
                  hojoCharacters: 12,
                  NLCCharacters: 13,
                  traditionalNamesCharacters: 14
                },
                numberCase: {
                  code: 21,
                  exclusive: true,
                  lowerCaseNumbers: 0,
                  upperCaseNumbers: 1
                },
                textSpacing: {
                  code: 22,
                  exclusive: true,
                  proportionalText: 0,
                  monospacedText: 1,
                  halfWidthText: 2,
                  thirdWidthText: 3,
                  quarterWidthText: 4,
                  altProportionalText: 5,
                  altHalfWidthText: 6
                },
                transliteration: {
                  code: 23,
                  exclusive: true,
                  noTransliteration: 0
                },
                // hanjaToHangul: 1
                // hiraganaToKatakana: 2
                // katakanaToHiragana: 3
                // kanaToRomanization: 4
                // romanizationToHiragana: 5
                // romanizationToKatakana: 6
                // hanjaToHangulAltOne: 7
                // hanjaToHangulAltTwo: 8
                // hanjaToHangulAltThree: 9
                annotation: {
                  code: 24,
                  exclusive: true,
                  noAnnotation: 0,
                  boxAnnotation: 1,
                  roundedBoxAnnotation: 2,
                  circleAnnotation: 3,
                  invertedCircleAnnotation: 4,
                  parenthesisAnnotation: 5,
                  periodAnnotation: 6,
                  romanNumeralAnnotation: 7,
                  diamondAnnotation: 8,
                  invertedBoxAnnotation: 9,
                  invertedRoundedBoxAnnotation: 10
                },
                kanaSpacing: {
                  code: 25,
                  exclusive: true,
                  fullWidthKana: 0,
                  proportionalKana: 1
                },
                ideographicSpacing: {
                  code: 26,
                  exclusive: true,
                  fullWidthIdeographs: 0,
                  proportionalIdeographs: 1,
                  halfWidthIdeographs: 2
                },
                unicodeDecomposition: {
                  code: 27,
                  exclusive: false,
                  canonicalComposition: 0,
                  compatibilityComposition: 2,
                  transcodingComposition: 4
                },
                rubyKana: {
                  code: 28,
                  exclusive: false,
                  // noRubyKana: 0     # deprecated - use rubyKanaOff instead
                  // rubyKana: 1     # deprecated - use rubyKanaOn instead
                  rubyKana: 2
                },
                CJKSymbolAlternatives: {
                  code: 29,
                  exclusive: true,
                  noCJKSymbolAlternatives: 0,
                  CJKSymbolAltOne: 1,
                  CJKSymbolAltTwo: 2,
                  CJKSymbolAltThree: 3,
                  CJKSymbolAltFour: 4,
                  CJKSymbolAltFive: 5
                },
                ideographicAlternatives: {
                  code: 30,
                  exclusive: true,
                  noIdeographicAlternatives: 0,
                  ideographicAltOne: 1,
                  ideographicAltTwo: 2,
                  ideographicAltThree: 3,
                  ideographicAltFour: 4,
                  ideographicAltFive: 5
                },
                CJKVerticalRomanPlacement: {
                  code: 31,
                  exclusive: true,
                  CJKVerticalRomanCentered: 0,
                  CJKVerticalRomanHBaseline: 1
                },
                italicCJKRoman: {
                  code: 32,
                  exclusive: false,
                  // noCJKItalicRoman: 0     # deprecated - use CJKItalicRomanOff instead
                  // CJKItalicRoman: 1     # deprecated - use CJKItalicRomanOn instead
                  CJKItalicRoman: 2
                },
                caseSensitiveLayout: {
                  code: 33,
                  exclusive: false,
                  caseSensitiveLayout: 0,
                  caseSensitiveSpacing: 2
                },
                alternateKana: {
                  code: 34,
                  exclusive: false,
                  alternateHorizKana: 0,
                  alternateVertKana: 2
                },
                stylisticAlternatives: {
                  code: 35,
                  exclusive: false,
                  noStylisticAlternates: 0,
                  stylisticAltOne: 2,
                  stylisticAltTwo: 4,
                  stylisticAltThree: 6,
                  stylisticAltFour: 8,
                  stylisticAltFive: 10,
                  stylisticAltSix: 12,
                  stylisticAltSeven: 14,
                  stylisticAltEight: 16,
                  stylisticAltNine: 18,
                  stylisticAltTen: 20,
                  stylisticAltEleven: 22,
                  stylisticAltTwelve: 24,
                  stylisticAltThirteen: 26,
                  stylisticAltFourteen: 28,
                  stylisticAltFifteen: 30,
                  stylisticAltSixteen: 32,
                  stylisticAltSeventeen: 34,
                  stylisticAltEighteen: 36,
                  stylisticAltNineteen: 38,
                  stylisticAltTwenty: 40
                },
                contextualAlternates: {
                  code: 36,
                  exclusive: false,
                  contextualAlternates: 0,
                  swashAlternates: 2,
                  contextualSwashAlternates: 4
                },
                lowerCase: {
                  code: 37,
                  exclusive: true,
                  defaultLowerCase: 0,
                  lowerCaseSmallCaps: 1,
                  lowerCasePetiteCaps: 2
                },
                upperCase: {
                  code: 38,
                  exclusive: true,
                  defaultUpperCase: 0,
                  upperCaseSmallCaps: 1,
                  upperCasePetiteCaps: 2
                },
                languageTag: {
                  code: 39,
                  exclusive: true
                },
                CJKRomanSpacing: {
                  code: 103,
                  exclusive: true,
                  halfWidthCJKRoman: 0,
                  proportionalCJKRoman: 1,
                  defaultCJKRoman: 2,
                  fullWidthCJKRoman: 3
                }
              };
              const $2b7f887ebcb5888a$var$feature = (name, selector) => [
                $2b7f887ebcb5888a$var$features[name].code,
                $2b7f887ebcb5888a$var$features[name][selector]
              ];
              const $2b7f887ebcb5888a$var$OTMapping = {
                rlig: $2b7f887ebcb5888a$var$feature("ligatures", "requiredLigatures"),
                clig: $2b7f887ebcb5888a$var$feature("ligatures", "contextualLigatures"),
                dlig: $2b7f887ebcb5888a$var$feature("ligatures", "rareLigatures"),
                hlig: $2b7f887ebcb5888a$var$feature("ligatures", "historicalLigatures"),
                liga: $2b7f887ebcb5888a$var$feature("ligatures", "commonLigatures"),
                hist: $2b7f887ebcb5888a$var$feature("ligatures", "historicalLigatures"),
                smcp: $2b7f887ebcb5888a$var$feature("lowerCase", "lowerCaseSmallCaps"),
                pcap: $2b7f887ebcb5888a$var$feature("lowerCase", "lowerCasePetiteCaps"),
                frac: $2b7f887ebcb5888a$var$feature("fractions", "diagonalFractions"),
                dnom: $2b7f887ebcb5888a$var$feature("fractions", "diagonalFractions"),
                numr: $2b7f887ebcb5888a$var$feature("fractions", "diagonalFractions"),
                afrc: $2b7f887ebcb5888a$var$feature("fractions", "verticalFractions"),
                // aalt
                // abvf, abvm, abvs, akhn, blwf, blwm, blws, cfar, cjct, cpsp, falt, isol, jalt, ljmo, mset?
                // ltra, ltrm, nukt, pref, pres, pstf, psts, rand, rkrf, rphf, rtla, rtlm, size, tjmo, tnum?
                // unic, vatu, vhal, vjmo, vpal, vrt2
                // dist -> trak table?
                // kern, vkrn -> kern table
                // lfbd + opbd + rtbd -> opbd table?
                // mark, mkmk -> acnt table?
                // locl -> languageTag + ltag table
                case: $2b7f887ebcb5888a$var$feature("caseSensitiveLayout", "caseSensitiveLayout"),
                ccmp: $2b7f887ebcb5888a$var$feature("unicodeDecomposition", "canonicalComposition"),
                cpct: $2b7f887ebcb5888a$var$feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
                valt: $2b7f887ebcb5888a$var$feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
                swsh: $2b7f887ebcb5888a$var$feature("contextualAlternates", "swashAlternates"),
                cswh: $2b7f887ebcb5888a$var$feature("contextualAlternates", "contextualSwashAlternates"),
                curs: $2b7f887ebcb5888a$var$feature("cursiveConnection", "cursive"),
                c2pc: $2b7f887ebcb5888a$var$feature("upperCase", "upperCasePetiteCaps"),
                c2sc: $2b7f887ebcb5888a$var$feature("upperCase", "upperCaseSmallCaps"),
                init: $2b7f887ebcb5888a$var$feature("smartSwash", "wordInitialSwashes"),
                fin2: $2b7f887ebcb5888a$var$feature("smartSwash", "wordFinalSwashes"),
                medi: $2b7f887ebcb5888a$var$feature("smartSwash", "nonFinalSwashes"),
                med2: $2b7f887ebcb5888a$var$feature("smartSwash", "nonFinalSwashes"),
                fin3: $2b7f887ebcb5888a$var$feature("smartSwash", "wordFinalSwashes"),
                fina: $2b7f887ebcb5888a$var$feature("smartSwash", "wordFinalSwashes"),
                pkna: $2b7f887ebcb5888a$var$feature("kanaSpacing", "proportionalKana"),
                half: $2b7f887ebcb5888a$var$feature("textSpacing", "halfWidthText"),
                halt: $2b7f887ebcb5888a$var$feature("textSpacing", "altHalfWidthText"),
                hkna: $2b7f887ebcb5888a$var$feature("alternateKana", "alternateHorizKana"),
                vkna: $2b7f887ebcb5888a$var$feature("alternateKana", "alternateVertKana"),
                // hngl: feature 'transliteration', 'hanjaToHangulSelector' # deprecated
                ital: $2b7f887ebcb5888a$var$feature("italicCJKRoman", "CJKItalicRoman"),
                lnum: $2b7f887ebcb5888a$var$feature("numberCase", "upperCaseNumbers"),
                onum: $2b7f887ebcb5888a$var$feature("numberCase", "lowerCaseNumbers"),
                mgrk: $2b7f887ebcb5888a$var$feature("mathematicalExtras", "mathematicalGreek"),
                // nalt: not enough info. what type of annotation?
                // ornm: ditto, which ornament style?
                calt: $2b7f887ebcb5888a$var$feature("contextualAlternates", "contextualAlternates"),
                vrt2: $2b7f887ebcb5888a$var$feature("verticalSubstitution", "substituteVerticalForms"),
                vert: $2b7f887ebcb5888a$var$feature("verticalSubstitution", "substituteVerticalForms"),
                tnum: $2b7f887ebcb5888a$var$feature("numberSpacing", "monospacedNumbers"),
                pnum: $2b7f887ebcb5888a$var$feature("numberSpacing", "proportionalNumbers"),
                sups: $2b7f887ebcb5888a$var$feature("verticalPosition", "superiors"),
                subs: $2b7f887ebcb5888a$var$feature("verticalPosition", "inferiors"),
                ordn: $2b7f887ebcb5888a$var$feature("verticalPosition", "ordinals"),
                pwid: $2b7f887ebcb5888a$var$feature("textSpacing", "proportionalText"),
                hwid: $2b7f887ebcb5888a$var$feature("textSpacing", "halfWidthText"),
                qwid: $2b7f887ebcb5888a$var$feature("textSpacing", "quarterWidthText"),
                twid: $2b7f887ebcb5888a$var$feature("textSpacing", "thirdWidthText"),
                fwid: $2b7f887ebcb5888a$var$feature("textSpacing", "proportionalText"),
                palt: $2b7f887ebcb5888a$var$feature("textSpacing", "altProportionalText"),
                trad: $2b7f887ebcb5888a$var$feature("characterShape", "traditionalCharacters"),
                smpl: $2b7f887ebcb5888a$var$feature("characterShape", "simplifiedCharacters"),
                jp78: $2b7f887ebcb5888a$var$feature("characterShape", "JIS1978Characters"),
                jp83: $2b7f887ebcb5888a$var$feature("characterShape", "JIS1983Characters"),
                jp90: $2b7f887ebcb5888a$var$feature("characterShape", "JIS1990Characters"),
                jp04: $2b7f887ebcb5888a$var$feature("characterShape", "JIS2004Characters"),
                expt: $2b7f887ebcb5888a$var$feature("characterShape", "expertCharacters"),
                hojo: $2b7f887ebcb5888a$var$feature("characterShape", "hojoCharacters"),
                nlck: $2b7f887ebcb5888a$var$feature("characterShape", "NLCCharacters"),
                tnam: $2b7f887ebcb5888a$var$feature("characterShape", "traditionalNamesCharacters"),
                ruby: $2b7f887ebcb5888a$var$feature("rubyKana", "rubyKana"),
                titl: $2b7f887ebcb5888a$var$feature("styleOptions", "titlingCaps"),
                zero: $2b7f887ebcb5888a$var$feature("typographicExtras", "slashedZero"),
                ss01: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltOne"),
                ss02: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltTwo"),
                ss03: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltThree"),
                ss04: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltFour"),
                ss05: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltFive"),
                ss06: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltSix"),
                ss07: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltSeven"),
                ss08: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltEight"),
                ss09: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltNine"),
                ss10: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltTen"),
                ss11: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltEleven"),
                ss12: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltTwelve"),
                ss13: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltThirteen"),
                ss14: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltFourteen"),
                ss15: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltFifteen"),
                ss16: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltSixteen"),
                ss17: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltSeventeen"),
                ss18: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltEighteen"),
                ss19: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltNineteen"),
                ss20: $2b7f887ebcb5888a$var$feature("stylisticAlternatives", "stylisticAltTwenty")
              };
              for (let i = 1; i <= 99; i++) $2b7f887ebcb5888a$var$OTMapping[`cv${`00${i}`.slice(-2)}`] = [
                $2b7f887ebcb5888a$var$features.characterAlternatives.code,
                i
              ];
              let $2b7f887ebcb5888a$var$AATMapping = {};
              for (let ot in $2b7f887ebcb5888a$var$OTMapping) {
                let aat = $2b7f887ebcb5888a$var$OTMapping[ot];
                if ($2b7f887ebcb5888a$var$AATMapping[aat[0]] == null) $2b7f887ebcb5888a$var$AATMapping[aat[0]] = {};
                $2b7f887ebcb5888a$var$AATMapping[aat[0]][aat[1]] = ot;
              }
              function $2b7f887ebcb5888a$export$b813f7d2a1677c16(features) {
                let res = {};
                for (let k in features) {
                  let r;
                  if (r = $2b7f887ebcb5888a$var$OTMapping[k]) {
                    if (res[r[0]] == null) res[r[0]] = {};
                    res[r[0]][r[1]] = features[k];
                  }
                }
                return res;
              }
              function $2b7f887ebcb5888a$var$mapFeatureStrings(f) {
                let [type, setting] = f;
                if (isNaN(type)) var typeCode = $2b7f887ebcb5888a$var$features[type] && $2b7f887ebcb5888a$var$features[type].code;
                else var typeCode = type;
                if (isNaN(setting)) var settingCode = $2b7f887ebcb5888a$var$features[type] && $2b7f887ebcb5888a$var$features[type][setting];
                else var settingCode = setting;
                return [
                  typeCode,
                  settingCode
                ];
              }
              function $2b7f887ebcb5888a$export$bd6df347a4f391c4(features) {
                let res = {};
                if (Array.isArray(features)) for (let k = 0; k < features.length; k++) {
                  let r;
                  let f = $2b7f887ebcb5888a$var$mapFeatureStrings(features[k]);
                  if (r = $2b7f887ebcb5888a$var$AATMapping[f[0]] && $2b7f887ebcb5888a$var$AATMapping[f[0]][f[1]]) res[r] = true;
                }
                else if (typeof features === "object") for (let type in features) {
                  let feature = features[type];
                  for (let setting in feature) {
                    let r;
                    let f = $2b7f887ebcb5888a$var$mapFeatureStrings([
                      type,
                      setting
                    ]);
                    if (feature[setting] && (r = $2b7f887ebcb5888a$var$AATMapping[f[0]] && $2b7f887ebcb5888a$var$AATMapping[f[0]][f[1]])) res[r] = true;
                  }
                }
                return Object.keys(res);
              }
              class $f3d63ae925545400$export$2e2bcd8739ae039 {
                lookup(glyph) {
                  switch (this.table.version) {
                    case 0:
                      return this.table.values.getItem(glyph);
                    case 2:
                    case 4: {
                      let min = 0;
                      let max = this.table.binarySearchHeader.nUnits - 1;
                      while (min <= max) {
                        var mid = min + max >> 1;
                        var seg = this.table.segments[mid];
                        if (seg.firstGlyph === 65535) return null;
                        if (glyph < seg.firstGlyph) max = mid - 1;
                        else if (glyph > seg.lastGlyph) min = mid + 1;
                        else {
                          if (this.table.version === 2) return seg.value;
                          else return seg.values[glyph - seg.firstGlyph];
                        }
                      }
                      return null;
                    }
                    case 6: {
                      let min = 0;
                      let max = this.table.binarySearchHeader.nUnits - 1;
                      while (min <= max) {
                        var mid = min + max >> 1;
                        var seg = this.table.segments[mid];
                        if (seg.glyph === 65535) return null;
                        if (glyph < seg.glyph) max = mid - 1;
                        else if (glyph > seg.glyph) min = mid + 1;
                        else return seg.value;
                      }
                      return null;
                    }
                    case 8:
                      return this.table.values[glyph - this.table.firstGlyph];
                    default:
                      throw new Error(`Unknown lookup table format: ${this.table.version}`);
                  }
                }
                glyphsForValue(classValue) {
                  let res = [];
                  switch (this.table.version) {
                    case 2:
                    case 4:
                      for (let segment of this.table.segments) if (this.table.version === 2 && segment.value === classValue) res.push(...(0, $66a5b9fb5318558a$export$d02631cccf789723)(segment.firstGlyph, segment.lastGlyph + 1));
                      else {
                        for (let index = 0; index < segment.values.length; index++) if (segment.values[index] === classValue) res.push(segment.firstGlyph + index);
                      }
                      break;
                    case 6:
                      for (let segment of this.table.segments) if (segment.value === classValue) res.push(segment.glyph);
                      break;
                    case 8:
                      for (let i = 0; i < this.table.values.length; i++) if (this.table.values[i] === classValue) res.push(this.table.firstGlyph + i);
                      break;
                    default:
                      throw new Error(`Unknown lookup table format: ${this.table.version}`);
                  }
                  return res;
                }
                constructor(table) {
                  this.table = table;
                }
              }
              (0, $gfJaN$swchelperscjs_ts_decoratecjs._)([
                (0, $3bda6911913b43f0$export$69a3209f1a06c04d)
              ], $f3d63ae925545400$export$2e2bcd8739ae039.prototype, "glyphsForValue", null);
              const $860c6347bb941b91$var$START_OF_TEXT_STATE = 0;
              const $860c6347bb941b91$var$START_OF_LINE_STATE = 1;
              const $860c6347bb941b91$var$END_OF_TEXT_CLASS = 0;
              const $860c6347bb941b91$var$OUT_OF_BOUNDS_CLASS = 1;
              const $860c6347bb941b91$var$DELETED_GLYPH_CLASS = 2;
              const $860c6347bb941b91$var$END_OF_LINE_CLASS = 3;
              const $860c6347bb941b91$var$DONT_ADVANCE = 16384;
              class $860c6347bb941b91$export$2e2bcd8739ae039 {
                process(glyphs, reverse, processEntry) {
                  let currentState = $860c6347bb941b91$var$START_OF_TEXT_STATE;
                  let index = reverse ? glyphs.length - 1 : 0;
                  let dir = reverse ? -1 : 1;
                  while (dir === 1 && index <= glyphs.length || dir === -1 && index >= -1) {
                    let glyph = null;
                    let classCode = $860c6347bb941b91$var$OUT_OF_BOUNDS_CLASS;
                    let shouldAdvance = true;
                    if (index === glyphs.length || index === -1) classCode = $860c6347bb941b91$var$END_OF_TEXT_CLASS;
                    else {
                      glyph = glyphs[index];
                      if (glyph.id === 65535) classCode = $860c6347bb941b91$var$DELETED_GLYPH_CLASS;
                      else {
                        classCode = this.lookupTable.lookup(glyph.id);
                        if (classCode == null) classCode = $860c6347bb941b91$var$OUT_OF_BOUNDS_CLASS;
                      }
                    }
                    let row = this.stateTable.stateArray.getItem(currentState);
                    let entryIndex = row[classCode];
                    let entry = this.stateTable.entryTable.getItem(entryIndex);
                    if (classCode !== $860c6347bb941b91$var$END_OF_TEXT_CLASS && classCode !== $860c6347bb941b91$var$DELETED_GLYPH_CLASS) {
                      processEntry(glyph, entry, index);
                      shouldAdvance = !(entry.flags & $860c6347bb941b91$var$DONT_ADVANCE);
                    }
                    currentState = entry.newState;
                    if (shouldAdvance) index += dir;
                  }
                  return glyphs;
                }
                /**
                * Performs a depth-first traversal of the glyph strings
                * represented by the state machine.
                */
                traverse(opts, state = 0, visited = /* @__PURE__ */ new Set()) {
                  if (visited.has(state)) return;
                  visited.add(state);
                  let { nClasses, stateArray, entryTable } = this.stateTable;
                  let row = stateArray.getItem(state);
                  for (let classCode = 4; classCode < nClasses; classCode++) {
                    let entryIndex = row[classCode];
                    let entry = entryTable.getItem(entryIndex);
                    for (let glyph of this.lookupTable.glyphsForValue(classCode)) {
                      if (opts.enter) opts.enter(glyph, entry);
                      if (entry.newState !== 0) this.traverse(opts, entry.newState, visited);
                      if (opts.exit) opts.exit(glyph, entry);
                    }
                  }
                }
                constructor(stateTable) {
                  this.stateTable = stateTable;
                  this.lookupTable = new (0, $f3d63ae925545400$export$2e2bcd8739ae039)(stateTable.classTable);
                }
              }
              const $99be642f82069918$var$MARK_FIRST = 32768;
              const $99be642f82069918$var$MARK_LAST = 8192;
              const $99be642f82069918$var$VERB = 15;
              const $99be642f82069918$var$SET_MARK = 32768;
              const $99be642f82069918$var$SET_COMPONENT = 32768;
              const $99be642f82069918$var$PERFORM_ACTION = 8192;
              const $99be642f82069918$var$LAST_MASK = 2147483648;
              const $99be642f82069918$var$STORE_MASK = 1073741824;
              const $99be642f82069918$var$OFFSET_MASK = 1073741823;
              const $99be642f82069918$var$VERTICAL_ONLY = 8388608;
              const $99be642f82069918$var$REVERSE_DIRECTION = 4194304;
              const $99be642f82069918$var$HORIZONTAL_AND_VERTICAL = 2097152;
              const $99be642f82069918$var$CURRENT_IS_KASHIDA_LIKE = 8192;
              const $99be642f82069918$var$MARKED_IS_KASHIDA_LIKE = 4096;
              const $99be642f82069918$var$CURRENT_INSERT_BEFORE = 2048;
              const $99be642f82069918$var$MARKED_INSERT_BEFORE = 1024;
              const $99be642f82069918$var$CURRENT_INSERT_COUNT = 992;
              const $99be642f82069918$var$MARKED_INSERT_COUNT = 31;
              class $99be642f82069918$export$2e2bcd8739ae039 {
                // Processes an array of glyphs and applies the specified features
                // Features should be in the form of {featureType:{featureSetting:boolean}}
                process(glyphs, features = {}) {
                  for (let chain of this.morx.chains) {
                    let flags = chain.defaultFlags;
                    for (let feature of chain.features) {
                      let f;
                      if (f = features[feature.featureType]) {
                        if (f[feature.featureSetting]) {
                          flags &= feature.disableFlags;
                          flags |= feature.enableFlags;
                        } else if (f[feature.featureSetting] === false) {
                          flags |= ~feature.disableFlags;
                          flags &= ~feature.enableFlags;
                        }
                      }
                    }
                    for (let subtable of chain.subtables) if (subtable.subFeatureFlags & flags) this.processSubtable(subtable, glyphs);
                  }
                  let index = glyphs.length - 1;
                  while (index >= 0) {
                    if (glyphs[index].id === 65535) glyphs.splice(index, 1);
                    index--;
                  }
                  return glyphs;
                }
                processSubtable(subtable, glyphs) {
                  this.subtable = subtable;
                  this.glyphs = glyphs;
                  if (this.subtable.type === 4) {
                    this.processNoncontextualSubstitutions(this.subtable, this.glyphs);
                    return;
                  }
                  this.ligatureStack = [];
                  this.markedGlyph = null;
                  this.firstGlyph = null;
                  this.lastGlyph = null;
                  this.markedIndex = null;
                  let stateMachine = this.getStateMachine(subtable);
                  let process = this.getProcessor();
                  let reverse = !!(this.subtable.coverage & $99be642f82069918$var$REVERSE_DIRECTION);
                  return stateMachine.process(this.glyphs, reverse, process);
                }
                getStateMachine(subtable) {
                  return new (0, $860c6347bb941b91$export$2e2bcd8739ae039)(subtable.table.stateTable);
                }
                getProcessor() {
                  switch (this.subtable.type) {
                    case 0:
                      return this.processIndicRearragement;
                    case 1:
                      return this.processContextualSubstitution;
                    case 2:
                      return this.processLigature;
                    case 4:
                      return this.processNoncontextualSubstitutions;
                    case 5:
                      return this.processGlyphInsertion;
                    default:
                      throw new Error(`Invalid morx subtable type: ${this.subtable.type}`);
                  }
                }
                processIndicRearragement(glyph, entry, index) {
                  if (entry.flags & $99be642f82069918$var$MARK_FIRST) this.firstGlyph = index;
                  if (entry.flags & $99be642f82069918$var$MARK_LAST) this.lastGlyph = index;
                  $99be642f82069918$var$reorderGlyphs(this.glyphs, entry.flags & $99be642f82069918$var$VERB, this.firstGlyph, this.lastGlyph);
                }
                processContextualSubstitution(glyph, entry, index) {
                  let subsitutions = this.subtable.table.substitutionTable.items;
                  if (entry.markIndex !== 65535) {
                    let lookup = subsitutions.getItem(entry.markIndex);
                    let lookupTable = new (0, $f3d63ae925545400$export$2e2bcd8739ae039)(lookup);
                    glyph = this.glyphs[this.markedGlyph];
                    var gid = lookupTable.lookup(glyph.id);
                    if (gid) this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints);
                  }
                  if (entry.currentIndex !== 65535) {
                    let lookup = subsitutions.getItem(entry.currentIndex);
                    let lookupTable = new (0, $f3d63ae925545400$export$2e2bcd8739ae039)(lookup);
                    glyph = this.glyphs[index];
                    var gid = lookupTable.lookup(glyph.id);
                    if (gid) this.glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);
                  }
                  if (entry.flags & $99be642f82069918$var$SET_MARK) this.markedGlyph = index;
                }
                processLigature(glyph, entry, index) {
                  if (entry.flags & $99be642f82069918$var$SET_COMPONENT) this.ligatureStack.push(index);
                  if (entry.flags & $99be642f82069918$var$PERFORM_ACTION) {
                    let actions = this.subtable.table.ligatureActions;
                    let components = this.subtable.table.components;
                    let ligatureList = this.subtable.table.ligatureList;
                    let actionIndex = entry.action;
                    let last = false;
                    let ligatureIndex = 0;
                    let codePoints = [];
                    let ligatureGlyphs = [];
                    while (!last) {
                      let componentGlyph = this.ligatureStack.pop();
                      codePoints.unshift(...this.glyphs[componentGlyph].codePoints);
                      let action = actions.getItem(actionIndex++);
                      last = !!(action & $99be642f82069918$var$LAST_MASK);
                      let store = !!(action & $99be642f82069918$var$STORE_MASK);
                      let offset = (action & $99be642f82069918$var$OFFSET_MASK) << 2 >> 2;
                      offset += this.glyphs[componentGlyph].id;
                      let component = components.getItem(offset);
                      ligatureIndex += component;
                      if (last || store) {
                        let ligatureEntry = ligatureList.getItem(ligatureIndex);
                        this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);
                        ligatureGlyphs.push(componentGlyph);
                        ligatureIndex = 0;
                        codePoints = [];
                      } else this.glyphs[componentGlyph] = this.font.getGlyph(65535);
                    }
                    this.ligatureStack.push(...ligatureGlyphs);
                  }
                }
                processNoncontextualSubstitutions(subtable, glyphs, index) {
                  let lookupTable = new (0, $f3d63ae925545400$export$2e2bcd8739ae039)(subtable.table.lookupTable);
                  for (index = 0; index < glyphs.length; index++) {
                    let glyph = glyphs[index];
                    if (glyph.id !== 65535) {
                      let gid = lookupTable.lookup(glyph.id);
                      if (gid) glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);
                    }
                  }
                }
                _insertGlyphs(glyphIndex, insertionActionIndex, count, isBefore) {
                  let insertions = [];
                  while (count--) {
                    let gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);
                    insertions.push(this.font.getGlyph(gid));
                  }
                  if (!isBefore) glyphIndex++;
                  this.glyphs.splice(glyphIndex, 0, ...insertions);
                }
                processGlyphInsertion(glyph, entry, index) {
                  if (entry.flags & $99be642f82069918$var$SET_MARK) this.markedIndex = index;
                  if (entry.markedInsertIndex !== 65535) {
                    let count = (entry.flags & $99be642f82069918$var$MARKED_INSERT_COUNT) >>> 5;
                    let isBefore = !!(entry.flags & $99be642f82069918$var$MARKED_INSERT_BEFORE);
                    this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);
                  }
                  if (entry.currentInsertIndex !== 65535) {
                    let count = (entry.flags & $99be642f82069918$var$CURRENT_INSERT_COUNT) >>> 5;
                    let isBefore = !!(entry.flags & $99be642f82069918$var$CURRENT_INSERT_BEFORE);
                    this._insertGlyphs(index, entry.currentInsertIndex, count, isBefore);
                  }
                }
                getSupportedFeatures() {
                  let features = [];
                  for (let chain of this.morx.chains) for (let feature of chain.features) features.push([
                    feature.featureType,
                    feature.featureSetting
                  ]);
                  return features;
                }
                generateInputs(gid) {
                  if (!this.inputCache) this.generateInputCache();
                  return this.inputCache[gid] || [];
                }
                generateInputCache() {
                  this.inputCache = {};
                  for (let chain of this.morx.chains) {
                    let flags = chain.defaultFlags;
                    for (let subtable of chain.subtables) if (subtable.subFeatureFlags & flags) this.generateInputsForSubtable(subtable);
                  }
                }
                generateInputsForSubtable(subtable) {
                  if (subtable.type !== 2) return;
                  let reverse = !!(subtable.coverage & $99be642f82069918$var$REVERSE_DIRECTION);
                  if (reverse) throw new Error("Reverse subtable, not supported.");
                  this.subtable = subtable;
                  this.ligatureStack = [];
                  let stateMachine = this.getStateMachine(subtable);
                  let process = this.getProcessor();
                  let input = [];
                  let stack = [];
                  this.glyphs = [];
                  stateMachine.traverse({
                    enter: (glyph, entry) => {
                      let glyphs = this.glyphs;
                      stack.push({
                        glyphs: glyphs.slice(),
                        ligatureStack: this.ligatureStack.slice()
                      });
                      let g = this.font.getGlyph(glyph);
                      input.push(g);
                      glyphs.push(input[input.length - 1]);
                      process(glyphs[glyphs.length - 1], entry, glyphs.length - 1);
                      let count = 0;
                      let found = 0;
                      for (let i = 0; i < glyphs.length && count <= 1; i++) if (glyphs[i].id !== 65535) {
                        count++;
                        found = glyphs[i].id;
                      }
                      if (count === 1) {
                        let result = input.map((g2) => g2.id);
                        let cache = this.inputCache[found];
                        if (cache) cache.push(result);
                        else this.inputCache[found] = [
                          result
                        ];
                      }
                    },
                    exit: () => {
                      ({ glyphs: this.glyphs, ligatureStack: this.ligatureStack } = stack.pop());
                      input.pop();
                    }
                  });
                }
                constructor(font) {
                  this.processIndicRearragement = this.processIndicRearragement.bind(this);
                  this.processContextualSubstitution = this.processContextualSubstitution.bind(this);
                  this.processLigature = this.processLigature.bind(this);
                  this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);
                  this.processGlyphInsertion = this.processGlyphInsertion.bind(this);
                  this.font = font;
                  this.morx = font.morx;
                  this.inputCache = null;
                }
              }
              (0, $gfJaN$swchelperscjs_ts_decoratecjs._)([
                (0, $3bda6911913b43f0$export$69a3209f1a06c04d)
              ], $99be642f82069918$export$2e2bcd8739ae039.prototype, "getStateMachine", null);
              function $99be642f82069918$var$swap(glyphs, rangeA, rangeB, reverseA = false, reverseB = false) {
                let end = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);
                if (reverseB) end.reverse();
                let start = glyphs.splice(rangeA[0], rangeA[1], ...end);
                if (reverseA) start.reverse();
                glyphs.splice(rangeB[0] - (rangeA[1] - 1), 0, ...start);
                return glyphs;
              }
              function $99be642f82069918$var$reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {
                let length = lastGlyph - firstGlyph + 1;
                switch (verb) {
                  case 0:
                    return glyphs;
                  case 1:
                    return $99be642f82069918$var$swap(glyphs, [
                      firstGlyph,
                      1
                    ], [
                      lastGlyph,
                      0
                    ]);
                  case 2:
                    return $99be642f82069918$var$swap(glyphs, [
                      firstGlyph,
                      0
                    ], [
                      lastGlyph,
                      1
                    ]);
                  case 3:
                    return $99be642f82069918$var$swap(glyphs, [
                      firstGlyph,
                      1
                    ], [
                      lastGlyph,
                      1
                    ]);
                  case 4:
                    return $99be642f82069918$var$swap(glyphs, [
                      firstGlyph,
                      2
                    ], [
                      lastGlyph,
                      0
                    ]);
                  case 5:
                    return $99be642f82069918$var$swap(glyphs, [
                      firstGlyph,
                      2
                    ], [
                      lastGlyph,
                      0
                    ], true, false);
                  case 6:
                    return $99be642f82069918$var$swap(glyphs, [
                      firstGlyph,
                      0
                    ], [
                      lastGlyph,
                      2
                    ]);
                  case 7:
                    return $99be642f82069918$var$swap(glyphs, [
                      firstGlyph,
                      0
                    ], [
                      lastGlyph,
                      2
                    ], false, true);
                  case 8:
                    return $99be642f82069918$var$swap(glyphs, [
                      firstGlyph,
                      1
                    ], [
                      lastGlyph,
                      2
                    ]);
                  case 9:
                    return $99be642f82069918$var$swap(glyphs, [
                      firstGlyph,
                      1
                    ], [
                      lastGlyph,
                      2
                    ], false, true);
                  case 10:
                    return $99be642f82069918$var$swap(glyphs, [
                      firstGlyph,
                      2
                    ], [
                      lastGlyph,
                      1
                    ]);
                  case 11:
                    return $99be642f82069918$var$swap(glyphs, [
                      firstGlyph,
                      2
                    ], [
                      lastGlyph,
                      1
                    ], true, false);
                  case 12:
                    return $99be642f82069918$var$swap(glyphs, [
                      firstGlyph,
                      2
                    ], [
                      lastGlyph,
                      2
                    ]);
                  case 13:
                    return $99be642f82069918$var$swap(glyphs, [
                      firstGlyph,
                      2
                    ], [
                      lastGlyph,
                      2
                    ], true, false);
                  case 14:
                    return $99be642f82069918$var$swap(glyphs, [
                      firstGlyph,
                      2
                    ], [
                      lastGlyph,
                      2
                    ], false, true);
                  case 15:
                    return $99be642f82069918$var$swap(glyphs, [
                      firstGlyph,
                      2
                    ], [
                      lastGlyph,
                      2
                    ], true, true);
                  default:
                    throw new Error(`Unknown verb: ${verb}`);
                }
              }
              class $860fcbd64bc12fbc$export$2e2bcd8739ae039 {
                substitute(glyphRun) {
                  if (glyphRun.direction === "rtl") glyphRun.glyphs.reverse();
                  this.morxProcessor.process(glyphRun.glyphs, $2b7f887ebcb5888a$export$b813f7d2a1677c16(glyphRun.features));
                }
                getAvailableFeatures(script, language) {
                  return $2b7f887ebcb5888a$export$bd6df347a4f391c4(this.morxProcessor.getSupportedFeatures());
                }
                stringsForGlyph(gid) {
                  let glyphStrings = this.morxProcessor.generateInputs(gid);
                  let result = /* @__PURE__ */ new Set();
                  for (let glyphs of glyphStrings) this._addStrings(glyphs, 0, result, "");
                  return result;
                }
                _addStrings(glyphs, index, strings, string) {
                  let codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index]);
                  for (let codePoint of codePoints) {
                    let s = string + String.fromCodePoint(codePoint);
                    if (index < glyphs.length - 1) this._addStrings(glyphs, index + 1, strings, s);
                    else strings.add(s);
                  }
                }
                constructor(font) {
                  this.font = font;
                  this.morxProcessor = new (0, $99be642f82069918$export$2e2bcd8739ae039)(font);
                  this.fallbackPosition = false;
                }
              }
              class $d7e93cca3cf8ce8a$export$2e2bcd8739ae039 {
                /**
                * Adds the given features to the last stage.
                * Ignores features that have already been applied.
                */
                _addFeatures(features, global) {
                  let stageIndex = this.stages.length - 1;
                  let stage = this.stages[stageIndex];
                  for (let feature of features) if (this.allFeatures[feature] == null) {
                    stage.push(feature);
                    this.allFeatures[feature] = stageIndex;
                    if (global) this.globalFeatures[feature] = true;
                  }
                }
                /**
                * Add features to the last stage
                */
                add(arg, global = true) {
                  if (this.stages.length === 0) this.stages.push([]);
                  if (typeof arg === "string") arg = [
                    arg
                  ];
                  if (Array.isArray(arg)) this._addFeatures(arg, global);
                  else if (typeof arg === "object") {
                    this._addFeatures(arg.global || [], true);
                    this._addFeatures(arg.local || [], false);
                  } else throw new Error("Unsupported argument to ShapingPlan#add");
                }
                /**
                * Add a new stage
                */
                addStage(arg, global) {
                  if (typeof arg === "function") this.stages.push(arg, []);
                  else {
                    this.stages.push([]);
                    this.add(arg, global);
                  }
                }
                setFeatureOverrides(features) {
                  if (Array.isArray(features)) this.add(features);
                  else if (typeof features === "object") for (let tag in features) {
                    if (features[tag]) this.add(tag);
                    else if (this.allFeatures[tag] != null) {
                      let stage = this.stages[this.allFeatures[tag]];
                      stage.splice(stage.indexOf(tag), 1);
                      delete this.allFeatures[tag];
                      delete this.globalFeatures[tag];
                    }
                  }
                }
                /**
                * Assigns the global features to the given glyphs
                */
                assignGlobalFeatures(glyphs) {
                  for (let glyph of glyphs) for (let feature in this.globalFeatures) glyph.features[feature] = true;
                }
                /**
                * Executes the planned stages using the given OTProcessor
                */
                process(processor, glyphs, positions) {
                  for (let stage of this.stages) {
                    if (typeof stage === "function") {
                      if (!positions) stage(this.font, glyphs, this);
                    } else if (stage.length > 0) processor.applyFeatures(stage, glyphs, positions);
                  }
                }
                constructor(font, script, direction) {
                  this.font = font;
                  this.script = script;
                  this.direction = direction;
                  this.stages = [];
                  this.globalFeatures = {};
                  this.allFeatures = {};
                }
              }
              const $d28fb665ee343afc$var$VARIATION_FEATURES = [
                "rvrn"
              ];
              const $d28fb665ee343afc$var$COMMON_FEATURES = [
                "ccmp",
                "locl",
                "rlig",
                "mark",
                "mkmk"
              ];
              const $d28fb665ee343afc$var$FRACTIONAL_FEATURES = [
                "frac",
                "numr",
                "dnom"
              ];
              const $d28fb665ee343afc$var$HORIZONTAL_FEATURES = [
                "calt",
                "clig",
                "liga",
                "rclt",
                "curs",
                "kern"
              ];
              const $d28fb665ee343afc$var$VERTICAL_FEATURES = [
                "vert"
              ];
              const $d28fb665ee343afc$var$DIRECTIONAL_FEATURES = {
                ltr: [
                  "ltra",
                  "ltrm"
                ],
                rtl: [
                  "rtla",
                  "rtlm"
                ]
              };
              class $d28fb665ee343afc$export$2e2bcd8739ae039 {
                static plan(plan, glyphs, features) {
                  this.planPreprocessing(plan);
                  this.planFeatures(plan);
                  this.planPostprocessing(plan, features);
                  plan.assignGlobalFeatures(glyphs);
                  this.assignFeatures(plan, glyphs);
                }
                static planPreprocessing(plan) {
                  plan.add({
                    global: [
                      ...$d28fb665ee343afc$var$VARIATION_FEATURES,
                      ...$d28fb665ee343afc$var$DIRECTIONAL_FEATURES[plan.direction]
                    ],
                    local: $d28fb665ee343afc$var$FRACTIONAL_FEATURES
                  });
                }
                static planFeatures(plan) {
                }
                static planPostprocessing(plan, userFeatures) {
                  plan.add([
                    ...$d28fb665ee343afc$var$COMMON_FEATURES,
                    ...$d28fb665ee343afc$var$HORIZONTAL_FEATURES
                  ]);
                  plan.setFeatureOverrides(userFeatures);
                }
                static assignFeatures(plan, glyphs) {
                  for (let i = 0; i < glyphs.length; i++) {
                    let glyph = glyphs[i];
                    if (glyph.codePoints[0] === 8260) {
                      let start = i;
                      let end = i + 1;
                      while (start > 0 && (0, $gfJaN$unicodeproperties.isDigit)(glyphs[start - 1].codePoints[0])) {
                        glyphs[start - 1].features.numr = true;
                        glyphs[start - 1].features.frac = true;
                        start--;
                      }
                      while (end < glyphs.length && (0, $gfJaN$unicodeproperties.isDigit)(glyphs[end].codePoints[0])) {
                        glyphs[end].features.dnom = true;
                        glyphs[end].features.frac = true;
                        end++;
                      }
                      glyph.features.frac = true;
                      i = end - 1;
                    }
                  }
                }
              }
              (0, $gfJaN$swchelperscjs_define_propertycjs._)($d28fb665ee343afc$export$2e2bcd8739ae039, "zeroMarkWidths", "AFTER_GPOS");
              const $17ba6019f27bfcf9$var$trie = new (0, $parcel$interopDefault($gfJaN$unicodetrie))((0, $66a5b9fb5318558a$export$94fdf11bafc8de6b)("APABAAAAAAAAOAAAAf0BAv7tmi1MxDAUx7vtvjhAgcDgkEgEAnmXEBIMCYaEcygEiqBQ4FAkCE4ikUgMiiBJSAgSiUQSDMn9L9eSl6bddddug9t7yS/trevre+3r27pcNxZiG+yCfdCVv/9LeQxOwRm4AJegD27ALbgD9+ABPJF+z+BN/h7yDj5k/VOWX6SdmU5+wLWknggxDxaS8u0qiiX4uiz9XamQ3wzDMAzDMAzDMAzDVI/h959V/v7BMAzDMAzDMLlyNTNiMSdewVxbiA44B4/guz1qW58VYlMI0WsJ0W+N6kXw0spvPtdwhtkwnGM6uLaV4Xyzg3v3PM9DPfQ/sOg4xPWjipy31P8LTqbU304c/cLCUmWJLNB2Uz2U1KTeRKNmKHVMfbJC+/0loTZRH/W5cvEvBJPMbREkWt3FD1NcqXZBSpuE2Ad0PBehPtNrPtIEdYP+hiRt/V1jIiE69X4NT/uVZI3PUHE9bm5M7ePGdZWy951v7Nn6j8v1WWKP3mt6ttnsigx6VN7Vc0VomSSGqW2mGNP1muZPl7LfjNUaKNFtDGVf2fvE9O7VlBS5j333c5p/eeoOqcs1R/hIqDWLJ7TTlksirVT1SI7l8k4Yp+g3jafGcrU1RM6l9th80XOpnlN97bDNY4i4s61B0Si/ipa0uHMl6zqEjlFfCZm/TM8KmzQDjmuTAQ=="));
              const $17ba6019f27bfcf9$var$FEATURES = [
                "isol",
                "fina",
                "fin2",
                "fin3",
                "medi",
                "med2",
                "init"
              ];
              const $17ba6019f27bfcf9$var$ShapingClasses = {
                Non_Joining: 0,
                Left_Joining: 1,
                Right_Joining: 2,
                Dual_Joining: 3,
                Join_Causing: 3,
                ALAPH: 4,
                "DALATH RISH": 5,
                Transparent: 6
              };
              const $17ba6019f27bfcf9$var$ISOL = "isol";
              const $17ba6019f27bfcf9$var$FINA = "fina";
              const $17ba6019f27bfcf9$var$FIN2 = "fin2";
              const $17ba6019f27bfcf9$var$FIN3 = "fin3";
              const $17ba6019f27bfcf9$var$MEDI = "medi";
              const $17ba6019f27bfcf9$var$MED2 = "med2";
              const $17ba6019f27bfcf9$var$INIT = "init";
              const $17ba6019f27bfcf9$var$NONE = null;
              const $17ba6019f27bfcf9$var$STATE_TABLE = [
                //   Non_Joining,        Left_Joining,       Right_Joining,     Dual_Joining,           ALAPH,            DALATH RISH
                // State 0: prev was U,  not willing to join.
                [
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$NONE,
                    0
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$ISOL,
                    2
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$ISOL,
                    1
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$ISOL,
                    2
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$ISOL,
                    1
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$ISOL,
                    6
                  ]
                ],
                // State 1: prev was R or ISOL/ALAPH,  not willing to join.
                [
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$NONE,
                    0
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$ISOL,
                    2
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$ISOL,
                    1
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$ISOL,
                    2
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$FIN2,
                    5
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$ISOL,
                    6
                  ]
                ],
                // State 2: prev was D/L in ISOL form,  willing to join.
                [
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$NONE,
                    0
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$ISOL,
                    2
                  ],
                  [
                    $17ba6019f27bfcf9$var$INIT,
                    $17ba6019f27bfcf9$var$FINA,
                    1
                  ],
                  [
                    $17ba6019f27bfcf9$var$INIT,
                    $17ba6019f27bfcf9$var$FINA,
                    3
                  ],
                  [
                    $17ba6019f27bfcf9$var$INIT,
                    $17ba6019f27bfcf9$var$FINA,
                    4
                  ],
                  [
                    $17ba6019f27bfcf9$var$INIT,
                    $17ba6019f27bfcf9$var$FINA,
                    6
                  ]
                ],
                // State 3: prev was D in FINA form,  willing to join.
                [
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$NONE,
                    0
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$ISOL,
                    2
                  ],
                  [
                    $17ba6019f27bfcf9$var$MEDI,
                    $17ba6019f27bfcf9$var$FINA,
                    1
                  ],
                  [
                    $17ba6019f27bfcf9$var$MEDI,
                    $17ba6019f27bfcf9$var$FINA,
                    3
                  ],
                  [
                    $17ba6019f27bfcf9$var$MEDI,
                    $17ba6019f27bfcf9$var$FINA,
                    4
                  ],
                  [
                    $17ba6019f27bfcf9$var$MEDI,
                    $17ba6019f27bfcf9$var$FINA,
                    6
                  ]
                ],
                // State 4: prev was FINA ALAPH,  not willing to join.
                [
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$NONE,
                    0
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$ISOL,
                    2
                  ],
                  [
                    $17ba6019f27bfcf9$var$MED2,
                    $17ba6019f27bfcf9$var$ISOL,
                    1
                  ],
                  [
                    $17ba6019f27bfcf9$var$MED2,
                    $17ba6019f27bfcf9$var$ISOL,
                    2
                  ],
                  [
                    $17ba6019f27bfcf9$var$MED2,
                    $17ba6019f27bfcf9$var$FIN2,
                    5
                  ],
                  [
                    $17ba6019f27bfcf9$var$MED2,
                    $17ba6019f27bfcf9$var$ISOL,
                    6
                  ]
                ],
                // State 5: prev was FIN2/FIN3 ALAPH,  not willing to join.
                [
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$NONE,
                    0
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$ISOL,
                    2
                  ],
                  [
                    $17ba6019f27bfcf9$var$ISOL,
                    $17ba6019f27bfcf9$var$ISOL,
                    1
                  ],
                  [
                    $17ba6019f27bfcf9$var$ISOL,
                    $17ba6019f27bfcf9$var$ISOL,
                    2
                  ],
                  [
                    $17ba6019f27bfcf9$var$ISOL,
                    $17ba6019f27bfcf9$var$FIN2,
                    5
                  ],
                  [
                    $17ba6019f27bfcf9$var$ISOL,
                    $17ba6019f27bfcf9$var$ISOL,
                    6
                  ]
                ],
                // State 6: prev was DALATH/RISH,  not willing to join.
                [
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$NONE,
                    0
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$ISOL,
                    2
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$ISOL,
                    1
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$ISOL,
                    2
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$FIN3,
                    5
                  ],
                  [
                    $17ba6019f27bfcf9$var$NONE,
                    $17ba6019f27bfcf9$var$ISOL,
                    6
                  ]
                ]
              ];
              class $17ba6019f27bfcf9$export$2e2bcd8739ae039 extends (0, $d28fb665ee343afc$export$2e2bcd8739ae039) {
                static planFeatures(plan) {
                  plan.add([
                    "ccmp",
                    "locl"
                  ]);
                  for (let i = 0; i < $17ba6019f27bfcf9$var$FEATURES.length; i++) {
                    let feature = $17ba6019f27bfcf9$var$FEATURES[i];
                    plan.addStage(feature, false);
                  }
                  plan.addStage("mset");
                }
                static assignFeatures(plan, glyphs) {
                  super.assignFeatures(plan, glyphs);
                  let prev = -1;
                  let state = 0;
                  let actions = [];
                  for (let i = 0; i < glyphs.length; i++) {
                    let curAction, prevAction;
                    var glyph = glyphs[i];
                    let type = $17ba6019f27bfcf9$var$getShapingClass(glyph.codePoints[0]);
                    if (type === $17ba6019f27bfcf9$var$ShapingClasses.Transparent) {
                      actions[i] = $17ba6019f27bfcf9$var$NONE;
                      continue;
                    }
                    [prevAction, curAction, state] = $17ba6019f27bfcf9$var$STATE_TABLE[state][type];
                    if (prevAction !== $17ba6019f27bfcf9$var$NONE && prev !== -1) actions[prev] = prevAction;
                    actions[i] = curAction;
                    prev = i;
                  }
                  for (let index = 0; index < glyphs.length; index++) {
                    let feature;
                    var glyph = glyphs[index];
                    if (feature = actions[index]) glyph.features[feature] = true;
                  }
                }
              }
              function $17ba6019f27bfcf9$var$getShapingClass(codePoint) {
                let res = $17ba6019f27bfcf9$var$trie.get(codePoint);
                if (res) return res - 1;
                let category = (0, $gfJaN$unicodeproperties.getCategory)(codePoint);
                if (category === "Mn" || category === "Me" || category === "Cf") return $17ba6019f27bfcf9$var$ShapingClasses.Transparent;
                return $17ba6019f27bfcf9$var$ShapingClasses.Non_Joining;
              }
              class $d6368085223f631e$export$2e2bcd8739ae039 {
                reset(options = {}, index = 0) {
                  this.options = options;
                  this.flags = options.flags || {};
                  this.markAttachmentType = options.markAttachmentType || 0;
                  this.index = index;
                }
                get cur() {
                  return this.glyphs[this.index] || null;
                }
                shouldIgnore(glyph) {
                  return this.flags.ignoreMarks && glyph.isMark || this.flags.ignoreBaseGlyphs && glyph.isBase || this.flags.ignoreLigatures && glyph.isLigature || this.markAttachmentType && glyph.isMark && glyph.markAttachmentType !== this.markAttachmentType;
                }
                move(dir) {
                  this.index += dir;
                  while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index])) this.index += dir;
                  if (0 > this.index || this.index >= this.glyphs.length) return null;
                  return this.glyphs[this.index];
                }
                next() {
                  return this.move(1);
                }
                prev() {
                  return this.move(-1);
                }
                peek(count = 1) {
                  let idx = this.index;
                  let res = this.increment(count);
                  this.index = idx;
                  return res;
                }
                peekIndex(count = 1) {
                  let idx = this.index;
                  this.increment(count);
                  let res = this.index;
                  this.index = idx;
                  return res;
                }
                increment(count = 1) {
                  let dir = count < 0 ? -1 : 1;
                  count = Math.abs(count);
                  while (count--) this.move(dir);
                  return this.glyphs[this.index];
                }
                constructor(glyphs, options) {
                  this.glyphs = glyphs;
                  this.reset(options);
                }
              }
              const $7b226e6bbeadedeb$var$DEFAULT_SCRIPTS = [
                "DFLT",
                "dflt",
                "latn"
              ];
              class $7b226e6bbeadedeb$export$2e2bcd8739ae039 {
                findScript(script) {
                  if (this.table.scriptList == null) return null;
                  if (!Array.isArray(script)) script = [
                    script
                  ];
                  for (let s of script) for (let entry of this.table.scriptList) {
                    if (entry.tag === s) return entry;
                  }
                  return null;
                }
                selectScript(script, language, direction) {
                  let changed = false;
                  let entry;
                  if (!this.script || script !== this.scriptTag) {
                    entry = this.findScript(script);
                    if (!entry) entry = this.findScript($7b226e6bbeadedeb$var$DEFAULT_SCRIPTS);
                    if (!entry) return this.scriptTag;
                    this.scriptTag = entry.tag;
                    this.script = entry.script;
                    this.language = null;
                    this.languageTag = null;
                    changed = true;
                  }
                  if (!direction || direction !== this.direction) this.direction = direction || $e38a1a895f6aeb54$export$9fddb9d0dd7d8a54(script);
                  if (language && language.length < 4) language += " ".repeat(4 - language.length);
                  if (!language || language !== this.languageTag) {
                    this.language = null;
                    for (let lang of this.script.langSysRecords) if (lang.tag === language) {
                      this.language = lang.langSys;
                      this.languageTag = lang.tag;
                      break;
                    }
                    if (!this.language) {
                      this.language = this.script.defaultLangSys;
                      this.languageTag = null;
                    }
                    changed = true;
                  }
                  if (changed) {
                    this.features = {};
                    if (this.language) for (let featureIndex of this.language.featureIndexes) {
                      let record = this.table.featureList[featureIndex];
                      let substituteFeature = this.substituteFeatureForVariations(featureIndex);
                      this.features[record.tag] = substituteFeature || record.feature;
                    }
                  }
                  return this.scriptTag;
                }
                lookupsForFeatures(userFeatures = [], exclude) {
                  let lookups = [];
                  for (let tag of userFeatures) {
                    let feature = this.features[tag];
                    if (!feature) continue;
                    for (let lookupIndex of feature.lookupListIndexes) {
                      if (exclude && exclude.indexOf(lookupIndex) !== -1) continue;
                      lookups.push({
                        feature: tag,
                        index: lookupIndex,
                        lookup: this.table.lookupList.get(lookupIndex)
                      });
                    }
                  }
                  lookups.sort((a, b) => a.index - b.index);
                  return lookups;
                }
                substituteFeatureForVariations(featureIndex) {
                  if (this.variationsIndex === -1) return null;
                  let record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];
                  let substitutions = record.featureTableSubstitution.substitutions;
                  for (let substitution of substitutions) {
                    if (substitution.featureIndex === featureIndex) return substitution.alternateFeatureTable;
                  }
                  return null;
                }
                findVariationsIndex(coords) {
                  let variations = this.table.featureVariations;
                  if (!variations) return -1;
                  let records = variations.featureVariationRecords;
                  for (let i = 0; i < records.length; i++) {
                    let conditions = records[i].conditionSet.conditionTable;
                    if (this.variationConditionsMatch(conditions, coords)) return i;
                  }
                  return -1;
                }
                variationConditionsMatch(conditions, coords) {
                  return conditions.every((condition) => {
                    let coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;
                    return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;
                  });
                }
                applyFeatures(userFeatures, glyphs, advances) {
                  let lookups = this.lookupsForFeatures(userFeatures);
                  this.applyLookups(lookups, glyphs, advances);
                }
                applyLookups(lookups, glyphs, positions) {
                  this.glyphs = glyphs;
                  this.positions = positions;
                  this.glyphIterator = new (0, $d6368085223f631e$export$2e2bcd8739ae039)(glyphs);
                  for (let { feature, lookup } of lookups) {
                    this.currentFeature = feature;
                    this.glyphIterator.reset(lookup.flags);
                    while (this.glyphIterator.index < glyphs.length) {
                      if (!(feature in this.glyphIterator.cur.features)) {
                        this.glyphIterator.next();
                        continue;
                      }
                      for (let table of lookup.subTables) {
                        let res = this.applyLookup(lookup.lookupType, table);
                        if (res) break;
                      }
                      this.glyphIterator.next();
                    }
                  }
                }
                applyLookup(lookup, table) {
                  throw new Error("applyLookup must be implemented by subclasses");
                }
                applyLookupList(lookupRecords) {
                  let options = this.glyphIterator.options;
                  let glyphIndex = this.glyphIterator.index;
                  for (let lookupRecord of lookupRecords) {
                    this.glyphIterator.reset(options, glyphIndex);
                    this.glyphIterator.increment(lookupRecord.sequenceIndex);
                    let lookup = this.table.lookupList.get(lookupRecord.lookupListIndex);
                    this.glyphIterator.reset(lookup.flags, this.glyphIterator.index);
                    for (let table of lookup.subTables) {
                      if (this.applyLookup(lookup.lookupType, table)) break;
                    }
                  }
                  this.glyphIterator.reset(options, glyphIndex);
                  return true;
                }
                coverageIndex(coverage, glyph) {
                  if (glyph == null) glyph = this.glyphIterator.cur.id;
                  switch (coverage.version) {
                    case 1:
                      return coverage.glyphs.indexOf(glyph);
                    case 2:
                      for (let range of coverage.rangeRecords) {
                        if (range.start <= glyph && glyph <= range.end) return range.startCoverageIndex + glyph - range.start;
                      }
                      break;
                  }
                  return -1;
                }
                match(sequenceIndex, sequence, fn, matched) {
                  let pos = this.glyphIterator.index;
                  let glyph = this.glyphIterator.increment(sequenceIndex);
                  let idx = 0;
                  while (idx < sequence.length && glyph && fn(sequence[idx], glyph)) {
                    if (matched) matched.push(this.glyphIterator.index);
                    idx++;
                    glyph = this.glyphIterator.next();
                  }
                  this.glyphIterator.index = pos;
                  if (idx < sequence.length) return false;
                  return matched || true;
                }
                sequenceMatches(sequenceIndex, sequence) {
                  return this.match(sequenceIndex, sequence, (component, glyph) => component === glyph.id);
                }
                sequenceMatchIndices(sequenceIndex, sequence) {
                  return this.match(sequenceIndex, sequence, (component, glyph) => {
                    if (!(this.currentFeature in glyph.features)) return false;
                    return component === glyph.id;
                  }, []);
                }
                coverageSequenceMatches(sequenceIndex, sequence) {
                  return this.match(sequenceIndex, sequence, (coverage, glyph) => this.coverageIndex(coverage, glyph.id) >= 0);
                }
                getClassID(glyph, classDef) {
                  switch (classDef.version) {
                    case 1:
                      let i = glyph - classDef.startGlyph;
                      if (i >= 0 && i < classDef.classValueArray.length) return classDef.classValueArray[i];
                      break;
                    case 2:
                      for (let range of classDef.classRangeRecord) {
                        if (range.start <= glyph && glyph <= range.end) return range.class;
                      }
                      break;
                  }
                  return 0;
                }
                classSequenceMatches(sequenceIndex, sequence, classDef) {
                  return this.match(sequenceIndex, sequence, (classID, glyph) => classID === this.getClassID(glyph.id, classDef));
                }
                applyContext(table) {
                  let index, set;
                  switch (table.version) {
                    case 1:
                      index = this.coverageIndex(table.coverage);
                      if (index === -1) return false;
                      set = table.ruleSets[index];
                      for (let rule of set) {
                        if (this.sequenceMatches(1, rule.input)) return this.applyLookupList(rule.lookupRecords);
                      }
                      break;
                    case 2:
                      if (this.coverageIndex(table.coverage) === -1) return false;
                      index = this.getClassID(this.glyphIterator.cur.id, table.classDef);
                      if (index === -1) return false;
                      set = table.classSet[index];
                      for (let rule of set) {
                        if (this.classSequenceMatches(1, rule.classes, table.classDef)) return this.applyLookupList(rule.lookupRecords);
                      }
                      break;
                    case 3:
                      if (this.coverageSequenceMatches(0, table.coverages)) return this.applyLookupList(table.lookupRecords);
                      break;
                  }
                  return false;
                }
                applyChainingContext(table) {
                  let index;
                  switch (table.version) {
                    case 1:
                      index = this.coverageIndex(table.coverage);
                      if (index === -1) return false;
                      let set = table.chainRuleSets[index];
                      for (let rule of set) {
                        if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack) && this.sequenceMatches(1, rule.input) && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) return this.applyLookupList(rule.lookupRecords);
                      }
                      break;
                    case 2:
                      if (this.coverageIndex(table.coverage) === -1) return false;
                      index = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);
                      let rules = table.chainClassSet[index];
                      if (!rules) return false;
                      for (let rule of rules) {
                        if (this.classSequenceMatches(-rule.backtrack.length, rule.backtrack, table.backtrackClassDef) && this.classSequenceMatches(1, rule.input, table.inputClassDef) && this.classSequenceMatches(1 + rule.input.length, rule.lookahead, table.lookaheadClassDef)) return this.applyLookupList(rule.lookupRecords);
                      }
                      break;
                    case 3:
                      if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) && this.coverageSequenceMatches(0, table.inputCoverage) && this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage)) return this.applyLookupList(table.lookupRecords);
                      break;
                  }
                  return false;
                }
                constructor(font, table) {
                  this.font = font;
                  this.table = table;
                  this.script = null;
                  this.scriptTag = null;
                  this.language = null;
                  this.languageTag = null;
                  this.features = {};
                  this.lookups = {};
                  this.variationsIndex = font._variationProcessor ? this.findVariationsIndex(font._variationProcessor.normalizedCoords) : -1;
                  this.selectScript();
                  this.glyphs = [];
                  this.positions = [];
                  this.ligatureID = 1;
                  this.currentFeature = null;
                }
              }
              class $f22bb23c9fd478d8$export$2e2bcd8739ae039 {
                get id() {
                  return this._id;
                }
                set id(id) {
                  this._id = id;
                  this.substituted = true;
                  let GDEF = this._font.GDEF;
                  if (GDEF && GDEF.glyphClassDef) {
                    let classID = (0, $7b226e6bbeadedeb$export$2e2bcd8739ae039).prototype.getClassID(id, GDEF.glyphClassDef);
                    this.isBase = classID === 1;
                    this.isLigature = classID === 2;
                    this.isMark = classID === 3;
                    this.markAttachmentType = GDEF.markAttachClassDef ? (0, $7b226e6bbeadedeb$export$2e2bcd8739ae039).prototype.getClassID(id, GDEF.markAttachClassDef) : 0;
                  } else {
                    this.isMark = this.codePoints.length > 0 && this.codePoints.every((0, $gfJaN$unicodeproperties.isMark));
                    this.isBase = !this.isMark;
                    this.isLigature = this.codePoints.length > 1;
                    this.markAttachmentType = 0;
                  }
                }
                copy() {
                  return new $f22bb23c9fd478d8$export$2e2bcd8739ae039(this._font, this.id, this.codePoints, this.features);
                }
                constructor(font, id, codePoints = [], features) {
                  this._font = font;
                  this.codePoints = codePoints;
                  this.id = id;
                  this.features = {};
                  if (Array.isArray(features)) for (let i = 0; i < features.length; i++) {
                    let feature = features[i];
                    this.features[feature] = true;
                  }
                  else if (typeof features === "object") Object.assign(this.features, features);
                  this.ligatureID = null;
                  this.ligatureComponent = null;
                  this.isLigated = false;
                  this.cursiveAttachment = null;
                  this.markAttachment = null;
                  this.shaperInfo = null;
                  this.substituted = false;
                  this.isMultiplied = false;
                }
              }
              class $fa1d9fd80dd7279e$export$2e2bcd8739ae039 extends (0, $d28fb665ee343afc$export$2e2bcd8739ae039) {
                static planFeatures(plan) {
                  plan.add([
                    "ljmo",
                    "vjmo",
                    "tjmo"
                  ], false);
                }
                static assignFeatures(plan, glyphs) {
                  let state = 0;
                  let i = 0;
                  while (i < glyphs.length) {
                    let action;
                    let glyph = glyphs[i];
                    let code = glyph.codePoints[0];
                    let type = $fa1d9fd80dd7279e$var$getType(code);
                    [action, state] = $fa1d9fd80dd7279e$var$STATE_TABLE[state][type];
                    switch (action) {
                      case $fa1d9fd80dd7279e$var$DECOMPOSE:
                        if (!plan.font.hasGlyphForCodePoint(code)) i = $fa1d9fd80dd7279e$var$decompose(glyphs, i, plan.font);
                        break;
                      case $fa1d9fd80dd7279e$var$COMPOSE:
                        i = $fa1d9fd80dd7279e$var$compose(glyphs, i, plan.font);
                        break;
                      case $fa1d9fd80dd7279e$var$TONE_MARK:
                        $fa1d9fd80dd7279e$var$reorderToneMark(glyphs, i, plan.font);
                        break;
                      case $fa1d9fd80dd7279e$var$INVALID:
                        i = $fa1d9fd80dd7279e$var$insertDottedCircle(glyphs, i, plan.font);
                        break;
                    }
                    i++;
                  }
                }
              }
              (0, $gfJaN$swchelperscjs_define_propertycjs._)($fa1d9fd80dd7279e$export$2e2bcd8739ae039, "zeroMarkWidths", "NONE");
              const $fa1d9fd80dd7279e$var$HANGUL_BASE = 44032;
              const $fa1d9fd80dd7279e$var$HANGUL_END = 55204;
              const $fa1d9fd80dd7279e$var$HANGUL_COUNT = $fa1d9fd80dd7279e$var$HANGUL_END - $fa1d9fd80dd7279e$var$HANGUL_BASE + 1;
              const $fa1d9fd80dd7279e$var$L_BASE = 4352;
              const $fa1d9fd80dd7279e$var$V_BASE = 4449;
              const $fa1d9fd80dd7279e$var$T_BASE = 4519;
              const $fa1d9fd80dd7279e$var$L_COUNT = 19;
              const $fa1d9fd80dd7279e$var$V_COUNT = 21;
              const $fa1d9fd80dd7279e$var$T_COUNT = 28;
              const $fa1d9fd80dd7279e$var$L_END = $fa1d9fd80dd7279e$var$L_BASE + $fa1d9fd80dd7279e$var$L_COUNT - 1;
              const $fa1d9fd80dd7279e$var$V_END = $fa1d9fd80dd7279e$var$V_BASE + $fa1d9fd80dd7279e$var$V_COUNT - 1;
              const $fa1d9fd80dd7279e$var$T_END = $fa1d9fd80dd7279e$var$T_BASE + $fa1d9fd80dd7279e$var$T_COUNT - 1;
              const $fa1d9fd80dd7279e$var$DOTTED_CIRCLE = 9676;
              const $fa1d9fd80dd7279e$var$isL = (code) => 4352 <= code && code <= 4447 || 43360 <= code && code <= 43388;
              const $fa1d9fd80dd7279e$var$isV = (code) => 4448 <= code && code <= 4519 || 55216 <= code && code <= 55238;
              const $fa1d9fd80dd7279e$var$isT = (code) => 4520 <= code && code <= 4607 || 55243 <= code && code <= 55291;
              const $fa1d9fd80dd7279e$var$isTone = (code) => 12334 <= code && code <= 12335;
              const $fa1d9fd80dd7279e$var$isLVT = (code) => $fa1d9fd80dd7279e$var$HANGUL_BASE <= code && code <= $fa1d9fd80dd7279e$var$HANGUL_END;
              const $fa1d9fd80dd7279e$var$isLV = (code) => code - $fa1d9fd80dd7279e$var$HANGUL_BASE < $fa1d9fd80dd7279e$var$HANGUL_COUNT && (code - $fa1d9fd80dd7279e$var$HANGUL_BASE) % $fa1d9fd80dd7279e$var$T_COUNT === 0;
              const $fa1d9fd80dd7279e$var$isCombiningL = (code) => $fa1d9fd80dd7279e$var$L_BASE <= code && code <= $fa1d9fd80dd7279e$var$L_END;
              const $fa1d9fd80dd7279e$var$isCombiningV = (code) => $fa1d9fd80dd7279e$var$V_BASE <= code && code <= $fa1d9fd80dd7279e$var$V_END;
              const $fa1d9fd80dd7279e$var$isCombiningT = (code) => $fa1d9fd80dd7279e$var$T_BASE + 1 && 1 <= code && code <= $fa1d9fd80dd7279e$var$T_END;
              const $fa1d9fd80dd7279e$var$X = 0;
              const $fa1d9fd80dd7279e$var$L = 1;
              const $fa1d9fd80dd7279e$var$V = 2;
              const $fa1d9fd80dd7279e$var$T = 3;
              const $fa1d9fd80dd7279e$var$LV = 4;
              const $fa1d9fd80dd7279e$var$LVT = 5;
              const $fa1d9fd80dd7279e$var$M = 6;
              function $fa1d9fd80dd7279e$var$getType(code) {
                if ($fa1d9fd80dd7279e$var$isL(code)) return $fa1d9fd80dd7279e$var$L;
                if ($fa1d9fd80dd7279e$var$isV(code)) return $fa1d9fd80dd7279e$var$V;
                if ($fa1d9fd80dd7279e$var$isT(code)) return $fa1d9fd80dd7279e$var$T;
                if ($fa1d9fd80dd7279e$var$isLV(code)) return $fa1d9fd80dd7279e$var$LV;
                if ($fa1d9fd80dd7279e$var$isLVT(code)) return $fa1d9fd80dd7279e$var$LVT;
                if ($fa1d9fd80dd7279e$var$isTone(code)) return $fa1d9fd80dd7279e$var$M;
                return $fa1d9fd80dd7279e$var$X;
              }
              const $fa1d9fd80dd7279e$var$NO_ACTION = 0;
              const $fa1d9fd80dd7279e$var$DECOMPOSE = 1;
              const $fa1d9fd80dd7279e$var$COMPOSE = 2;
              const $fa1d9fd80dd7279e$var$TONE_MARK = 4;
              const $fa1d9fd80dd7279e$var$INVALID = 5;
              const $fa1d9fd80dd7279e$var$STATE_TABLE = [
                //       X                 L                 V                T                  LV                LVT               M
                // State 0: start state
                [
                  [
                    $fa1d9fd80dd7279e$var$NO_ACTION,
                    0
                  ],
                  [
                    $fa1d9fd80dd7279e$var$NO_ACTION,
                    1
                  ],
                  [
                    $fa1d9fd80dd7279e$var$NO_ACTION,
                    0
                  ],
                  [
                    $fa1d9fd80dd7279e$var$NO_ACTION,
                    0
                  ],
                  [
                    $fa1d9fd80dd7279e$var$DECOMPOSE,
                    2
                  ],
                  [
                    $fa1d9fd80dd7279e$var$DECOMPOSE,
                    3
                  ],
                  [
                    $fa1d9fd80dd7279e$var$INVALID,
                    0
                  ]
                ],
                // State 1: <L>
                [
                  [
                    $fa1d9fd80dd7279e$var$NO_ACTION,
                    0
                  ],
                  [
                    $fa1d9fd80dd7279e$var$NO_ACTION,
                    1
                  ],
                  [
                    $fa1d9fd80dd7279e$var$COMPOSE,
                    2
                  ],
                  [
                    $fa1d9fd80dd7279e$var$NO_ACTION,
                    0
                  ],
                  [
                    $fa1d9fd80dd7279e$var$DECOMPOSE,
                    2
                  ],
                  [
                    $fa1d9fd80dd7279e$var$DECOMPOSE,
                    3
                  ],
                  [
                    $fa1d9fd80dd7279e$var$INVALID,
                    0
                  ]
                ],
                // State 2: <L,V> or <LV>
                [
                  [
                    $fa1d9fd80dd7279e$var$NO_ACTION,
                    0
                  ],
                  [
                    $fa1d9fd80dd7279e$var$NO_ACTION,
                    1
                  ],
                  [
                    $fa1d9fd80dd7279e$var$NO_ACTION,
                    0
                  ],
                  [
                    $fa1d9fd80dd7279e$var$COMPOSE,
                    3
                  ],
                  [
                    $fa1d9fd80dd7279e$var$DECOMPOSE,
                    2
                  ],
                  [
                    $fa1d9fd80dd7279e$var$DECOMPOSE,
                    3
                  ],
                  [
                    $fa1d9fd80dd7279e$var$TONE_MARK,
                    0
                  ]
                ],
                // State 3: <L,V,T> or <LVT>
                [
                  [
                    $fa1d9fd80dd7279e$var$NO_ACTION,
                    0
                  ],
                  [
                    $fa1d9fd80dd7279e$var$NO_ACTION,
                    1
                  ],
                  [
                    $fa1d9fd80dd7279e$var$NO_ACTION,
                    0
                  ],
                  [
                    $fa1d9fd80dd7279e$var$NO_ACTION,
                    0
                  ],
                  [
                    $fa1d9fd80dd7279e$var$DECOMPOSE,
                    2
                  ],
                  [
                    $fa1d9fd80dd7279e$var$DECOMPOSE,
                    3
                  ],
                  [
                    $fa1d9fd80dd7279e$var$TONE_MARK,
                    0
                  ]
                ]
              ];
              function $fa1d9fd80dd7279e$var$getGlyph(font, code, features) {
                return new (0, $f22bb23c9fd478d8$export$2e2bcd8739ae039)(font, font.glyphForCodePoint(code).id, [
                  code
                ], features);
              }
              function $fa1d9fd80dd7279e$var$decompose(glyphs, i, font) {
                let glyph = glyphs[i];
                let code = glyph.codePoints[0];
                let s = code - $fa1d9fd80dd7279e$var$HANGUL_BASE;
                let t = $fa1d9fd80dd7279e$var$T_BASE + s % $fa1d9fd80dd7279e$var$T_COUNT;
                s = s / $fa1d9fd80dd7279e$var$T_COUNT | 0;
                let l = $fa1d9fd80dd7279e$var$L_BASE + s / $fa1d9fd80dd7279e$var$V_COUNT | 0;
                let v = $fa1d9fd80dd7279e$var$V_BASE + s % $fa1d9fd80dd7279e$var$V_COUNT;
                if (!font.hasGlyphForCodePoint(l) || !font.hasGlyphForCodePoint(v) || t !== $fa1d9fd80dd7279e$var$T_BASE && !font.hasGlyphForCodePoint(t)) return i;
                let ljmo = $fa1d9fd80dd7279e$var$getGlyph(font, l, glyph.features);
                ljmo.features.ljmo = true;
                let vjmo = $fa1d9fd80dd7279e$var$getGlyph(font, v, glyph.features);
                vjmo.features.vjmo = true;
                let insert = [
                  ljmo,
                  vjmo
                ];
                if (t > $fa1d9fd80dd7279e$var$T_BASE) {
                  let tjmo = $fa1d9fd80dd7279e$var$getGlyph(font, t, glyph.features);
                  tjmo.features.tjmo = true;
                  insert.push(tjmo);
                }
                glyphs.splice(i, 1, ...insert);
                return i + insert.length - 1;
              }
              function $fa1d9fd80dd7279e$var$compose(glyphs, i, font) {
                let glyph = glyphs[i];
                let code = glyphs[i].codePoints[0];
                let type = $fa1d9fd80dd7279e$var$getType(code);
                let prev = glyphs[i - 1].codePoints[0];
                let prevType = $fa1d9fd80dd7279e$var$getType(prev);
                let lv, ljmo, vjmo, tjmo;
                if (prevType === $fa1d9fd80dd7279e$var$LV && type === $fa1d9fd80dd7279e$var$T) {
                  lv = prev;
                  tjmo = glyph;
                } else {
                  if (type === $fa1d9fd80dd7279e$var$V) {
                    ljmo = glyphs[i - 1];
                    vjmo = glyph;
                  } else {
                    ljmo = glyphs[i - 2];
                    vjmo = glyphs[i - 1];
                    tjmo = glyph;
                  }
                  let l = ljmo.codePoints[0];
                  let v = vjmo.codePoints[0];
                  if ($fa1d9fd80dd7279e$var$isCombiningL(l) && $fa1d9fd80dd7279e$var$isCombiningV(v)) lv = $fa1d9fd80dd7279e$var$HANGUL_BASE + ((l - $fa1d9fd80dd7279e$var$L_BASE) * $fa1d9fd80dd7279e$var$V_COUNT + (v - $fa1d9fd80dd7279e$var$V_BASE)) * $fa1d9fd80dd7279e$var$T_COUNT;
                }
                let t = tjmo && tjmo.codePoints[0] || $fa1d9fd80dd7279e$var$T_BASE;
                if (lv != null && (t === $fa1d9fd80dd7279e$var$T_BASE || $fa1d9fd80dd7279e$var$isCombiningT(t))) {
                  let s = lv + (t - $fa1d9fd80dd7279e$var$T_BASE);
                  if (font.hasGlyphForCodePoint(s)) {
                    let del = prevType === $fa1d9fd80dd7279e$var$V ? 3 : 2;
                    glyphs.splice(i - del + 1, del, $fa1d9fd80dd7279e$var$getGlyph(font, s, glyph.features));
                    return i - del + 1;
                  }
                }
                if (ljmo) ljmo.features.ljmo = true;
                if (vjmo) vjmo.features.vjmo = true;
                if (tjmo) tjmo.features.tjmo = true;
                if (prevType === $fa1d9fd80dd7279e$var$LV) {
                  $fa1d9fd80dd7279e$var$decompose(glyphs, i - 1, font);
                  return i + 1;
                }
                return i;
              }
              function $fa1d9fd80dd7279e$var$getLength(code) {
                switch ($fa1d9fd80dd7279e$var$getType(code)) {
                  case $fa1d9fd80dd7279e$var$LV:
                  case $fa1d9fd80dd7279e$var$LVT:
                    return 1;
                  case $fa1d9fd80dd7279e$var$V:
                    return 2;
                  case $fa1d9fd80dd7279e$var$T:
                    return 3;
                }
              }
              function $fa1d9fd80dd7279e$var$reorderToneMark(glyphs, i, font) {
                let glyph = glyphs[i];
                let code = glyphs[i].codePoints[0];
                if (font.glyphForCodePoint(code).advanceWidth === 0) return;
                let prev = glyphs[i - 1].codePoints[0];
                let len = $fa1d9fd80dd7279e$var$getLength(prev);
                glyphs.splice(i, 1);
                return glyphs.splice(i - len, 0, glyph);
              }
              function $fa1d9fd80dd7279e$var$insertDottedCircle(glyphs, i, font) {
                let glyph = glyphs[i];
                let code = glyphs[i].codePoints[0];
                if (font.hasGlyphForCodePoint($fa1d9fd80dd7279e$var$DOTTED_CIRCLE)) {
                  let dottedCircle = $fa1d9fd80dd7279e$var$getGlyph(font, $fa1d9fd80dd7279e$var$DOTTED_CIRCLE, glyph.features);
                  let idx = font.glyphForCodePoint(code).advanceWidth === 0 ? i : i + 1;
                  glyphs.splice(idx, 0, dottedCircle);
                  i++;
                }
                return i;
              }
              var $d22b56f2cf15e5ba$exports = {};
              $d22b56f2cf15e5ba$exports = JSON.parse('{"stateTable":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,14,15,16,17],[0,0,0,18,19,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,28,29,30,31,32,33,0,34,0,0,35,36,0,0,37,0],[0,0,0,38,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,39,0,0,0,40,41,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,12,43,0,0,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,0,43,0,0,0,0],[0,0,0,45,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,50,0,0,51,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,0],[0,0,0,53,54,55,56,57,58,0,59,0,0,60,61,0,0,62,0],[0,0,0,4,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,63,64,0,0,40,41,0,9,0,10,0,0,0,42,0,63,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,0,2,16,0],[0,0,0,18,65,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,0,0],[0,0,0,69,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,73,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,75,0,0,0,76,77,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,25,79,0,0,0,0],[0,0,0,18,19,20,74,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,81,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,86,0,0,87,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,88,0,0,0,0,0,0,0,0],[0,0,0,18,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,89,90,0,0,76,77,0,23,0,24,0,0,0,78,0,89,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,0,0],[0,0,0,94,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,96,0,0,0,97,98,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,35,100,0,0,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,102,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,107,0,0,108,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,109,0,0,0,0,0,0,0,0],[0,0,0,28,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,110,111,0,0,97,98,0,33,0,34,0,0,0,99,0,110,0,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,0,0],[0,0,0,0,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,0,0,115,116,117,118,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,39,0,122,0,123,123,8,9,0,10,0,0,0,42,0,39,0,0],[0,124,64,0,0,0,0,0,0,0,0,0,0,0,0,0,124,0,0],[0,39,0,0,0,121,125,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,126,126,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,47,47,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,128,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,129,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,50,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,134,0,0,0,0,0,0,0,0],[0,0,0,135,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,136,0,0,0,137,138,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,60,140,0,0,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,0,140,0,0,0,0],[0,0,0,142,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,147,0,0,148,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,149,0,0,0,0,0,0,0,0],[0,0,0,53,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,150,151,0,0,137,138,0,58,0,59,0,0,0,139,0,150,0,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,0,0],[0,0,0,155,116,156,157,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,75,3,4,5,159,160,8,161,0,162,0,11,12,163,0,75,16,0],[0,0,0,0,0,40,164,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,0,165,0,0,0,0],[0,124,64,0,0,40,164,0,9,0,10,0,0,0,42,0,124,0,0],[0,0,0,0,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,71,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,167,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,168,0,0,0,0,0,0,0,0],[0,0,0,0,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,0,79,0,0,0,0],[0,0,0,169,170,171,172,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,75,0,176,0,177,177,22,23,0,24,0,0,0,78,0,75,0,0],[0,178,90,0,0,0,0,0,0,0,0,0,0,0,0,0,178,0,0],[0,75,0,0,0,175,179,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,180,180,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,83,83,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,182,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,183,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,86,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,188,0,0,0,0,0,0,0,0],[0,0,0,189,170,190,191,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,76,193,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,0,194,0,0,0,0],[0,178,90,0,0,76,193,0,23,0,24,0,0,0,78,0,178,0,0],[0,0,0,0,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,195,196,197,198,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,96,0,202,0,203,203,32,33,0,34,0,0,0,99,0,96,0,0],[0,204,111,0,0,0,0,0,0,0,0,0,0,0,0,0,204,0,0],[0,96,0,0,0,201,205,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,206,206,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,104,104,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,208,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,209,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,107,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,214,0,0,0,0,0,0,0,0],[0,0,0,215,196,216,217,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,97,219,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,0,220,0,0,0,0],[0,204,111,0,0,97,219,0,33,0,34,0,0,0,99,0,204,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,223,0,0,0,40,224,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,119,225,0,0,0,0],[0,0,0,115,116,117,222,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,115,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,226,64,0,0,40,224,0,9,0,10,0,0,0,42,0,226,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,39,0,0,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,44,44,8,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,227,0,228,229,0,9,0,10,0,0,230,0,0,0,0,0],[0,39,0,122,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,231,231,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,131,131,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,234,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,235,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,0,0,240,241,242,243,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,136,0,247,0,248,248,57,58,0,59,0,0,0,139,0,136,0,0],[0,249,151,0,0,0,0,0,0,0,0,0,0,0,0,0,249,0,0],[0,136,0,0,0,246,250,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,251,251,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,144,144,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,253,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,254,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,147,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,259,0,0,0,0,0,0,0,0],[0,0,0,260,241,261,262,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,137,264,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,0,265,0,0,0,0],[0,249,151,0,0,137,264,0,58,0,59,0,0,0,139,0,249,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,158,225,0,0,0,0],[0,0,0,155,116,156,222,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,155,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,43,266,266,8,161,0,24,0,0,12,267,0,0,0,0],[0,75,0,176,43,268,268,269,161,0,24,0,0,0,267,0,75,0,0],[0,0,0,0,0,270,0,0,271,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,272,0,0,0,0,0,0,0,0],[0,273,274,0,0,40,41,0,9,0,10,0,0,0,42,0,273,0,0],[0,0,0,40,0,123,123,8,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,121,275,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,276,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,279,0,0,0,76,280,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,173,281,0,0,0,0],[0,0,0,169,170,171,278,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,169,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,282,90,0,0,76,280,0,23,0,24,0,0,0,78,0,282,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,75,0,0,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,80,80,22,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,283,0,284,285,0,23,0,24,0,0,286,0,0,0,0,0],[0,75,0,176,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,287,287,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,288,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,185,185,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,290,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,291,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,192,281,0,0,0,0],[0,0,0,189,170,190,278,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,189,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,76,0,177,177,22,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,175,296,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,299,0,0,0,97,300,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,199,301,0,0,0,0],[0,0,0,195,196,197,298,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,195,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,302,111,0,0,97,300,0,33,0,34,0,0,0,99,0,302,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,96,0,0,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,101,101,32,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,303,0,304,305,0,33,0,34,0,0,306,0,0,0,0,0],[0,96,0,202,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,307,307,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,308,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,211,211,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,310,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,311,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,218,301,0,0,0,0],[0,0,0,215,196,216,298,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,215,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,97,0,203,203,32,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,201,316,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,0,225,0,0,0,0],[0,0,0,317,318,319,320,8,9,0,10,0,0,321,322,0,0,16,0],[0,223,0,323,0,123,123,8,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,0,0,121,324,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,325,318,326,327,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,64,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,230,0,0,0,0,0],[0,0,0,227,0,228,121,0,9,0,10,0,0,230,0,0,0,0,0],[0,0,0,227,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46,0,0],[0,0,0,0,0,329,329,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,330,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,237,237,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,332,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,333,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,337,0,0,0,137,338,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,244,339,0,0,0,0],[0,0,0,240,241,242,336,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,240,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,340,151,0,0,137,338,0,58,0,59,0,0,0,139,0,340,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,136,0,0,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,141,141,57,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,341,0,342,343,0,58,0,59,0,0,344,0,0,0,0,0],[0,136,0,247,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,345,345,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,346,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,256,256,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,348,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,349,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,263,339,0,0,0,0],[0,0,0,260,241,261,336,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,260,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,137,0,248,248,57,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,246,354,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,126,126,8,23,0,0,0,0,0,0,0,0,0,0],[0,355,90,0,0,121,125,0,9,0,10,0,0,0,42,0,355,0,0],[0,0,0,0,0,356,356,269,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,357,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,270,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,363,0,0,0,0,0,0,0,0],[0,0,0,364,116,365,366,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,40,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,0,281,0,0,0,0],[0,0,0,369,370,371,372,22,23,0,24,0,0,373,374,0,0,27,0],[0,279,0,375,0,177,177,22,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,0,0,175,376,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,377,370,378,379,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,90,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,286,0,0,0,0,0],[0,0,0,283,0,284,175,0,23,0,24,0,0,286,0,0,0,0,0],[0,0,0,283,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,82,0,0],[0,0,0,0,0,381,381,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,382,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,293,293,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,384,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,385,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,76,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,0,301,0,0,0,0],[0,0,0,387,388,389,390,32,33,0,34,0,0,391,392,0,0,37,0],[0,299,0,393,0,203,203,32,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,0,0,201,394,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,395,388,396,397,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,111,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,306,0,0,0,0,0],[0,0,0,303,0,304,201,0,33,0,34,0,0,306,0,0,0,0,0],[0,0,0,303,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,103,0,0],[0,0,0,0,0,399,399,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,400,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,313,313,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,402,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,403,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,97,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,407,0,0,0,40,408,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,321,409,0,0,0,0],[0,0,0,317,318,319,406,8,9,0,10,0,0,321,322,0,0,16,0],[0,0,0,317,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,410,64,0,0,40,408,0,9,0,10,0,0,0,42,0,410,0,0],[0,223,0,0,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,323,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,328,409,0,0,0,0],[0,0,0,325,318,326,406,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,325,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,0,0,0,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0],[0,0,0,0,0,411,411,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,412,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,413,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,0,339,0,0,0,0],[0,0,0,414,415,416,417,57,58,0,59,0,0,418,419,0,0,62,0],[0,337,0,420,0,248,248,57,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,0,0,246,421,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,422,415,423,424,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,151,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,344,0,0,0,0,0],[0,0,0,341,0,342,246,0,58,0,59,0,0,344,0,0,0,0,0],[0,0,0,341,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,143,0,0],[0,0,0,0,0,426,426,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,427,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,351,351,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,429,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,430,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,137,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,432,116,433,434,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,0,0,180,180,269,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,359,359,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,437,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,438,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,443,274,0,0,0,0,0,0,0,0,0,0,0,0,0,443,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,367,225,0,0,0,0],[0,0,0,364,116,365,445,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,364,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,448,0,0,0,76,449,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,373,450,0,0,0,0],[0,0,0,369,370,371,447,22,23,0,24,0,0,373,374,0,0,27,0],[0,0,0,369,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,451,90,0,0,76,449,0,23,0,24,0,0,0,78,0,451,0,0],[0,279,0,0,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,375,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,380,450,0,0,0,0],[0,0,0,377,370,378,447,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,377,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,0,0,0,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,184,0,0],[0,0,0,0,0,452,452,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,453,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,454,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,457,0,0,0,97,458,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,391,459,0,0,0,0],[0,0,0,387,388,389,456,32,33,0,34,0,0,391,392,0,0,37,0],[0,0,0,387,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,460,111,0,0,97,458,0,33,0,34,0,0,0,99,0,460,0,0],[0,299,0,0,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,393,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,398,459,0,0,0,0],[0,0,0,395,388,396,456,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,395,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,0,0,0,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,210,0,0],[0,0,0,0,0,461,461,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,462,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,463,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,0,409,0,0,0,0],[0,0,0,464,465,466,467,8,9,0,10,0,0,468,469,0,0,16,0],[0,407,0,470,0,123,123,8,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,0,0,121,471,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,472,465,473,474,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,0,0,0,0,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,236,0,0],[0,0,0,0,0,0,476,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,479,0,0,0,137,480,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,418,481,0,0,0,0],[0,0,0,414,415,416,478,57,58,0,59,0,0,418,419,0,0,62,0],[0,0,0,414,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,482,151,0,0,137,480,0,58,0,59,0,0,0,139,0,482,0,0],[0,337,0,0,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,420,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,425,481,0,0,0,0],[0,0,0,422,415,423,478,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,422,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,0,0,0,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0],[0,0,0,0,0,483,483,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,484,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,485,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,435,225,0,0,0,0],[0,0,0,432,116,433,445,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,432,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,486,486,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,487,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,440,440,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,489,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,490,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,495,0,496,497,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,0,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,0,225,0,0,0,0],[0,0,0,0,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,0,450,0,0,0,0],[0,0,0,499,500,501,502,22,23,0,24,0,0,503,504,0,0,27,0],[0,448,0,505,0,177,177,22,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,0,0,175,506,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,507,500,508,509,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,0,0,0,0,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,292,0,0],[0,0,0,0,0,0,511,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,0,459,0,0,0,0],[0,0,0,512,513,514,515,32,33,0,34,0,0,516,517,0,0,37,0],[0,457,0,518,0,203,203,32,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,0,0,201,519,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,520,513,521,522,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,0,0,0,0,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,312,0,0],[0,0,0,0,0,0,524,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,527,0,0,0,40,528,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,468,529,0,0,0,0],[0,0,0,464,465,466,526,8,9,0,10,0,0,468,469,0,0,16,0],[0,0,0,464,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,530,64,0,0,40,528,0,9,0,10,0,0,0,42,0,530,0,0],[0,407,0,0,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,470,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,475,529,0,0,0,0],[0,0,0,472,465,473,526,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,472,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,0,0],[0,0,0,0,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,0,481,0,0,0,0],[0,0,0,531,532,533,534,57,58,0,59,0,0,535,536,0,0,62,0],[0,479,0,537,0,248,248,57,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,0,0,246,538,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,539,532,540,541,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,0,0,0,0,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,350,0,0],[0,0,0,0,0,0,543,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,358,0,0],[0,0,0,0,0,544,544,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,545,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,492,492,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,547,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,548,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,274,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,498,0,0,0,0,0],[0,0,0,495,0,496,368,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,495,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,553,0,0,0,76,554,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,503,555,0,0,0,0],[0,0,0,499,500,501,552,22,23,0,24,0,0,503,504,0,0,27,0],[0,0,0,499,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,556,90,0,0,76,554,0,23,0,24,0,0,0,78,0,556,0,0],[0,448,0,0,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,505,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,510,555,0,0,0,0],[0,0,0,507,500,508,552,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,507,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,76,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,559,0,0,0,97,560,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,516,561,0,0,0,0],[0,0,0,512,513,514,558,32,33,0,34,0,0,516,517,0,0,37,0],[0,0,0,512,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,562,111,0,0,97,560,0,33,0,34,0,0,0,99,0,562,0,0],[0,457,0,0,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,518,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,523,561,0,0,0,0],[0,0,0,520,513,521,558,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,520,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,97,0,0],[0,0,0,0,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,0,529,0,0,0,0],[0,0,0,563,66,564,565,8,9,0,10,0,0,566,68,0,0,16,0],[0,527,0,567,0,123,123,8,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,0,0,121,568,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,569,66,570,571,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,575,0,0,0,137,576,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,535,577,0,0,0,0],[0,0,0,531,532,533,574,57,58,0,59,0,0,535,536,0,0,62,0],[0,0,0,531,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,578,151,0,0,137,576,0,58,0,59,0,0,0,139,0,578,0,0],[0,479,0,0,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,537,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,542,577,0,0,0,0],[0,0,0,539,532,540,574,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,539,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,137,0,0],[0,0,0,0,0,0,0,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,439,0,0],[0,0,0,0,0,579,579,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,580,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,581,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,0,555,0,0,0,0],[0,0,0,582,91,583,584,22,23,0,24,0,0,585,93,0,0,27,0],[0,553,0,586,0,177,177,22,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,0,0,175,587,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,588,91,589,590,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,0,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,0,561,0,0,0,0],[0,0,0,592,112,593,594,32,33,0,34,0,0,595,114,0,0,37,0],[0,559,0,596,0,203,203,32,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,0,0,201,597,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,598,112,599,600,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,566,165,0,0,0,0],[0,0,0,563,66,564,67,8,9,0,10,0,0,566,68,0,0,16,0],[0,0,0,563,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,527,0,0,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,567,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,572,165,0,0,0,0],[0,0,0,569,66,570,67,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,569,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,0,577,0,0,0,0],[0,0,0,603,152,604,605,57,58,0,59,0,0,606,154,0,0,62,0],[0,575,0,607,0,248,248,57,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,0,0,246,608,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,609,152,610,611,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,0,0,0,0,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,491,0,0],[0,0,0,0,0,0,613,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,585,194,0,0,0,0],[0,0,0,582,91,583,92,22,23,0,24,0,0,585,93,0,0,27,0],[0,0,0,582,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,553,0,0,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,586,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,591,194,0,0,0,0],[0,0,0,588,91,589,92,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,588,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,595,220,0,0,0,0],[0,0,0,592,112,593,113,32,33,0,34,0,0,595,114,0,0,37,0],[0,0,0,592,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,559,0,0,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,596,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,601,220,0,0,0,0],[0,0,0,598,112,599,113,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,598,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,606,265,0,0,0,0],[0,0,0,603,152,604,153,57,58,0,59,0,0,606,154,0,0,62,0],[0,0,0,603,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,575,0,0,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,607,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,612,265,0,0,0,0],[0,0,0,609,152,610,153,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,609,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,549,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0]],"accepting":[false,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,false,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,false,false,true,false,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,false,false,true,true,false,false,true,true,true,false,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,false,false,false,false,false,false,false,true,true,false,false,true,true,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,false,true,true,false,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,false,true,true,true,true,true,false,true,true,false,true,true,true],"tags":[[],["broken_cluster"],["consonant_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["consonant_syllable"],["broken_cluster"],["symbol_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["broken_cluster"],["broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],[],["broken_cluster"],["symbol_cluster"],[],["symbol_cluster"],["symbol_cluster"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["symbol_cluster"],["symbol_cluster"],["symbol_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],["symbol_cluster"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],[],["broken_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],[],["consonant_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],[],["vowel_syllable"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],[],[],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],["standalone_cluster"],[],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],[],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],[],[],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],[],[],[],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],["consonant_syllable"],["vowel_syllable"],["standalone_cluster"]]}');
              var $79781f8c452881c2$exports = {};
              $79781f8c452881c2$exports = JSON.parse('{"categories":["O","IND","S","GB","B","FM","CGJ","VMAbv","VMPst","VAbv","VPst","CMBlw","VPre","VBlw","H","VMBlw","CMAbv","MBlw","CS","R","SUB","MPst","MPre","FAbv","FPst","FBlw","null","SMAbv","SMBlw","VMPre","ZWNJ","ZWJ","WJ","M","VS","N","HN","MAbv"],"decompositions":{"2507":[2503,2494],"2508":[2503,2519],"2888":[2887,2902],"2891":[2887,2878],"2892":[2887,2903],"3018":[3014,3006],"3019":[3015,3006],"3020":[3014,3031],"3144":[3142,3158],"3264":[3263,3285],"3271":[3270,3285],"3272":[3270,3286],"3274":[3270,3266],"3275":[3270,3266,3285],"3402":[3398,3390],"3403":[3399,3390],"3404":[3398,3415],"3546":[3545,3530],"3548":[3545,3535],"3549":[3545,3535,3530],"3550":[3545,3551],"3635":[3661,3634],"3763":[3789,3762],"3955":[3953,3954],"3957":[3953,3956],"3958":[4018,3968],"3959":[4018,3953,3968],"3960":[4019,3968],"3961":[4019,3953,3968],"3969":[3953,3968],"6971":[6970,6965],"6973":[6972,6965],"6976":[6974,6965],"6977":[6975,6965],"6979":[6978,6965],"69934":[69937,69927],"69935":[69938,69927],"70475":[70471,70462],"70476":[70471,70487],"70843":[70841,70842],"70844":[70841,70832],"70846":[70841,70845],"71098":[71096,71087],"71099":[71097,71087]},"stateTable":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[2,2,3,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,17,18,11,19,20,21,22,0,0,0,23,0,0,2,0,0,24,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,0,27,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,39,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,49,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,53,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,51,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,54,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0]],"accepting":[false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true],"tags":[[],["broken_cluster"],["independent_cluster"],["symbol_cluster"],["standard_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["numeral_cluster"],["broken_cluster"],["independent_cluster"],["symbol_cluster"],["symbol_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["virama_terminated_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["broken_cluster"],["broken_cluster"],["numeral_cluster"],["number_joiner_terminated_cluster"],["standard_cluster"],["standard_cluster"],["numeral_cluster"]]}');
              const $79e3b6f2c331d0bf$export$a513ea61a7bee91c = {
                X: 1,
                C: 2,
                V: 4,
                N: 8,
                H: 16,
                ZWNJ: 32,
                ZWJ: 64,
                M: 128,
                SM: 256,
                VD: 512,
                A: 1024,
                Placeholder: 2048,
                Dotted_Circle: 4096,
                RS: 8192,
                Coeng: 16384,
                Repha: 32768,
                Ra: 65536,
                CM: 131072,
                Symbol: 262144
                // Avagraha, etc that take marks (SM,A,VD).
              };
              const $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0 = {
                Start: 1,
                Ra_To_Become_Reph: 2,
                Pre_M: 4,
                Pre_C: 8,
                Base_C: 16,
                After_Main: 32,
                Above_C: 64,
                Before_Sub: 128,
                Below_C: 256,
                After_Sub: 512,
                Before_Post: 1024,
                Post_C: 2048,
                After_Post: 4096,
                Final_C: 8192,
                SMVD: 16384,
                End: 32768
              };
              const $79e3b6f2c331d0bf$export$8519deaa7de2b07 = $79e3b6f2c331d0bf$export$a513ea61a7bee91c.C | $79e3b6f2c331d0bf$export$a513ea61a7bee91c.Ra | $79e3b6f2c331d0bf$export$a513ea61a7bee91c.CM | $79e3b6f2c331d0bf$export$a513ea61a7bee91c.V | $79e3b6f2c331d0bf$export$a513ea61a7bee91c.Placeholder | $79e3b6f2c331d0bf$export$a513ea61a7bee91c.Dotted_Circle;
              const $79e3b6f2c331d0bf$export$bbcd928767338e0d = $79e3b6f2c331d0bf$export$a513ea61a7bee91c.ZWJ | $79e3b6f2c331d0bf$export$a513ea61a7bee91c.ZWNJ;
              const $79e3b6f2c331d0bf$export$ca9599b2a300afc = $79e3b6f2c331d0bf$export$a513ea61a7bee91c.H | $79e3b6f2c331d0bf$export$a513ea61a7bee91c.Coeng;
              const $79e3b6f2c331d0bf$export$e99d119da76a0fc5 = {
                Default: {
                  hasOldSpec: false,
                  virama: 0,
                  basePos: "Last",
                  rephPos: $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0.Before_Post,
                  rephMode: "Implicit",
                  blwfMode: "Pre_And_Post"
                },
                Devanagari: {
                  hasOldSpec: true,
                  virama: 2381,
                  basePos: "Last",
                  rephPos: $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0.Before_Post,
                  rephMode: "Implicit",
                  blwfMode: "Pre_And_Post"
                },
                Bengali: {
                  hasOldSpec: true,
                  virama: 2509,
                  basePos: "Last",
                  rephPos: $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0.After_Sub,
                  rephMode: "Implicit",
                  blwfMode: "Pre_And_Post"
                },
                Gurmukhi: {
                  hasOldSpec: true,
                  virama: 2637,
                  basePos: "Last",
                  rephPos: $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0.Before_Sub,
                  rephMode: "Implicit",
                  blwfMode: "Pre_And_Post"
                },
                Gujarati: {
                  hasOldSpec: true,
                  virama: 2765,
                  basePos: "Last",
                  rephPos: $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0.Before_Post,
                  rephMode: "Implicit",
                  blwfMode: "Pre_And_Post"
                },
                Oriya: {
                  hasOldSpec: true,
                  virama: 2893,
                  basePos: "Last",
                  rephPos: $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0.After_Main,
                  rephMode: "Implicit",
                  blwfMode: "Pre_And_Post"
                },
                Tamil: {
                  hasOldSpec: true,
                  virama: 3021,
                  basePos: "Last",
                  rephPos: $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0.After_Post,
                  rephMode: "Implicit",
                  blwfMode: "Pre_And_Post"
                },
                Telugu: {
                  hasOldSpec: true,
                  virama: 3149,
                  basePos: "Last",
                  rephPos: $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0.After_Post,
                  rephMode: "Explicit",
                  blwfMode: "Post_Only"
                },
                Kannada: {
                  hasOldSpec: true,
                  virama: 3277,
                  basePos: "Last",
                  rephPos: $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0.After_Post,
                  rephMode: "Implicit",
                  blwfMode: "Post_Only"
                },
                Malayalam: {
                  hasOldSpec: true,
                  virama: 3405,
                  basePos: "Last",
                  rephPos: $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0.After_Main,
                  rephMode: "Log_Repha",
                  blwfMode: "Pre_And_Post"
                },
                // Handled by UniversalShaper
                // Sinhala: {
                //   hasOldSpec: false,
                //   virama: 0x0DCA,
                //   basePos: 'Last_Sinhala',
                //   rephPos: POSITIONS.After_Main,
                //   rephMode: 'Explicit',
                //   blwfMode: 'Pre_And_Post'
                // },
                Khmer: {
                  hasOldSpec: false,
                  virama: 6098,
                  basePos: "First",
                  rephPos: $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0.Ra_To_Become_Reph,
                  rephMode: "Vis_Repha",
                  blwfMode: "Pre_And_Post"
                }
              };
              const $79e3b6f2c331d0bf$export$f647c9cfdd77d95a = {
                // Khmer
                6078: [
                  6081,
                  6078
                ],
                6079: [
                  6081,
                  6079
                ],
                6080: [
                  6081,
                  6080
                ],
                6084: [
                  6081,
                  6084
                ],
                6085: [
                  6081,
                  6085
                ]
              };
              const { decompositions: $d203e6b9523d0071$var$decompositions } = (0, $parcel$interopDefault($79781f8c452881c2$exports));
              const $d203e6b9523d0071$var$trie = new (0, $parcel$interopDefault($gfJaN$unicodetrie))((0, $66a5b9fb5318558a$export$94fdf11bafc8de6b)("AAARAAAAAABg2AAAAWYPmfDtnXuMXFUdx+/uzs7M7szudAtECGJRIMRQbUAithQWkGAKiVhNpFVRRAmIQVCDkDYICGotIA9BTCz8IeUviv7BQ2PBtBIRLBBQIWAUsKg1BKxRAqIgfs/cc+aeOXPej3tnZX7JJ/dxzj3nd36/8753Z5fUsuxgsAwcAU4Gp4BPgM+Cd4P3RjieDs4GXwLrHJ5bDy4DG8A14LvgZrAZbAF3gns0z18ALgY/B78C94NHwBPgabAE/AX8DbwM5sF/QX0yD5vFcU/wVnAgWAoOAyvAceBE8CGwBpwGzgJfAF8BXwXfAFeC68EmsBlsAXeCreA+8CB4DDwF/gh2gd3gFfAGmKxn2QzYC+wHDgRLweFgJTgWrKrnuq/GcQ04jV6fheN54EJwEbgcXAG+Q8O/j+Mt4DZwB9haz8t9Hz3a8iCN/xiOvwRP0evH6fE68AzOH+Ke2eWYhw3PcGnuxvkr4A3QaGRZB7wFLAEHg2XgiEZ/fHKcp/ceBh/A+cngFPCpRm6vM3E8l8a5gN67GMdvgqsbeX2ap9yI601gM7gN3AG20mfuo8cdOP6GpvdUg9oKxz839GV90RDO2/glxN1B790NXsN1rZll7WYRdw+c70uvTwIHNAfTO0RyL5TDmnnbc3lmRQI9UnM0dD5eovfz4FpJ/BNpXNYWV+N6Lfg0hY97JK1vn+Pur9DoQur2F7m436bHDUK8C5t5/8vruo4+97WmXG+GLmzEiBF+PDwEOowYMWLEiBEjRoxYeBw5BDqIPEfXut9yWN+vVNxfrnnmWqR/PdgENoMt4E5wD9gOHgCPgifBs2BXM99b2o3jP8F/wMRUlrXAHNgHvH0q3895J46HguXgWHAGLctmLv9VuL96qnp7jxgxYsSbCbJvuRZ97/tqxT59VVRtixEjRsThBG7OSt5zzoPT0M+cBc4T5noXOs79TqLHeZrHUeCSqeJ96gacXy2kecNU8V6Hh7yXuQlhtw7B/PO1RTkr52Aj8JNFZjYg3gOKuC/g/v6Ls2wNuAY8urg//PcIb+6RZXuDNeCS6SzbBrJWlh0DLiFHco8ed9IjzzvaWfa9sZzTcf6D9mCcnbg3PlNcH4fzS8F2MDaLdQG4dLZIJxbbaZqv4ri8k58f3+mPs66T6/TTzqDeI0aMGDGiHP5dcR8ce/xxYcWi6vOfr725uRzcjnngXVOD61Hync+9uL+Nmyfej/NHpvL56A5Jeuz7uyfo+pqcPz2Vf1NH0ttJ03pekt8SmuY/EPYy9zzbN319ym/9TL6ZIt9MHCXRdxJtoAkWTRdz472n87D9cTwYLJvuz++I6WIePo/zE8AHp4v8WLyP0nufnM6/+zoDx8+DL08P6r9+urheRtO+jD6/cdrsx3mqu8w+xH4PScKIXa5D2jeCm8Et4DbwI/BjcC/4BXgI/Bb8DuwEu8Bu8Ap4A9RaRZptnO8J9gUHgEPAoWA5OLY1qMO90GEV7q+mYWtxPBWcIYnL4p+DsPNbxfVFOP86uAr8DNc34HgTDb8Vx9sVaRFI/LtagzYjnCqpb908EX87eBA8Bh4Hf2jle/9/wvGFVv787rrZZy8h7qtgDOuFOmiBuXYRvg/O9wMHgXeB97SLspk4sq0OI/q9v13+ek+sh3zYSRp9jrYorw9ll1/GRzR+KotYZSHf8laVP2lvpA/8OGdPMk59hqtXZ+L8nHbxvWwqO65ryu+fT3VZz+l4dET7L0R072ljsMyzTpaJqQxsbL8M9WajY789DO85XMp/Dcp3Qztdn+9qf/a97ZWK8PXc3G+TpC/nv8Mncy7ZvICF302P5O+aNiOtLdTXd+D4Q7DVwfcvWvx9zTEJ/o5iG3R8YAjGNFseha5PGuZKz7b7xxXbOrXMcu5eJSo//rXdH/73Enz6L1q/X+fyIu8wZGtNBmkjkzNZNgP2AvuBg2bysKUzduXn/66JtNeN4PCZvO0/x7Ujdn4VnYOvRJzjZ/I+9sQZeftX2Tc1RPcPz/Tf4/si0g+t5Mq+kfZjZL34Mc5ul3PPnE7TOxvHK2qDaZ+L++db2HyYqMo/qVnb/P8uH8/rmnFxR0k6DCu/rjj/RxT7KGUSWgbd+LMQuEgYB1zsk2qtvJD8v5AhdfdttbEunSxbcJD9Zf7chqp1Hlbe7FK1/aPVTfp7FgtC1yGGiSncFK/DhZvi+epZta0WWjlsfDZMyPRdSPrryqSSKnXx1bkq/Ye9TlRpk7Lrjq1UrfdC9X+MtKqwP6+3a/4pJFUZF0pZZpv91MYjMBaRRXbxpho5zQmUY3F+Pt4o7rvQrBXPdm00TaE24uMadaM2meLSI7iu071t3er3b6ZLi8JEde3qw+6zGv+ycF5kaRBh/m1T/7Yl/mMyTuMwadP4xL9ifjJpNwbvDZRJ8G8vnqV/Wf12aa/kyOdl69+BspTsXzGueE6E+JfZnvmXIfNPW+FfXkjb1YmqPNpnLP3b61fHCj/X5tzGANf2y3yqvC7Jv7btV4TVbdammI9l/g0dS5lNxLrk2j9r8xjjxhBQnygg0lgg/bOrfyct+udJi/Yrk0lFnxC7f+5kRbsNmcexfrubt0X/rGvLqrGSnYv3ZPHEe8r7lvMvUfi2LOu/2dg8LrRtQt2yfcv8r5IU70VkIs6nbebUXf0M/o7Znl39Sdoz+X1oEb5N8ffF67qhPfPP6eoUbxf+GRf/6sRnvaSdmw+Bf1VxmbD+2sa//DU7t/Gv2PfKpKdrBP92Ojk+IvqX16ks/2qxbL8EZnc2HqsgYuqPuzZV+I3RbujbDm+T0PmWCVO/5jqftp1zy+wSA6s0JWtp2z5e1oZV+yMsjB3ZXolsv0Ulrv01v3/iKrF94Qtbt9siCnmeb6fjjf59KnLk1xaEbvtvFnFirGvEOqmycQrbm/IMsXd3P28uh4nM3swXRER717OiX8kc7K2qqyn2p3maFGU/aruP5VCv+PraoTYU8yUmmbDwcYo6pusnM486xdoga4dkPCb1pK7Sfc6ebvkd4qeAtQcd/N63bB3lU3dlUnUf38VyvqCqK7JxlNSd7lydrDlm+/uqHiRvl30Nrp/n9zpkZRjoJ3V1diyP05rIYXHYs+w+D5+WMS8b5gZtKcuX0KT5d/WwtB97VnyvY6rjMukI56HI0rFJPwt8PjT/1OXzSbcMeEmdh294qvKK4rNu7j4n3LNZg8TKXwafv025U+XvKjHsT8Q7/7LGaJt9lAh7Asz3uv0XEX6t0duDoWN/93wmh92XpUHmCKb9GALbG+rZP3AfNbQPKKv/jpF/bP0JXfuW1QYk7dhljcyvk5mw+933Hpo1g26PQ2ZP6zVmTJt47P25jncD9vPwGS+q9QS/V6RaY8j8K8LmvUr9HfYCpH5OWL9lZY+Sv6pesHCJHbtrf9k6etZvf0G1L0ja4cAe1UT/s3zdCe3/Q5/n372wMc97/E1Qh0Tbmfwh3m/V9On72tNnrCF1sJkVe1EyXMdBa7+lHMsk44zMF6St9e2djNnbm8ybpHkq+gbbemMaH0UZmD8obKGrk7r+nt+3bE7o83YZp/vqOKdv6PzJNN6mTJsI/51XR7i2ZrGA5B6zFwnjzxmqPjaGfW3tZNrz1eljq29mOOqeCfF/irRt87PNw0uXSVAvrmOMNT569MptsYaV0sic/wbY13e8hPrb9K2ySUJ0j6G/Lu0U4qpTrR23jMp6m5hU+YTaWCeh9aIsm/rqUHV4bFv42kgnZdfH1PUj1D7DVH9d8khRN1zFRl/+/TW//qxL1uH83+mk3H+SvRtS2TDU90nX2TpM6/1xzZpZtoYdK763dqlz0f6uNeFehcs+H/nbGP77MpX06n/ofpzP+tVmTUvRtVuX/cjS67OE5kRBrxyJ+w/dPo7r+9cO1160e3gqu0S2uW7PjN/L6ns/UfMf10Lai87frJ+3KndAfc8yTf1M3T4s6qm4/yh7/2GSkG8UMw//DvRLgbYZSEOxr0LCWvRdjfh9XGzfqN4NivfZd7rsmFp08zmbssrKJEuTfVMZopdpbuwSrhNv3/N2s+0PDG3KNB6RMrFvJHv6B85HXObAoWsd3zm3i+6uZYytv+5+pohbpo6+tpZJFfmGlrcMf4c8b1Pe2OUIsaXJrinCTfaxtZOt+NYnU3hIfQlN20Z/1+dt7JaqLsbIzycNWZmrlNg2Dc2/LJ1T+T6WrrYSml4Ku7ik7yIx2opJD51vU9UfVRmrqL8u/olZj0PyCLV5irxcdKoi/6rKb8qTrHsnhW9jyZH/nSpeWDzxd9769uQ016lgUuf2pAfKPhu2FpfZL2Yb9snLNl/fNIepXaUsj4vNXCXUZ75px8ojNP8UPvAta2g6fb+F1ckZuneshv1vGXXDeyRRrN/bBPS1Jul+l+7zW86R7Wv63WXyDpt/RxraRjvC+TC3O61/Sqj/prag8x372yQivn+XwudrI2X2E2KdtJEov52e0L+uv4FO3p/rvssgsL8F4d/z9PzlWS94m8fqS3361Fi+6qaVYHwi9Yz4iH2fobIj+45cpz/TUaarr/4+z+vaWtVtyAX2d1LG8W9C3f+F1mnf36/k4w3YPrLv+XBVXCJs3cr+n4MKJuLv/fN9GhNdXVP5pJMN9vFi3rpv3/r8Ywg3SYp66zNOsO8QGcxPpnmRS/1mvmJjju3v7absI2xspQrvs1dNbjOj/wP7h1RlZyKGy8occ408UL8En4v6xfC/K3z52XzJd62T8vuZGGsxo/6O46ntmNqqFb/jps2/hHV4rPKH0svT4pstU7t2tZ9u/ZdqbJL1MwP6O86Fyt4jYaIrGz9mjEt8lFL4PtVE6votG2P6fpdf/GZRse7s3bf4BtSl/DIbKMctx++Z+8o6K6z9FPOwKsRmXiaNl7C+6NYRpjlbqG1j72f49qsuY4brd/amb4ZVc8TQ+sSH985LrEe8iPWJnfPrJRbWbb+dwn4x6o+r/aS2S7w3qWt//LnYz2ntE0vH1uDcyKatx1rH+EiMPEN1SZG/iz6+9o01Rob6O7Q+xLZ1jHobK61U+pWVvo2EpuWqzzD6Poa+pvhli0wn8Zq/72Mzm2d90o5VN1x9ZKuzbTgvqWwUIin8FSpl1CXXvFRxU0iozVPYJDRtF3uFphn6XAyJUUdD7SjTJ8v6n9fVbVObkKWp001lc9VRlqdOf5v0ZM+bymdbfp1NfG0bq27Y5JMyfxeJkU6o/inKH8O2Zfgidb6h/g3VJ7QcVbWL0Pxt6rlrPqa4KfQ25a2zl4/E8GdM/4fK/wA="));
              const $d203e6b9523d0071$var$stateMachine = new (0, $parcel$interopDefault($gfJaN$dfa))((0, $parcel$interopDefault($d22b56f2cf15e5ba$exports)));
              class $d203e6b9523d0071$export$2e2bcd8739ae039 extends (0, $d28fb665ee343afc$export$2e2bcd8739ae039) {
                static planFeatures(plan) {
                  plan.addStage($d203e6b9523d0071$var$setupSyllables);
                  plan.addStage([
                    "locl",
                    "ccmp"
                  ]);
                  plan.addStage($d203e6b9523d0071$var$initialReordering);
                  plan.addStage("nukt");
                  plan.addStage("akhn");
                  plan.addStage("rphf", false);
                  plan.addStage("rkrf");
                  plan.addStage("pref", false);
                  plan.addStage("blwf", false);
                  plan.addStage("abvf", false);
                  plan.addStage("half", false);
                  plan.addStage("pstf", false);
                  plan.addStage("vatu");
                  plan.addStage("cjct");
                  plan.addStage("cfar", false);
                  plan.addStage($d203e6b9523d0071$var$finalReordering);
                  plan.addStage({
                    local: [
                      "init"
                    ],
                    global: [
                      "pres",
                      "abvs",
                      "blws",
                      "psts",
                      "haln",
                      "dist",
                      "abvm",
                      "blwm",
                      "calt",
                      "clig"
                    ]
                  });
                  plan.unicodeScript = $e38a1a895f6aeb54$export$ce50e82f12a827a4(plan.script);
                  plan.indicConfig = (0, $79e3b6f2c331d0bf$export$e99d119da76a0fc5)[plan.unicodeScript] || (0, $79e3b6f2c331d0bf$export$e99d119da76a0fc5).Default;
                  plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== "2";
                }
                static assignFeatures(plan, glyphs) {
                  for (let i = glyphs.length - 1; i >= 0; i--) {
                    let codepoint = glyphs[i].codePoints[0];
                    let d = (0, $79e3b6f2c331d0bf$export$f647c9cfdd77d95a)[codepoint] || $d203e6b9523d0071$var$decompositions[codepoint];
                    if (d) {
                      let decomposed = d.map((c) => {
                        let g = plan.font.glyphForCodePoint(c);
                        return new (0, $f22bb23c9fd478d8$export$2e2bcd8739ae039)(plan.font, g.id, [
                          c
                        ], glyphs[i].features);
                      });
                      glyphs.splice(i, 1, ...decomposed);
                    }
                  }
                }
              }
              (0, $gfJaN$swchelperscjs_define_propertycjs._)($d203e6b9523d0071$export$2e2bcd8739ae039, "zeroMarkWidths", "NONE");
              function $d203e6b9523d0071$var$indicCategory(glyph) {
                return $d203e6b9523d0071$var$trie.get(glyph.codePoints[0]) >> 8;
              }
              function $d203e6b9523d0071$var$indicPosition(glyph) {
                return 1 << ($d203e6b9523d0071$var$trie.get(glyph.codePoints[0]) & 255);
              }
              class $d203e6b9523d0071$var$IndicInfo {
                constructor(category, position, syllableType, syllable) {
                  this.category = category;
                  this.position = position;
                  this.syllableType = syllableType;
                  this.syllable = syllable;
                }
              }
              function $d203e6b9523d0071$var$setupSyllables(font, glyphs) {
                let syllable = 0;
                let last = 0;
                for (let [start, end, tags] of $d203e6b9523d0071$var$stateMachine.match(glyphs.map($d203e6b9523d0071$var$indicCategory))) {
                  if (start > last) {
                    ++syllable;
                    for (let i = last; i < start; i++) glyphs[i].shaperInfo = new $d203e6b9523d0071$var$IndicInfo((0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).X, (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).End, "non_indic_cluster", syllable);
                  }
                  ++syllable;
                  for (let i = start; i <= end; i++) glyphs[i].shaperInfo = new $d203e6b9523d0071$var$IndicInfo(1 << $d203e6b9523d0071$var$indicCategory(glyphs[i]), $d203e6b9523d0071$var$indicPosition(glyphs[i]), tags[0], syllable);
                  last = end + 1;
                }
                if (last < glyphs.length) {
                  ++syllable;
                  for (let i = last; i < glyphs.length; i++) glyphs[i].shaperInfo = new $d203e6b9523d0071$var$IndicInfo((0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).X, (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).End, "non_indic_cluster", syllable);
                }
              }
              function $d203e6b9523d0071$var$isConsonant(glyph) {
                return glyph.shaperInfo.category & (0, $79e3b6f2c331d0bf$export$8519deaa7de2b07);
              }
              function $d203e6b9523d0071$var$isJoiner(glyph) {
                return glyph.shaperInfo.category & (0, $79e3b6f2c331d0bf$export$bbcd928767338e0d);
              }
              function $d203e6b9523d0071$var$isHalantOrCoeng(glyph) {
                return glyph.shaperInfo.category & (0, $79e3b6f2c331d0bf$export$ca9599b2a300afc);
              }
              function $d203e6b9523d0071$var$wouldSubstitute(glyphs, feature) {
                for (let glyph of glyphs) glyph.features = {
                  [feature]: true
                };
                let GSUB = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;
                GSUB.applyFeatures([
                  feature
                ], glyphs);
                return glyphs.length === 1;
              }
              function $d203e6b9523d0071$var$consonantPosition(font, consonant, virama) {
                let glyphs = [
                  virama,
                  consonant,
                  virama
                ];
                if ($d203e6b9523d0071$var$wouldSubstitute(glyphs.slice(0, 2), "blwf") || $d203e6b9523d0071$var$wouldSubstitute(glyphs.slice(1, 3), "blwf")) return (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Below_C;
                else if ($d203e6b9523d0071$var$wouldSubstitute(glyphs.slice(0, 2), "pstf") || $d203e6b9523d0071$var$wouldSubstitute(glyphs.slice(1, 3), "pstf")) return (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Post_C;
                else if ($d203e6b9523d0071$var$wouldSubstitute(glyphs.slice(0, 2), "pref") || $d203e6b9523d0071$var$wouldSubstitute(glyphs.slice(1, 3), "pref")) return (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Post_C;
                return (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Base_C;
              }
              function $d203e6b9523d0071$var$initialReordering(font, glyphs, plan) {
                let indicConfig = plan.indicConfig;
                let features = font._layoutEngine.engine.GSUBProcessor.features;
                let dottedCircle = font.glyphForCodePoint(9676).id;
                let virama = font.glyphForCodePoint(indicConfig.virama).id;
                if (virama) {
                  let info = new (0, $f22bb23c9fd478d8$export$2e2bcd8739ae039)(font, virama, [
                    indicConfig.virama
                  ]);
                  for (let i = 0; i < glyphs.length; i++) if (glyphs[i].shaperInfo.position === (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Base_C) glyphs[i].shaperInfo.position = $d203e6b9523d0071$var$consonantPosition(font, glyphs[i].copy(), info);
                }
                for (let start = 0, end = $d203e6b9523d0071$var$nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = $d203e6b9523d0071$var$nextSyllable(glyphs, start)) {
                  let { category, syllableType } = glyphs[start].shaperInfo;
                  if (syllableType === "symbol_cluster" || syllableType === "non_indic_cluster") continue;
                  if (syllableType === "broken_cluster" && dottedCircle) {
                    let g = new (0, $f22bb23c9fd478d8$export$2e2bcd8739ae039)(font, dottedCircle, [
                      9676
                    ]);
                    g.shaperInfo = new $d203e6b9523d0071$var$IndicInfo(1 << $d203e6b9523d0071$var$indicCategory(g), $d203e6b9523d0071$var$indicPosition(g), glyphs[start].shaperInfo.syllableType, glyphs[start].shaperInfo.syllable);
                    let i = start;
                    while (i < end && glyphs[i].shaperInfo.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).Repha) i++;
                    glyphs.splice(i++, 0, g);
                    end++;
                  }
                  let base = end;
                  let limit = start;
                  let hasReph = false;
                  if (indicConfig.rephPos !== (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph && features.rphf && start + 3 <= end && (indicConfig.rephMode === "Implicit" && !$d203e6b9523d0071$var$isJoiner(glyphs[start + 2]) || indicConfig.rephMode === "Explicit" && glyphs[start + 2].shaperInfo.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).ZWJ)) {
                    let g = [
                      glyphs[start].copy(),
                      glyphs[start + 1].copy(),
                      glyphs[start + 2].copy()
                    ];
                    if ($d203e6b9523d0071$var$wouldSubstitute(g.slice(0, 2), "rphf") || indicConfig.rephMode === "Explicit" && $d203e6b9523d0071$var$wouldSubstitute(g, "rphf")) {
                      limit += 2;
                      while (limit < end && $d203e6b9523d0071$var$isJoiner(glyphs[limit])) limit++;
                      base = start;
                      hasReph = true;
                    }
                  } else if (indicConfig.rephMode === "Log_Repha" && glyphs[start].shaperInfo.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).Repha) {
                    limit++;
                    while (limit < end && $d203e6b9523d0071$var$isJoiner(glyphs[limit])) limit++;
                    base = start;
                    hasReph = true;
                  }
                  switch (indicConfig.basePos) {
                    case "Last": {
                      let i = end;
                      let seenBelow = false;
                      do {
                        let info = glyphs[--i].shaperInfo;
                        if ($d203e6b9523d0071$var$isConsonant(glyphs[i])) {
                          if (info.position !== (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Below_C && (info.position !== (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Post_C || seenBelow)) {
                            base = i;
                            break;
                          }
                          if (info.position === (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Below_C) seenBelow = true;
                          base = i;
                        } else if (start < i && info.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).ZWJ && glyphs[i - 1].shaperInfo.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).H) break;
                      } while (i > limit);
                      break;
                    }
                    case "First":
                      base = start;
                      for (let i = base + 1; i < end; i++) if ($d203e6b9523d0071$var$isConsonant(glyphs[i])) glyphs[i].shaperInfo.position = (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Below_C;
                  }
                  if (hasReph && base === start && limit - base <= 2) hasReph = false;
                  for (let i = start; i < base; i++) {
                    let info = glyphs[i].shaperInfo;
                    info.position = Math.min((0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Pre_C, info.position);
                  }
                  if (base < end) glyphs[base].shaperInfo.position = (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Base_C;
                  for (let i = base + 1; i < end; i++) if (glyphs[i].shaperInfo.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).M) {
                    for (let j = i + 1; j < end; j++) if ($d203e6b9523d0071$var$isConsonant(glyphs[j])) {
                      glyphs[j].shaperInfo.position = (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Final_C;
                      break;
                    }
                    break;
                  }
                  if (hasReph) glyphs[start].shaperInfo.position = (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph;
                  if (plan.isOldSpec) {
                    let disallowDoubleHalants = plan.unicodeScript !== "Malayalam";
                    for (let i = base + 1; i < end; i++) if (glyphs[i].shaperInfo.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).H) {
                      let j;
                      for (j = end - 1; j > i; j--) {
                        if ($d203e6b9523d0071$var$isConsonant(glyphs[j]) || disallowDoubleHalants && glyphs[j].shaperInfo.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).H) break;
                      }
                      if (glyphs[j].shaperInfo.category !== (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).H && j > i) {
                        let t = glyphs[i];
                        glyphs.splice(i, 0, ...glyphs.splice(i + 1, j - i));
                        glyphs[j] = t;
                      }
                      break;
                    }
                  }
                  let lastPos = (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Start;
                  for (let i = start; i < end; i++) {
                    let info = glyphs[i].shaperInfo;
                    if (info.category & ((0, $79e3b6f2c331d0bf$export$bbcd928767338e0d) | (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).N | (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).RS | (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).CM | (0, $79e3b6f2c331d0bf$export$ca9599b2a300afc) & info.category)) {
                      info.position = lastPos;
                      if (info.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).H && info.position === (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Pre_M) {
                        for (let j = i; j > start; j--) if (glyphs[j - 1].shaperInfo.position !== (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Pre_M) {
                          info.position = glyphs[j - 1].shaperInfo.position;
                          break;
                        }
                      }
                    } else if (info.position !== (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).SMVD) lastPos = info.position;
                  }
                  let last = base;
                  for (let i = base + 1; i < end; i++) {
                    if ($d203e6b9523d0071$var$isConsonant(glyphs[i])) {
                      for (let j = last + 1; j < i; j++) if (glyphs[j].shaperInfo.position < (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).SMVD) glyphs[j].shaperInfo.position = glyphs[i].shaperInfo.position;
                      last = i;
                    } else if (glyphs[i].shaperInfo.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).M) last = i;
                  }
                  let arr = glyphs.slice(start, end);
                  arr.sort((a, b) => a.shaperInfo.position - b.shaperInfo.position);
                  glyphs.splice(start, arr.length, ...arr);
                  for (let i = start; i < end; i++) if (glyphs[i].shaperInfo.position === (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Base_C) {
                    base = i;
                    break;
                  }
                  for (let i = start; i < end && glyphs[i].shaperInfo.position === (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph; i++) glyphs[i].features.rphf = true;
                  let blwf = !plan.isOldSpec && indicConfig.blwfMode === "Pre_And_Post";
                  for (let i = start; i < base; i++) {
                    glyphs[i].features.half = true;
                    if (blwf) glyphs[i].features.blwf = true;
                  }
                  for (let i = base + 1; i < end; i++) {
                    glyphs[i].features.abvf = true;
                    glyphs[i].features.pstf = true;
                    glyphs[i].features.blwf = true;
                  }
                  if (plan.isOldSpec && plan.unicodeScript === "Devanagari") {
                    for (let i = start; i + 1 < base; i++) if (glyphs[i].shaperInfo.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).Ra && glyphs[i + 1].shaperInfo.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).H && (i + 1 === base || glyphs[i + 2].shaperInfo.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).ZWJ)) {
                      glyphs[i].features.blwf = true;
                      glyphs[i + 1].features.blwf = true;
                    }
                  }
                  let prefLen = 2;
                  if (features.pref && base + prefLen < end)
                    for (let i = base + 1; i + prefLen - 1 < end; i++) {
                      let g = [
                        glyphs[i].copy(),
                        glyphs[i + 1].copy()
                      ];
                      if ($d203e6b9523d0071$var$wouldSubstitute(g, "pref")) {
                        for (let j = 0; j < prefLen; j++) glyphs[i++].features.pref = true;
                        if (features.cfar) for (; i < end; i++) glyphs[i].features.cfar = true;
                        break;
                      }
                    }
                  for (let i = start + 1; i < end; i++) if ($d203e6b9523d0071$var$isJoiner(glyphs[i])) {
                    let nonJoiner = glyphs[i].shaperInfo.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).ZWNJ;
                    let j = i;
                    do {
                      j--;
                      if (nonJoiner) delete glyphs[j].features.half;
                    } while (j > start && !$d203e6b9523d0071$var$isConsonant(glyphs[j]));
                  }
                }
              }
              function $d203e6b9523d0071$var$finalReordering(font, glyphs, plan) {
                let indicConfig = plan.indicConfig;
                let features = font._layoutEngine.engine.GSUBProcessor.features;
                for (let start = 0, end = $d203e6b9523d0071$var$nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = $d203e6b9523d0071$var$nextSyllable(glyphs, start)) {
                  let tryPref = !!features.pref;
                  let base = start;
                  for (; base < end; base++) if (glyphs[base].shaperInfo.position >= (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Base_C) {
                    if (tryPref && base + 1 < end) {
                      for (let i = base + 1; i < end; i++) if (glyphs[i].features.pref) {
                        if (!(glyphs[i].substituted && glyphs[i].isLigated && !glyphs[i].isMultiplied)) {
                          base = i;
                          while (base < end && $d203e6b9523d0071$var$isHalantOrCoeng(glyphs[base])) base++;
                          glyphs[base].shaperInfo.position = (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).BASE_C;
                          tryPref = false;
                        }
                        break;
                      }
                    }
                    if (plan.unicodeScript === "Malayalam") for (let i = base + 1; i < end; i++) {
                      while (i < end && $d203e6b9523d0071$var$isJoiner(glyphs[i])) i++;
                      if (i === end || !$d203e6b9523d0071$var$isHalantOrCoeng(glyphs[i])) break;
                      i++;
                      while (i < end && $d203e6b9523d0071$var$isJoiner(glyphs[i])) i++;
                      if (i < end && $d203e6b9523d0071$var$isConsonant(glyphs[i]) && glyphs[i].shaperInfo.position === (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Below_C) {
                        base = i;
                        glyphs[base].shaperInfo.position = (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Base_C;
                      }
                    }
                    if (start < base && glyphs[base].shaperInfo.position > (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Base_C) base--;
                    break;
                  }
                  if (base === end && start < base && glyphs[base - 1].shaperInfo.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).ZWJ) base--;
                  if (base < end) while (start < base && glyphs[base].shaperInfo.category & ((0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).N | (0, $79e3b6f2c331d0bf$export$ca9599b2a300afc))) base--;
                  if (start + 1 < end && start < base) {
                    let newPos = base === end ? base - 2 : base - 1;
                    if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
                      while (newPos > start && !(glyphs[newPos].shaperInfo.category & ((0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).M | (0, $79e3b6f2c331d0bf$export$ca9599b2a300afc)))) newPos--;
                      if ($d203e6b9523d0071$var$isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Pre_M) {
                        if (newPos + 1 < end && $d203e6b9523d0071$var$isJoiner(glyphs[newPos + 1])) newPos++;
                      } else newPos = start;
                    }
                    if (start < newPos && glyphs[newPos].shaperInfo.position !== (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Pre_M) {
                      for (let i = newPos; i > start; i--) if (glyphs[i - 1].shaperInfo.position === (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Pre_M) {
                        let oldPos = i - 1;
                        if (oldPos < base && base <= newPos) base--;
                        let tmp = glyphs[oldPos];
                        glyphs.splice(oldPos, 0, ...glyphs.splice(oldPos + 1, newPos - oldPos));
                        glyphs[newPos] = tmp;
                        newPos--;
                      }
                    }
                  }
                  if (start + 1 < end && glyphs[start].shaperInfo.position === (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph && glyphs[start].shaperInfo.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).Repha !== (glyphs[start].isLigated && !glyphs[start].isMultiplied)) {
                    let newRephPos;
                    let rephPos = indicConfig.rephPos;
                    let found = false;
                    if (rephPos !== (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).After_Post) {
                      newRephPos = start + 1;
                      while (newRephPos < base && !$d203e6b9523d0071$var$isHalantOrCoeng(glyphs[newRephPos])) newRephPos++;
                      if (newRephPos < base && $d203e6b9523d0071$var$isHalantOrCoeng(glyphs[newRephPos])) {
                        if (newRephPos + 1 < base && $d203e6b9523d0071$var$isJoiner(glyphs[newRephPos + 1])) newRephPos++;
                        found = true;
                      }
                      if (!found && rephPos === (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).After_Main) {
                        newRephPos = base;
                        while (newRephPos + 1 < end && glyphs[newRephPos + 1].shaperInfo.position <= (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).After_Main) newRephPos++;
                        found = newRephPos < end;
                      }
                      if (!found && rephPos === (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).After_Sub) {
                        newRephPos = base;
                        while (newRephPos + 1 < end && !(glyphs[newRephPos + 1].shaperInfo.position & ((0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Post_C | (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).After_Post | (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).SMVD))) newRephPos++;
                        found = newRephPos < end;
                      }
                    }
                    if (!found) {
                      newRephPos = start + 1;
                      while (newRephPos < base && !$d203e6b9523d0071$var$isHalantOrCoeng(glyphs[newRephPos])) newRephPos++;
                      if (newRephPos < base && $d203e6b9523d0071$var$isHalantOrCoeng(glyphs[newRephPos])) {
                        if (newRephPos + 1 < base && $d203e6b9523d0071$var$isJoiner(glyphs[newRephPos + 1])) newRephPos++;
                        found = true;
                      }
                    }
                    if (!found) {
                      newRephPos = end - 1;
                      while (newRephPos > start && glyphs[newRephPos].shaperInfo.position === (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).SMVD) newRephPos--;
                      if ($d203e6b9523d0071$var$isHalantOrCoeng(glyphs[newRephPos])) {
                        for (let i = base + 1; i < newRephPos; i++) if (glyphs[i].shaperInfo.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).M) newRephPos--;
                      }
                    }
                    let reph = glyphs[start];
                    glyphs.splice(start, 0, ...glyphs.splice(start + 1, newRephPos - start));
                    glyphs[newRephPos] = reph;
                    if (start < base && base <= newRephPos) base--;
                  }
                  if (tryPref && base + 1 < end) {
                    for (let i = base + 1; i < end; i++) if (glyphs[i].features.pref) {
                      if (glyphs[i].isLigated && !glyphs[i].isMultiplied) {
                        let newPos = base;
                        if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
                          while (newPos > start && !(glyphs[newPos - 1].shaperInfo.category & ((0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).M | (0, $79e3b6f2c331d0bf$export$ca9599b2a300afc)))) newPos--;
                          if (newPos > start && glyphs[newPos - 1].shaperInfo.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).M) {
                            let oldPos2 = i;
                            for (let j = base + 1; j < oldPos2; j++) if (glyphs[j].shaperInfo.category === (0, $79e3b6f2c331d0bf$export$a513ea61a7bee91c).M) {
                              newPos--;
                              break;
                            }
                          }
                        }
                        if (newPos > start && $d203e6b9523d0071$var$isHalantOrCoeng(glyphs[newPos - 1])) {
                          if (newPos < end && $d203e6b9523d0071$var$isJoiner(glyphs[newPos])) newPos++;
                        }
                        let oldPos = i;
                        let tmp = glyphs[oldPos];
                        glyphs.splice(newPos + 1, 0, ...glyphs.splice(newPos, oldPos - newPos));
                        glyphs[newPos] = tmp;
                        if (newPos <= base && base < oldPos) base++;
                      }
                      break;
                    }
                  }
                  if (glyphs[start].shaperInfo.position === (0, $79e3b6f2c331d0bf$export$1a1f61c9c4dd9df0).Pre_M && (!start || !/Cf|Mn/.test((0, $gfJaN$unicodeproperties.getCategory)(glyphs[start - 1].codePoints[0])))) glyphs[start].features.init = true;
                }
              }
              function $d203e6b9523d0071$var$nextSyllable(glyphs, start) {
                if (start >= glyphs.length) return start;
                let syllable = glyphs[start].shaperInfo.syllable;
                while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable) ;
                return start;
              }
              const { categories: $9b772791ccede8a5$var$categories, decompositions: $9b772791ccede8a5$var$decompositions } = (0, $parcel$interopDefault($79781f8c452881c2$exports));
              const $9b772791ccede8a5$var$trie = new (0, $parcel$interopDefault($gfJaN$unicodetrie))((0, $66a5b9fb5318558a$export$94fdf11bafc8de6b)("AAACAAAAAAAQugAAAQUO+vHtnHuMX0UVx2d3u/t7bXe7FlqgvB+mpQhFmhikMRAg0ZQmakMU+cPWBzZisEGNjUpoiIYCEgmGUGOEGqOVNPUZUGNA+QNIBU2KREEFFSMBUYRISMXE+B3vnPzOzp553tcWfif5ZO5jnufMzJ2ZO/eumlDqFLAWnAMuBBvBZnC5uXZeBe4WsA1sBzs8/naCXcL1G8GtYDfYA74NvgfuAfcZHmT+fwEeBb8DTwvxPQWeAavACyZvq8z9VYxXwCGglijVBcvACnA8eCM4E6wHG8BF4BLwbvA+8AHwUbAd7AA7wS5wC9gN7gR7wX5wN7gXPAAeBr8Gvwd/Ac+CF8EhoCaV6oBZsBKcAE4FZ0wWeV8P9zxwoTnfCHczuBxsAdvAx8Gnzf1r4X4B3AxuA1+bHJb9m5PzdVGW/Yjv+xXHyfmxFfd9OH8Q/Ar8Bjw1WZT3GfACeAX8N5CfqSmlZsAKsGqqCH8K3DXgbHCuuXYB3HeAd4HLpgrdarbi+EPgY+CT4HPg8ybMTcb9MtyvghtYut/A+b4pf95+ELgfw08Qx/3gADgInjDl0veehPtX8A/wsrn2KtzxDuogWNoJx38k/BzXKeI8Ee5qcBZYD9aZtDbg+AwT19uMX83F7JizCdcvBZdZ97c6/BMfMWmfzfTm88/95aLj+DDSvApcDXZ04uPfaen3TMHPLvi5BezuFPVtD4t/qUcfe3FvP7gb3Ouwo9T+H+gMy/UIjh8DfwBPm7T08d/M8WMBe1Sh3xEjXo+M2s+IESNGjBgxYsSI1wLrOsM1gRsi/P+TzV3/Zc1jvxgR/j8IM9Et1mEGcJeDFeA4cJq5/ia467uF/w1wzwdvB+80998LdwvYZs63w90Bdnbd6Wp/uzz3R4wYMWJEvZzTMm2Xf8SIEfVQd/v+EsaPt3eL90J3wP2WMJ78Trd4t6+P77Hu37cIxp9/ny6YXqrUJeCR6TA74e/nll81MzxejeMtYA94HBwy91bPYow+O/S3A8d7oIM/gRN7CAP29Iqx/B1ThfuwOecM+vA3NmRjf6Gfm3BtH7v+PI7XDpS6EuwDz4O10+0/f9om1F4ehO4OmHp6EO7jxl56nvhsN/15ut+4Z0b657yYkZ7UJ0jhX0bcr3bn+6P87vekN4762QNzvWHZtL+jcH5srzg/uTf0f3pvfj5i+6tYW7rK9+aefO+tuL4BXAQ2gs3gPeBJc//9OL4CXAWuNvc/A64DN4Jbwe0s7jtxvBfsAz8EPwX3gwPgoJAHPQ9/Atf/bO7p/TTP4fglwS/5/zfujfWH5z0cz4Gj+8X5Sf1ib4m+vwbHZ/fdOtP+z+3LOnPp/QL4vxhsApeCy8BWk/a2ftFmYu22Hf4/Ba4B14Hrwc0sP7fh+Cvg6+Au8F1WthA/8pT7UeTxZ/12njkuXT8UyM9i6iur1EEb6f+yPz/eg0b3v4X7x365fMaW42lPu7PTv6vi8i/G+lWF/cvUk7bLl1r+5/rN5tu3j2qvWTd/qV+4h+AqjDGnBsX59GDo94iBXDa6v6Yjl6vu+h8itJcsZq/ZykHhHg/3tMHhUe9s/Yfuny7YNxTvQ8LYdrER2+/c0GBezhrMv3ZNRv7PmYirh7oOv4W1Y72/cwPOzx8U7X8d2295sfE3MPnbBPfSQbHv9nK4HxTqiK/trI7Yy5mLzvuVg/nX+N7V51A3r+gMy/4J434W7l2dYf5PZWGuNX6uh3uzEPetuLY7sZ20zTETY2oxyBhj3DrnfsidYPeXRGLHpxzX6pbFofGRkFBdGhcgW40L4cYtd9JAElO36q4LEzXHX7VMtZ2BEhJjy9dT25fazOtJxhwsBrHzwfu8w12kMYN9fLhIbp2RxlI59rX1dzjpsKl2Fxt3iu6rbofc9q5+KcRrXVzzDn6/Crvk6p/y1GFgGhs9/6maHjBLgv8/18fTxl1q0bPoW8ywsFTGWaazHosrNn/kP2eeqEroZYLZphsZl7L82eephMIqNT8dyT9JjH1Jpg32ubZvTB/SF665ymSnnaqjUHum+1Qn+NyOtz9f2r6y5OQ51b6hYy0D40r2tYXar30+Y/mbVX6JqY+hMC60XZapoh3S/HdOpT3DYu3rs0lKnquyb277JZvyPlqp+f1zVVK2/dJYNpQGf04uYyh1+PTPqfalZ2tO/xwSu+3bOrDzmWvfcTW/fLmibRx6lkvlcOlc8qsE/y5/rnSk67F1iAu1VT6+4jKt5tufn8e2b+n57JKcckhrsKG1Cd6Wu+Y8tf2l5DenPafqQZ/7xstKLeyr+XnInjSelvRgS9n27JPQM5n6Am7jmLG8VK6m7OvyS2L313XYV2r/tth5LWPfNxhyhI+1Up7HVbe/HMgeZE8brtNQ/7tcyX0cn//H2LTO9kpir5VI6yYp9szJW9W2jI1Tqfl5ic2v1GZ5XaG6RDZbyvxMO/DVh1SdUj5y1vraaHs+2/TYNXvtSRoXk4wrf9w6fEctnFt0zL2y+xFsfSrLza2zOTqMiZv8xOpbn8+xsL5ykdj6VsxNKb/Lvxb7nX8u48y1x6yuMW3V9tNxTlouzXslibVxndjC14xda8g2NIbg5x01XAP2lfeIBFSi/zrQEporTXru8fCueiy1CUnqrhspSM9SzbSS64tep9R1ZsZcOxKsUEUfNZeYtr0vjY5DeXW915hT8/PRV8MxlR1HV4DHZZc9R7dzajgWoXikdLtGr0uEfPigsGS/NvYjSHW87XejoXZehZ74XrcqpQ4d5T5f7Gu8f6g7fQmefoqOqk4/VarQv2o4/VDetPDnhjR2dc3BCBp/9NVw7KGfwStVMf6aZNAajj6224j9HCZbpZa/LvH1gU30i/q5WnUdSNEprxv2eIOwx2pcjjLMsmObo008k0J4u69P3d9QdbspW/dy080Nb8PXqcrmj0vsc7tu6qwD1A5oLYr3U3XWSxqj6/a10nCMkudJMyxvrvbK55jUrqU+Xlr/Iai98jY7mVAml5QNHxq31j2m5TrSdmp6z5p+9kpzQntdQbI1Pafr6I9C60gxrALHGtdF6tyhLTtxeBuW+hhqyzPMX931xl6rJ5f6n5h3blpsW7vKbvdBfL1gpYfjDLrvob1drrRT+mcuMf1OrJSdW/P+RfufdUB+pOtdTzhpL5t0jfKr46P3obQfQdPGt1jS+DEkx4MT2PmEg1j72OthqfZNWX+JuZ4at/2sTAmn5cSIMqZIjk0pnD0+aUI6YS9ekdaspWsp8cWEC62dS66UTkq+ypajyvXSlPz4xhQhm/ns6wpXBVI560jHN9aKkdT46spvWT916rONdHNsGSNtl6Hp8oakTVukpF9n3U3Jx0TNefbp3R4jltVfFfpvQkJpNaH/puyco++qbZPz7sE1L3DFGVovc4XPLUPO3ELyrzLiSpmPhaTJfqeJ+t60PiTh9snNW2656upDQ+Wtyg6ueJquB7HSVPspW9a28lDWJouhb6iyv7XjTfVL67j2vjDpvUfMt1Vl4GvctMaeq/vYcFWXIfV5Ku3XaxK951H6dsWFrhcxa3pU/pz3C1xc71tTcaXjGjtJbYIj7UHm7wxSyx+D/d7SfpfJ3wPpfSQp32tS2dt8V2tD7+Bce3rpPa3eC6Dr8Ulq+K+J3HFvbn312Zv2RdStr9g0pP0P/B04XbP3Q8cIT2dlRF6orkrhY/Rv27FqHfL1DP480ffo/V6V7aTHXLKDbTdXOOrnyG1ScvSv6xqve30lPzdpj36M8Pilb+L5vr0xE3dd30nWIfZ45uSSxK4x+CRmTUK6F/LrSsfnj+aOdYyvpXyMK7/OpHWjlDTsa0rJum5K7Ppnj7F9c+0q0qtr7pQji2X9oMwcVrJfmblwU2V2SV3rEk3YuO46XXf8MfrQz077G2zftyDkj/ZqhcZr9nldkOg5ykAt3GunJbR3NGYsUfWafd3ts853C4dLHppOM6WcfM5C+xSbaC/2HMa1H9v1vXdoXm/LKSVpYh5wqmr/X67SfwHtPc9a97p/k8bt0hpbW0j1Svr2m+7Rd98qIQ1pvSF273dKOjHYNmk6fd8/JX3tWIddblBqoU5p7zrZKnd9TppjVq0DSitWqkwz12b2exb7vwjaRvS/TFd/S+8AYvIo+Suri5TwvvZRdV1IQevQ1/8SA+UeH5eto7n/X1Oe86ptaafl8kPjcF7P7W93eD9d5n+oSvn7fFe7I/G9q1IBfylSR71N6fft94ZU18hOXKR+JqUO8f4+5dvLsmWlMQb/Vov+CUDlpTGUndeQlG3fdZWdRPoPgl3mmDlsLnaey/4X3tVuU+o6L3/Pym+qlLV/jk6rlBRd8394hZ6JdnuqIv2ykOh3pfq96Wkq/E8qu2xl88/tOJ4R3tfmpbGi3c5T859bzqr7MbsN03iI5itUNj5eaEKWqIX/KJCQ/iFWNZMmHXs8ovWk53JzFq5vPul6zDjLV36pX7bzvNzB0YlQOZephWtRS5T7eeSq8030R77/HvC1d7tN83Zt9yltrDdwSR0XxsZd5l+MvvvU1/M9jSnj+Nh6FPJbBld/w6XHXH5MZeXrOfS/65g9RTl1JCa8chzX2RZ9/3lXSh4/VqWfEBNq4b82Ytp6m+9Qqxir1jX+rfPdT1vvsWhM6bPbmON6E1LnPCZW7L0qqXswmtqf0MQelZj4myrzYtzvIYmURlvtqapyx+gzRfd0XPfahVSOquMoG+dibBdl46iyfdbV1qvUW9m8+KTudMvkzZe/pqTJ+pWTflX5zw1fVfox6ZTVc8hvHflOSb+OuG1JsZ0kufXAJf8D"));
              const $9b772791ccede8a5$var$stateMachine = new (0, $parcel$interopDefault($gfJaN$dfa))((0, $parcel$interopDefault($79781f8c452881c2$exports)));
              class $9b772791ccede8a5$export$2e2bcd8739ae039 extends (0, $d28fb665ee343afc$export$2e2bcd8739ae039) {
                static planFeatures(plan) {
                  plan.addStage($9b772791ccede8a5$var$setupSyllables);
                  plan.addStage([
                    "locl",
                    "ccmp",
                    "nukt",
                    "akhn"
                  ]);
                  plan.addStage($9b772791ccede8a5$var$clearSubstitutionFlags);
                  plan.addStage([
                    "rphf"
                  ], false);
                  plan.addStage($9b772791ccede8a5$var$recordRphf);
                  plan.addStage($9b772791ccede8a5$var$clearSubstitutionFlags);
                  plan.addStage([
                    "pref"
                  ]);
                  plan.addStage($9b772791ccede8a5$var$recordPref);
                  plan.addStage([
                    "rkrf",
                    "abvf",
                    "blwf",
                    "half",
                    "pstf",
                    "vatu",
                    "cjct"
                  ]);
                  plan.addStage($9b772791ccede8a5$var$reorder);
                  plan.addStage([
                    "abvs",
                    "blws",
                    "pres",
                    "psts",
                    "dist",
                    "abvm",
                    "blwm"
                  ]);
                }
                static assignFeatures(plan, glyphs) {
                  for (let i = glyphs.length - 1; i >= 0; i--) {
                    let codepoint = glyphs[i].codePoints[0];
                    if ($9b772791ccede8a5$var$decompositions[codepoint]) {
                      let decomposed = $9b772791ccede8a5$var$decompositions[codepoint].map((c) => {
                        let g = plan.font.glyphForCodePoint(c);
                        return new (0, $f22bb23c9fd478d8$export$2e2bcd8739ae039)(plan.font, g.id, [
                          c
                        ], glyphs[i].features);
                      });
                      glyphs.splice(i, 1, ...decomposed);
                    }
                  }
                }
              }
              (0, $gfJaN$swchelperscjs_define_propertycjs._)($9b772791ccede8a5$export$2e2bcd8739ae039, "zeroMarkWidths", "BEFORE_GPOS");
              function $9b772791ccede8a5$var$useCategory(glyph) {
                return $9b772791ccede8a5$var$trie.get(glyph.codePoints[0]);
              }
              class $9b772791ccede8a5$var$USEInfo {
                constructor(category, syllableType, syllable) {
                  this.category = category;
                  this.syllableType = syllableType;
                  this.syllable = syllable;
                }
              }
              function $9b772791ccede8a5$var$setupSyllables(font, glyphs) {
                let syllable = 0;
                for (let [start, end, tags] of $9b772791ccede8a5$var$stateMachine.match(glyphs.map($9b772791ccede8a5$var$useCategory))) {
                  ++syllable;
                  for (let i = start; i <= end; i++) glyphs[i].shaperInfo = new $9b772791ccede8a5$var$USEInfo($9b772791ccede8a5$var$categories[$9b772791ccede8a5$var$useCategory(glyphs[i])], tags[0], syllable);
                  let limit = glyphs[start].shaperInfo.category === "R" ? 1 : Math.min(3, end - start);
                  for (let i = start; i < start + limit; i++) glyphs[i].features.rphf = true;
                }
              }
              function $9b772791ccede8a5$var$clearSubstitutionFlags(font, glyphs) {
                for (let glyph of glyphs) glyph.substituted = false;
              }
              function $9b772791ccede8a5$var$recordRphf(font, glyphs) {
                for (let glyph of glyphs) if (glyph.substituted && glyph.features.rphf)
                  glyph.shaperInfo.category = "R";
              }
              function $9b772791ccede8a5$var$recordPref(font, glyphs) {
                for (let glyph of glyphs) if (glyph.substituted)
                  glyph.shaperInfo.category = "VPre";
              }
              function $9b772791ccede8a5$var$reorder(font, glyphs) {
                let dottedCircle = font.glyphForCodePoint(9676).id;
                for (let start = 0, end = $9b772791ccede8a5$var$nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = $9b772791ccede8a5$var$nextSyllable(glyphs, start)) {
                  let i, j;
                  let info = glyphs[start].shaperInfo;
                  let type = info.syllableType;
                  if (type !== "virama_terminated_cluster" && type !== "standard_cluster" && type !== "broken_cluster") continue;
                  if (type === "broken_cluster" && dottedCircle) {
                    let g = new (0, $f22bb23c9fd478d8$export$2e2bcd8739ae039)(font, dottedCircle, [
                      9676
                    ]);
                    g.shaperInfo = info;
                    for (i = start; i < end && glyphs[i].shaperInfo.category === "R"; i++) ;
                    glyphs.splice(++i, 0, g);
                    end++;
                  }
                  if (info.category === "R" && end - start > 1)
                    for (i = start + 1; i < end; i++) {
                      info = glyphs[i].shaperInfo;
                      if ($9b772791ccede8a5$var$isBase(info) || $9b772791ccede8a5$var$isHalant(glyphs[i])) {
                        if ($9b772791ccede8a5$var$isHalant(glyphs[i])) i--;
                        glyphs.splice(start, 0, ...glyphs.splice(start + 1, i - start), glyphs[i]);
                        break;
                      }
                    }
                  for (i = start, j = end; i < end; i++) {
                    info = glyphs[i].shaperInfo;
                    if ($9b772791ccede8a5$var$isBase(info) || $9b772791ccede8a5$var$isHalant(glyphs[i]))
                      j = $9b772791ccede8a5$var$isHalant(glyphs[i]) ? i + 1 : i;
                    else if ((info.category === "VPre" || info.category === "VMPre") && j < i) glyphs.splice(j, 1, glyphs[i], ...glyphs.splice(j, i - j));
                  }
                }
              }
              function $9b772791ccede8a5$var$nextSyllable(glyphs, start) {
                if (start >= glyphs.length) return start;
                let syllable = glyphs[start].shaperInfo.syllable;
                while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable) ;
                return start;
              }
              function $9b772791ccede8a5$var$isHalant(glyph) {
                return glyph.shaperInfo.category === "H" && !glyph.isLigated;
              }
              function $9b772791ccede8a5$var$isBase(info) {
                return info.category === "B" || info.category === "GB";
              }
              const $fdb4471fc82bc2c2$var$SHAPERS = {
                arab: (0, $17ba6019f27bfcf9$export$2e2bcd8739ae039),
                mong: (0, $17ba6019f27bfcf9$export$2e2bcd8739ae039),
                syrc: (0, $17ba6019f27bfcf9$export$2e2bcd8739ae039),
                "nko ": (0, $17ba6019f27bfcf9$export$2e2bcd8739ae039),
                phag: (0, $17ba6019f27bfcf9$export$2e2bcd8739ae039),
                mand: (0, $17ba6019f27bfcf9$export$2e2bcd8739ae039),
                mani: (0, $17ba6019f27bfcf9$export$2e2bcd8739ae039),
                phlp: (0, $17ba6019f27bfcf9$export$2e2bcd8739ae039),
                hang: (0, $fa1d9fd80dd7279e$export$2e2bcd8739ae039),
                bng2: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                beng: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                dev2: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                deva: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                gjr2: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                gujr: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                guru: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                gur2: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                knda: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                knd2: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                mlm2: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                mlym: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                ory2: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                orya: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                taml: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                tml2: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                telu: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                tel2: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                khmr: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                bali: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                batk: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                brah: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                bugi: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                buhd: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                cakm: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                cham: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                dupl: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                egyp: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                gran: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                hano: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                java: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                kthi: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                kali: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                khar: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                khoj: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                sind: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                lepc: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                limb: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                mahj: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                // mand: UniversalShaper, // Mandaic
                // mani: UniversalShaper, // Manichaean
                mtei: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                modi: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                // mong: UniversalShaper, // Mongolian
                // 'nko ': UniversalShaper, // NKo
                hmng: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                // phag: UniversalShaper, // Phags-pa
                // phlp: UniversalShaper, // Psalter Pahlavi
                rjng: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                saur: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                shrd: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                sidd: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                sinh: (0, $d203e6b9523d0071$export$2e2bcd8739ae039),
                sund: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                sylo: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                tglg: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                tagb: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                tale: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                lana: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                tavt: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                takr: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                tibt: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                tfng: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                tirh: (0, $9b772791ccede8a5$export$2e2bcd8739ae039),
                latn: (0, $d28fb665ee343afc$export$2e2bcd8739ae039),
                DFLT: (0, $d28fb665ee343afc$export$2e2bcd8739ae039)
              };
              function $fdb4471fc82bc2c2$export$7877a478dd30fd3d(script) {
                if (!Array.isArray(script)) script = [
                  script
                ];
                for (let s of script) {
                  let shaper = $fdb4471fc82bc2c2$var$SHAPERS[s];
                  if (shaper) return shaper;
                }
                return 0, $d28fb665ee343afc$export$2e2bcd8739ae039;
              }
              class $86bc1883359e094a$export$2e2bcd8739ae039 extends (0, $7b226e6bbeadedeb$export$2e2bcd8739ae039) {
                applyLookup(lookupType, table) {
                  switch (lookupType) {
                    case 1: {
                      let index = this.coverageIndex(table.coverage);
                      if (index === -1) return false;
                      let glyph = this.glyphIterator.cur;
                      switch (table.version) {
                        case 1:
                          glyph.id = glyph.id + table.deltaGlyphID & 65535;
                          break;
                        case 2:
                          glyph.id = table.substitute.get(index);
                          break;
                      }
                      return true;
                    }
                    case 2: {
                      let index = this.coverageIndex(table.coverage);
                      if (index !== -1) {
                        let sequence = table.sequences.get(index);
                        if (sequence.length === 0) {
                          this.glyphs.splice(this.glyphIterator.index, 1);
                          return true;
                        }
                        this.glyphIterator.cur.id = sequence[0];
                        this.glyphIterator.cur.ligatureComponent = 0;
                        let features = this.glyphIterator.cur.features;
                        let curGlyph = this.glyphIterator.cur;
                        let replacement = sequence.slice(1).map((gid, i) => {
                          let glyph = new (0, $f22bb23c9fd478d8$export$2e2bcd8739ae039)(this.font, gid, void 0, features);
                          glyph.shaperInfo = curGlyph.shaperInfo;
                          glyph.isLigated = curGlyph.isLigated;
                          glyph.ligatureComponent = i + 1;
                          glyph.substituted = true;
                          glyph.isMultiplied = true;
                          return glyph;
                        });
                        this.glyphs.splice(this.glyphIterator.index + 1, 0, ...replacement);
                        return true;
                      }
                      return false;
                    }
                    case 3: {
                      let index = this.coverageIndex(table.coverage);
                      if (index !== -1) {
                        let USER_INDEX = 0;
                        this.glyphIterator.cur.id = table.alternateSet.get(index)[USER_INDEX];
                        return true;
                      }
                      return false;
                    }
                    case 4: {
                      let index = this.coverageIndex(table.coverage);
                      if (index === -1) return false;
                      for (let ligature of table.ligatureSets.get(index)) {
                        let matched = this.sequenceMatchIndices(1, ligature.components);
                        if (!matched) continue;
                        let curGlyph = this.glyphIterator.cur;
                        let characters = curGlyph.codePoints.slice();
                        for (let index2 of matched) characters.push(...this.glyphs[index2].codePoints);
                        let ligatureGlyph = new (0, $f22bb23c9fd478d8$export$2e2bcd8739ae039)(this.font, ligature.glyph, characters, curGlyph.features);
                        ligatureGlyph.shaperInfo = curGlyph.shaperInfo;
                        ligatureGlyph.isLigated = true;
                        ligatureGlyph.substituted = true;
                        let isMarkLigature = curGlyph.isMark;
                        for (let i = 0; i < matched.length && isMarkLigature; i++) isMarkLigature = this.glyphs[matched[i]].isMark;
                        ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;
                        let lastLigID = curGlyph.ligatureID;
                        let lastNumComps = curGlyph.codePoints.length;
                        let curComps = lastNumComps;
                        let idx = this.glyphIterator.index + 1;
                        for (let matchIndex of matched) {
                          if (isMarkLigature) idx = matchIndex;
                          else while (idx < matchIndex) {
                            var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);
                            this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;
                            this.glyphs[idx].ligatureComponent = ligatureComponent;
                            idx++;
                          }
                          lastLigID = this.glyphs[idx].ligatureID;
                          lastNumComps = this.glyphs[idx].codePoints.length;
                          curComps += lastNumComps;
                          idx++;
                        }
                        if (lastLigID && !isMarkLigature) for (let i = idx; i < this.glyphs.length; i++) {
                          if (this.glyphs[i].ligatureID === lastLigID) {
                            var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[i].ligatureComponent || 1, lastNumComps);
                            this.glyphs[i].ligatureComponent = ligatureComponent;
                          } else break;
                        }
                        for (let i = matched.length - 1; i >= 0; i--) this.glyphs.splice(matched[i], 1);
                        this.glyphs[this.glyphIterator.index] = ligatureGlyph;
                        return true;
                      }
                      return false;
                    }
                    case 5:
                      return this.applyContext(table);
                    case 6:
                      return this.applyChainingContext(table);
                    case 7:
                      return this.applyLookup(table.lookupType, table.extension);
                    default:
                      throw new Error(`GSUB lookupType ${lookupType} is not supported`);
                  }
                }
              }
              class $79ea6270f0a90256$export$2e2bcd8739ae039 extends (0, $7b226e6bbeadedeb$export$2e2bcd8739ae039) {
                applyPositionValue(sequenceIndex, value) {
                  let position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];
                  if (value.xAdvance != null) position.xAdvance += value.xAdvance;
                  if (value.yAdvance != null) position.yAdvance += value.yAdvance;
                  if (value.xPlacement != null) position.xOffset += value.xPlacement;
                  if (value.yPlacement != null) position.yOffset += value.yPlacement;
                  let variationProcessor = this.font._variationProcessor;
                  let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
                  if (variationProcessor && variationStore) {
                    if (value.xPlaDevice) position.xOffset += variationProcessor.getDelta(variationStore, value.xPlaDevice.a, value.xPlaDevice.b);
                    if (value.yPlaDevice) position.yOffset += variationProcessor.getDelta(variationStore, value.yPlaDevice.a, value.yPlaDevice.b);
                    if (value.xAdvDevice) position.xAdvance += variationProcessor.getDelta(variationStore, value.xAdvDevice.a, value.xAdvDevice.b);
                    if (value.yAdvDevice) position.yAdvance += variationProcessor.getDelta(variationStore, value.yAdvDevice.a, value.yAdvDevice.b);
                  }
                }
                applyLookup(lookupType, table) {
                  switch (lookupType) {
                    case 1: {
                      let index = this.coverageIndex(table.coverage);
                      if (index === -1) return false;
                      switch (table.version) {
                        case 1:
                          this.applyPositionValue(0, table.value);
                          break;
                        case 2:
                          this.applyPositionValue(0, table.values.get(index));
                          break;
                      }
                      return true;
                    }
                    case 2: {
                      let nextGlyph = this.glyphIterator.peek();
                      if (!nextGlyph) return false;
                      let index = this.coverageIndex(table.coverage);
                      if (index === -1) return false;
                      switch (table.version) {
                        case 1:
                          let set = table.pairSets.get(index);
                          for (let pair2 of set) if (pair2.secondGlyph === nextGlyph.id) {
                            this.applyPositionValue(0, pair2.value1);
                            this.applyPositionValue(1, pair2.value2);
                            return true;
                          }
                          return false;
                        case 2:
                          let class1 = this.getClassID(this.glyphIterator.cur.id, table.classDef1);
                          let class2 = this.getClassID(nextGlyph.id, table.classDef2);
                          if (class1 === -1 || class2 === -1) return false;
                          var pair = table.classRecords.get(class1).get(class2);
                          this.applyPositionValue(0, pair.value1);
                          this.applyPositionValue(1, pair.value2);
                          return true;
                      }
                    }
                    case 3: {
                      let nextIndex = this.glyphIterator.peekIndex();
                      let nextGlyph = this.glyphs[nextIndex];
                      if (!nextGlyph) return false;
                      let curRecord = table.entryExitRecords[this.coverageIndex(table.coverage)];
                      if (!curRecord || !curRecord.exitAnchor) return false;
                      let nextRecord = table.entryExitRecords[this.coverageIndex(table.coverage, nextGlyph.id)];
                      if (!nextRecord || !nextRecord.entryAnchor) return false;
                      let entry = this.getAnchor(nextRecord.entryAnchor);
                      let exit = this.getAnchor(curRecord.exitAnchor);
                      let cur = this.positions[this.glyphIterator.index];
                      let next = this.positions[nextIndex];
                      let d;
                      switch (this.direction) {
                        case "ltr":
                          cur.xAdvance = exit.x + cur.xOffset;
                          d = entry.x + next.xOffset;
                          next.xAdvance -= d;
                          next.xOffset -= d;
                          break;
                        case "rtl":
                          d = exit.x + cur.xOffset;
                          cur.xAdvance -= d;
                          cur.xOffset -= d;
                          next.xAdvance = entry.x + next.xOffset;
                          break;
                      }
                      if (this.glyphIterator.flags.rightToLeft) {
                        this.glyphIterator.cur.cursiveAttachment = nextIndex;
                        cur.yOffset = entry.y - exit.y;
                      } else {
                        nextGlyph.cursiveAttachment = this.glyphIterator.index;
                        cur.yOffset = exit.y - entry.y;
                      }
                      return true;
                    }
                    case 4: {
                      let markIndex = this.coverageIndex(table.markCoverage);
                      if (markIndex === -1) return false;
                      let baseGlyphIndex = this.glyphIterator.index;
                      while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0)) ;
                      if (baseGlyphIndex < 0) return false;
                      let baseIndex = this.coverageIndex(table.baseCoverage, this.glyphs[baseGlyphIndex].id);
                      if (baseIndex === -1) return false;
                      let markRecord = table.markArray[markIndex];
                      let baseAnchor = table.baseArray[baseIndex][markRecord.class];
                      this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
                      return true;
                    }
                    case 5: {
                      let markIndex = this.coverageIndex(table.markCoverage);
                      if (markIndex === -1) return false;
                      let baseGlyphIndex = this.glyphIterator.index;
                      while (--baseGlyphIndex >= 0 && this.glyphs[baseGlyphIndex].isMark) ;
                      if (baseGlyphIndex < 0) return false;
                      let ligIndex = this.coverageIndex(table.ligatureCoverage, this.glyphs[baseGlyphIndex].id);
                      if (ligIndex === -1) return false;
                      let ligAttach = table.ligatureArray[ligIndex];
                      let markGlyph = this.glyphIterator.cur;
                      let ligGlyph = this.glyphs[baseGlyphIndex];
                      let compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && markGlyph.ligatureComponent > 0 ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1 : ligGlyph.codePoints.length - 1;
                      let markRecord = table.markArray[markIndex];
                      let baseAnchor = ligAttach[compIndex][markRecord.class];
                      this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
                      return true;
                    }
                    case 6: {
                      let mark1Index = this.coverageIndex(table.mark1Coverage);
                      if (mark1Index === -1) return false;
                      let prevIndex = this.glyphIterator.peekIndex(-1);
                      let prev = this.glyphs[prevIndex];
                      if (!prev || !prev.isMark) return false;
                      let cur = this.glyphIterator.cur;
                      let good = false;
                      if (cur.ligatureID === prev.ligatureID) {
                        if (!cur.ligatureID) good = true;
                        else if (cur.ligatureComponent === prev.ligatureComponent) good = true;
                      } else if (cur.ligatureID && !cur.ligatureComponent || prev.ligatureID && !prev.ligatureComponent) good = true;
                      if (!good) return false;
                      let mark2Index = this.coverageIndex(table.mark2Coverage, prev.id);
                      if (mark2Index === -1) return false;
                      let markRecord = table.mark1Array[mark1Index];
                      let baseAnchor = table.mark2Array[mark2Index][markRecord.class];
                      this.applyAnchor(markRecord, baseAnchor, prevIndex);
                      return true;
                    }
                    case 7:
                      return this.applyContext(table);
                    case 8:
                      return this.applyChainingContext(table);
                    case 9:
                      return this.applyLookup(table.lookupType, table.extension);
                    default:
                      throw new Error(`Unsupported GPOS table: ${lookupType}`);
                  }
                }
                applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {
                  let baseCoords = this.getAnchor(baseAnchor);
                  let markCoords = this.getAnchor(markRecord.markAnchor);
                  let basePos = this.positions[baseGlyphIndex];
                  let markPos = this.positions[this.glyphIterator.index];
                  markPos.xOffset = baseCoords.x - markCoords.x;
                  markPos.yOffset = baseCoords.y - markCoords.y;
                  this.glyphIterator.cur.markAttachment = baseGlyphIndex;
                }
                getAnchor(anchor) {
                  let x = anchor.xCoordinate;
                  let y = anchor.yCoordinate;
                  let variationProcessor = this.font._variationProcessor;
                  let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
                  if (variationProcessor && variationStore) {
                    if (anchor.xDeviceTable) x += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);
                    if (anchor.yDeviceTable) y += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);
                  }
                  return {
                    x,
                    y
                  };
                }
                applyFeatures(userFeatures, glyphs, advances) {
                  super.applyFeatures(userFeatures, glyphs, advances);
                  for (var i = 0; i < this.glyphs.length; i++) this.fixCursiveAttachment(i);
                  this.fixMarkAttachment();
                }
                fixCursiveAttachment(i) {
                  let glyph = this.glyphs[i];
                  if (glyph.cursiveAttachment != null) {
                    let j = glyph.cursiveAttachment;
                    glyph.cursiveAttachment = null;
                    this.fixCursiveAttachment(j);
                    this.positions[i].yOffset += this.positions[j].yOffset;
                  }
                }
                fixMarkAttachment() {
                  for (let i = 0; i < this.glyphs.length; i++) {
                    let glyph = this.glyphs[i];
                    if (glyph.markAttachment != null) {
                      let j = glyph.markAttachment;
                      this.positions[i].xOffset += this.positions[j].xOffset;
                      this.positions[i].yOffset += this.positions[j].yOffset;
                      if (this.direction === "ltr") for (let k = j; k < i; k++) {
                        this.positions[i].xOffset -= this.positions[k].xAdvance;
                        this.positions[i].yOffset -= this.positions[k].yAdvance;
                      }
                      else for (let k = j + 1; k < i + 1; k++) {
                        this.positions[i].xOffset += this.positions[k].xAdvance;
                        this.positions[i].yOffset += this.positions[k].yAdvance;
                      }
                    }
                  }
                }
              }
              class $b2f26a32cb9ab2fa$export$2e2bcd8739ae039 {
                setup(glyphRun) {
                  this.glyphInfos = glyphRun.glyphs.map((glyph) => new (0, $f22bb23c9fd478d8$export$2e2bcd8739ae039)(this.font, glyph.id, [
                    ...glyph.codePoints
                  ]));
                  let script = null;
                  if (this.GPOSProcessor) script = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
                  if (this.GSUBProcessor) script = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
                  this.shaper = $fdb4471fc82bc2c2$export$7877a478dd30fd3d(script);
                  this.plan = new (0, $d7e93cca3cf8ce8a$export$2e2bcd8739ae039)(this.font, script, glyphRun.direction);
                  this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features);
                  for (let key in this.plan.allFeatures) glyphRun.features[key] = true;
                }
                substitute(glyphRun) {
                  if (this.GSUBProcessor) {
                    this.plan.process(this.GSUBProcessor, this.glyphInfos);
                    glyphRun.glyphs = this.glyphInfos.map((glyphInfo) => this.font.getGlyph(glyphInfo.id, glyphInfo.codePoints));
                  }
                }
                position(glyphRun) {
                  if (this.shaper.zeroMarkWidths === "BEFORE_GPOS") this.zeroMarkAdvances(glyphRun.positions);
                  if (this.GPOSProcessor) this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);
                  if (this.shaper.zeroMarkWidths === "AFTER_GPOS") this.zeroMarkAdvances(glyphRun.positions);
                  if (glyphRun.direction === "rtl") {
                    glyphRun.glyphs.reverse();
                    glyphRun.positions.reverse();
                  }
                  return this.GPOSProcessor && this.GPOSProcessor.features;
                }
                zeroMarkAdvances(positions) {
                  for (let i = 0; i < this.glyphInfos.length; i++) if (this.glyphInfos[i].isMark) {
                    positions[i].xAdvance = 0;
                    positions[i].yAdvance = 0;
                  }
                }
                cleanup() {
                  this.glyphInfos = null;
                  this.plan = null;
                  this.shaper = null;
                }
                getAvailableFeatures(script, language) {
                  let features = [];
                  if (this.GSUBProcessor) {
                    this.GSUBProcessor.selectScript(script, language);
                    features.push(...Object.keys(this.GSUBProcessor.features));
                  }
                  if (this.GPOSProcessor) {
                    this.GPOSProcessor.selectScript(script, language);
                    features.push(...Object.keys(this.GPOSProcessor.features));
                  }
                  return features;
                }
                constructor(font) {
                  this.font = font;
                  this.glyphInfos = null;
                  this.plan = null;
                  this.GSUBProcessor = null;
                  this.GPOSProcessor = null;
                  this.fallbackPosition = true;
                  if (font.GSUB) this.GSUBProcessor = new (0, $86bc1883359e094a$export$2e2bcd8739ae039)(font, font.GSUB);
                  if (font.GPOS) this.GPOSProcessor = new (0, $79ea6270f0a90256$export$2e2bcd8739ae039)(font, font.GPOS);
                }
              }
              class $9d641258c9d7180d$export$2e2bcd8739ae039 {
                layout(string, features, script, language, direction) {
                  if (typeof features === "string") {
                    direction = language;
                    language = script;
                    script = features;
                    features = [];
                  }
                  if (typeof string === "string") {
                    if (script == null) script = $e38a1a895f6aeb54$export$e5cb25e204fb8450(string);
                    var glyphs = this.font.glyphsForString(string);
                  } else {
                    if (script == null) {
                      let codePoints = [];
                      for (let glyph of string) codePoints.push(...glyph.codePoints);
                      script = $e38a1a895f6aeb54$export$16fab0757cfc223d(codePoints);
                    }
                    var glyphs = string;
                  }
                  let glyphRun = new (0, $b19c79ec7a94fa39$export$2e2bcd8739ae039)(glyphs, features, script, language, direction);
                  if (glyphs.length === 0) {
                    glyphRun.positions = [];
                    return glyphRun;
                  }
                  if (this.engine && this.engine.setup) this.engine.setup(glyphRun);
                  this.substitute(glyphRun);
                  this.position(glyphRun);
                  this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);
                  if (this.engine && this.engine.cleanup) this.engine.cleanup();
                  return glyphRun;
                }
                substitute(glyphRun) {
                  if (this.engine && this.engine.substitute) this.engine.substitute(glyphRun);
                }
                position(glyphRun) {
                  glyphRun.positions = glyphRun.glyphs.map((glyph) => new (0, $9195cf1266c12ea5$export$2e2bcd8739ae039)(glyph.advanceWidth));
                  let positioned = null;
                  if (this.engine && this.engine.position) positioned = this.engine.position(glyphRun);
                  if (!positioned && (!this.engine || this.engine.fallbackPosition)) {
                    if (!this.unicodeLayoutEngine) this.unicodeLayoutEngine = new (0, $a57a26817cd35108$export$2e2bcd8739ae039)(this.font);
                    this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);
                  }
                  if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {
                    if (!this.kernProcessor) this.kernProcessor = new (0, $4646d52c2a559cdb$export$2e2bcd8739ae039)(this.font);
                    this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);
                    glyphRun.features.kern = true;
                  }
                }
                hideDefaultIgnorables(glyphs, positions) {
                  let space = this.font.glyphForCodePoint(32);
                  for (let i = 0; i < glyphs.length; i++) if (this.isDefaultIgnorable(glyphs[i].codePoints[0])) {
                    glyphs[i] = space;
                    positions[i].xAdvance = 0;
                    positions[i].yAdvance = 0;
                  }
                }
                isDefaultIgnorable(ch) {
                  let plane = ch >> 16;
                  if (plane === 0)
                    switch (ch >> 8) {
                      case 0:
                        return ch === 173;
                      case 3:
                        return ch === 847;
                      case 6:
                        return ch === 1564;
                      case 23:
                        return 6068 <= ch && ch <= 6069;
                      case 24:
                        return 6155 <= ch && ch <= 6158;
                      case 32:
                        return 8203 <= ch && ch <= 8207 || 8234 <= ch && ch <= 8238 || 8288 <= ch && ch <= 8303;
                      case 254:
                        return 65024 <= ch && ch <= 65039 || ch === 65279;
                      case 255:
                        return 65520 <= ch && ch <= 65528;
                      default:
                        return false;
                    }
                  else
                    switch (plane) {
                      case 1:
                        return 113824 <= ch && ch <= 113827 || 119155 <= ch && ch <= 119162;
                      case 14:
                        return 917504 <= ch && ch <= 921599;
                      default:
                        return false;
                    }
                }
                getAvailableFeatures(script, language) {
                  let features = [];
                  if (this.engine) features.push(...this.engine.getAvailableFeatures(script, language));
                  if (this.font.kern && features.indexOf("kern") === -1) features.push("kern");
                  return features;
                }
                stringsForGlyph(gid) {
                  let result = /* @__PURE__ */ new Set();
                  let codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);
                  for (let codePoint of codePoints) result.add(String.fromCodePoint(codePoint));
                  if (this.engine && this.engine.stringsForGlyph) for (let string of this.engine.stringsForGlyph(gid)) result.add(string);
                  return Array.from(result);
                }
                constructor(font) {
                  this.font = font;
                  this.unicodeLayoutEngine = null;
                  this.kernProcessor = null;
                  if (this.font.morx) this.engine = new (0, $860fcbd64bc12fbc$export$2e2bcd8739ae039)(this.font);
                  else if (this.font.GSUB || this.font.GPOS) this.engine = new (0, $b2f26a32cb9ab2fa$export$2e2bcd8739ae039)(this.font);
                }
              }
              const $67ee4828d81adb28$var$SVG_COMMANDS = {
                moveTo: "M",
                lineTo: "L",
                quadraticCurveTo: "Q",
                bezierCurveTo: "C",
                closePath: "Z"
              };
              class $67ee4828d81adb28$export$2e2bcd8739ae039 {
                /**
                * Compiles the path to a JavaScript function that can be applied with
                * a graphics context in order to render the path.
                * @return {string}
                */
                toFunction() {
                  return (ctx) => {
                    this.commands.forEach((c) => {
                      return ctx[c.command].apply(ctx, c.args);
                    });
                  };
                }
                /**
                * Converts the path to an SVG path data string
                * @return {string}
                */
                toSVG() {
                  let cmds = this.commands.map((c) => {
                    let args = c.args.map((arg) => Math.round(arg * 100) / 100);
                    return `${$67ee4828d81adb28$var$SVG_COMMANDS[c.command]}${args.join(" ")}`;
                  });
                  return cmds.join("");
                }
                /**
                * Gets the "control box" of a path.
                * This is like the bounding box, but it includes all points including
                * control points of bezier segments and is much faster to compute than
                * the real bounding box.
                * @type {BBox}
                */
                get cbox() {
                  if (!this._cbox) {
                    let cbox = new (0, $0e2da1c4ce69e8ad$export$2e2bcd8739ae039)();
                    for (let command of this.commands) for (let i = 0; i < command.args.length; i += 2) cbox.addPoint(command.args[i], command.args[i + 1]);
                    this._cbox = Object.freeze(cbox);
                  }
                  return this._cbox;
                }
                /**
                * Gets the exact bounding box of the path by evaluating curve segments.
                * Slower to compute than the control box, but more accurate.
                * @type {BBox}
                */
                get bbox() {
                  if (this._bbox) return this._bbox;
                  let bbox = new (0, $0e2da1c4ce69e8ad$export$2e2bcd8739ae039)();
                  let cx = 0, cy = 0;
                  let f = (t) => Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i];
                  for (let c of this.commands) switch (c.command) {
                    case "moveTo":
                    case "lineTo":
                      let [x, y] = c.args;
                      bbox.addPoint(x, y);
                      cx = x;
                      cy = y;
                      break;
                    case "quadraticCurveTo":
                    case "bezierCurveTo":
                      if (c.command === "quadraticCurveTo") {
                        var [qp1x, qp1y, p3x, p3y] = c.args;
                        var cp1x = cx + 2 / 3 * (qp1x - cx);
                        var cp1y = cy + 2 / 3 * (qp1y - cy);
                        var cp2x = p3x + 2 / 3 * (qp1x - p3x);
                        var cp2y = p3y + 2 / 3 * (qp1y - p3y);
                      } else var [cp1x, cp1y, cp2x, cp2y, p3x, p3y] = c.args;
                      bbox.addPoint(p3x, p3y);
                      var p0 = [
                        cx,
                        cy
                      ];
                      var p1 = [
                        cp1x,
                        cp1y
                      ];
                      var p2 = [
                        cp2x,
                        cp2y
                      ];
                      var p3 = [
                        p3x,
                        p3y
                      ];
                      for (var i = 0; i <= 1; i++) {
                        let b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
                        let a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
                        c = 3 * p1[i] - 3 * p0[i];
                        if (a === 0) {
                          if (b === 0) continue;
                          let t = -c / b;
                          if (0 < t && t < 1) {
                            if (i === 0) bbox.addPoint(f(t), bbox.maxY);
                            else if (i === 1) bbox.addPoint(bbox.maxX, f(t));
                          }
                          continue;
                        }
                        let b2ac = Math.pow(b, 2) - 4 * c * a;
                        if (b2ac < 0) continue;
                        let t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
                        if (0 < t1 && t1 < 1) {
                          if (i === 0) bbox.addPoint(f(t1), bbox.maxY);
                          else if (i === 1) bbox.addPoint(bbox.maxX, f(t1));
                        }
                        let t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
                        if (0 < t2 && t2 < 1) {
                          if (i === 0) bbox.addPoint(f(t2), bbox.maxY);
                          else if (i === 1) bbox.addPoint(bbox.maxX, f(t2));
                        }
                      }
                      cx = p3x;
                      cy = p3y;
                      break;
                  }
                  return this._bbox = Object.freeze(bbox);
                }
                /**
                * Applies a mapping function to each point in the path.
                * @param {function} fn
                * @return {Path}
                */
                mapPoints(fn) {
                  let path = new $67ee4828d81adb28$export$2e2bcd8739ae039();
                  for (let c of this.commands) {
                    let args = [];
                    for (let i = 0; i < c.args.length; i += 2) {
                      let [x, y] = fn(c.args[i], c.args[i + 1]);
                      args.push(x, y);
                    }
                    path[c.command](...args);
                  }
                  return path;
                }
                /**
                * Transforms the path by the given matrix.
                */
                transform(m0, m1, m2, m3, m4, m5) {
                  return this.mapPoints((x, y) => {
                    const tx = m0 * x + m2 * y + m4;
                    const ty = m1 * x + m3 * y + m5;
                    return [
                      tx,
                      ty
                    ];
                  });
                }
                /**
                * Translates the path by the given offset.
                */
                translate(x, y) {
                  return this.transform(1, 0, 0, 1, x, y);
                }
                /**
                * Rotates the path by the given angle (in radians).
                */
                rotate(angle) {
                  let cos = Math.cos(angle);
                  let sin = Math.sin(angle);
                  return this.transform(cos, sin, -sin, cos, 0, 0);
                }
                /**
                * Scales the path.
                */
                scale(scaleX, scaleY = scaleX) {
                  return this.transform(scaleX, 0, 0, scaleY, 0, 0);
                }
                constructor() {
                  this.commands = [];
                  this._bbox = null;
                  this._cbox = null;
                }
              }
              for (let command of [
                "moveTo",
                "lineTo",
                "quadraticCurveTo",
                "bezierCurveTo",
                "closePath"
              ]) $67ee4828d81adb28$export$2e2bcd8739ae039.prototype[command] = function(...args) {
                this._bbox = this._cbox = null;
                this.commands.push({
                  command,
                  args
                });
                return this;
              };
              var $85e16e40023cfb0f$export$2e2bcd8739ae039 = [
                ".notdef",
                ".null",
                "nonmarkingreturn",
                "space",
                "exclam",
                "quotedbl",
                "numbersign",
                "dollar",
                "percent",
                "ampersand",
                "quotesingle",
                "parenleft",
                "parenright",
                "asterisk",
                "plus",
                "comma",
                "hyphen",
                "period",
                "slash",
                "zero",
                "one",
                "two",
                "three",
                "four",
                "five",
                "six",
                "seven",
                "eight",
                "nine",
                "colon",
                "semicolon",
                "less",
                "equal",
                "greater",
                "question",
                "at",
                "A",
                "B",
                "C",
                "D",
                "E",
                "F",
                "G",
                "H",
                "I",
                "J",
                "K",
                "L",
                "M",
                "N",
                "O",
                "P",
                "Q",
                "R",
                "S",
                "T",
                "U",
                "V",
                "W",
                "X",
                "Y",
                "Z",
                "bracketleft",
                "backslash",
                "bracketright",
                "asciicircum",
                "underscore",
                "grave",
                "a",
                "b",
                "c",
                "d",
                "e",
                "f",
                "g",
                "h",
                "i",
                "j",
                "k",
                "l",
                "m",
                "n",
                "o",
                "p",
                "q",
                "r",
                "s",
                "t",
                "u",
                "v",
                "w",
                "x",
                "y",
                "z",
                "braceleft",
                "bar",
                "braceright",
                "asciitilde",
                "Adieresis",
                "Aring",
                "Ccedilla",
                "Eacute",
                "Ntilde",
                "Odieresis",
                "Udieresis",
                "aacute",
                "agrave",
                "acircumflex",
                "adieresis",
                "atilde",
                "aring",
                "ccedilla",
                "eacute",
                "egrave",
                "ecircumflex",
                "edieresis",
                "iacute",
                "igrave",
                "icircumflex",
                "idieresis",
                "ntilde",
                "oacute",
                "ograve",
                "ocircumflex",
                "odieresis",
                "otilde",
                "uacute",
                "ugrave",
                "ucircumflex",
                "udieresis",
                "dagger",
                "degree",
                "cent",
                "sterling",
                "section",
                "bullet",
                "paragraph",
                "germandbls",
                "registered",
                "copyright",
                "trademark",
                "acute",
                "dieresis",
                "notequal",
                "AE",
                "Oslash",
                "infinity",
                "plusminus",
                "lessequal",
                "greaterequal",
                "yen",
                "mu",
                "partialdiff",
                "summation",
                "product",
                "pi",
                "integral",
                "ordfeminine",
                "ordmasculine",
                "Omega",
                "ae",
                "oslash",
                "questiondown",
                "exclamdown",
                "logicalnot",
                "radical",
                "florin",
                "approxequal",
                "Delta",
                "guillemotleft",
                "guillemotright",
                "ellipsis",
                "nonbreakingspace",
                "Agrave",
                "Atilde",
                "Otilde",
                "OE",
                "oe",
                "endash",
                "emdash",
                "quotedblleft",
                "quotedblright",
                "quoteleft",
                "quoteright",
                "divide",
                "lozenge",
                "ydieresis",
                "Ydieresis",
                "fraction",
                "currency",
                "guilsinglleft",
                "guilsinglright",
                "fi",
                "fl",
                "daggerdbl",
                "periodcentered",
                "quotesinglbase",
                "quotedblbase",
                "perthousand",
                "Acircumflex",
                "Ecircumflex",
                "Aacute",
                "Edieresis",
                "Egrave",
                "Iacute",
                "Icircumflex",
                "Idieresis",
                "Igrave",
                "Oacute",
                "Ocircumflex",
                "apple",
                "Ograve",
                "Uacute",
                "Ucircumflex",
                "Ugrave",
                "dotlessi",
                "circumflex",
                "tilde",
                "macron",
                "breve",
                "dotaccent",
                "ring",
                "cedilla",
                "hungarumlaut",
                "ogonek",
                "caron",
                "Lslash",
                "lslash",
                "Scaron",
                "scaron",
                "Zcaron",
                "zcaron",
                "brokenbar",
                "Eth",
                "eth",
                "Yacute",
                "yacute",
                "Thorn",
                "thorn",
                "minus",
                "multiply",
                "onesuperior",
                "twosuperior",
                "threesuperior",
                "onehalf",
                "onequarter",
                "threequarters",
                "franc",
                "Gbreve",
                "gbreve",
                "Idotaccent",
                "Scedilla",
                "scedilla",
                "Cacute",
                "cacute",
                "Ccaron",
                "ccaron",
                "dcroat"
              ];
              class $0e4f52d7996e478b$export$2e2bcd8739ae039 {
                _getPath() {
                  return new (0, $67ee4828d81adb28$export$2e2bcd8739ae039)();
                }
                _getCBox() {
                  return this.path.cbox;
                }
                _getBBox() {
                  return this.path.bbox;
                }
                _getTableMetrics(table) {
                  if (this.id < table.metrics.length) return table.metrics.get(this.id);
                  let metric = table.metrics.get(table.metrics.length - 1);
                  let res = {
                    advance: metric ? metric.advance : 0,
                    bearing: table.bearings.get(this.id - table.metrics.length) || 0
                  };
                  return res;
                }
                _getMetrics(cbox) {
                  if (this._metrics) return this._metrics;
                  let { advance: advanceWidth, bearing: leftBearing } = this._getTableMetrics(this._font.hmtx);
                  if (this._font.vmtx) var { advance: advanceHeight, bearing: topBearing } = this._getTableMetrics(this._font.vmtx);
                  else {
                    let os2;
                    if (typeof cbox === "undefined" || cbox === null) ({ cbox } = this);
                    if ((os2 = this._font["OS/2"]) && os2.version > 0) {
                      var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);
                      var topBearing = os2.typoAscender - cbox.maxY;
                    } else {
                      let { hhea } = this._font;
                      var advanceHeight = Math.abs(hhea.ascent - hhea.descent);
                      var topBearing = hhea.ascent - cbox.maxY;
                    }
                  }
                  if (this._font._variationProcessor && this._font.HVAR) advanceWidth += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);
                  return this._metrics = {
                    advanceWidth,
                    advanceHeight,
                    leftBearing,
                    topBearing
                  };
                }
                /**
                * The glyphs control box.
                * This is often the same as the bounding box, but is faster to compute.
                * Because of the way bezier curves are defined, some of the control points
                * can be outside of the bounding box. Where `bbox` takes this into account,
                * `cbox` does not. Thus, cbox is less accurate, but faster to compute.
                * See [here](http://www.freetype.org/freetype2/docs/glyphs/glyphs-6.html#section-2)
                * for a more detailed description.
                *
                * @type {BBox}
                */
                get cbox() {
                  return this._getCBox();
                }
                /**
                * The glyphs bounding box, i.e. the rectangle that encloses the
                * glyph outline as tightly as possible.
                * @type {BBox}
                */
                get bbox() {
                  return this._getBBox();
                }
                /**
                * A vector Path object representing the glyph outline.
                * @type {Path}
                */
                get path() {
                  return this._getPath();
                }
                /**
                * Returns a path scaled to the given font size.
                * @param {number} size
                * @return {Path}
                */
                getScaledPath(size) {
                  let scale = 1 / this._font.unitsPerEm * size;
                  return this.path.scale(scale);
                }
                /**
                * The glyph's advance width.
                * @type {number}
                */
                get advanceWidth() {
                  return this._getMetrics().advanceWidth;
                }
                /**
                * The glyph's advance height.
                * @type {number}
                */
                get advanceHeight() {
                  return this._getMetrics().advanceHeight;
                }
                get ligatureCaretPositions() {
                }
                _getName() {
                  let { post } = this._font;
                  if (!post) return null;
                  switch (post.version) {
                    case 1:
                      return (0, $85e16e40023cfb0f$export$2e2bcd8739ae039)[this.id];
                    case 2:
                      let id = post.glyphNameIndex[this.id];
                      if (id < (0, $85e16e40023cfb0f$export$2e2bcd8739ae039).length) return (0, $85e16e40023cfb0f$export$2e2bcd8739ae039)[id];
                      return post.names[id - (0, $85e16e40023cfb0f$export$2e2bcd8739ae039).length];
                    case 2.5:
                      return (0, $85e16e40023cfb0f$export$2e2bcd8739ae039)[this.id + post.offsets[this.id]];
                    case 4:
                      return String.fromCharCode(post.map[this.id]);
                  }
                }
                /**
                * The glyph's name
                * @type {string}
                */
                get name() {
                  return this._getName();
                }
                /**
                * Renders the glyph to the given graphics context, at the specified font size.
                * @param {CanvasRenderingContext2d} ctx
                * @param {number} size
                */
                render(ctx, size) {
                  ctx.save();
                  let scale = 1 / this._font.head.unitsPerEm * size;
                  ctx.scale(scale, scale);
                  let fn = this.path.toFunction();
                  fn(ctx);
                  ctx.fill();
                  ctx.restore();
                }
                constructor(id, codePoints, font) {
                  this.id = id;
                  this.codePoints = codePoints;
                  this._font = font;
                  this.isMark = this.codePoints.length > 0 && this.codePoints.every((0, $gfJaN$unicodeproperties.isMark));
                  this.isLigature = this.codePoints.length > 1;
                }
              }
              (0, $gfJaN$swchelperscjs_ts_decoratecjs._)([
                (0, $3bda6911913b43f0$export$69a3209f1a06c04d)
              ], $0e4f52d7996e478b$export$2e2bcd8739ae039.prototype, "cbox", null);
              (0, $gfJaN$swchelperscjs_ts_decoratecjs._)([
                (0, $3bda6911913b43f0$export$69a3209f1a06c04d)
              ], $0e4f52d7996e478b$export$2e2bcd8739ae039.prototype, "bbox", null);
              (0, $gfJaN$swchelperscjs_ts_decoratecjs._)([
                (0, $3bda6911913b43f0$export$69a3209f1a06c04d)
              ], $0e4f52d7996e478b$export$2e2bcd8739ae039.prototype, "path", null);
              (0, $gfJaN$swchelperscjs_ts_decoratecjs._)([
                (0, $3bda6911913b43f0$export$69a3209f1a06c04d)
              ], $0e4f52d7996e478b$export$2e2bcd8739ae039.prototype, "advanceWidth", null);
              (0, $gfJaN$swchelperscjs_ts_decoratecjs._)([
                (0, $3bda6911913b43f0$export$69a3209f1a06c04d)
              ], $0e4f52d7996e478b$export$2e2bcd8739ae039.prototype, "advanceHeight", null);
              (0, $gfJaN$swchelperscjs_ts_decoratecjs._)([
                (0, $3bda6911913b43f0$export$69a3209f1a06c04d)
              ], $0e4f52d7996e478b$export$2e2bcd8739ae039.prototype, "name", null);
              let $f680320fa07ef53d$var$GlyfHeader = new $gfJaN$restructure.Struct({
                numberOfContours: $gfJaN$restructure.int16,
                xMin: $gfJaN$restructure.int16,
                yMin: $gfJaN$restructure.int16,
                xMax: $gfJaN$restructure.int16,
                yMax: $gfJaN$restructure.int16
              });
              const $f680320fa07ef53d$var$ON_CURVE = 1;
              const $f680320fa07ef53d$var$X_SHORT_VECTOR = 2;
              const $f680320fa07ef53d$var$Y_SHORT_VECTOR = 4;
              const $f680320fa07ef53d$var$REPEAT = 8;
              const $f680320fa07ef53d$var$SAME_X = 16;
              const $f680320fa07ef53d$var$SAME_Y = 32;
              const $f680320fa07ef53d$var$ARG_1_AND_2_ARE_WORDS = 1;
              const $f680320fa07ef53d$var$ARGS_ARE_XY_VALUES = 2;
              const $f680320fa07ef53d$var$ROUND_XY_TO_GRID = 4;
              const $f680320fa07ef53d$var$WE_HAVE_A_SCALE = 8;
              const $f680320fa07ef53d$var$MORE_COMPONENTS = 32;
              const $f680320fa07ef53d$var$WE_HAVE_AN_X_AND_Y_SCALE = 64;
              const $f680320fa07ef53d$var$WE_HAVE_A_TWO_BY_TWO = 128;
              const $f680320fa07ef53d$var$WE_HAVE_INSTRUCTIONS = 256;
              const $f680320fa07ef53d$var$USE_MY_METRICS = 512;
              const $f680320fa07ef53d$var$OVERLAP_COMPOUND = 1024;
              const $f680320fa07ef53d$var$SCALED_COMPONENT_OFFSET = 2048;
              const $f680320fa07ef53d$var$UNSCALED_COMPONENT_OFFSET = 4096;
              class $f680320fa07ef53d$export$baf26146a414f24a {
                copy() {
                  return new $f680320fa07ef53d$export$baf26146a414f24a(this.onCurve, this.endContour, this.x, this.y);
                }
                constructor(onCurve, endContour, x = 0, y = 0) {
                  this.onCurve = onCurve;
                  this.endContour = endContour;
                  this.x = x;
                  this.y = y;
                }
              }
              class $f680320fa07ef53d$var$Component {
                constructor(glyphID, dx, dy) {
                  this.glyphID = glyphID;
                  this.dx = dx;
                  this.dy = dy;
                  this.pos = 0;
                  this.scaleX = this.scaleY = 1;
                  this.scale01 = this.scale10 = 0;
                }
              }
              class $f680320fa07ef53d$export$2e2bcd8739ae039 extends (0, $0e4f52d7996e478b$export$2e2bcd8739ae039) {
                // Parses just the glyph header and returns the bounding box
                _getCBox(internal) {
                  if (this._font._variationProcessor && !internal) return this.path.cbox;
                  let stream = this._font._getTableStream("glyf");
                  stream.pos += this._font.loca.offsets[this.id];
                  let glyph = $f680320fa07ef53d$var$GlyfHeader.decode(stream);
                  let cbox = new (0, $0e2da1c4ce69e8ad$export$2e2bcd8739ae039)(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);
                  return Object.freeze(cbox);
                }
                // Parses a single glyph coordinate
                _parseGlyphCoord(stream, prev, short, same) {
                  if (short) {
                    var val = stream.readUInt8();
                    if (!same) val = -val;
                    val += prev;
                  } else if (same) var val = prev;
                  else var val = prev + stream.readInt16BE();
                  return val;
                }
                // Decodes the glyph data into points for simple glyphs,
                // or components for composite glyphs
                _decode() {
                  let glyfPos = this._font.loca.offsets[this.id];
                  let nextPos = this._font.loca.offsets[this.id + 1];
                  if (glyfPos === nextPos) return null;
                  let stream = this._font._getTableStream("glyf");
                  stream.pos += glyfPos;
                  let startPos = stream.pos;
                  let glyph = $f680320fa07ef53d$var$GlyfHeader.decode(stream);
                  if (glyph.numberOfContours > 0) this._decodeSimple(glyph, stream);
                  else if (glyph.numberOfContours < 0) this._decodeComposite(glyph, stream, startPos);
                  return glyph;
                }
                _decodeSimple(glyph, stream) {
                  glyph.points = [];
                  let endPtsOfContours = new $gfJaN$restructure.Array($gfJaN$restructure.uint16, glyph.numberOfContours).decode(stream);
                  glyph.instructions = new $gfJaN$restructure.Array($gfJaN$restructure.uint8, $gfJaN$restructure.uint16).decode(stream);
                  let flags = [];
                  let numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;
                  while (flags.length < numCoords) {
                    var flag = stream.readUInt8();
                    flags.push(flag);
                    if (flag & $f680320fa07ef53d$var$REPEAT) {
                      let count = stream.readUInt8();
                      for (let j = 0; j < count; j++) flags.push(flag);
                    }
                  }
                  for (var i = 0; i < flags.length; i++) {
                    var flag = flags[i];
                    let point = new $f680320fa07ef53d$export$baf26146a414f24a(!!(flag & $f680320fa07ef53d$var$ON_CURVE), endPtsOfContours.indexOf(i) >= 0, 0, 0);
                    glyph.points.push(point);
                  }
                  let px = 0;
                  for (var i = 0; i < flags.length; i++) {
                    var flag = flags[i];
                    glyph.points[i].x = px = this._parseGlyphCoord(stream, px, flag & $f680320fa07ef53d$var$X_SHORT_VECTOR, flag & $f680320fa07ef53d$var$SAME_X);
                  }
                  let py = 0;
                  for (var i = 0; i < flags.length; i++) {
                    var flag = flags[i];
                    glyph.points[i].y = py = this._parseGlyphCoord(stream, py, flag & $f680320fa07ef53d$var$Y_SHORT_VECTOR, flag & $f680320fa07ef53d$var$SAME_Y);
                  }
                  if (this._font._variationProcessor) {
                    let points = glyph.points.slice();
                    points.push(...this._getPhantomPoints(glyph));
                    this._font._variationProcessor.transformPoints(this.id, points);
                    glyph.phantomPoints = points.slice(-4);
                  }
                  return;
                }
                _decodeComposite(glyph, stream, offset = 0) {
                  glyph.components = [];
                  let haveInstructions = false;
                  let flags = $f680320fa07ef53d$var$MORE_COMPONENTS;
                  while (flags & $f680320fa07ef53d$var$MORE_COMPONENTS) {
                    flags = stream.readUInt16BE();
                    let gPos = stream.pos - offset;
                    let glyphID = stream.readUInt16BE();
                    if (!haveInstructions) haveInstructions = (flags & $f680320fa07ef53d$var$WE_HAVE_INSTRUCTIONS) !== 0;
                    if (flags & $f680320fa07ef53d$var$ARG_1_AND_2_ARE_WORDS) {
                      var dx = stream.readInt16BE();
                      var dy = stream.readInt16BE();
                    } else {
                      var dx = stream.readInt8();
                      var dy = stream.readInt8();
                    }
                    var component = new $f680320fa07ef53d$var$Component(glyphID, dx, dy);
                    component.pos = gPos;
                    if (flags & $f680320fa07ef53d$var$WE_HAVE_A_SCALE)
                      component.scaleX = component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                    else if (flags & $f680320fa07ef53d$var$WE_HAVE_AN_X_AND_Y_SCALE) {
                      component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                      component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                    } else if (flags & $f680320fa07ef53d$var$WE_HAVE_A_TWO_BY_TWO) {
                      component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                      component.scale01 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                      component.scale10 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                      component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                    }
                    glyph.components.push(component);
                  }
                  if (this._font._variationProcessor) {
                    let points = [];
                    for (let j = 0; j < glyph.components.length; j++) {
                      var component = glyph.components[j];
                      points.push(new $f680320fa07ef53d$export$baf26146a414f24a(true, true, component.dx, component.dy));
                    }
                    points.push(...this._getPhantomPoints(glyph));
                    this._font._variationProcessor.transformPoints(this.id, points);
                    glyph.phantomPoints = points.splice(-4, 4);
                    for (let i = 0; i < points.length; i++) {
                      let point = points[i];
                      glyph.components[i].dx = point.x;
                      glyph.components[i].dy = point.y;
                    }
                  }
                  return haveInstructions;
                }
                _getPhantomPoints(glyph) {
                  let cbox = this._getCBox(true);
                  if (this._metrics == null) this._metrics = (0, $0e4f52d7996e478b$export$2e2bcd8739ae039).prototype._getMetrics.call(this, cbox);
                  let { advanceWidth, advanceHeight, leftBearing, topBearing } = this._metrics;
                  return [
                    new $f680320fa07ef53d$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing, 0),
                    new $f680320fa07ef53d$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing + advanceWidth, 0),
                    new $f680320fa07ef53d$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing),
                    new $f680320fa07ef53d$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing + advanceHeight)
                  ];
                }
                // Decodes font data, resolves composite glyphs, and returns an array of contours
                _getContours() {
                  let glyph = this._decode();
                  if (!glyph) return [];
                  let points = [];
                  if (glyph.numberOfContours < 0)
                    for (let component of glyph.components) {
                      let contours2 = this._font.getGlyph(component.glyphID)._getContours();
                      for (let i = 0; i < contours2.length; i++) {
                        let contour = contours2[i];
                        for (let j = 0; j < contour.length; j++) {
                          let point2 = contour[j];
                          let x = point2.x * component.scaleX + point2.y * component.scale01 + component.dx;
                          let y = point2.y * component.scaleY + point2.x * component.scale10 + component.dy;
                          points.push(new $f680320fa07ef53d$export$baf26146a414f24a(point2.onCurve, point2.endContour, x, y));
                        }
                      }
                    }
                  else points = glyph.points || [];
                  if (glyph.phantomPoints && !this._font.directory.tables.HVAR) {
                    this._metrics.advanceWidth = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;
                    this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;
                    this._metrics.leftBearing = glyph.xMin - glyph.phantomPoints[0].x;
                    this._metrics.topBearing = glyph.phantomPoints[2].y - glyph.yMax;
                  }
                  let contours = [];
                  let cur = [];
                  for (let k = 0; k < points.length; k++) {
                    var point = points[k];
                    cur.push(point);
                    if (point.endContour) {
                      contours.push(cur);
                      cur = [];
                    }
                  }
                  return contours;
                }
                _getMetrics() {
                  if (this._metrics) return this._metrics;
                  let cbox = this._getCBox(true);
                  super._getMetrics(cbox);
                  if (this._font._variationProcessor && !this._font.HVAR)
                    this.path;
                  return this._metrics;
                }
                // Converts contours to a Path object that can be rendered
                _getPath() {
                  let contours = this._getContours();
                  let path = new (0, $67ee4828d81adb28$export$2e2bcd8739ae039)();
                  for (let i = 0; i < contours.length; i++) {
                    let contour = contours[i];
                    let firstPt = contour[0];
                    let lastPt = contour[contour.length - 1];
                    let start = 0;
                    if (firstPt.onCurve) {
                      var curvePt = null;
                      start = 1;
                    } else {
                      if (lastPt.onCurve)
                        firstPt = lastPt;
                      else
                        firstPt = new $f680320fa07ef53d$export$baf26146a414f24a(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);
                      var curvePt = firstPt;
                    }
                    path.moveTo(firstPt.x, firstPt.y);
                    for (let j = start; j < contour.length; j++) {
                      let pt = contour[j];
                      let prevPt = j === 0 ? firstPt : contour[j - 1];
                      if (prevPt.onCurve && pt.onCurve) path.lineTo(pt.x, pt.y);
                      else if (prevPt.onCurve && !pt.onCurve) var curvePt = pt;
                      else if (!prevPt.onCurve && !pt.onCurve) {
                        let midX = (prevPt.x + pt.x) / 2;
                        let midY = (prevPt.y + pt.y) / 2;
                        path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);
                        var curvePt = pt;
                      } else if (!prevPt.onCurve && pt.onCurve) {
                        path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
                        var curvePt = null;
                      } else throw new Error("Unknown TTF path state");
                    }
                    if (curvePt) path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
                    path.closePath();
                  }
                  return path;
                }
                constructor(...args) {
                  super(...args);
                  (0, $gfJaN$swchelperscjs_define_propertycjs._)(this, "type", "TTF");
                }
              }
              class $7ee0705195f3b047$export$2e2bcd8739ae039 extends (0, $0e4f52d7996e478b$export$2e2bcd8739ae039) {
                _getName() {
                  if (this._font.CFF2) return super._getName();
                  return this._font["CFF "].getGlyphName(this.id);
                }
                bias(s) {
                  if (s.length < 1240) return 107;
                  else if (s.length < 33900) return 1131;
                  else return 32768;
                }
                _getPath() {
                  let cff = this._font.CFF2 || this._font["CFF "];
                  let { stream } = cff;
                  let str = cff.topDict.CharStrings[this.id];
                  let end = str.offset + str.length;
                  stream.pos = str.offset;
                  let path = new (0, $67ee4828d81adb28$export$2e2bcd8739ae039)();
                  let stack = [];
                  let trans = [];
                  let width = null;
                  let nStems = 0;
                  let x = 0, y = 0;
                  let usedGsubrs;
                  let usedSubrs;
                  let open2 = false;
                  this._usedGsubrs = usedGsubrs = {};
                  this._usedSubrs = usedSubrs = {};
                  let gsubrs = cff.globalSubrIndex || [];
                  let gsubrsBias = this.bias(gsubrs);
                  let privateDict = cff.privateDictForGlyph(this.id) || {};
                  let subrs = privateDict.Subrs || [];
                  let subrsBias = this.bias(subrs);
                  let vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;
                  let vsindex = privateDict.vsindex;
                  let variationProcessor = this._font._variationProcessor;
                  function checkWidth() {
                    if (width == null) width = stack.shift() + privateDict.nominalWidthX;
                  }
                  function parseStems() {
                    if (stack.length % 2 !== 0) checkWidth();
                    nStems += stack.length >> 1;
                    return stack.length = 0;
                  }
                  function moveTo(x2, y2) {
                    if (open2) path.closePath();
                    path.moveTo(x2, y2);
                    open2 = true;
                  }
                  let parse = function() {
                    while (stream.pos < end) {
                      let op = stream.readUInt8();
                      if (op < 32) {
                        let index, subr, phase;
                        let c1x, c1y, c2x, c2y, c3x, c3y;
                        let c4x, c4y, c5x, c5y, c6x, c6y;
                        let pts;
                        switch (op) {
                          case 1:
                          case 3:
                          case 18:
                          case 23:
                            parseStems();
                            break;
                          case 4:
                            if (stack.length > 1) checkWidth();
                            y += stack.shift();
                            moveTo(x, y);
                            break;
                          case 5:
                            while (stack.length >= 2) {
                              x += stack.shift();
                              y += stack.shift();
                              path.lineTo(x, y);
                            }
                            break;
                          case 6:
                          case 7:
                            phase = op === 6;
                            while (stack.length >= 1) {
                              if (phase) x += stack.shift();
                              else y += stack.shift();
                              path.lineTo(x, y);
                              phase = !phase;
                            }
                            break;
                          case 8:
                            while (stack.length > 0) {
                              c1x = x + stack.shift();
                              c1y = y + stack.shift();
                              c2x = c1x + stack.shift();
                              c2y = c1y + stack.shift();
                              x = c2x + stack.shift();
                              y = c2y + stack.shift();
                              path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                            }
                            break;
                          case 10:
                            index = stack.pop() + subrsBias;
                            subr = subrs[index];
                            if (subr) {
                              usedSubrs[index] = true;
                              let p = stream.pos;
                              let e = end;
                              stream.pos = subr.offset;
                              end = subr.offset + subr.length;
                              parse();
                              stream.pos = p;
                              end = e;
                            }
                            break;
                          case 11:
                            if (cff.version >= 2) break;
                            return;
                          case 14:
                            if (cff.version >= 2) break;
                            if (stack.length > 0) checkWidth();
                            if (open2) {
                              path.closePath();
                              open2 = false;
                            }
                            break;
                          case 15:
                            if (cff.version < 2) throw new Error("vsindex operator not supported in CFF v1");
                            vsindex = stack.pop();
                            break;
                          case 16: {
                            if (cff.version < 2) throw new Error("blend operator not supported in CFF v1");
                            if (!variationProcessor) throw new Error("blend operator in non-variation font");
                            let blendVector = variationProcessor.getBlendVector(vstore, vsindex);
                            let numBlends = stack.pop();
                            let numOperands = numBlends * blendVector.length;
                            let delta = stack.length - numOperands;
                            let base = delta - numBlends;
                            for (let i = 0; i < numBlends; i++) {
                              let sum = stack[base + i];
                              for (let j = 0; j < blendVector.length; j++) sum += blendVector[j] * stack[delta++];
                              stack[base + i] = sum;
                            }
                            while (numOperands--) stack.pop();
                            break;
                          }
                          case 19:
                          case 20:
                            parseStems();
                            stream.pos += nStems + 7 >> 3;
                            break;
                          case 21:
                            if (stack.length > 2) checkWidth();
                            x += stack.shift();
                            y += stack.shift();
                            moveTo(x, y);
                            break;
                          case 22:
                            if (stack.length > 1) checkWidth();
                            x += stack.shift();
                            moveTo(x, y);
                            break;
                          case 24:
                            while (stack.length >= 8) {
                              c1x = x + stack.shift();
                              c1y = y + stack.shift();
                              c2x = c1x + stack.shift();
                              c2y = c1y + stack.shift();
                              x = c2x + stack.shift();
                              y = c2y + stack.shift();
                              path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                            }
                            x += stack.shift();
                            y += stack.shift();
                            path.lineTo(x, y);
                            break;
                          case 25:
                            while (stack.length >= 8) {
                              x += stack.shift();
                              y += stack.shift();
                              path.lineTo(x, y);
                            }
                            c1x = x + stack.shift();
                            c1y = y + stack.shift();
                            c2x = c1x + stack.shift();
                            c2y = c1y + stack.shift();
                            x = c2x + stack.shift();
                            y = c2y + stack.shift();
                            path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                            break;
                          case 26:
                            if (stack.length % 2) x += stack.shift();
                            while (stack.length >= 4) {
                              c1x = x;
                              c1y = y + stack.shift();
                              c2x = c1x + stack.shift();
                              c2y = c1y + stack.shift();
                              x = c2x;
                              y = c2y + stack.shift();
                              path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                            }
                            break;
                          case 27:
                            if (stack.length % 2) y += stack.shift();
                            while (stack.length >= 4) {
                              c1x = x + stack.shift();
                              c1y = y;
                              c2x = c1x + stack.shift();
                              c2y = c1y + stack.shift();
                              x = c2x + stack.shift();
                              y = c2y;
                              path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                            }
                            break;
                          case 28:
                            stack.push(stream.readInt16BE());
                            break;
                          case 29:
                            index = stack.pop() + gsubrsBias;
                            subr = gsubrs[index];
                            if (subr) {
                              usedGsubrs[index] = true;
                              let p = stream.pos;
                              let e = end;
                              stream.pos = subr.offset;
                              end = subr.offset + subr.length;
                              parse();
                              stream.pos = p;
                              end = e;
                            }
                            break;
                          case 30:
                          case 31:
                            phase = op === 31;
                            while (stack.length >= 4) {
                              if (phase) {
                                c1x = x + stack.shift();
                                c1y = y;
                                c2x = c1x + stack.shift();
                                c2y = c1y + stack.shift();
                                y = c2y + stack.shift();
                                x = c2x + (stack.length === 1 ? stack.shift() : 0);
                              } else {
                                c1x = x;
                                c1y = y + stack.shift();
                                c2x = c1x + stack.shift();
                                c2y = c1y + stack.shift();
                                x = c2x + stack.shift();
                                y = c2y + (stack.length === 1 ? stack.shift() : 0);
                              }
                              path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                              phase = !phase;
                            }
                            break;
                          case 12:
                            op = stream.readUInt8();
                            switch (op) {
                              case 3:
                                let a = stack.pop();
                                let b = stack.pop();
                                stack.push(a && b ? 1 : 0);
                                break;
                              case 4:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(a || b ? 1 : 0);
                                break;
                              case 5:
                                a = stack.pop();
                                stack.push(a ? 0 : 1);
                                break;
                              case 9:
                                a = stack.pop();
                                stack.push(Math.abs(a));
                                break;
                              case 10:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(a + b);
                                break;
                              case 11:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(a - b);
                                break;
                              case 12:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(a / b);
                                break;
                              case 14:
                                a = stack.pop();
                                stack.push(-a);
                                break;
                              case 15:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(a === b ? 1 : 0);
                                break;
                              case 18:
                                stack.pop();
                                break;
                              case 20:
                                let val = stack.pop();
                                let idx = stack.pop();
                                trans[idx] = val;
                                break;
                              case 21:
                                idx = stack.pop();
                                stack.push(trans[idx] || 0);
                                break;
                              case 22:
                                let s1 = stack.pop();
                                let s2 = stack.pop();
                                let v1 = stack.pop();
                                let v2 = stack.pop();
                                stack.push(v1 <= v2 ? s1 : s2);
                                break;
                              case 23:
                                stack.push(Math.random());
                                break;
                              case 24:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(a * b);
                                break;
                              case 26:
                                a = stack.pop();
                                stack.push(Math.sqrt(a));
                                break;
                              case 27:
                                a = stack.pop();
                                stack.push(a, a);
                                break;
                              case 28:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(b, a);
                                break;
                              case 29:
                                idx = stack.pop();
                                if (idx < 0) idx = 0;
                                else if (idx > stack.length - 1) idx = stack.length - 1;
                                stack.push(stack[idx]);
                                break;
                              case 30:
                                let n = stack.pop();
                                let j = stack.pop();
                                if (j >= 0) while (j > 0) {
                                  var t = stack[n - 1];
                                  for (let i = n - 2; i >= 0; i--) stack[i + 1] = stack[i];
                                  stack[0] = t;
                                  j--;
                                }
                                else while (j < 0) {
                                  var t = stack[0];
                                  for (let i = 0; i <= n; i++) stack[i] = stack[i + 1];
                                  stack[n - 1] = t;
                                  j++;
                                }
                                break;
                              case 34:
                                c1x = x + stack.shift();
                                c1y = y;
                                c2x = c1x + stack.shift();
                                c2y = c1y + stack.shift();
                                c3x = c2x + stack.shift();
                                c3y = c2y;
                                c4x = c3x + stack.shift();
                                c4y = c3y;
                                c5x = c4x + stack.shift();
                                c5y = c4y;
                                c6x = c5x + stack.shift();
                                c6y = c5y;
                                x = c6x;
                                y = c6y;
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                                path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                                break;
                              case 35:
                                pts = [];
                                for (let i = 0; i <= 5; i++) {
                                  x += stack.shift();
                                  y += stack.shift();
                                  pts.push(x, y);
                                }
                                path.bezierCurveTo(...pts.slice(0, 6));
                                path.bezierCurveTo(...pts.slice(6));
                                stack.shift();
                                break;
                              case 36:
                                c1x = x + stack.shift();
                                c1y = y + stack.shift();
                                c2x = c1x + stack.shift();
                                c2y = c1y + stack.shift();
                                c3x = c2x + stack.shift();
                                c3y = c2y;
                                c4x = c3x + stack.shift();
                                c4y = c3y;
                                c5x = c4x + stack.shift();
                                c5y = c4y + stack.shift();
                                c6x = c5x + stack.shift();
                                c6y = c5y;
                                x = c6x;
                                y = c6y;
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                                path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                                break;
                              case 37:
                                let startx = x;
                                let starty = y;
                                pts = [];
                                for (let i = 0; i <= 4; i++) {
                                  x += stack.shift();
                                  y += stack.shift();
                                  pts.push(x, y);
                                }
                                if (Math.abs(x - startx) > Math.abs(y - starty)) {
                                  x += stack.shift();
                                  y = starty;
                                } else {
                                  x = startx;
                                  y += stack.shift();
                                }
                                pts.push(x, y);
                                path.bezierCurveTo(...pts.slice(0, 6));
                                path.bezierCurveTo(...pts.slice(6));
                                break;
                              default:
                                throw new Error(`Unknown op: 12 ${op}`);
                            }
                            break;
                          default:
                            throw new Error(`Unknown op: ${op}`);
                        }
                      } else if (op < 247) stack.push(op - 139);
                      else if (op < 251) {
                        var b1 = stream.readUInt8();
                        stack.push((op - 247) * 256 + b1 + 108);
                      } else if (op < 255) {
                        var b1 = stream.readUInt8();
                        stack.push(-(op - 251) * 256 - b1 - 108);
                      } else stack.push(stream.readInt32BE() / 65536);
                    }
                  };
                  parse();
                  if (open2) path.closePath();
                  return path;
                }
                constructor(...args) {
                  super(...args);
                  (0, $gfJaN$swchelperscjs_define_propertycjs._)(this, "type", "CFF");
                }
              }
              let $55855d6d316b015e$var$SBIXImage = new $gfJaN$restructure.Struct({
                originX: $gfJaN$restructure.uint16,
                originY: $gfJaN$restructure.uint16,
                type: new $gfJaN$restructure.String(4),
                data: new $gfJaN$restructure.Buffer((t) => t.parent.buflen - t._currentOffset)
              });
              class $55855d6d316b015e$export$2e2bcd8739ae039 extends (0, $f680320fa07ef53d$export$2e2bcd8739ae039) {
                /**
                * Returns an object representing a glyph image at the given point size.
                * The object has a data property with a Buffer containing the actual image data,
                * along with the image type, and origin.
                *
                * @param {number} size
                * @return {object}
                */
                getImageForSize(size) {
                  for (let i = 0; i < this._font.sbix.imageTables.length; i++) {
                    var table = this._font.sbix.imageTables[i];
                    if (table.ppem >= size) break;
                  }
                  let offsets = table.imageOffsets;
                  let start = offsets[this.id];
                  let end = offsets[this.id + 1];
                  if (start === end) return null;
                  this._font.stream.pos = start;
                  return $55855d6d316b015e$var$SBIXImage.decode(this._font.stream, {
                    buflen: end - start
                  });
                }
                render(ctx, size) {
                  let img = this.getImageForSize(size);
                  if (img != null) {
                    let scale = size / this._font.unitsPerEm;
                    ctx.image(img.data, {
                      height: size,
                      x: img.originX,
                      y: (this.bbox.minY - img.originY) * scale
                    });
                  }
                  if (this._font.sbix.flags.renderOutlines) super.render(ctx, size);
                }
                constructor(...args) {
                  super(...args);
                  (0, $gfJaN$swchelperscjs_define_propertycjs._)(this, "type", "SBIX");
                }
              }
              class $42d9dbd2de9ee2d8$var$COLRLayer {
                constructor(glyph, color) {
                  this.glyph = glyph;
                  this.color = color;
                }
              }
              class $42d9dbd2de9ee2d8$export$2e2bcd8739ae039 extends (0, $0e4f52d7996e478b$export$2e2bcd8739ae039) {
                _getBBox() {
                  let bbox = new (0, $0e2da1c4ce69e8ad$export$2e2bcd8739ae039)();
                  for (let i = 0; i < this.layers.length; i++) {
                    let layer = this.layers[i];
                    let b = layer.glyph.bbox;
                    bbox.addPoint(b.minX, b.minY);
                    bbox.addPoint(b.maxX, b.maxY);
                  }
                  return bbox;
                }
                /**
                * Returns an array of objects containing the glyph and color for
                * each layer in the composite color glyph.
                * @type {object[]}
                */
                get layers() {
                  let cpal = this._font.CPAL;
                  let colr = this._font.COLR;
                  let low = 0;
                  let high = colr.baseGlyphRecord.length - 1;
                  while (low <= high) {
                    let mid = low + high >> 1;
                    var rec = colr.baseGlyphRecord[mid];
                    if (this.id < rec.gid) high = mid - 1;
                    else if (this.id > rec.gid) low = mid + 1;
                    else {
                      var baseLayer = rec;
                      break;
                    }
                  }
                  if (baseLayer == null) {
                    var g = this._font._getBaseGlyph(this.id);
                    var color = {
                      red: 0,
                      green: 0,
                      blue: 0,
                      alpha: 255
                    };
                    return [
                      new $42d9dbd2de9ee2d8$var$COLRLayer(g, color)
                    ];
                  }
                  let layers = [];
                  for (let i = baseLayer.firstLayerIndex; i < baseLayer.firstLayerIndex + baseLayer.numLayers; i++) {
                    var rec = colr.layerRecords[i];
                    var color = cpal.colorRecords[rec.paletteIndex];
                    var g = this._font._getBaseGlyph(rec.gid);
                    layers.push(new $42d9dbd2de9ee2d8$var$COLRLayer(g, color));
                  }
                  return layers;
                }
                render(ctx, size) {
                  for (let { glyph, color } of this.layers) {
                    ctx.fillColor([
                      color.red,
                      color.green,
                      color.blue
                    ], color.alpha / 255 * 100);
                    glyph.render(ctx, size);
                  }
                  return;
                }
                constructor(...args) {
                  super(...args);
                  (0, $gfJaN$swchelperscjs_define_propertycjs._)(this, "type", "COLR");
                }
              }
              const $7586bb9ea67c41d8$var$TUPLES_SHARE_POINT_NUMBERS = 32768;
              const $7586bb9ea67c41d8$var$TUPLE_COUNT_MASK = 4095;
              const $7586bb9ea67c41d8$var$EMBEDDED_TUPLE_COORD = 32768;
              const $7586bb9ea67c41d8$var$INTERMEDIATE_TUPLE = 16384;
              const $7586bb9ea67c41d8$var$PRIVATE_POINT_NUMBERS = 8192;
              const $7586bb9ea67c41d8$var$TUPLE_INDEX_MASK = 4095;
              const $7586bb9ea67c41d8$var$POINTS_ARE_WORDS = 128;
              const $7586bb9ea67c41d8$var$POINT_RUN_COUNT_MASK = 127;
              const $7586bb9ea67c41d8$var$DELTAS_ARE_ZERO = 128;
              const $7586bb9ea67c41d8$var$DELTAS_ARE_WORDS = 64;
              const $7586bb9ea67c41d8$var$DELTA_RUN_COUNT_MASK = 63;
              class $7586bb9ea67c41d8$export$2e2bcd8739ae039 {
                normalizeCoords(coords) {
                  let normalized = [];
                  for (var i = 0; i < this.font.fvar.axis.length; i++) {
                    let axis = this.font.fvar.axis[i];
                    if (coords[i] < axis.defaultValue) normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.defaultValue - axis.minValue + Number.EPSILON));
                    else normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.maxValue - axis.defaultValue + Number.EPSILON));
                  }
                  if (this.font.avar) for (var i = 0; i < this.font.avar.segment.length; i++) {
                    let segment = this.font.avar.segment[i];
                    for (let j = 0; j < segment.correspondence.length; j++) {
                      let pair = segment.correspondence[j];
                      if (j >= 1 && normalized[i] < pair.fromCoord) {
                        let prev = segment.correspondence[j - 1];
                        normalized[i] = ((normalized[i] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + Number.EPSILON) / (pair.fromCoord - prev.fromCoord + Number.EPSILON) + prev.toCoord;
                        break;
                      }
                    }
                  }
                  return normalized;
                }
                transformPoints(gid, glyphPoints) {
                  if (!this.font.fvar || !this.font.gvar) return;
                  let { gvar } = this.font;
                  if (gid >= gvar.glyphCount) return;
                  let offset = gvar.offsets[gid];
                  if (offset === gvar.offsets[gid + 1]) return;
                  let { stream } = this.font;
                  stream.pos = offset;
                  if (stream.pos >= stream.length) return;
                  let tupleCount = stream.readUInt16BE();
                  let offsetToData = offset + stream.readUInt16BE();
                  if (tupleCount & $7586bb9ea67c41d8$var$TUPLES_SHARE_POINT_NUMBERS) {
                    var here = stream.pos;
                    stream.pos = offsetToData;
                    var sharedPoints = this.decodePoints();
                    offsetToData = stream.pos;
                    stream.pos = here;
                  }
                  let origPoints = glyphPoints.map((pt) => pt.copy());
                  tupleCount &= $7586bb9ea67c41d8$var$TUPLE_COUNT_MASK;
                  for (let i = 0; i < tupleCount; i++) {
                    let tupleDataSize = stream.readUInt16BE();
                    let tupleIndex = stream.readUInt16BE();
                    if (tupleIndex & $7586bb9ea67c41d8$var$EMBEDDED_TUPLE_COORD) {
                      var tupleCoords = [];
                      for (let a = 0; a < gvar.axisCount; a++) tupleCoords.push(stream.readInt16BE() / 16384);
                    } else {
                      if ((tupleIndex & $7586bb9ea67c41d8$var$TUPLE_INDEX_MASK) >= gvar.globalCoordCount) throw new Error("Invalid gvar table");
                      var tupleCoords = gvar.globalCoords[tupleIndex & $7586bb9ea67c41d8$var$TUPLE_INDEX_MASK];
                    }
                    if (tupleIndex & $7586bb9ea67c41d8$var$INTERMEDIATE_TUPLE) {
                      var startCoords = [];
                      for (let a = 0; a < gvar.axisCount; a++) startCoords.push(stream.readInt16BE() / 16384);
                      var endCoords = [];
                      for (let a = 0; a < gvar.axisCount; a++) endCoords.push(stream.readInt16BE() / 16384);
                    }
                    let factor = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);
                    if (factor === 0) {
                      offsetToData += tupleDataSize;
                      continue;
                    }
                    var here = stream.pos;
                    stream.pos = offsetToData;
                    if (tupleIndex & $7586bb9ea67c41d8$var$PRIVATE_POINT_NUMBERS) var points = this.decodePoints();
                    else var points = sharedPoints;
                    let nPoints = points.length === 0 ? glyphPoints.length : points.length;
                    let xDeltas = this.decodeDeltas(nPoints);
                    let yDeltas = this.decodeDeltas(nPoints);
                    if (points.length === 0) for (let i2 = 0; i2 < glyphPoints.length; i2++) {
                      var point = glyphPoints[i2];
                      point.x += Math.round(xDeltas[i2] * factor);
                      point.y += Math.round(yDeltas[i2] * factor);
                    }
                    else {
                      let outPoints = origPoints.map((pt) => pt.copy());
                      let hasDelta = glyphPoints.map(() => false);
                      for (let i2 = 0; i2 < points.length; i2++) {
                        let idx = points[i2];
                        if (idx < glyphPoints.length) {
                          let point2 = outPoints[idx];
                          hasDelta[idx] = true;
                          point2.x += xDeltas[i2] * factor;
                          point2.y += yDeltas[i2] * factor;
                        }
                      }
                      this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);
                      for (let i2 = 0; i2 < glyphPoints.length; i2++) {
                        let deltaX = outPoints[i2].x - origPoints[i2].x;
                        let deltaY = outPoints[i2].y - origPoints[i2].y;
                        glyphPoints[i2].x = Math.round(glyphPoints[i2].x + deltaX);
                        glyphPoints[i2].y = Math.round(glyphPoints[i2].y + deltaY);
                      }
                    }
                    offsetToData += tupleDataSize;
                    stream.pos = here;
                  }
                }
                decodePoints() {
                  let stream = this.font.stream;
                  let count = stream.readUInt8();
                  if (count & $7586bb9ea67c41d8$var$POINTS_ARE_WORDS) count = (count & $7586bb9ea67c41d8$var$POINT_RUN_COUNT_MASK) << 8 | stream.readUInt8();
                  let points = new Uint16Array(count);
                  let i = 0;
                  let point = 0;
                  while (i < count) {
                    let run = stream.readUInt8();
                    let runCount = (run & $7586bb9ea67c41d8$var$POINT_RUN_COUNT_MASK) + 1;
                    let fn = run & $7586bb9ea67c41d8$var$POINTS_ARE_WORDS ? stream.readUInt16 : stream.readUInt8;
                    for (let j = 0; j < runCount && i < count; j++) {
                      point += fn.call(stream);
                      points[i++] = point;
                    }
                  }
                  return points;
                }
                decodeDeltas(count) {
                  let stream = this.font.stream;
                  let i = 0;
                  let deltas = new Int16Array(count);
                  while (i < count) {
                    let run = stream.readUInt8();
                    let runCount = (run & $7586bb9ea67c41d8$var$DELTA_RUN_COUNT_MASK) + 1;
                    if (run & $7586bb9ea67c41d8$var$DELTAS_ARE_ZERO) i += runCount;
                    else {
                      let fn = run & $7586bb9ea67c41d8$var$DELTAS_ARE_WORDS ? stream.readInt16BE : stream.readInt8;
                      for (let j = 0; j < runCount && i < count; j++) deltas[i++] = fn.call(stream);
                    }
                  }
                  return deltas;
                }
                tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {
                  let normalized = this.normalizedCoords;
                  let { gvar } = this.font;
                  let factor = 1;
                  for (let i = 0; i < gvar.axisCount; i++) {
                    if (tupleCoords[i] === 0) continue;
                    if (normalized[i] === 0) return 0;
                    if ((tupleIndex & $7586bb9ea67c41d8$var$INTERMEDIATE_TUPLE) === 0) {
                      if (normalized[i] < Math.min(0, tupleCoords[i]) || normalized[i] > Math.max(0, tupleCoords[i])) return 0;
                      factor = (factor * normalized[i] + Number.EPSILON) / (tupleCoords[i] + Number.EPSILON);
                    } else {
                      if (normalized[i] < startCoords[i] || normalized[i] > endCoords[i]) return 0;
                      else if (normalized[i] < tupleCoords[i]) factor = factor * (normalized[i] - startCoords[i] + Number.EPSILON) / (tupleCoords[i] - startCoords[i] + Number.EPSILON);
                      else factor = factor * (endCoords[i] - normalized[i] + Number.EPSILON) / (endCoords[i] - tupleCoords[i] + Number.EPSILON);
                    }
                  }
                  return factor;
                }
                // Interpolates points without delta values.
                // Needed for the  and Q glyphs in Skia.
                // Algorithm from Freetype.
                interpolateMissingDeltas(points, inPoints, hasDelta) {
                  if (points.length === 0) return;
                  let point = 0;
                  while (point < points.length) {
                    let firstPoint = point;
                    let endPoint = point;
                    let pt = points[endPoint];
                    while (!pt.endContour) pt = points[++endPoint];
                    while (point <= endPoint && !hasDelta[point]) point++;
                    if (point > endPoint) continue;
                    let firstDelta = point;
                    let curDelta = point;
                    point++;
                    while (point <= endPoint) {
                      if (hasDelta[point]) {
                        this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);
                        curDelta = point;
                      }
                      point++;
                    }
                    if (curDelta === firstDelta) this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);
                    else {
                      this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);
                      if (firstDelta > 0) this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);
                    }
                    point = endPoint + 1;
                  }
                }
                deltaInterpolate(p1, p2, ref1, ref2, inPoints, outPoints) {
                  if (p1 > p2) return;
                  let iterable = [
                    "x",
                    "y"
                  ];
                  for (let i = 0; i < iterable.length; i++) {
                    let k = iterable[i];
                    if (inPoints[ref1][k] > inPoints[ref2][k]) {
                      var p = ref1;
                      ref1 = ref2;
                      ref2 = p;
                    }
                    let in1 = inPoints[ref1][k];
                    let in2 = inPoints[ref2][k];
                    let out1 = outPoints[ref1][k];
                    let out2 = outPoints[ref2][k];
                    if (in1 !== in2 || out1 === out2) {
                      let scale = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);
                      for (let p3 = p1; p3 <= p2; p3++) {
                        let out = inPoints[p3][k];
                        if (out <= in1) out += out1 - in1;
                        else if (out >= in2) out += out2 - in2;
                        else out = out1 + (out - in1) * scale;
                        outPoints[p3][k] = out;
                      }
                    }
                  }
                }
                deltaShift(p1, p2, ref, inPoints, outPoints) {
                  let deltaX = outPoints[ref].x - inPoints[ref].x;
                  let deltaY = outPoints[ref].y - inPoints[ref].y;
                  if (deltaX === 0 && deltaY === 0) return;
                  for (let p = p1; p <= p2; p++) if (p !== ref) {
                    outPoints[p].x += deltaX;
                    outPoints[p].y += deltaY;
                  }
                }
                getAdvanceAdjustment(gid, table) {
                  let outerIndex, innerIndex;
                  if (table.advanceWidthMapping) {
                    let idx = gid;
                    if (idx >= table.advanceWidthMapping.mapCount) idx = table.advanceWidthMapping.mapCount - 1;
                    let entryFormat = table.advanceWidthMapping.entryFormat;
                    ({ outerIndex, innerIndex } = table.advanceWidthMapping.mapData[idx]);
                  } else {
                    outerIndex = 0;
                    innerIndex = gid;
                  }
                  return this.getDelta(table.itemVariationStore, outerIndex, innerIndex);
                }
                // See pseudo code from `Font Variations Overview'
                // in the OpenType specification.
                getDelta(itemStore, outerIndex, innerIndex) {
                  if (outerIndex >= itemStore.itemVariationData.length) return 0;
                  let varData = itemStore.itemVariationData[outerIndex];
                  if (innerIndex >= varData.deltaSets.length) return 0;
                  let deltaSet = varData.deltaSets[innerIndex];
                  let blendVector = this.getBlendVector(itemStore, outerIndex);
                  let netAdjustment = 0;
                  for (let master = 0; master < varData.regionIndexCount; master++) netAdjustment += deltaSet.deltas[master] * blendVector[master];
                  return netAdjustment;
                }
                getBlendVector(itemStore, outerIndex) {
                  let varData = itemStore.itemVariationData[outerIndex];
                  if (this.blendVectors.has(varData)) return this.blendVectors.get(varData);
                  let normalizedCoords = this.normalizedCoords;
                  let blendVector = [];
                  for (let master = 0; master < varData.regionIndexCount; master++) {
                    let scalar = 1;
                    let regionIndex = varData.regionIndexes[master];
                    let axes = itemStore.variationRegionList.variationRegions[regionIndex];
                    for (let j = 0; j < axes.length; j++) {
                      let axis = axes[j];
                      let axisScalar;
                      if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord) axisScalar = 1;
                      else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0) axisScalar = 1;
                      else if (axis.peakCoord === 0) axisScalar = 1;
                      else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord) axisScalar = 0;
                      else {
                        if (normalizedCoords[j] === axis.peakCoord) axisScalar = 1;
                        else if (normalizedCoords[j] < axis.peakCoord) axisScalar = (normalizedCoords[j] - axis.startCoord + Number.EPSILON) / (axis.peakCoord - axis.startCoord + Number.EPSILON);
                        else axisScalar = (axis.endCoord - normalizedCoords[j] + Number.EPSILON) / (axis.endCoord - axis.peakCoord + Number.EPSILON);
                      }
                      scalar *= axisScalar;
                    }
                    blendVector[master] = scalar;
                  }
                  this.blendVectors.set(varData, blendVector);
                  return blendVector;
                }
                constructor(font, coords) {
                  this.font = font;
                  this.normalizedCoords = this.normalizeCoords(coords);
                  this.blendVectors = /* @__PURE__ */ new Map();
                }
              }
              const $a8ac370803cb82cf$var$resolved = Promise.resolve();
              class $a8ac370803cb82cf$export$2e2bcd8739ae039 {
                includeGlyph(glyph) {
                  if (typeof glyph === "object") glyph = glyph.id;
                  if (this.mapping[glyph] == null) {
                    this.glyphs.push(glyph);
                    this.mapping[glyph] = this.glyphs.length - 1;
                  }
                  return this.mapping[glyph];
                }
                constructor(font) {
                  this.font = font;
                  this.glyphs = [];
                  this.mapping = {};
                  this.includeGlyph(0);
                }
              }
              const $2784eedf0b35a048$var$ON_CURVE = 1;
              const $2784eedf0b35a048$var$X_SHORT_VECTOR = 2;
              const $2784eedf0b35a048$var$Y_SHORT_VECTOR = 4;
              const $2784eedf0b35a048$var$REPEAT = 8;
              const $2784eedf0b35a048$var$SAME_X = 16;
              const $2784eedf0b35a048$var$SAME_Y = 32;
              class $2784eedf0b35a048$var$Point {
                static size(val) {
                  return val >= 0 && val <= 255 ? 1 : 2;
                }
                static encode(stream, value) {
                  if (value >= 0 && value <= 255) stream.writeUInt8(value);
                  else stream.writeInt16BE(value);
                }
              }
              let $2784eedf0b35a048$var$Glyf = new $gfJaN$restructure.Struct({
                numberOfContours: $gfJaN$restructure.int16,
                xMin: $gfJaN$restructure.int16,
                yMin: $gfJaN$restructure.int16,
                xMax: $gfJaN$restructure.int16,
                yMax: $gfJaN$restructure.int16,
                endPtsOfContours: new $gfJaN$restructure.Array($gfJaN$restructure.uint16, "numberOfContours"),
                instructions: new $gfJaN$restructure.Array($gfJaN$restructure.uint8, $gfJaN$restructure.uint16),
                flags: new $gfJaN$restructure.Array($gfJaN$restructure.uint8, 0),
                xPoints: new $gfJaN$restructure.Array($2784eedf0b35a048$var$Point, 0),
                yPoints: new $gfJaN$restructure.Array($2784eedf0b35a048$var$Point, 0)
              });
              class $2784eedf0b35a048$export$2e2bcd8739ae039 {
                encodeSimple(path, instructions = []) {
                  let endPtsOfContours = [];
                  let xPoints = [];
                  let yPoints = [];
                  let flags = [];
                  let same = 0;
                  let lastX = 0, lastY = 0, lastFlag = 0;
                  let pointCount = 0;
                  for (let i = 0; i < path.commands.length; i++) {
                    let c = path.commands[i];
                    for (let j = 0; j < c.args.length; j += 2) {
                      let x = c.args[j];
                      let y = c.args[j + 1];
                      let flag = 0;
                      if (c.command === "quadraticCurveTo" && j === 2) {
                        let next = path.commands[i + 1];
                        if (next && next.command === "quadraticCurveTo") {
                          let midX = (lastX + next.args[0]) / 2;
                          let midY = (lastY + next.args[1]) / 2;
                          if (x === midX && y === midY) continue;
                        }
                      }
                      if (!(c.command === "quadraticCurveTo" && j === 0)) flag |= $2784eedf0b35a048$var$ON_CURVE;
                      flag = this._encodePoint(x, lastX, xPoints, flag, $2784eedf0b35a048$var$X_SHORT_VECTOR, $2784eedf0b35a048$var$SAME_X);
                      flag = this._encodePoint(y, lastY, yPoints, flag, $2784eedf0b35a048$var$Y_SHORT_VECTOR, $2784eedf0b35a048$var$SAME_Y);
                      if (flag === lastFlag && same < 255) {
                        flags[flags.length - 1] |= $2784eedf0b35a048$var$REPEAT;
                        same++;
                      } else {
                        if (same > 0) {
                          flags.push(same);
                          same = 0;
                        }
                        flags.push(flag);
                        lastFlag = flag;
                      }
                      lastX = x;
                      lastY = y;
                      pointCount++;
                    }
                    if (c.command === "closePath") endPtsOfContours.push(pointCount - 1);
                  }
                  if (path.commands.length > 1 && path.commands[path.commands.length - 1].command !== "closePath") endPtsOfContours.push(pointCount - 1);
                  let bbox = path.bbox;
                  let glyf = {
                    numberOfContours: endPtsOfContours.length,
                    xMin: bbox.minX,
                    yMin: bbox.minY,
                    xMax: bbox.maxX,
                    yMax: bbox.maxY,
                    endPtsOfContours,
                    instructions,
                    flags,
                    xPoints,
                    yPoints
                  };
                  let size = $2784eedf0b35a048$var$Glyf.size(glyf);
                  let tail = 4 - size % 4;
                  let stream = new $gfJaN$restructure.EncodeStream(size + tail);
                  $2784eedf0b35a048$var$Glyf.encode(stream, glyf);
                  if (tail !== 0) stream.fill(0, tail);
                  return stream.buffer;
                }
                _encodePoint(value, last, points, flag, shortFlag, sameFlag) {
                  let diff = value - last;
                  if (value === last) flag |= sameFlag;
                  else {
                    if (-255 <= diff && diff <= 255) {
                      flag |= shortFlag;
                      if (diff < 0) diff = -diff;
                      else flag |= sameFlag;
                    }
                    points.push(diff);
                  }
                  return flag;
                }
              }
              class $fe042f4b88f46896$export$2e2bcd8739ae039 extends (0, $a8ac370803cb82cf$export$2e2bcd8739ae039) {
                _addGlyph(gid) {
                  let glyph = this.font.getGlyph(gid);
                  let glyf = glyph._decode();
                  let curOffset = this.font.loca.offsets[gid];
                  let nextOffset = this.font.loca.offsets[gid + 1];
                  let stream = this.font._getTableStream("glyf");
                  stream.pos += curOffset;
                  let buffer = stream.readBuffer(nextOffset - curOffset);
                  if (glyf && glyf.numberOfContours < 0) {
                    buffer = new Uint8Array(buffer);
                    let view = new DataView(buffer.buffer);
                    for (let component of glyf.components) {
                      gid = this.includeGlyph(component.glyphID);
                      view.setUint16(component.pos, gid);
                    }
                  } else if (glyf && this.font._variationProcessor)
                    buffer = this.glyphEncoder.encodeSimple(glyph.path, glyf.instructions);
                  this.glyf.push(buffer);
                  this.loca.offsets.push(this.offset);
                  this.hmtx.metrics.push({
                    advance: glyph.advanceWidth,
                    bearing: glyph._getMetrics().leftBearing
                  });
                  this.offset += buffer.length;
                  return this.glyf.length - 1;
                }
                encode() {
                  this.glyf = [];
                  this.offset = 0;
                  this.loca = {
                    offsets: [],
                    version: this.font.loca.version
                  };
                  this.hmtx = {
                    metrics: [],
                    bearings: []
                  };
                  let i = 0;
                  while (i < this.glyphs.length) this._addGlyph(this.glyphs[i++]);
                  let maxp = (0, $parcel$interopDefault($gfJaN$clone))(this.font.maxp);
                  maxp.numGlyphs = this.glyf.length;
                  this.loca.offsets.push(this.offset);
                  let head = (0, $parcel$interopDefault($gfJaN$clone))(this.font.head);
                  head.indexToLocFormat = this.loca.version;
                  let hhea = (0, $parcel$interopDefault($gfJaN$clone))(this.font.hhea);
                  hhea.numberOfMetrics = this.hmtx.metrics.length;
                  return (0, $df50e1efe10a1247$export$2e2bcd8739ae039).toBuffer({
                    tables: {
                      head,
                      hhea,
                      loca: this.loca,
                      maxp,
                      "cvt ": this.font["cvt "],
                      prep: this.font.prep,
                      glyf: this.glyf,
                      hmtx: this.hmtx,
                      fpgm: this.font.fpgm
                    }
                  });
                }
                constructor(font) {
                  super(font);
                  this.glyphEncoder = new (0, $2784eedf0b35a048$export$2e2bcd8739ae039)();
                }
              }
              class $ec40f80c07a4e08a$export$2e2bcd8739ae039 extends (0, $a8ac370803cb82cf$export$2e2bcd8739ae039) {
                subsetCharstrings() {
                  this.charstrings = [];
                  let gsubrs = {};
                  for (let gid of this.glyphs) {
                    this.charstrings.push(this.cff.getCharString(gid));
                    let glyph = this.font.getGlyph(gid);
                    let path = glyph.path;
                    for (let subr in glyph._usedGsubrs) gsubrs[subr] = true;
                  }
                  this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);
                }
                subsetSubrs(subrs, used) {
                  let res = [];
                  for (let i = 0; i < subrs.length; i++) {
                    let subr = subrs[i];
                    if (used[i]) {
                      this.cff.stream.pos = subr.offset;
                      res.push(this.cff.stream.readBuffer(subr.length));
                    } else res.push(new Uint8Array([
                      11
                    ]));
                  }
                  return res;
                }
                subsetFontdict(topDict) {
                  topDict.FDArray = [];
                  topDict.FDSelect = {
                    version: 0,
                    fds: []
                  };
                  let used_fds = {};
                  let used_subrs = [];
                  let fd_select = {};
                  for (let gid of this.glyphs) {
                    let fd = this.cff.fdForGlyph(gid);
                    if (fd == null) continue;
                    if (!used_fds[fd]) {
                      topDict.FDArray.push(Object.assign({}, this.cff.topDict.FDArray[fd]));
                      used_subrs.push({});
                      fd_select[fd] = topDict.FDArray.length - 1;
                    }
                    used_fds[fd] = true;
                    topDict.FDSelect.fds.push(fd_select[fd]);
                    let glyph = this.font.getGlyph(gid);
                    let path = glyph.path;
                    for (let subr in glyph._usedSubrs) used_subrs[fd_select[fd]][subr] = true;
                  }
                  for (let i = 0; i < topDict.FDArray.length; i++) {
                    let dict = topDict.FDArray[i];
                    delete dict.FontName;
                    if (dict.Private && dict.Private.Subrs) {
                      dict.Private = Object.assign({}, dict.Private);
                      dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i]);
                    }
                  }
                  return;
                }
                createCIDFontdict(topDict) {
                  let used_subrs = {};
                  for (let gid of this.glyphs) {
                    let glyph = this.font.getGlyph(gid);
                    let path = glyph.path;
                    for (let subr in glyph._usedSubrs) used_subrs[subr] = true;
                  }
                  let privateDict = Object.assign({}, this.cff.topDict.Private);
                  if (this.cff.topDict.Private && this.cff.topDict.Private.Subrs) privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);
                  topDict.FDArray = [
                    {
                      Private: privateDict
                    }
                  ];
                  return topDict.FDSelect = {
                    version: 3,
                    nRanges: 1,
                    ranges: [
                      {
                        first: 0,
                        fd: 0
                      }
                    ],
                    sentinel: this.charstrings.length
                  };
                }
                addString(string) {
                  if (!string) return null;
                  if (!this.strings) this.strings = [];
                  this.strings.push(string);
                  return (0, $860d3574d7fa3a51$export$2e2bcd8739ae039).length + this.strings.length - 1;
                }
                encode() {
                  this.subsetCharstrings();
                  let charset = {
                    version: this.charstrings.length > 255 ? 2 : 1,
                    ranges: [
                      {
                        first: 1,
                        nLeft: this.charstrings.length - 2
                      }
                    ]
                  };
                  let topDict = Object.assign({}, this.cff.topDict);
                  topDict.Private = null;
                  topDict.charset = charset;
                  topDict.Encoding = null;
                  topDict.CharStrings = this.charstrings;
                  for (let key of [
                    "version",
                    "Notice",
                    "Copyright",
                    "FullName",
                    "FamilyName",
                    "Weight",
                    "PostScript",
                    "BaseFontName",
                    "FontName"
                  ]) topDict[key] = this.addString(this.cff.string(topDict[key]));
                  topDict.ROS = [
                    this.addString("Adobe"),
                    this.addString("Identity"),
                    0
                  ];
                  topDict.CIDCount = this.charstrings.length;
                  if (this.cff.isCIDFont) this.subsetFontdict(topDict);
                  else this.createCIDFontdict(topDict);
                  let top = {
                    version: 1,
                    hdrSize: this.cff.hdrSize,
                    offSize: 4,
                    header: this.cff.header,
                    nameIndex: [
                      this.cff.postscriptName
                    ],
                    topDictIndex: [
                      topDict
                    ],
                    stringIndex: this.strings,
                    globalSubrIndex: this.gsubrs
                  };
                  return (0, $5b547cf9e5da519b$export$2e2bcd8739ae039).toBuffer(top);
                }
                constructor(font) {
                  super(font);
                  this.cff = this.font["CFF "];
                  if (!this.cff) throw new Error("Not a CFF Font");
                }
              }
              class $0a8ef2660a6ce4b6$export$2e2bcd8739ae039 {
                static probe(buffer) {
                  let format = (0, $66a5b9fb5318558a$export$3d28c1996ced1f14).decode(buffer.slice(0, 4));
                  return format === "true" || format === "OTTO" || format === String.fromCharCode(0, 1, 0, 0);
                }
                setDefaultLanguage(lang = null) {
                  this.defaultLanguage = lang;
                }
                _getTable(table) {
                  if (!(table.tag in this._tables)) try {
                    this._tables[table.tag] = this._decodeTable(table);
                  } catch (e) {
                    if ($59aa4ed98453e1d4$export$bd5c5d8b8dcafd78) {
                      console.error(`Error decoding table ${table.tag}`);
                      console.error(e.stack);
                    }
                  }
                  return this._tables[table.tag];
                }
                _getTableStream(tag) {
                  let table = this.directory.tables[tag];
                  if (table) {
                    this.stream.pos = table.offset;
                    return this.stream;
                  }
                  return null;
                }
                _decodeDirectory() {
                  return this.directory = (0, $df50e1efe10a1247$export$2e2bcd8739ae039).decode(this.stream, {
                    _startOffset: 0
                  });
                }
                _decodeTable(table) {
                  let pos = this.stream.pos;
                  let stream = this._getTableStream(table.tag);
                  let result = (0, $5825c04ce8f7102d$export$2e2bcd8739ae039)[table.tag].decode(stream, this, table.length);
                  this.stream.pos = pos;
                  return result;
                }
                /**
                * Gets a string from the font's `name` table
                * `lang` is a BCP-47 language code.
                * @return {string}
                */
                getName(key, lang = this.defaultLanguage || $59aa4ed98453e1d4$export$42940898df819940) {
                  let record = this.name && this.name.records[key];
                  if (record)
                    return record[lang] || record[this.defaultLanguage] || record[$59aa4ed98453e1d4$export$42940898df819940] || record["en"] || record[Object.keys(record)[0]] || null;
                  return null;
                }
                /**
                * The unique PostScript name for this font, e.g. "Helvetica-Bold"
                * @type {string}
                */
                get postscriptName() {
                  return this.getName("postscriptName");
                }
                /**
                * The font's full name, e.g. "Helvetica Bold"
                * @type {string}
                */
                get fullName() {
                  return this.getName("fullName");
                }
                /**
                * The font's family name, e.g. "Helvetica"
                * @type {string}
                */
                get familyName() {
                  return this.getName("fontFamily");
                }
                /**
                * The font's sub-family, e.g. "Bold".
                * @type {string}
                */
                get subfamilyName() {
                  return this.getName("fontSubfamily");
                }
                /**
                * The font's copyright information
                * @type {string}
                */
                get copyright() {
                  return this.getName("copyright");
                }
                /**
                * The font's version number
                * @type {string}
                */
                get version() {
                  return this.getName("version");
                }
                /**
                * The fonts [ascender](https://en.wikipedia.org/wiki/Ascender_(typography))
                * @type {number}
                */
                get ascent() {
                  return this.hhea.ascent;
                }
                /**
                * The fonts [descender](https://en.wikipedia.org/wiki/Descender)
                * @type {number}
                */
                get descent() {
                  return this.hhea.descent;
                }
                /**
                * The amount of space that should be included between lines
                * @type {number}
                */
                get lineGap() {
                  return this.hhea.lineGap;
                }
                /**
                * The offset from the normal underline position that should be used
                * @type {number}
                */
                get underlinePosition() {
                  return this.post.underlinePosition;
                }
                /**
                * The weight of the underline that should be used
                * @type {number}
                */
                get underlineThickness() {
                  return this.post.underlineThickness;
                }
                /**
                * If this is an italic font, the angle the cursor should be drawn at to match the font design
                * @type {number}
                */
                get italicAngle() {
                  return this.post.italicAngle;
                }
                /**
                * The height of capital letters above the baseline.
                * See [here](https://en.wikipedia.org/wiki/Cap_height) for more details.
                * @type {number}
                */
                get capHeight() {
                  let os2 = this["OS/2"];
                  return os2 ? os2.capHeight : this.ascent;
                }
                /**
                * The height of lower case letters in the font.
                * See [here](https://en.wikipedia.org/wiki/X-height) for more details.
                * @type {number}
                */
                get xHeight() {
                  let os2 = this["OS/2"];
                  return os2 ? os2.xHeight : 0;
                }
                /**
                * The number of glyphs in the font.
                * @type {number}
                */
                get numGlyphs() {
                  return this.maxp.numGlyphs;
                }
                /**
                * The size of the fonts internal coordinate grid
                * @type {number}
                */
                get unitsPerEm() {
                  return this.head.unitsPerEm;
                }
                /**
                * The fonts bounding box, i.e. the box that encloses all glyphs in the font.
                * @type {BBox}
                */
                get bbox() {
                  return Object.freeze(new (0, $0e2da1c4ce69e8ad$export$2e2bcd8739ae039)(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));
                }
                get _cmapProcessor() {
                  return new (0, $0d6e160064c86e50$export$2e2bcd8739ae039)(this.cmap);
                }
                /**
                * An array of all of the unicode code points supported by the font.
                * @type {number[]}
                */
                get characterSet() {
                  return this._cmapProcessor.getCharacterSet();
                }
                /**
                * Returns whether there is glyph in the font for the given unicode code point.
                *
                * @param {number} codePoint
                * @return {boolean}
                */
                hasGlyphForCodePoint(codePoint) {
                  return !!this._cmapProcessor.lookup(codePoint);
                }
                /**
                * Maps a single unicode code point to a Glyph object.
                * Does not perform any advanced substitutions (there is no context to do so).
                *
                * @param {number} codePoint
                * @return {Glyph}
                */
                glyphForCodePoint(codePoint) {
                  return this.getGlyph(this._cmapProcessor.lookup(codePoint), [
                    codePoint
                  ]);
                }
                /**
                * Returns an array of Glyph objects for the given string.
                * This is only a one-to-one mapping from characters to glyphs.
                * For most uses, you should use font.layout (described below), which
                * provides a much more advanced mapping supporting AAT and OpenType shaping.
                *
                * @param {string} string
                * @return {Glyph[]}
                */
                glyphsForString(string) {
                  let glyphs = [];
                  let len = string.length;
                  let idx = 0;
                  let last = -1;
                  let state = -1;
                  while (idx <= len) {
                    let code = 0;
                    let nextState = 0;
                    if (idx < len) {
                      code = string.charCodeAt(idx++);
                      if (55296 <= code && code <= 56319 && idx < len) {
                        let next = string.charCodeAt(idx);
                        if (56320 <= next && next <= 57343) {
                          idx++;
                          code = ((code & 1023) << 10) + (next & 1023) + 65536;
                        }
                      }
                      nextState = 65024 <= code && code <= 65039 || 917760 <= code && code <= 917999 ? 1 : 0;
                    } else idx++;
                    if (state === 0 && nextState === 1)
                      glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last, code), [
                        last,
                        code
                      ]));
                    else if (state === 0 && nextState === 0)
                      glyphs.push(this.glyphForCodePoint(last));
                    last = code;
                    state = nextState;
                  }
                  return glyphs;
                }
                get _layoutEngine() {
                  return new (0, $9d641258c9d7180d$export$2e2bcd8739ae039)(this);
                }
                /**
                * Returns a GlyphRun object, which includes an array of Glyphs and GlyphPositions for the given string.
                *
                * @param {string} string
                * @param {string[]} [userFeatures]
                * @param {string} [script]
                * @param {string} [language]
                * @param {string} [direction]
                * @return {GlyphRun}
                */
                layout(string, userFeatures, script, language, direction) {
                  return this._layoutEngine.layout(string, userFeatures, script, language, direction);
                }
                /**
                * Returns an array of strings that map to the given glyph id.
                * @param {number} gid - glyph id
                */
                stringsForGlyph(gid) {
                  return this._layoutEngine.stringsForGlyph(gid);
                }
                /**
                * An array of all [OpenType feature tags](https://www.microsoft.com/typography/otspec/featuretags.htm)
                * (or mapped AAT tags) supported by the font.
                * The features parameter is an array of OpenType feature tags to be applied in addition to the default set.
                * If this is an AAT font, the OpenType feature tags are mapped to AAT features.
                *
                * @type {string[]}
                */
                get availableFeatures() {
                  return this._layoutEngine.getAvailableFeatures();
                }
                getAvailableFeatures(script, language) {
                  return this._layoutEngine.getAvailableFeatures(script, language);
                }
                _getBaseGlyph(glyph, characters = []) {
                  if (!this._glyphs[glyph]) {
                    if (this.directory.tables.glyf) this._glyphs[glyph] = new (0, $f680320fa07ef53d$export$2e2bcd8739ae039)(glyph, characters, this);
                    else if (this.directory.tables["CFF "] || this.directory.tables.CFF2) this._glyphs[glyph] = new (0, $7ee0705195f3b047$export$2e2bcd8739ae039)(glyph, characters, this);
                  }
                  return this._glyphs[glyph] || null;
                }
                /**
                * Returns a glyph object for the given glyph id.
                * You can pass the array of code points this glyph represents for
                * your use later, and it will be stored in the glyph object.
                *
                * @param {number} glyph
                * @param {number[]} characters
                * @return {Glyph}
                */
                getGlyph(glyph, characters = []) {
                  if (!this._glyphs[glyph]) {
                    if (this.directory.tables.sbix) this._glyphs[glyph] = new (0, $55855d6d316b015e$export$2e2bcd8739ae039)(glyph, characters, this);
                    else if (this.directory.tables.COLR && this.directory.tables.CPAL) this._glyphs[glyph] = new (0, $42d9dbd2de9ee2d8$export$2e2bcd8739ae039)(glyph, characters, this);
                    else this._getBaseGlyph(glyph, characters);
                  }
                  return this._glyphs[glyph] || null;
                }
                /**
                * Returns a Subset for this font.
                * @return {Subset}
                */
                createSubset() {
                  if (this.directory.tables["CFF "]) return new (0, $ec40f80c07a4e08a$export$2e2bcd8739ae039)(this);
                  return new (0, $fe042f4b88f46896$export$2e2bcd8739ae039)(this);
                }
                /**
                * Returns an object describing the available variation axes
                * that this font supports. Keys are setting tags, and values
                * contain the axis name, range, and default value.
                *
                * @type {object}
                */
                get variationAxes() {
                  let res = {};
                  if (!this.fvar) return res;
                  for (let axis of this.fvar.axis) res[axis.axisTag.trim()] = {
                    name: axis.name.en,
                    min: axis.minValue,
                    default: axis.defaultValue,
                    max: axis.maxValue
                  };
                  return res;
                }
                /**
                * Returns an object describing the named variation instances
                * that the font designer has specified. Keys are variation names
                * and values are the variation settings for this instance.
                *
                * @type {object}
                */
                get namedVariations() {
                  let res = {};
                  if (!this.fvar) return res;
                  for (let instance of this.fvar.instance) {
                    let settings = {};
                    for (let i = 0; i < this.fvar.axis.length; i++) {
                      let axis = this.fvar.axis[i];
                      settings[axis.axisTag.trim()] = instance.coord[i];
                    }
                    res[instance.name.en] = settings;
                  }
                  return res;
                }
                /**
                * Returns a new font with the given variation settings applied.
                * Settings can either be an instance name, or an object containing
                * variation tags as specified by the `variationAxes` property.
                *
                * @param {object} settings
                * @return {TTFFont}
                */
                getVariation(settings) {
                  if (!(this.directory.tables.fvar && (this.directory.tables.gvar && this.directory.tables.glyf || this.directory.tables.CFF2))) throw new Error("Variations require a font with the fvar, gvar and glyf, or CFF2 tables.");
                  if (typeof settings === "string") settings = this.namedVariations[settings];
                  if (typeof settings !== "object") throw new Error("Variation settings must be either a variation name or settings object.");
                  let coords = this.fvar.axis.map((axis, i) => {
                    let axisTag = axis.axisTag.trim();
                    if (axisTag in settings) return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));
                    else return axis.defaultValue;
                  });
                  let stream = new $gfJaN$restructure.DecodeStream(this.stream.buffer);
                  stream.pos = this._directoryPos;
                  let font = new $0a8ef2660a6ce4b6$export$2e2bcd8739ae039(stream, coords);
                  font._tables = this._tables;
                  return font;
                }
                get _variationProcessor() {
                  if (!this.fvar) return null;
                  let variationCoords = this.variationCoords;
                  if (!variationCoords && !this.CFF2) return null;
                  if (!variationCoords) variationCoords = this.fvar.axis.map((axis) => axis.defaultValue);
                  return new (0, $7586bb9ea67c41d8$export$2e2bcd8739ae039)(this, variationCoords);
                }
                // Standardized format plugin API
                getFont(name) {
                  return this.getVariation(name);
                }
                constructor(stream, variationCoords = null) {
                  (0, $gfJaN$swchelperscjs_define_propertycjs._)(this, "type", "TTF");
                  this.defaultLanguage = null;
                  this.stream = stream;
                  this.variationCoords = variationCoords;
                  this._directoryPos = this.stream.pos;
                  this._tables = {};
                  this._glyphs = {};
                  this._decodeDirectory();
                  for (let tag in this.directory.tables) {
                    let table = this.directory.tables[tag];
                    if ((0, $5825c04ce8f7102d$export$2e2bcd8739ae039)[tag] && table.length > 0) Object.defineProperty(this, tag, {
                      get: this._getTable.bind(this, table)
                    });
                  }
                }
              }
              (0, $gfJaN$swchelperscjs_ts_decoratecjs._)([
                (0, $3bda6911913b43f0$export$69a3209f1a06c04d)
              ], $0a8ef2660a6ce4b6$export$2e2bcd8739ae039.prototype, "bbox", null);
              (0, $gfJaN$swchelperscjs_ts_decoratecjs._)([
                (0, $3bda6911913b43f0$export$69a3209f1a06c04d)
              ], $0a8ef2660a6ce4b6$export$2e2bcd8739ae039.prototype, "_cmapProcessor", null);
              (0, $gfJaN$swchelperscjs_ts_decoratecjs._)([
                (0, $3bda6911913b43f0$export$69a3209f1a06c04d)
              ], $0a8ef2660a6ce4b6$export$2e2bcd8739ae039.prototype, "characterSet", null);
              (0, $gfJaN$swchelperscjs_ts_decoratecjs._)([
                (0, $3bda6911913b43f0$export$69a3209f1a06c04d)
              ], $0a8ef2660a6ce4b6$export$2e2bcd8739ae039.prototype, "_layoutEngine", null);
              (0, $gfJaN$swchelperscjs_ts_decoratecjs._)([
                (0, $3bda6911913b43f0$export$69a3209f1a06c04d)
              ], $0a8ef2660a6ce4b6$export$2e2bcd8739ae039.prototype, "variationAxes", null);
              (0, $gfJaN$swchelperscjs_ts_decoratecjs._)([
                (0, $3bda6911913b43f0$export$69a3209f1a06c04d)
              ], $0a8ef2660a6ce4b6$export$2e2bcd8739ae039.prototype, "namedVariations", null);
              (0, $gfJaN$swchelperscjs_ts_decoratecjs._)([
                (0, $3bda6911913b43f0$export$69a3209f1a06c04d)
              ], $0a8ef2660a6ce4b6$export$2e2bcd8739ae039.prototype, "_variationProcessor", null);
              let $89f72d2d7c9afc0d$var$WOFFDirectoryEntry = new $gfJaN$restructure.Struct({
                tag: new $gfJaN$restructure.String(4),
                offset: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, "void", {
                  type: "global"
                }),
                compLength: $gfJaN$restructure.uint32,
                length: $gfJaN$restructure.uint32,
                origChecksum: $gfJaN$restructure.uint32
              });
              let $89f72d2d7c9afc0d$var$WOFFDirectory = new $gfJaN$restructure.Struct({
                tag: new $gfJaN$restructure.String(4),
                flavor: $gfJaN$restructure.uint32,
                length: $gfJaN$restructure.uint32,
                numTables: $gfJaN$restructure.uint16,
                reserved: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint16),
                totalSfntSize: $gfJaN$restructure.uint32,
                majorVersion: $gfJaN$restructure.uint16,
                minorVersion: $gfJaN$restructure.uint16,
                metaOffset: $gfJaN$restructure.uint32,
                metaLength: $gfJaN$restructure.uint32,
                metaOrigLength: $gfJaN$restructure.uint32,
                privOffset: $gfJaN$restructure.uint32,
                privLength: $gfJaN$restructure.uint32,
                tables: new $gfJaN$restructure.Array($89f72d2d7c9afc0d$var$WOFFDirectoryEntry, "numTables")
              });
              $89f72d2d7c9afc0d$var$WOFFDirectory.process = function() {
                let tables = {};
                for (let table of this.tables) tables[table.tag] = table;
                this.tables = tables;
              };
              var $89f72d2d7c9afc0d$export$2e2bcd8739ae039 = $89f72d2d7c9afc0d$var$WOFFDirectory;
              class $8a0a49baaf5d834d$export$2e2bcd8739ae039 extends (0, $0a8ef2660a6ce4b6$export$2e2bcd8739ae039) {
                static probe(buffer) {
                  return (0, $66a5b9fb5318558a$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "wOFF";
                }
                _decodeDirectory() {
                  this.directory = (0, $89f72d2d7c9afc0d$export$2e2bcd8739ae039).decode(this.stream, {
                    _startOffset: 0
                  });
                }
                _getTableStream(tag) {
                  let table = this.directory.tables[tag];
                  if (table) {
                    this.stream.pos = table.offset;
                    if (table.compLength < table.length) {
                      this.stream.pos += 2;
                      let outBuffer = new Uint8Array(table.length);
                      let buf = (0, $parcel$interopDefault($gfJaN$tinyinflate))(this.stream.readBuffer(table.compLength - 2), outBuffer);
                      return new $gfJaN$restructure.DecodeStream(buf);
                    } else return this.stream;
                  }
                  return null;
                }
                constructor(...args) {
                  super(...args);
                  (0, $gfJaN$swchelperscjs_define_propertycjs._)(this, "type", "WOFF");
                }
              }
              class $44b9edca0e403d6d$export$2e2bcd8739ae039 extends (0, $f680320fa07ef53d$export$2e2bcd8739ae039) {
                _decode() {
                  return this._font._transformedGlyphs[this.id];
                }
                _getCBox() {
                  return this.path.bbox;
                }
                constructor(...args) {
                  super(...args);
                  (0, $gfJaN$swchelperscjs_define_propertycjs._)(this, "type", "WOFF2");
                }
              }
              const $2f0bfd9a5c1d7b58$var$Base128 = {
                decode(stream) {
                  let result = 0;
                  let iterable = [
                    0,
                    1,
                    2,
                    3,
                    4
                  ];
                  for (let j = 0; j < iterable.length; j++) {
                    let i = iterable[j];
                    let code = stream.readUInt8();
                    if (result & 3758096384) throw new Error("Overflow");
                    result = result << 7 | code & 127;
                    if ((code & 128) === 0) return result;
                  }
                  throw new Error("Bad base 128 number");
                }
              };
              let $2f0bfd9a5c1d7b58$var$knownTags = [
                "cmap",
                "head",
                "hhea",
                "hmtx",
                "maxp",
                "name",
                "OS/2",
                "post",
                "cvt ",
                "fpgm",
                "glyf",
                "loca",
                "prep",
                "CFF ",
                "VORG",
                "EBDT",
                "EBLC",
                "gasp",
                "hdmx",
                "kern",
                "LTSH",
                "PCLT",
                "VDMX",
                "vhea",
                "vmtx",
                "BASE",
                "GDEF",
                "GPOS",
                "GSUB",
                "EBSC",
                "JSTF",
                "MATH",
                "CBDT",
                "CBLC",
                "COLR",
                "CPAL",
                "SVG ",
                "sbix",
                "acnt",
                "avar",
                "bdat",
                "bloc",
                "bsln",
                "cvar",
                "fdsc",
                "feat",
                "fmtx",
                "fvar",
                "gvar",
                "hsty",
                "just",
                "lcar",
                "mort",
                "morx",
                "opbd",
                "prop",
                "trak",
                "Zapf",
                "Silf",
                "Glat",
                "Gloc",
                "Feat",
                "Sill"
              ];
              let $2f0bfd9a5c1d7b58$var$WOFF2DirectoryEntry = new $gfJaN$restructure.Struct({
                flags: $gfJaN$restructure.uint8,
                customTag: new $gfJaN$restructure.Optional(new $gfJaN$restructure.String(4), (t) => (t.flags & 63) === 63),
                tag: (t) => t.customTag || $2f0bfd9a5c1d7b58$var$knownTags[t.flags & 63],
                length: $2f0bfd9a5c1d7b58$var$Base128,
                transformVersion: (t) => t.flags >>> 6 & 3,
                transformed: (t) => t.tag === "glyf" || t.tag === "loca" ? t.transformVersion === 0 : t.transformVersion !== 0,
                transformLength: new $gfJaN$restructure.Optional($2f0bfd9a5c1d7b58$var$Base128, (t) => t.transformed)
              });
              let $2f0bfd9a5c1d7b58$var$WOFF2Directory = new $gfJaN$restructure.Struct({
                tag: new $gfJaN$restructure.String(4),
                flavor: $gfJaN$restructure.uint32,
                length: $gfJaN$restructure.uint32,
                numTables: $gfJaN$restructure.uint16,
                reserved: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint16),
                totalSfntSize: $gfJaN$restructure.uint32,
                totalCompressedSize: $gfJaN$restructure.uint32,
                majorVersion: $gfJaN$restructure.uint16,
                minorVersion: $gfJaN$restructure.uint16,
                metaOffset: $gfJaN$restructure.uint32,
                metaLength: $gfJaN$restructure.uint32,
                metaOrigLength: $gfJaN$restructure.uint32,
                privOffset: $gfJaN$restructure.uint32,
                privLength: $gfJaN$restructure.uint32,
                tables: new $gfJaN$restructure.Array($2f0bfd9a5c1d7b58$var$WOFF2DirectoryEntry, "numTables")
              });
              $2f0bfd9a5c1d7b58$var$WOFF2Directory.process = function() {
                let tables = {};
                for (let i = 0; i < this.tables.length; i++) {
                  let table = this.tables[i];
                  tables[table.tag] = table;
                }
                return this.tables = tables;
              };
              var $2f0bfd9a5c1d7b58$export$2e2bcd8739ae039 = $2f0bfd9a5c1d7b58$var$WOFF2Directory;
              class $333fb94547d9fb5c$export$2e2bcd8739ae039 extends (0, $0a8ef2660a6ce4b6$export$2e2bcd8739ae039) {
                static probe(buffer) {
                  return (0, $66a5b9fb5318558a$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "wOF2";
                }
                _decodeDirectory() {
                  this.directory = (0, $2f0bfd9a5c1d7b58$export$2e2bcd8739ae039).decode(this.stream);
                  this._dataPos = this.stream.pos;
                }
                _decompress() {
                  if (!this._decompressed) {
                    this.stream.pos = this._dataPos;
                    let buffer = this.stream.readBuffer(this.directory.totalCompressedSize);
                    let decompressedSize = 0;
                    for (let tag in this.directory.tables) {
                      let entry = this.directory.tables[tag];
                      entry.offset = decompressedSize;
                      decompressedSize += entry.transformLength != null ? entry.transformLength : entry.length;
                    }
                    let decompressed = (0, $parcel$interopDefault($gfJaN$brotlidecompressjs))(buffer, decompressedSize);
                    if (!decompressed) throw new Error("Error decoding compressed data in WOFF2");
                    this.stream = new $gfJaN$restructure.DecodeStream(decompressed);
                    this._decompressed = true;
                  }
                }
                _decodeTable(table) {
                  this._decompress();
                  return super._decodeTable(table);
                }
                // Override this method to get a glyph and return our
                // custom subclass if there is a glyf table.
                _getBaseGlyph(glyph, characters = []) {
                  if (!this._glyphs[glyph]) {
                    if (this.directory.tables.glyf && this.directory.tables.glyf.transformed) {
                      if (!this._transformedGlyphs) this._transformGlyfTable();
                      return this._glyphs[glyph] = new (0, $44b9edca0e403d6d$export$2e2bcd8739ae039)(glyph, characters, this);
                    } else return super._getBaseGlyph(glyph, characters);
                  }
                }
                _transformGlyfTable() {
                  this._decompress();
                  this.stream.pos = this.directory.tables.glyf.offset;
                  let table = $333fb94547d9fb5c$var$GlyfTable.decode(this.stream);
                  let glyphs = [];
                  for (let index = 0; index < table.numGlyphs; index++) {
                    let glyph = {};
                    let nContours = table.nContours.readInt16BE();
                    glyph.numberOfContours = nContours;
                    if (nContours > 0) {
                      let nPoints = [];
                      let totalPoints = 0;
                      for (let i = 0; i < nContours; i++) {
                        let r = $333fb94547d9fb5c$var$read255UInt16(table.nPoints);
                        totalPoints += r;
                        nPoints.push(totalPoints);
                      }
                      glyph.points = $333fb94547d9fb5c$var$decodeTriplet(table.flags, table.glyphs, totalPoints);
                      for (let i = 0; i < nContours; i++) glyph.points[nPoints[i] - 1].endContour = true;
                      var instructionSize = $333fb94547d9fb5c$var$read255UInt16(table.glyphs);
                    } else if (nContours < 0) {
                      let haveInstructions = (0, $f680320fa07ef53d$export$2e2bcd8739ae039).prototype._decodeComposite.call({
                        _font: this
                      }, glyph, table.composites);
                      if (haveInstructions) var instructionSize = $333fb94547d9fb5c$var$read255UInt16(table.glyphs);
                    }
                    glyphs.push(glyph);
                  }
                  this._transformedGlyphs = glyphs;
                }
                constructor(...args) {
                  super(...args);
                  (0, $gfJaN$swchelperscjs_define_propertycjs._)(this, "type", "WOFF2");
                }
              }
              class $333fb94547d9fb5c$var$Substream {
                decode(stream, parent) {
                  return new $gfJaN$restructure.DecodeStream(this._buf.decode(stream, parent));
                }
                constructor(length) {
                  this.length = length;
                  this._buf = new $gfJaN$restructure.Buffer(length);
                }
              }
              let $333fb94547d9fb5c$var$GlyfTable = new $gfJaN$restructure.Struct({
                version: $gfJaN$restructure.uint32,
                numGlyphs: $gfJaN$restructure.uint16,
                indexFormat: $gfJaN$restructure.uint16,
                nContourStreamSize: $gfJaN$restructure.uint32,
                nPointsStreamSize: $gfJaN$restructure.uint32,
                flagStreamSize: $gfJaN$restructure.uint32,
                glyphStreamSize: $gfJaN$restructure.uint32,
                compositeStreamSize: $gfJaN$restructure.uint32,
                bboxStreamSize: $gfJaN$restructure.uint32,
                instructionStreamSize: $gfJaN$restructure.uint32,
                nContours: new $333fb94547d9fb5c$var$Substream("nContourStreamSize"),
                nPoints: new $333fb94547d9fb5c$var$Substream("nPointsStreamSize"),
                flags: new $333fb94547d9fb5c$var$Substream("flagStreamSize"),
                glyphs: new $333fb94547d9fb5c$var$Substream("glyphStreamSize"),
                composites: new $333fb94547d9fb5c$var$Substream("compositeStreamSize"),
                bboxes: new $333fb94547d9fb5c$var$Substream("bboxStreamSize"),
                instructions: new $333fb94547d9fb5c$var$Substream("instructionStreamSize")
              });
              const $333fb94547d9fb5c$var$WORD_CODE = 253;
              const $333fb94547d9fb5c$var$ONE_MORE_BYTE_CODE2 = 254;
              const $333fb94547d9fb5c$var$ONE_MORE_BYTE_CODE1 = 255;
              const $333fb94547d9fb5c$var$LOWEST_U_CODE = 253;
              function $333fb94547d9fb5c$var$read255UInt16(stream) {
                let code = stream.readUInt8();
                if (code === $333fb94547d9fb5c$var$WORD_CODE) return stream.readUInt16BE();
                if (code === $333fb94547d9fb5c$var$ONE_MORE_BYTE_CODE1) return stream.readUInt8() + $333fb94547d9fb5c$var$LOWEST_U_CODE;
                if (code === $333fb94547d9fb5c$var$ONE_MORE_BYTE_CODE2) return stream.readUInt8() + $333fb94547d9fb5c$var$LOWEST_U_CODE * 2;
                return code;
              }
              function $333fb94547d9fb5c$var$withSign(flag, baseval) {
                return flag & 1 ? baseval : -baseval;
              }
              function $333fb94547d9fb5c$var$decodeTriplet(flags, glyphs, nPoints) {
                let y;
                let x = y = 0;
                let res = [];
                for (let i = 0; i < nPoints; i++) {
                  let dx = 0, dy = 0;
                  let flag = flags.readUInt8();
                  let onCurve = !(flag >> 7);
                  flag &= 127;
                  if (flag < 10) {
                    dx = 0;
                    dy = $333fb94547d9fb5c$var$withSign(flag, ((flag & 14) << 7) + glyphs.readUInt8());
                  } else if (flag < 20) {
                    dx = $333fb94547d9fb5c$var$withSign(flag, ((flag - 10 & 14) << 7) + glyphs.readUInt8());
                    dy = 0;
                  } else if (flag < 84) {
                    var b0 = flag - 20;
                    var b1 = glyphs.readUInt8();
                    dx = $333fb94547d9fb5c$var$withSign(flag, 1 + (b0 & 48) + (b1 >> 4));
                    dy = $333fb94547d9fb5c$var$withSign(flag >> 1, 1 + ((b0 & 12) << 2) + (b1 & 15));
                  } else if (flag < 120) {
                    var b0 = flag - 84;
                    dx = $333fb94547d9fb5c$var$withSign(flag, 1 + (b0 / 12 << 8) + glyphs.readUInt8());
                    dy = $333fb94547d9fb5c$var$withSign(flag >> 1, 1 + (b0 % 12 >> 2 << 8) + glyphs.readUInt8());
                  } else if (flag < 124) {
                    var b1 = glyphs.readUInt8();
                    let b2 = glyphs.readUInt8();
                    dx = $333fb94547d9fb5c$var$withSign(flag, (b1 << 4) + (b2 >> 4));
                    dy = $333fb94547d9fb5c$var$withSign(flag >> 1, ((b2 & 15) << 8) + glyphs.readUInt8());
                  } else {
                    dx = $333fb94547d9fb5c$var$withSign(flag, glyphs.readUInt16BE());
                    dy = $333fb94547d9fb5c$var$withSign(flag >> 1, glyphs.readUInt16BE());
                  }
                  x += dx;
                  y += dy;
                  res.push(new (0, $f680320fa07ef53d$export$baf26146a414f24a)(onCurve, false, x, y));
                }
                return res;
              }
              let $e0b2de9958441c02$var$TTCHeader = new $gfJaN$restructure.VersionedStruct($gfJaN$restructure.uint32, {
                65536: {
                  numFonts: $gfJaN$restructure.uint32,
                  offsets: new $gfJaN$restructure.Array($gfJaN$restructure.uint32, "numFonts")
                },
                131072: {
                  numFonts: $gfJaN$restructure.uint32,
                  offsets: new $gfJaN$restructure.Array($gfJaN$restructure.uint32, "numFonts"),
                  dsigTag: $gfJaN$restructure.uint32,
                  dsigLength: $gfJaN$restructure.uint32,
                  dsigOffset: $gfJaN$restructure.uint32
                }
              });
              class $e0b2de9958441c02$export$2e2bcd8739ae039 {
                static probe(buffer) {
                  return (0, $66a5b9fb5318558a$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "ttcf";
                }
                getFont(name) {
                  for (let offset of this.header.offsets) {
                    let stream = new $gfJaN$restructure.DecodeStream(this.stream.buffer);
                    stream.pos = offset;
                    let font = new (0, $0a8ef2660a6ce4b6$export$2e2bcd8739ae039)(stream);
                    if (font.postscriptName === name || font.postscriptName instanceof Uint8Array && name instanceof Uint8Array && font.postscriptName.every((v, i) => name[i] === v)) return font;
                  }
                  return null;
                }
                get fonts() {
                  let fonts = [];
                  for (let offset of this.header.offsets) {
                    let stream = new $gfJaN$restructure.DecodeStream(this.stream.buffer);
                    stream.pos = offset;
                    fonts.push(new (0, $0a8ef2660a6ce4b6$export$2e2bcd8739ae039)(stream));
                  }
                  return fonts;
                }
                constructor(stream) {
                  (0, $gfJaN$swchelperscjs_define_propertycjs._)(this, "type", "TTC");
                  this.stream = stream;
                  if (stream.readString(4) !== "ttcf") throw new Error("Not a TrueType collection");
                  this.header = $e0b2de9958441c02$var$TTCHeader.decode(stream);
                }
              }
              let $d0fe640dc6c78783$var$DFontName = new $gfJaN$restructure.String($gfJaN$restructure.uint8);
              let $d0fe640dc6c78783$var$DFontData = new $gfJaN$restructure.Struct({
                len: $gfJaN$restructure.uint32,
                buf: new $gfJaN$restructure.Buffer("len")
              });
              let $d0fe640dc6c78783$var$Ref = new $gfJaN$restructure.Struct({
                id: $gfJaN$restructure.uint16,
                nameOffset: $gfJaN$restructure.int16,
                attr: $gfJaN$restructure.uint8,
                dataOffset: $gfJaN$restructure.uint24,
                handle: $gfJaN$restructure.uint32
              });
              let $d0fe640dc6c78783$var$Type = new $gfJaN$restructure.Struct({
                name: new $gfJaN$restructure.String(4),
                maxTypeIndex: $gfJaN$restructure.uint16,
                refList: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, new $gfJaN$restructure.Array($d0fe640dc6c78783$var$Ref, (t) => t.maxTypeIndex + 1), {
                  type: "parent"
                })
              });
              let $d0fe640dc6c78783$var$TypeList = new $gfJaN$restructure.Struct({
                length: $gfJaN$restructure.uint16,
                types: new $gfJaN$restructure.Array($d0fe640dc6c78783$var$Type, (t) => t.length + 1)
              });
              let $d0fe640dc6c78783$var$DFontMap = new $gfJaN$restructure.Struct({
                reserved: new $gfJaN$restructure.Reserved($gfJaN$restructure.uint8, 24),
                typeList: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, $d0fe640dc6c78783$var$TypeList),
                nameListOffset: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint16, "void")
              });
              let $d0fe640dc6c78783$var$DFontHeader = new $gfJaN$restructure.Struct({
                dataOffset: $gfJaN$restructure.uint32,
                map: new $gfJaN$restructure.Pointer($gfJaN$restructure.uint32, $d0fe640dc6c78783$var$DFontMap),
                dataLength: $gfJaN$restructure.uint32,
                mapLength: $gfJaN$restructure.uint32
              });
              class $d0fe640dc6c78783$export$2e2bcd8739ae039 {
                static probe(buffer) {
                  let stream = new $gfJaN$restructure.DecodeStream(buffer);
                  try {
                    var header = $d0fe640dc6c78783$var$DFontHeader.decode(stream);
                  } catch (e) {
                    return false;
                  }
                  for (let type of header.map.typeList.types) {
                    if (type.name === "sfnt") return true;
                  }
                  return false;
                }
                getFont(name) {
                  if (!this.sfnt) return null;
                  for (let ref of this.sfnt.refList) {
                    let pos = this.header.dataOffset + ref.dataOffset + 4;
                    let stream = new $gfJaN$restructure.DecodeStream(this.stream.buffer.slice(pos));
                    let font = new (0, $0a8ef2660a6ce4b6$export$2e2bcd8739ae039)(stream);
                    if (font.postscriptName === name || font.postscriptName instanceof Uint8Array && name instanceof Uint8Array && font.postscriptName.every((v, i) => name[i] === v)) return font;
                  }
                  return null;
                }
                get fonts() {
                  let fonts = [];
                  for (let ref of this.sfnt.refList) {
                    let pos = this.header.dataOffset + ref.dataOffset + 4;
                    let stream = new $gfJaN$restructure.DecodeStream(this.stream.buffer.slice(pos));
                    fonts.push(new (0, $0a8ef2660a6ce4b6$export$2e2bcd8739ae039)(stream));
                  }
                  return fonts;
                }
                constructor(stream) {
                  (0, $gfJaN$swchelperscjs_define_propertycjs._)(this, "type", "DFont");
                  this.stream = stream;
                  this.header = $d0fe640dc6c78783$var$DFontHeader.decode(this.stream);
                  for (let type of this.header.map.typeList.types) {
                    for (let ref of type.refList) if (ref.nameOffset >= 0) {
                      this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;
                      ref.name = $d0fe640dc6c78783$var$DFontName.decode(this.stream);
                    } else ref.name = null;
                    if (type.name === "sfnt") this.sfnt = type;
                  }
                }
              }
              (0, $59aa4ed98453e1d4$export$36b2f24e97d43be)((0, $0a8ef2660a6ce4b6$export$2e2bcd8739ae039));
              (0, $59aa4ed98453e1d4$export$36b2f24e97d43be)((0, $8a0a49baaf5d834d$export$2e2bcd8739ae039));
              (0, $59aa4ed98453e1d4$export$36b2f24e97d43be)((0, $333fb94547d9fb5c$export$2e2bcd8739ae039));
              (0, $59aa4ed98453e1d4$export$36b2f24e97d43be)((0, $e0b2de9958441c02$export$2e2bcd8739ae039));
              (0, $59aa4ed98453e1d4$export$36b2f24e97d43be)((0, $d0fe640dc6c78783$export$2e2bcd8739ae039));
              $parcel$exportWildcard(module2.exports, $59aa4ed98453e1d4$exports);
            },
            /***/
            1733(__unused_webpack_module, exports2, __webpack_require__2) {
              var Buffer = __webpack_require__2(783)["Buffer"];
              ;
              (function(sax) {
                sax.parser = function(strict, opt) {
                  return new SAXParser(strict, opt);
                };
                sax.SAXParser = SAXParser;
                sax.SAXStream = SAXStream;
                sax.createStream = createStream;
                sax.MAX_BUFFER_LENGTH = 64 * 1024;
                var buffers = [
                  "comment",
                  "sgmlDecl",
                  "textNode",
                  "tagName",
                  "doctype",
                  "procInstName",
                  "procInstBody",
                  "entity",
                  "attribName",
                  "attribValue",
                  "cdata",
                  "script"
                ];
                sax.EVENTS = [
                  "text",
                  "processinginstruction",
                  "sgmldeclaration",
                  "doctype",
                  "comment",
                  "opentagstart",
                  "attribute",
                  "opentag",
                  "closetag",
                  "opencdata",
                  "cdata",
                  "closecdata",
                  "error",
                  "end",
                  "ready",
                  "script",
                  "opennamespace",
                  "closenamespace"
                ];
                function SAXParser(strict, opt) {
                  if (!(this instanceof SAXParser)) {
                    return new SAXParser(strict, opt);
                  }
                  var parser = this;
                  clearBuffers(parser);
                  parser.q = parser.c = "";
                  parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
                  parser.opt = opt || {};
                  parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
                  parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
                  parser.tags = [];
                  parser.closed = parser.closedRoot = parser.sawRoot = false;
                  parser.tag = parser.error = null;
                  parser.strict = !!strict;
                  parser.noscript = !!(strict || parser.opt.noscript);
                  parser.state = S.BEGIN;
                  parser.strictEntities = parser.opt.strictEntities;
                  parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
                  parser.attribList = [];
                  if (parser.opt.xmlns) {
                    parser.ns = Object.create(rootNS);
                  }
                  if (parser.opt.unquotedAttributeValues === void 0) {
                    parser.opt.unquotedAttributeValues = !strict;
                  }
                  parser.trackPosition = parser.opt.position !== false;
                  if (parser.trackPosition) {
                    parser.position = parser.line = parser.column = 0;
                  }
                  emit(parser, "onready");
                }
                if (!Object.create) {
                  Object.create = function(o) {
                    function F() {
                    }
                    F.prototype = o;
                    var newf = new F();
                    return newf;
                  };
                }
                if (!Object.keys) {
                  Object.keys = function(o) {
                    var a = [];
                    for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
                    return a;
                  };
                }
                function checkBufferLength(parser) {
                  var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
                  var maxActual = 0;
                  for (var i = 0, l = buffers.length; i < l; i++) {
                    var len = parser[buffers[i]].length;
                    if (len > maxAllowed) {
                      switch (buffers[i]) {
                        case "textNode":
                          closeText(parser);
                          break;
                        case "cdata":
                          emitNode(parser, "oncdata", parser.cdata);
                          parser.cdata = "";
                          break;
                        case "script":
                          emitNode(parser, "onscript", parser.script);
                          parser.script = "";
                          break;
                        default:
                          error(parser, "Max buffer length exceeded: " + buffers[i]);
                      }
                    }
                    maxActual = Math.max(maxActual, len);
                  }
                  var m = sax.MAX_BUFFER_LENGTH - maxActual;
                  parser.bufferCheckPosition = m + parser.position;
                }
                function clearBuffers(parser) {
                  for (var i = 0, l = buffers.length; i < l; i++) {
                    parser[buffers[i]] = "";
                  }
                }
                function flushBuffers(parser) {
                  closeText(parser);
                  if (parser.cdata !== "") {
                    emitNode(parser, "oncdata", parser.cdata);
                    parser.cdata = "";
                  }
                  if (parser.script !== "") {
                    emitNode(parser, "onscript", parser.script);
                    parser.script = "";
                  }
                }
                SAXParser.prototype = {
                  end: function() {
                    end(this);
                  },
                  write,
                  resume: function() {
                    this.error = null;
                    return this;
                  },
                  close: function() {
                    return this.write(null);
                  },
                  flush: function() {
                    flushBuffers(this);
                  }
                };
                var Stream;
                try {
                  Stream = __webpack_require__2(9760).Stream;
                } catch (ex) {
                  Stream = function() {
                  };
                }
                if (!Stream) Stream = function() {
                };
                var streamWraps = sax.EVENTS.filter(function(ev) {
                  return ev !== "error" && ev !== "end";
                });
                function createStream(strict, opt) {
                  return new SAXStream(strict, opt);
                }
                function SAXStream(strict, opt) {
                  if (!(this instanceof SAXStream)) {
                    return new SAXStream(strict, opt);
                  }
                  Stream.apply(this);
                  this._parser = new SAXParser(strict, opt);
                  this.writable = true;
                  this.readable = true;
                  var me = this;
                  this._parser.onend = function() {
                    me.emit("end");
                  };
                  this._parser.onerror = function(er) {
                    me.emit("error", er);
                    me._parser.error = null;
                  };
                  this._decoder = null;
                  streamWraps.forEach(function(ev) {
                    Object.defineProperty(me, "on" + ev, {
                      get: function() {
                        return me._parser["on" + ev];
                      },
                      set: function(h) {
                        if (!h) {
                          me.removeAllListeners(ev);
                          me._parser["on" + ev] = h;
                          return h;
                        }
                        me.on(ev, h);
                      },
                      enumerable: true,
                      configurable: false
                    });
                  });
                }
                SAXStream.prototype = Object.create(Stream.prototype, {
                  constructor: {
                    value: SAXStream
                  }
                });
                SAXStream.prototype.write = function(data) {
                  if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
                    if (!this._decoder) {
                      this._decoder = new TextDecoder("utf8");
                    }
                    data = this._decoder.decode(data, { stream: true });
                  }
                  this._parser.write(data.toString());
                  this.emit("data", data);
                  return true;
                };
                SAXStream.prototype.end = function(chunk) {
                  if (chunk && chunk.length) {
                    this.write(chunk);
                  }
                  if (this._decoder) {
                    var remaining = this._decoder.decode();
                    if (remaining) {
                      this._parser.write(remaining);
                      this.emit("data", remaining);
                    }
                  }
                  this._parser.end();
                  return true;
                };
                SAXStream.prototype.on = function(ev, handler) {
                  var me = this;
                  if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
                    me._parser["on" + ev] = function() {
                      var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
                      args.splice(0, 0, ev);
                      me.emit.apply(me, args);
                    };
                  }
                  return Stream.prototype.on.call(me, ev, handler);
                };
                var CDATA = "[CDATA[";
                var DOCTYPE = "DOCTYPE";
                var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
                var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
                var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
                var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
                var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
                var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
                var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
                function isWhitespace(c) {
                  return c === " " || c === "\n" || c === "\r" || c === "	";
                }
                function isQuote(c) {
                  return c === '"' || c === "'";
                }
                function isAttribEnd(c) {
                  return c === ">" || isWhitespace(c);
                }
                function isMatch(regex, c) {
                  return regex.test(c);
                }
                function notMatch(regex, c) {
                  return !isMatch(regex, c);
                }
                var S = 0;
                sax.STATE = {
                  BEGIN: S++,
                  // leading byte order mark or whitespace
                  BEGIN_WHITESPACE: S++,
                  // leading whitespace
                  TEXT: S++,
                  // general stuff
                  TEXT_ENTITY: S++,
                  // &amp and such.
                  OPEN_WAKA: S++,
                  // <
                  SGML_DECL: S++,
                  // <!BLARG
                  SGML_DECL_QUOTED: S++,
                  // <!BLARG foo "bar
                  DOCTYPE: S++,
                  // <!DOCTYPE
                  DOCTYPE_QUOTED: S++,
                  // <!DOCTYPE "//blah
                  DOCTYPE_DTD: S++,
                  // <!DOCTYPE "//blah" [ ...
                  DOCTYPE_DTD_QUOTED: S++,
                  // <!DOCTYPE "//blah" [ "foo
                  COMMENT_STARTING: S++,
                  // <!-
                  COMMENT: S++,
                  // <!--
                  COMMENT_ENDING: S++,
                  // <!-- blah -
                  COMMENT_ENDED: S++,
                  // <!-- blah --
                  CDATA: S++,
                  // <![CDATA[ something
                  CDATA_ENDING: S++,
                  // ]
                  CDATA_ENDING_2: S++,
                  // ]]
                  PROC_INST: S++,
                  // <?hi
                  PROC_INST_BODY: S++,
                  // <?hi there
                  PROC_INST_ENDING: S++,
                  // <?hi "there" ?
                  OPEN_TAG: S++,
                  // <strong
                  OPEN_TAG_SLASH: S++,
                  // <strong /
                  ATTRIB: S++,
                  // <a
                  ATTRIB_NAME: S++,
                  // <a foo
                  ATTRIB_NAME_SAW_WHITE: S++,
                  // <a foo _
                  ATTRIB_VALUE: S++,
                  // <a foo=
                  ATTRIB_VALUE_QUOTED: S++,
                  // <a foo="bar
                  ATTRIB_VALUE_CLOSED: S++,
                  // <a foo="bar"
                  ATTRIB_VALUE_UNQUOTED: S++,
                  // <a foo=bar
                  ATTRIB_VALUE_ENTITY_Q: S++,
                  // <foo bar="&quot;"
                  ATTRIB_VALUE_ENTITY_U: S++,
                  // <foo bar=&quot
                  CLOSE_TAG: S++,
                  // </a
                  CLOSE_TAG_SAW_WHITE: S++,
                  // </a   >
                  SCRIPT: S++,
                  // <script> ...
                  SCRIPT_ENDING: S++
                  // <script> ... <
                };
                sax.XML_ENTITIES = {
                  amp: "&",
                  gt: ">",
                  lt: "<",
                  quot: '"',
                  apos: "'"
                };
                sax.ENTITIES = {
                  amp: "&",
                  gt: ">",
                  lt: "<",
                  quot: '"',
                  apos: "'",
                  AElig: 198,
                  Aacute: 193,
                  Acirc: 194,
                  Agrave: 192,
                  Aring: 197,
                  Atilde: 195,
                  Auml: 196,
                  Ccedil: 199,
                  ETH: 208,
                  Eacute: 201,
                  Ecirc: 202,
                  Egrave: 200,
                  Euml: 203,
                  Iacute: 205,
                  Icirc: 206,
                  Igrave: 204,
                  Iuml: 207,
                  Ntilde: 209,
                  Oacute: 211,
                  Ocirc: 212,
                  Ograve: 210,
                  Oslash: 216,
                  Otilde: 213,
                  Ouml: 214,
                  THORN: 222,
                  Uacute: 218,
                  Ucirc: 219,
                  Ugrave: 217,
                  Uuml: 220,
                  Yacute: 221,
                  aacute: 225,
                  acirc: 226,
                  aelig: 230,
                  agrave: 224,
                  aring: 229,
                  atilde: 227,
                  auml: 228,
                  ccedil: 231,
                  eacute: 233,
                  ecirc: 234,
                  egrave: 232,
                  eth: 240,
                  euml: 235,
                  iacute: 237,
                  icirc: 238,
                  igrave: 236,
                  iuml: 239,
                  ntilde: 241,
                  oacute: 243,
                  ocirc: 244,
                  ograve: 242,
                  oslash: 248,
                  otilde: 245,
                  ouml: 246,
                  szlig: 223,
                  thorn: 254,
                  uacute: 250,
                  ucirc: 251,
                  ugrave: 249,
                  uuml: 252,
                  yacute: 253,
                  yuml: 255,
                  copy: 169,
                  reg: 174,
                  nbsp: 160,
                  iexcl: 161,
                  cent: 162,
                  pound: 163,
                  curren: 164,
                  yen: 165,
                  brvbar: 166,
                  sect: 167,
                  uml: 168,
                  ordf: 170,
                  laquo: 171,
                  not: 172,
                  shy: 173,
                  macr: 175,
                  deg: 176,
                  plusmn: 177,
                  sup1: 185,
                  sup2: 178,
                  sup3: 179,
                  acute: 180,
                  micro: 181,
                  para: 182,
                  middot: 183,
                  cedil: 184,
                  ordm: 186,
                  raquo: 187,
                  frac14: 188,
                  frac12: 189,
                  frac34: 190,
                  iquest: 191,
                  times: 215,
                  divide: 247,
                  OElig: 338,
                  oelig: 339,
                  Scaron: 352,
                  scaron: 353,
                  Yuml: 376,
                  fnof: 402,
                  circ: 710,
                  tilde: 732,
                  Alpha: 913,
                  Beta: 914,
                  Gamma: 915,
                  Delta: 916,
                  Epsilon: 917,
                  Zeta: 918,
                  Eta: 919,
                  Theta: 920,
                  Iota: 921,
                  Kappa: 922,
                  Lambda: 923,
                  Mu: 924,
                  Nu: 925,
                  Xi: 926,
                  Omicron: 927,
                  Pi: 928,
                  Rho: 929,
                  Sigma: 931,
                  Tau: 932,
                  Upsilon: 933,
                  Phi: 934,
                  Chi: 935,
                  Psi: 936,
                  Omega: 937,
                  alpha: 945,
                  beta: 946,
                  gamma: 947,
                  delta: 948,
                  epsilon: 949,
                  zeta: 950,
                  eta: 951,
                  theta: 952,
                  iota: 953,
                  kappa: 954,
                  lambda: 955,
                  mu: 956,
                  nu: 957,
                  xi: 958,
                  omicron: 959,
                  pi: 960,
                  rho: 961,
                  sigmaf: 962,
                  sigma: 963,
                  tau: 964,
                  upsilon: 965,
                  phi: 966,
                  chi: 967,
                  psi: 968,
                  omega: 969,
                  thetasym: 977,
                  upsih: 978,
                  piv: 982,
                  ensp: 8194,
                  emsp: 8195,
                  thinsp: 8201,
                  zwnj: 8204,
                  zwj: 8205,
                  lrm: 8206,
                  rlm: 8207,
                  ndash: 8211,
                  mdash: 8212,
                  lsquo: 8216,
                  rsquo: 8217,
                  sbquo: 8218,
                  ldquo: 8220,
                  rdquo: 8221,
                  bdquo: 8222,
                  dagger: 8224,
                  Dagger: 8225,
                  bull: 8226,
                  hellip: 8230,
                  permil: 8240,
                  prime: 8242,
                  Prime: 8243,
                  lsaquo: 8249,
                  rsaquo: 8250,
                  oline: 8254,
                  frasl: 8260,
                  euro: 8364,
                  image: 8465,
                  weierp: 8472,
                  real: 8476,
                  trade: 8482,
                  alefsym: 8501,
                  larr: 8592,
                  uarr: 8593,
                  rarr: 8594,
                  darr: 8595,
                  harr: 8596,
                  crarr: 8629,
                  lArr: 8656,
                  uArr: 8657,
                  rArr: 8658,
                  dArr: 8659,
                  hArr: 8660,
                  forall: 8704,
                  part: 8706,
                  exist: 8707,
                  empty: 8709,
                  nabla: 8711,
                  isin: 8712,
                  notin: 8713,
                  ni: 8715,
                  prod: 8719,
                  sum: 8721,
                  minus: 8722,
                  lowast: 8727,
                  radic: 8730,
                  prop: 8733,
                  infin: 8734,
                  ang: 8736,
                  and: 8743,
                  or: 8744,
                  cap: 8745,
                  cup: 8746,
                  int: 8747,
                  there4: 8756,
                  sim: 8764,
                  cong: 8773,
                  asymp: 8776,
                  ne: 8800,
                  equiv: 8801,
                  le: 8804,
                  ge: 8805,
                  sub: 8834,
                  sup: 8835,
                  nsub: 8836,
                  sube: 8838,
                  supe: 8839,
                  oplus: 8853,
                  otimes: 8855,
                  perp: 8869,
                  sdot: 8901,
                  lceil: 8968,
                  rceil: 8969,
                  lfloor: 8970,
                  rfloor: 8971,
                  lang: 9001,
                  rang: 9002,
                  loz: 9674,
                  spades: 9824,
                  clubs: 9827,
                  hearts: 9829,
                  diams: 9830
                };
                Object.keys(sax.ENTITIES).forEach(function(key) {
                  var e = sax.ENTITIES[key];
                  var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
                  sax.ENTITIES[key] = s2;
                });
                for (var s in sax.STATE) {
                  sax.STATE[sax.STATE[s]] = s;
                }
                S = sax.STATE;
                function emit(parser, event, data) {
                  parser[event] && parser[event](data);
                }
                function emitNode(parser, nodeType, data) {
                  if (parser.textNode) closeText(parser);
                  emit(parser, nodeType, data);
                }
                function closeText(parser) {
                  parser.textNode = textopts(parser.opt, parser.textNode);
                  if (parser.textNode) emit(parser, "ontext", parser.textNode);
                  parser.textNode = "";
                }
                function textopts(opt, text) {
                  if (opt.trim) text = text.trim();
                  if (opt.normalize) text = text.replace(/\s+/g, " ");
                  return text;
                }
                function error(parser, er) {
                  closeText(parser);
                  if (parser.trackPosition) {
                    er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
                  }
                  er = new Error(er);
                  parser.error = er;
                  emit(parser, "onerror", er);
                  return parser;
                }
                function end(parser) {
                  if (parser.sawRoot && !parser.closedRoot)
                    strictFail(parser, "Unclosed root tag");
                  if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
                    error(parser, "Unexpected end");
                  }
                  closeText(parser);
                  parser.c = "";
                  parser.closed = true;
                  emit(parser, "onend");
                  SAXParser.call(parser, parser.strict, parser.opt);
                  return parser;
                }
                function strictFail(parser, message) {
                  if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
                    throw new Error("bad call to strictFail");
                  }
                  if (parser.strict) {
                    error(parser, message);
                  }
                }
                function newTag(parser) {
                  if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
                  var parent = parser.tags[parser.tags.length - 1] || parser;
                  var tag = parser.tag = { name: parser.tagName, attributes: {} };
                  if (parser.opt.xmlns) {
                    tag.ns = parent.ns;
                  }
                  parser.attribList.length = 0;
                  emitNode(parser, "onopentagstart", tag);
                }
                function qname(name, attribute) {
                  var i = name.indexOf(":");
                  var qualName = i < 0 ? ["", name] : name.split(":");
                  var prefix = qualName[0];
                  var local = qualName[1];
                  if (attribute && name === "xmlns") {
                    prefix = "xmlns";
                    local = "";
                  }
                  return { prefix, local };
                }
                function attrib(parser) {
                  if (!parser.strict) {
                    parser.attribName = parser.attribName[parser.looseCase]();
                  }
                  if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
                    parser.attribName = parser.attribValue = "";
                    return;
                  }
                  if (parser.opt.xmlns) {
                    var qn = qname(parser.attribName, true);
                    var prefix = qn.prefix;
                    var local = qn.local;
                    if (prefix === "xmlns") {
                      if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
                        strictFail(
                          parser,
                          "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
                        );
                      } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
                        strictFail(
                          parser,
                          "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
                        );
                      } else {
                        var tag = parser.tag;
                        var parent = parser.tags[parser.tags.length - 1] || parser;
                        if (tag.ns === parent.ns) {
                          tag.ns = Object.create(parent.ns);
                        }
                        tag.ns[local] = parser.attribValue;
                      }
                    }
                    parser.attribList.push([parser.attribName, parser.attribValue]);
                  } else {
                    parser.tag.attributes[parser.attribName] = parser.attribValue;
                    emitNode(parser, "onattribute", {
                      name: parser.attribName,
                      value: parser.attribValue
                    });
                  }
                  parser.attribName = parser.attribValue = "";
                }
                function openTag(parser, selfClosing) {
                  if (parser.opt.xmlns) {
                    var tag = parser.tag;
                    var qn = qname(parser.tagName);
                    tag.prefix = qn.prefix;
                    tag.local = qn.local;
                    tag.uri = tag.ns[qn.prefix] || "";
                    if (tag.prefix && !tag.uri) {
                      strictFail(
                        parser,
                        "Unbound namespace prefix: " + JSON.stringify(parser.tagName)
                      );
                      tag.uri = qn.prefix;
                    }
                    var parent = parser.tags[parser.tags.length - 1] || parser;
                    if (tag.ns && parent.ns !== tag.ns) {
                      Object.keys(tag.ns).forEach(function(p) {
                        emitNode(parser, "onopennamespace", {
                          prefix: p,
                          uri: tag.ns[p]
                        });
                      });
                    }
                    for (var i = 0, l = parser.attribList.length; i < l; i++) {
                      var nv = parser.attribList[i];
                      var name = nv[0];
                      var value = nv[1];
                      var qualName = qname(name, true);
                      var prefix = qualName.prefix;
                      var local = qualName.local;
                      var uri = prefix === "" ? "" : tag.ns[prefix] || "";
                      var a = {
                        name,
                        value,
                        prefix,
                        local,
                        uri
                      };
                      if (prefix && prefix !== "xmlns" && !uri) {
                        strictFail(
                          parser,
                          "Unbound namespace prefix: " + JSON.stringify(prefix)
                        );
                        a.uri = prefix;
                      }
                      parser.tag.attributes[name] = a;
                      emitNode(parser, "onattribute", a);
                    }
                    parser.attribList.length = 0;
                  }
                  parser.tag.isSelfClosing = !!selfClosing;
                  parser.sawRoot = true;
                  parser.tags.push(parser.tag);
                  emitNode(parser, "onopentag", parser.tag);
                  if (!selfClosing) {
                    if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
                      parser.state = S.SCRIPT;
                    } else {
                      parser.state = S.TEXT;
                    }
                    parser.tag = null;
                    parser.tagName = "";
                  }
                  parser.attribName = parser.attribValue = "";
                  parser.attribList.length = 0;
                }
                function closeTag(parser) {
                  if (!parser.tagName) {
                    strictFail(parser, "Weird empty close tag.");
                    parser.textNode += "</>";
                    parser.state = S.TEXT;
                    return;
                  }
                  if (parser.script) {
                    if (parser.tagName !== "script") {
                      parser.script += "</" + parser.tagName + ">";
                      parser.tagName = "";
                      parser.state = S.SCRIPT;
                      return;
                    }
                    emitNode(parser, "onscript", parser.script);
                    parser.script = "";
                  }
                  var t = parser.tags.length;
                  var tagName = parser.tagName;
                  if (!parser.strict) {
                    tagName = tagName[parser.looseCase]();
                  }
                  var closeTo = tagName;
                  while (t--) {
                    var close = parser.tags[t];
                    if (close.name !== closeTo) {
                      strictFail(parser, "Unexpected close tag");
                    } else {
                      break;
                    }
                  }
                  if (t < 0) {
                    strictFail(parser, "Unmatched closing tag: " + parser.tagName);
                    parser.textNode += "</" + parser.tagName + ">";
                    parser.state = S.TEXT;
                    return;
                  }
                  parser.tagName = tagName;
                  var s2 = parser.tags.length;
                  while (s2-- > t) {
                    var tag = parser.tag = parser.tags.pop();
                    parser.tagName = parser.tag.name;
                    emitNode(parser, "onclosetag", parser.tagName);
                    var x = {};
                    for (var i in tag.ns) {
                      x[i] = tag.ns[i];
                    }
                    var parent = parser.tags[parser.tags.length - 1] || parser;
                    if (parser.opt.xmlns && tag.ns !== parent.ns) {
                      Object.keys(tag.ns).forEach(function(p) {
                        var n = tag.ns[p];
                        emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
                      });
                    }
                  }
                  if (t === 0) parser.closedRoot = true;
                  parser.tagName = parser.attribValue = parser.attribName = "";
                  parser.attribList.length = 0;
                  parser.state = S.TEXT;
                }
                function parseEntity(parser) {
                  var entity = parser.entity;
                  var entityLC = entity.toLowerCase();
                  var num;
                  var numStr = "";
                  if (parser.ENTITIES[entity]) {
                    return parser.ENTITIES[entity];
                  }
                  if (parser.ENTITIES[entityLC]) {
                    return parser.ENTITIES[entityLC];
                  }
                  entity = entityLC;
                  if (entity.charAt(0) === "#") {
                    if (entity.charAt(1) === "x") {
                      entity = entity.slice(2);
                      num = parseInt(entity, 16);
                      numStr = num.toString(16);
                    } else {
                      entity = entity.slice(1);
                      num = parseInt(entity, 10);
                      numStr = num.toString(10);
                    }
                  }
                  entity = entity.replace(/^0+/, "");
                  if (isNaN(num) || numStr.toLowerCase() !== entity || num < 0 || num > 1114111) {
                    strictFail(parser, "Invalid character entity");
                    return "&" + parser.entity + ";";
                  }
                  return String.fromCodePoint(num);
                }
                function beginWhiteSpace(parser, c) {
                  if (c === "<") {
                    parser.state = S.OPEN_WAKA;
                    parser.startTagPosition = parser.position;
                  } else if (!isWhitespace(c)) {
                    strictFail(parser, "Non-whitespace before first tag.");
                    parser.textNode = c;
                    parser.state = S.TEXT;
                  }
                }
                function charAt(chunk, i) {
                  var result = "";
                  if (i < chunk.length) {
                    result = chunk.charAt(i);
                  }
                  return result;
                }
                function write(chunk) {
                  var parser = this;
                  if (this.error) {
                    throw this.error;
                  }
                  if (parser.closed) {
                    return error(
                      parser,
                      "Cannot write after close. Assign an onready handler."
                    );
                  }
                  if (chunk === null) {
                    return end(parser);
                  }
                  if (typeof chunk === "object") {
                    chunk = chunk.toString();
                  }
                  var i = 0;
                  var c = "";
                  while (true) {
                    c = charAt(chunk, i++);
                    parser.c = c;
                    if (!c) {
                      break;
                    }
                    if (parser.trackPosition) {
                      parser.position++;
                      if (c === "\n") {
                        parser.line++;
                        parser.column = 0;
                      } else {
                        parser.column++;
                      }
                    }
                    switch (parser.state) {
                      case S.BEGIN:
                        parser.state = S.BEGIN_WHITESPACE;
                        if (c === "\uFEFF") {
                          continue;
                        }
                        beginWhiteSpace(parser, c);
                        continue;
                      case S.BEGIN_WHITESPACE:
                        beginWhiteSpace(parser, c);
                        continue;
                      case S.TEXT:
                        if (parser.sawRoot && !parser.closedRoot) {
                          var starti = i - 1;
                          while (c && c !== "<" && c !== "&") {
                            c = charAt(chunk, i++);
                            if (c && parser.trackPosition) {
                              parser.position++;
                              if (c === "\n") {
                                parser.line++;
                                parser.column = 0;
                              } else {
                                parser.column++;
                              }
                            }
                          }
                          parser.textNode += chunk.substring(starti, i - 1);
                        }
                        if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                          parser.state = S.OPEN_WAKA;
                          parser.startTagPosition = parser.position;
                        } else {
                          if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                            strictFail(parser, "Text data outside of root node.");
                          }
                          if (c === "&") {
                            parser.state = S.TEXT_ENTITY;
                          } else {
                            parser.textNode += c;
                          }
                        }
                        continue;
                      case S.SCRIPT:
                        if (c === "<") {
                          parser.state = S.SCRIPT_ENDING;
                        } else {
                          parser.script += c;
                        }
                        continue;
                      case S.SCRIPT_ENDING:
                        if (c === "/") {
                          parser.state = S.CLOSE_TAG;
                        } else {
                          parser.script += "<" + c;
                          parser.state = S.SCRIPT;
                        }
                        continue;
                      case S.OPEN_WAKA:
                        if (c === "!") {
                          parser.state = S.SGML_DECL;
                          parser.sgmlDecl = "";
                        } else if (isWhitespace(c)) {
                        } else if (isMatch(nameStart, c)) {
                          parser.state = S.OPEN_TAG;
                          parser.tagName = c;
                        } else if (c === "/") {
                          parser.state = S.CLOSE_TAG;
                          parser.tagName = "";
                        } else if (c === "?") {
                          parser.state = S.PROC_INST;
                          parser.procInstName = parser.procInstBody = "";
                        } else {
                          strictFail(parser, "Unencoded <");
                          if (parser.startTagPosition + 1 < parser.position) {
                            var pad = parser.position - parser.startTagPosition;
                            c = new Array(pad).join(" ") + c;
                          }
                          parser.textNode += "<" + c;
                          parser.state = S.TEXT;
                        }
                        continue;
                      case S.SGML_DECL:
                        if (parser.sgmlDecl + c === "--") {
                          parser.state = S.COMMENT;
                          parser.comment = "";
                          parser.sgmlDecl = "";
                          continue;
                        }
                        if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
                          parser.state = S.DOCTYPE_DTD;
                          parser.doctype += "<!" + parser.sgmlDecl + c;
                          parser.sgmlDecl = "";
                        } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                          emitNode(parser, "onopencdata");
                          parser.state = S.CDATA;
                          parser.sgmlDecl = "";
                          parser.cdata = "";
                        } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                          parser.state = S.DOCTYPE;
                          if (parser.doctype || parser.sawRoot) {
                            strictFail(
                              parser,
                              "Inappropriately located doctype declaration"
                            );
                          }
                          parser.doctype = "";
                          parser.sgmlDecl = "";
                        } else if (c === ">") {
                          emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                          parser.sgmlDecl = "";
                          parser.state = S.TEXT;
                        } else if (isQuote(c)) {
                          parser.state = S.SGML_DECL_QUOTED;
                          parser.sgmlDecl += c;
                        } else {
                          parser.sgmlDecl += c;
                        }
                        continue;
                      case S.SGML_DECL_QUOTED:
                        if (c === parser.q) {
                          parser.state = S.SGML_DECL;
                          parser.q = "";
                        }
                        parser.sgmlDecl += c;
                        continue;
                      case S.DOCTYPE:
                        if (c === ">") {
                          parser.state = S.TEXT;
                          emitNode(parser, "ondoctype", parser.doctype);
                          parser.doctype = true;
                        } else {
                          parser.doctype += c;
                          if (c === "[") {
                            parser.state = S.DOCTYPE_DTD;
                          } else if (isQuote(c)) {
                            parser.state = S.DOCTYPE_QUOTED;
                            parser.q = c;
                          }
                        }
                        continue;
                      case S.DOCTYPE_QUOTED:
                        parser.doctype += c;
                        if (c === parser.q) {
                          parser.q = "";
                          parser.state = S.DOCTYPE;
                        }
                        continue;
                      case S.DOCTYPE_DTD:
                        if (c === "]") {
                          parser.doctype += c;
                          parser.state = S.DOCTYPE;
                        } else if (c === "<") {
                          parser.state = S.OPEN_WAKA;
                          parser.startTagPosition = parser.position;
                        } else if (isQuote(c)) {
                          parser.doctype += c;
                          parser.state = S.DOCTYPE_DTD_QUOTED;
                          parser.q = c;
                        } else {
                          parser.doctype += c;
                        }
                        continue;
                      case S.DOCTYPE_DTD_QUOTED:
                        parser.doctype += c;
                        if (c === parser.q) {
                          parser.state = S.DOCTYPE_DTD;
                          parser.q = "";
                        }
                        continue;
                      case S.COMMENT:
                        if (c === "-") {
                          parser.state = S.COMMENT_ENDING;
                        } else {
                          parser.comment += c;
                        }
                        continue;
                      case S.COMMENT_ENDING:
                        if (c === "-") {
                          parser.state = S.COMMENT_ENDED;
                          parser.comment = textopts(parser.opt, parser.comment);
                          if (parser.comment) {
                            emitNode(parser, "oncomment", parser.comment);
                          }
                          parser.comment = "";
                        } else {
                          parser.comment += "-" + c;
                          parser.state = S.COMMENT;
                        }
                        continue;
                      case S.COMMENT_ENDED:
                        if (c !== ">") {
                          strictFail(parser, "Malformed comment");
                          parser.comment += "--" + c;
                          parser.state = S.COMMENT;
                        } else if (parser.doctype && parser.doctype !== true) {
                          parser.state = S.DOCTYPE_DTD;
                        } else {
                          parser.state = S.TEXT;
                        }
                        continue;
                      case S.CDATA:
                        var starti = i - 1;
                        while (c && c !== "]") {
                          c = charAt(chunk, i++);
                          if (c && parser.trackPosition) {
                            parser.position++;
                            if (c === "\n") {
                              parser.line++;
                              parser.column = 0;
                            } else {
                              parser.column++;
                            }
                          }
                        }
                        parser.cdata += chunk.substring(starti, i - 1);
                        if (c === "]") {
                          parser.state = S.CDATA_ENDING;
                        }
                        continue;
                      case S.CDATA_ENDING:
                        if (c === "]") {
                          parser.state = S.CDATA_ENDING_2;
                        } else {
                          parser.cdata += "]" + c;
                          parser.state = S.CDATA;
                        }
                        continue;
                      case S.CDATA_ENDING_2:
                        if (c === ">") {
                          if (parser.cdata) {
                            emitNode(parser, "oncdata", parser.cdata);
                          }
                          emitNode(parser, "onclosecdata");
                          parser.cdata = "";
                          parser.state = S.TEXT;
                        } else if (c === "]") {
                          parser.cdata += "]";
                        } else {
                          parser.cdata += "]]" + c;
                          parser.state = S.CDATA;
                        }
                        continue;
                      case S.PROC_INST:
                        if (c === "?") {
                          parser.state = S.PROC_INST_ENDING;
                        } else if (isWhitespace(c)) {
                          parser.state = S.PROC_INST_BODY;
                        } else {
                          parser.procInstName += c;
                        }
                        continue;
                      case S.PROC_INST_BODY:
                        if (!parser.procInstBody && isWhitespace(c)) {
                          continue;
                        } else if (c === "?") {
                          parser.state = S.PROC_INST_ENDING;
                        } else {
                          parser.procInstBody += c;
                        }
                        continue;
                      case S.PROC_INST_ENDING:
                        if (c === ">") {
                          emitNode(parser, "onprocessinginstruction", {
                            name: parser.procInstName,
                            body: parser.procInstBody
                          });
                          parser.procInstName = parser.procInstBody = "";
                          parser.state = S.TEXT;
                        } else {
                          parser.procInstBody += "?" + c;
                          parser.state = S.PROC_INST_BODY;
                        }
                        continue;
                      case S.OPEN_TAG:
                        if (isMatch(nameBody, c)) {
                          parser.tagName += c;
                        } else {
                          newTag(parser);
                          if (c === ">") {
                            openTag(parser);
                          } else if (c === "/") {
                            parser.state = S.OPEN_TAG_SLASH;
                          } else {
                            if (!isWhitespace(c)) {
                              strictFail(parser, "Invalid character in tag name");
                            }
                            parser.state = S.ATTRIB;
                          }
                        }
                        continue;
                      case S.OPEN_TAG_SLASH:
                        if (c === ">") {
                          openTag(parser, true);
                          closeTag(parser);
                        } else {
                          strictFail(
                            parser,
                            "Forward-slash in opening tag not followed by >"
                          );
                          parser.state = S.ATTRIB;
                        }
                        continue;
                      case S.ATTRIB:
                        if (isWhitespace(c)) {
                          continue;
                        } else if (c === ">") {
                          openTag(parser);
                        } else if (c === "/") {
                          parser.state = S.OPEN_TAG_SLASH;
                        } else if (isMatch(nameStart, c)) {
                          parser.attribName = c;
                          parser.attribValue = "";
                          parser.state = S.ATTRIB_NAME;
                        } else {
                          strictFail(parser, "Invalid attribute name");
                        }
                        continue;
                      case S.ATTRIB_NAME:
                        if (c === "=") {
                          parser.state = S.ATTRIB_VALUE;
                        } else if (c === ">") {
                          strictFail(parser, "Attribute without value");
                          parser.attribValue = parser.attribName;
                          attrib(parser);
                          openTag(parser);
                        } else if (isWhitespace(c)) {
                          parser.state = S.ATTRIB_NAME_SAW_WHITE;
                        } else if (isMatch(nameBody, c)) {
                          parser.attribName += c;
                        } else {
                          strictFail(parser, "Invalid attribute name");
                        }
                        continue;
                      case S.ATTRIB_NAME_SAW_WHITE:
                        if (c === "=") {
                          parser.state = S.ATTRIB_VALUE;
                        } else if (isWhitespace(c)) {
                          continue;
                        } else {
                          strictFail(parser, "Attribute without value");
                          parser.tag.attributes[parser.attribName] = "";
                          parser.attribValue = "";
                          emitNode(parser, "onattribute", {
                            name: parser.attribName,
                            value: ""
                          });
                          parser.attribName = "";
                          if (c === ">") {
                            openTag(parser);
                          } else if (isMatch(nameStart, c)) {
                            parser.attribName = c;
                            parser.state = S.ATTRIB_NAME;
                          } else {
                            strictFail(parser, "Invalid attribute name");
                            parser.state = S.ATTRIB;
                          }
                        }
                        continue;
                      case S.ATTRIB_VALUE:
                        if (isWhitespace(c)) {
                          continue;
                        } else if (isQuote(c)) {
                          parser.q = c;
                          parser.state = S.ATTRIB_VALUE_QUOTED;
                        } else {
                          if (!parser.opt.unquotedAttributeValues) {
                            error(parser, "Unquoted attribute value");
                          }
                          parser.state = S.ATTRIB_VALUE_UNQUOTED;
                          parser.attribValue = c;
                        }
                        continue;
                      case S.ATTRIB_VALUE_QUOTED:
                        if (c !== parser.q) {
                          if (c === "&") {
                            parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                          } else {
                            parser.attribValue += c;
                          }
                          continue;
                        }
                        attrib(parser);
                        parser.q = "";
                        parser.state = S.ATTRIB_VALUE_CLOSED;
                        continue;
                      case S.ATTRIB_VALUE_CLOSED:
                        if (isWhitespace(c)) {
                          parser.state = S.ATTRIB;
                        } else if (c === ">") {
                          openTag(parser);
                        } else if (c === "/") {
                          parser.state = S.OPEN_TAG_SLASH;
                        } else if (isMatch(nameStart, c)) {
                          strictFail(parser, "No whitespace between attributes");
                          parser.attribName = c;
                          parser.attribValue = "";
                          parser.state = S.ATTRIB_NAME;
                        } else {
                          strictFail(parser, "Invalid attribute name");
                        }
                        continue;
                      case S.ATTRIB_VALUE_UNQUOTED:
                        if (!isAttribEnd(c)) {
                          if (c === "&") {
                            parser.state = S.ATTRIB_VALUE_ENTITY_U;
                          } else {
                            parser.attribValue += c;
                          }
                          continue;
                        }
                        attrib(parser);
                        if (c === ">") {
                          openTag(parser);
                        } else {
                          parser.state = S.ATTRIB;
                        }
                        continue;
                      case S.CLOSE_TAG:
                        if (!parser.tagName) {
                          if (isWhitespace(c)) {
                            continue;
                          } else if (notMatch(nameStart, c)) {
                            if (parser.script) {
                              parser.script += "</" + c;
                              parser.state = S.SCRIPT;
                            } else {
                              strictFail(parser, "Invalid tagname in closing tag.");
                            }
                          } else {
                            parser.tagName = c;
                          }
                        } else if (c === ">") {
                          closeTag(parser);
                        } else if (isMatch(nameBody, c)) {
                          parser.tagName += c;
                        } else if (parser.script) {
                          parser.script += "</" + parser.tagName + c;
                          parser.tagName = "";
                          parser.state = S.SCRIPT;
                        } else {
                          if (!isWhitespace(c)) {
                            strictFail(parser, "Invalid tagname in closing tag");
                          }
                          parser.state = S.CLOSE_TAG_SAW_WHITE;
                        }
                        continue;
                      case S.CLOSE_TAG_SAW_WHITE:
                        if (isWhitespace(c)) {
                          continue;
                        }
                        if (c === ">") {
                          closeTag(parser);
                        } else {
                          strictFail(parser, "Invalid characters in closing tag");
                        }
                        continue;
                      case S.TEXT_ENTITY:
                      case S.ATTRIB_VALUE_ENTITY_Q:
                      case S.ATTRIB_VALUE_ENTITY_U:
                        var returnState;
                        var buffer;
                        switch (parser.state) {
                          case S.TEXT_ENTITY:
                            returnState = S.TEXT;
                            buffer = "textNode";
                            break;
                          case S.ATTRIB_VALUE_ENTITY_Q:
                            returnState = S.ATTRIB_VALUE_QUOTED;
                            buffer = "attribValue";
                            break;
                          case S.ATTRIB_VALUE_ENTITY_U:
                            returnState = S.ATTRIB_VALUE_UNQUOTED;
                            buffer = "attribValue";
                            break;
                        }
                        if (c === ";") {
                          var parsedEntity = parseEntity(parser);
                          if (parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {
                            parser.entity = "";
                            parser.state = returnState;
                            parser.write(parsedEntity);
                          } else {
                            parser[buffer] += parsedEntity;
                            parser.entity = "";
                            parser.state = returnState;
                          }
                        } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                          parser.entity += c;
                        } else {
                          strictFail(parser, "Invalid character in entity name");
                          parser[buffer] += "&" + parser.entity + c;
                          parser.entity = "";
                          parser.state = returnState;
                        }
                        continue;
                      default: {
                        throw new Error(parser, "Unknown state: " + parser.state);
                      }
                    }
                  }
                  if (parser.position >= parser.bufferCheckPosition) {
                    checkBufferLength(parser);
                  }
                  return parser;
                }
                if (!String.fromCodePoint) {
                  ;
                  (function() {
                    var stringFromCharCode = String.fromCharCode;
                    var floor = Math.floor;
                    var fromCodePoint = function() {
                      var MAX_SIZE = 16384;
                      var codeUnits = [];
                      var highSurrogate;
                      var lowSurrogate;
                      var index = -1;
                      var length = arguments.length;
                      if (!length) {
                        return "";
                      }
                      var result = "";
                      while (++index < length) {
                        var codePoint = Number(arguments[index]);
                        if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                        codePoint < 0 || // not a valid Unicode code point
                        codePoint > 1114111 || // not a valid Unicode code point
                        floor(codePoint) !== codePoint) {
                          throw RangeError("Invalid code point: " + codePoint);
                        }
                        if (codePoint <= 65535) {
                          codeUnits.push(codePoint);
                        } else {
                          codePoint -= 65536;
                          highSurrogate = (codePoint >> 10) + 55296;
                          lowSurrogate = codePoint % 1024 + 56320;
                          codeUnits.push(highSurrogate, lowSurrogate);
                        }
                        if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                          result += stringFromCharCode.apply(null, codeUnits);
                          codeUnits.length = 0;
                        }
                      }
                      return result;
                    };
                    if (Object.defineProperty) {
                      Object.defineProperty(String, "fromCodePoint", {
                        value: fromCodePoint,
                        configurable: true,
                        writable: true
                      });
                    } else {
                      String.fromCodePoint = fromCodePoint;
                    }
                  })();
                }
              })(false ? 0 : exports2);
            },
            /***/
            1909(module2) {
              "use strict";
              module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
            },
            /***/
            2017(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var globalThis2 = __webpack_require__2(7756);
              var uncurryThis = __webpack_require__2(5336);
              var fails = __webpack_require__2(299);
              var aCallable = __webpack_require__2(1078);
              var internalSort = __webpack_require__2(644);
              var ArrayBufferViewCore = __webpack_require__2(4074);
              var FF = __webpack_require__2(5337);
              var IE_OR_EDGE = __webpack_require__2(7383);
              var V8 = __webpack_require__2(2227);
              var WEBKIT = __webpack_require__2(4507);
              var aTypedArray = ArrayBufferViewCore.aTypedArray;
              var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
              var Uint16Array2 = globalThis2.Uint16Array;
              var nativeSort = Uint16Array2 && uncurryThis(Uint16Array2.prototype.sort);
              var ACCEPT_INCORRECT_ARGUMENTS = !!nativeSort && !(fails(function() {
                nativeSort(new Uint16Array2(2), null);
              }) && fails(function() {
                nativeSort(new Uint16Array2(2), {});
              }));
              var STABLE_SORT = !!nativeSort && !fails(function() {
                if (V8) return V8 < 74;
                if (FF) return FF < 67;
                if (IE_OR_EDGE) return true;
                if (WEBKIT) return WEBKIT < 602;
                var array = new Uint16Array2(516);
                var expected = Array(516);
                var index, mod;
                for (index = 0; index < 516; index++) {
                  mod = index % 4;
                  array[index] = 515 - index;
                  expected[index] = index - 2 * mod + 3;
                }
                nativeSort(array, function(a, b) {
                  return (a / 4 | 0) - (b / 4 | 0);
                });
                for (index = 0; index < 516; index++) {
                  if (array[index] !== expected[index]) return true;
                }
              });
              var getSortCompare = function(comparefn) {
                return function(x, y) {
                  if (comparefn !== void 0) return +comparefn(x, y) || 0;
                  if (y !== y) return -1;
                  if (x !== x) return 1;
                  if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
                  return x > y;
                };
              };
              exportTypedArrayMethod("sort", function sort(comparefn) {
                if (comparefn !== void 0) aCallable(comparefn);
                if (STABLE_SORT) return nativeSort(this, comparefn);
                return internalSort(aTypedArray(this), getSortCompare(comparefn));
              }, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);
            },
            /***/
            2022(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              module2.exports = function() {
                if (typeof globalThis === "object") {
                  return globalThis;
                }
                var g;
                try {
                  g = this || new Function("return this")();
                } catch (e) {
                  if (typeof window === "object") {
                    return window;
                  }
                  if (typeof self === "object") {
                    return self;
                  }
                  if (typeof __webpack_require__2.g !== "undefined") {
                    return __webpack_require__2.g;
                  }
                }
                return g;
              }();
            },
            /***/
            2073(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(2858));
                } else {
                }
              })(void 0, function(CryptoJS) {
                CryptoJS.mode.CFB = function() {
                  var CFB = CryptoJS.lib.BlockCipherMode.extend();
                  CFB.Encryptor = CFB.extend({
                    processBlock: function(words, offset) {
                      var cipher = this._cipher;
                      var blockSize = cipher.blockSize;
                      generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
                      this._prevBlock = words.slice(offset, offset + blockSize);
                    }
                  });
                  CFB.Decryptor = CFB.extend({
                    processBlock: function(words, offset) {
                      var cipher = this._cipher;
                      var blockSize = cipher.blockSize;
                      var thisBlock = words.slice(offset, offset + blockSize);
                      generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
                      this._prevBlock = thisBlock;
                    }
                  });
                  function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
                    var keystream;
                    var iv = this._iv;
                    if (iv) {
                      keystream = iv.slice(0);
                      this._iv = void 0;
                    } else {
                      keystream = this._prevBlock;
                    }
                    cipher.encryptBlock(keystream, 0);
                    for (var i = 0; i < blockSize; i++) {
                      words[offset + i] ^= keystream[i];
                    }
                  }
                  return CFB;
                }();
                return CryptoJS.mode.CFB;
              });
            },
            /***/
            2091(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var isObject = __webpack_require__2(3598);
              var $String = String;
              var $TypeError = TypeError;
              module2.exports = function(argument) {
                if (isObject(argument)) return argument;
                throw new $TypeError($String(argument) + " is not an object");
              };
            },
            /***/
            2119(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var trunc = __webpack_require__2(2537);
              module2.exports = function(argument) {
                var number = +argument;
                return number !== number || number === 0 ? 0 : trunc(number);
              };
            },
            /***/
            2167(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var ERR_STREAM_PREMATURE_CLOSE = __webpack_require__2(3797).F.ERR_STREAM_PREMATURE_CLOSE;
              function once(callback) {
                var called = false;
                return function() {
                  if (called) return;
                  called = true;
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }
                  callback.apply(this, args);
                };
              }
              function noop() {
              }
              function isRequest(stream) {
                return stream.setHeader && typeof stream.abort === "function";
              }
              function eos(stream, opts, callback) {
                if (typeof opts === "function") return eos(stream, null, opts);
                if (!opts) opts = {};
                callback = once(callback || noop);
                var readable = opts.readable || opts.readable !== false && stream.readable;
                var writable = opts.writable || opts.writable !== false && stream.writable;
                var onlegacyfinish = function onlegacyfinish2() {
                  if (!stream.writable) onfinish();
                };
                var writableEnded = stream._writableState && stream._writableState.finished;
                var onfinish = function onfinish2() {
                  writable = false;
                  writableEnded = true;
                  if (!readable) callback.call(stream);
                };
                var readableEnded = stream._readableState && stream._readableState.endEmitted;
                var onend = function onend2() {
                  readable = false;
                  readableEnded = true;
                  if (!writable) callback.call(stream);
                };
                var onerror = function onerror2(err) {
                  callback.call(stream, err);
                };
                var onclose = function onclose2() {
                  var err;
                  if (readable && !readableEnded) {
                    if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
                    return callback.call(stream, err);
                  }
                  if (writable && !writableEnded) {
                    if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
                    return callback.call(stream, err);
                  }
                };
                var onrequest = function onrequest2() {
                  stream.req.on("finish", onfinish);
                };
                if (isRequest(stream)) {
                  stream.on("complete", onfinish);
                  stream.on("abort", onclose);
                  if (stream.req) onrequest();
                  else stream.on("request", onrequest);
                } else if (writable && !stream._writableState) {
                  stream.on("end", onlegacyfinish);
                  stream.on("close", onlegacyfinish);
                }
                stream.on("end", onend);
                stream.on("finish", onfinish);
                if (opts.error !== false) stream.on("error", onerror);
                stream.on("close", onclose);
                return function() {
                  stream.removeListener("complete", onfinish);
                  stream.removeListener("abort", onclose);
                  stream.removeListener("request", onrequest);
                  if (stream.req) stream.req.removeListener("finish", onfinish);
                  stream.removeListener("end", onlegacyfinish);
                  stream.removeListener("close", onlegacyfinish);
                  stream.removeListener("finish", onfinish);
                  stream.removeListener("end", onend);
                  stream.removeListener("error", onerror);
                  stream.removeListener("close", onclose);
                };
              }
              module2.exports = eos;
            },
            /***/
            2210(__unused_webpack_module, exports2) {
              function PrefixCodeRange(offset, nbits) {
                this.offset = offset;
                this.nbits = nbits;
              }
              exports2.kBlockLengthPrefixCode = [
                new PrefixCodeRange(1, 2),
                new PrefixCodeRange(5, 2),
                new PrefixCodeRange(9, 2),
                new PrefixCodeRange(13, 2),
                new PrefixCodeRange(17, 3),
                new PrefixCodeRange(25, 3),
                new PrefixCodeRange(33, 3),
                new PrefixCodeRange(41, 3),
                new PrefixCodeRange(49, 4),
                new PrefixCodeRange(65, 4),
                new PrefixCodeRange(81, 4),
                new PrefixCodeRange(97, 4),
                new PrefixCodeRange(113, 5),
                new PrefixCodeRange(145, 5),
                new PrefixCodeRange(177, 5),
                new PrefixCodeRange(209, 5),
                new PrefixCodeRange(241, 6),
                new PrefixCodeRange(305, 6),
                new PrefixCodeRange(369, 7),
                new PrefixCodeRange(497, 8),
                new PrefixCodeRange(753, 9),
                new PrefixCodeRange(1265, 10),
                new PrefixCodeRange(2289, 11),
                new PrefixCodeRange(4337, 12),
                new PrefixCodeRange(8433, 13),
                new PrefixCodeRange(16625, 24)
              ];
              exports2.kInsertLengthPrefixCode = [
                new PrefixCodeRange(0, 0),
                new PrefixCodeRange(1, 0),
                new PrefixCodeRange(2, 0),
                new PrefixCodeRange(3, 0),
                new PrefixCodeRange(4, 0),
                new PrefixCodeRange(5, 0),
                new PrefixCodeRange(6, 1),
                new PrefixCodeRange(8, 1),
                new PrefixCodeRange(10, 2),
                new PrefixCodeRange(14, 2),
                new PrefixCodeRange(18, 3),
                new PrefixCodeRange(26, 3),
                new PrefixCodeRange(34, 4),
                new PrefixCodeRange(50, 4),
                new PrefixCodeRange(66, 5),
                new PrefixCodeRange(98, 5),
                new PrefixCodeRange(130, 6),
                new PrefixCodeRange(194, 7),
                new PrefixCodeRange(322, 8),
                new PrefixCodeRange(578, 9),
                new PrefixCodeRange(1090, 10),
                new PrefixCodeRange(2114, 12),
                new PrefixCodeRange(6210, 14),
                new PrefixCodeRange(22594, 24)
              ];
              exports2.kCopyLengthPrefixCode = [
                new PrefixCodeRange(2, 0),
                new PrefixCodeRange(3, 0),
                new PrefixCodeRange(4, 0),
                new PrefixCodeRange(5, 0),
                new PrefixCodeRange(6, 0),
                new PrefixCodeRange(7, 0),
                new PrefixCodeRange(8, 0),
                new PrefixCodeRange(9, 0),
                new PrefixCodeRange(10, 1),
                new PrefixCodeRange(12, 1),
                new PrefixCodeRange(14, 2),
                new PrefixCodeRange(18, 2),
                new PrefixCodeRange(22, 3),
                new PrefixCodeRange(30, 3),
                new PrefixCodeRange(38, 4),
                new PrefixCodeRange(54, 4),
                new PrefixCodeRange(70, 5),
                new PrefixCodeRange(102, 5),
                new PrefixCodeRange(134, 6),
                new PrefixCodeRange(198, 7),
                new PrefixCodeRange(326, 8),
                new PrefixCodeRange(582, 9),
                new PrefixCodeRange(1094, 10),
                new PrefixCodeRange(2118, 24)
              ];
              exports2.kInsertRangeLut = [
                0,
                0,
                8,
                8,
                0,
                16,
                8,
                16,
                16
              ];
              exports2.kCopyRangeLut = [
                0,
                8,
                0,
                8,
                16,
                0,
                16,
                8,
                16
              ];
            },
            /***/
            2227(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var globalThis2 = __webpack_require__2(7756);
              var userAgent = __webpack_require__2(8115);
              var process = globalThis2.process;
              var Deno = globalThis2.Deno;
              var versions = process && process.versions || Deno && Deno.version;
              var v8 = versions && versions.v8;
              var match, version;
              if (v8) {
                match = v8.split(".");
                version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
              }
              if (!version && userAgent) {
                match = userAgent.match(/Edge\/(\d+)/);
                if (!match || match[1] >= 74) {
                  match = userAgent.match(/Chrome\/(\d+)/);
                  if (match) version = +match[1];
                }
              }
              module2.exports = version;
            },
            /***/
            2269(__unused_webpack_module, exports2, __webpack_require__2) {
              "use strict";
              var utils = __webpack_require__2(2519);
              var adler32 = __webpack_require__2(6911);
              var crc32 = __webpack_require__2(9049);
              var inflate_fast = __webpack_require__2(6395);
              var inflate_table = __webpack_require__2(2920);
              var CODES = 0;
              var LENS = 1;
              var DISTS = 2;
              var Z_FINISH = 4;
              var Z_BLOCK = 5;
              var Z_TREES = 6;
              var Z_OK = 0;
              var Z_STREAM_END = 1;
              var Z_NEED_DICT = 2;
              var Z_STREAM_ERROR = -2;
              var Z_DATA_ERROR = -3;
              var Z_MEM_ERROR = -4;
              var Z_BUF_ERROR = -5;
              var Z_DEFLATED = 8;
              var HEAD = 1;
              var FLAGS = 2;
              var TIME = 3;
              var OS = 4;
              var EXLEN = 5;
              var EXTRA = 6;
              var NAME = 7;
              var COMMENT = 8;
              var HCRC = 9;
              var DICTID = 10;
              var DICT = 11;
              var TYPE = 12;
              var TYPEDO = 13;
              var STORED = 14;
              var COPY_ = 15;
              var COPY = 16;
              var TABLE = 17;
              var LENLENS = 18;
              var CODELENS = 19;
              var LEN_ = 20;
              var LEN = 21;
              var LENEXT = 22;
              var DIST = 23;
              var DISTEXT = 24;
              var MATCH = 25;
              var LIT = 26;
              var CHECK = 27;
              var LENGTH = 28;
              var DONE = 29;
              var BAD = 30;
              var MEM = 31;
              var SYNC = 32;
              var ENOUGH_LENS = 852;
              var ENOUGH_DISTS = 592;
              var MAX_WBITS = 15;
              var DEF_WBITS = MAX_WBITS;
              function zswap32(q) {
                return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
              }
              function InflateState() {
                this.mode = 0;
                this.last = false;
                this.wrap = 0;
                this.havedict = false;
                this.flags = 0;
                this.dmax = 0;
                this.check = 0;
                this.total = 0;
                this.head = null;
                this.wbits = 0;
                this.wsize = 0;
                this.whave = 0;
                this.wnext = 0;
                this.window = null;
                this.hold = 0;
                this.bits = 0;
                this.length = 0;
                this.offset = 0;
                this.extra = 0;
                this.lencode = null;
                this.distcode = null;
                this.lenbits = 0;
                this.distbits = 0;
                this.ncode = 0;
                this.nlen = 0;
                this.ndist = 0;
                this.have = 0;
                this.next = null;
                this.lens = new utils.Buf16(320);
                this.work = new utils.Buf16(288);
                this.lendyn = null;
                this.distdyn = null;
                this.sane = 0;
                this.back = 0;
                this.was = 0;
              }
              function inflateResetKeep(strm) {
                var state;
                if (!strm || !strm.state) {
                  return Z_STREAM_ERROR;
                }
                state = strm.state;
                strm.total_in = strm.total_out = state.total = 0;
                strm.msg = "";
                if (state.wrap) {
                  strm.adler = state.wrap & 1;
                }
                state.mode = HEAD;
                state.last = 0;
                state.havedict = 0;
                state.dmax = 32768;
                state.head = null;
                state.hold = 0;
                state.bits = 0;
                state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
                state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
                state.sane = 1;
                state.back = -1;
                return Z_OK;
              }
              function inflateReset(strm) {
                var state;
                if (!strm || !strm.state) {
                  return Z_STREAM_ERROR;
                }
                state = strm.state;
                state.wsize = 0;
                state.whave = 0;
                state.wnext = 0;
                return inflateResetKeep(strm);
              }
              function inflateReset2(strm, windowBits) {
                var wrap;
                var state;
                if (!strm || !strm.state) {
                  return Z_STREAM_ERROR;
                }
                state = strm.state;
                if (windowBits < 0) {
                  wrap = 0;
                  windowBits = -windowBits;
                } else {
                  wrap = (windowBits >> 4) + 1;
                  if (windowBits < 48) {
                    windowBits &= 15;
                  }
                }
                if (windowBits && (windowBits < 8 || windowBits > 15)) {
                  return Z_STREAM_ERROR;
                }
                if (state.window !== null && state.wbits !== windowBits) {
                  state.window = null;
                }
                state.wrap = wrap;
                state.wbits = windowBits;
                return inflateReset(strm);
              }
              function inflateInit2(strm, windowBits) {
                var ret;
                var state;
                if (!strm) {
                  return Z_STREAM_ERROR;
                }
                state = new InflateState();
                strm.state = state;
                state.window = null;
                ret = inflateReset2(strm, windowBits);
                if (ret !== Z_OK) {
                  strm.state = null;
                }
                return ret;
              }
              function inflateInit(strm) {
                return inflateInit2(strm, DEF_WBITS);
              }
              var virgin = true;
              var lenfix, distfix;
              function fixedtables(state) {
                if (virgin) {
                  var sym;
                  lenfix = new utils.Buf32(512);
                  distfix = new utils.Buf32(32);
                  sym = 0;
                  while (sym < 144) {
                    state.lens[sym++] = 8;
                  }
                  while (sym < 256) {
                    state.lens[sym++] = 9;
                  }
                  while (sym < 280) {
                    state.lens[sym++] = 7;
                  }
                  while (sym < 288) {
                    state.lens[sym++] = 8;
                  }
                  inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
                  sym = 0;
                  while (sym < 32) {
                    state.lens[sym++] = 5;
                  }
                  inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
                  virgin = false;
                }
                state.lencode = lenfix;
                state.lenbits = 9;
                state.distcode = distfix;
                state.distbits = 5;
              }
              function updatewindow(strm, src, end, copy) {
                var dist;
                var state = strm.state;
                if (state.window === null) {
                  state.wsize = 1 << state.wbits;
                  state.wnext = 0;
                  state.whave = 0;
                  state.window = new utils.Buf8(state.wsize);
                }
                if (copy >= state.wsize) {
                  utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
                  state.wnext = 0;
                  state.whave = state.wsize;
                } else {
                  dist = state.wsize - state.wnext;
                  if (dist > copy) {
                    dist = copy;
                  }
                  utils.arraySet(state.window, src, end - copy, dist, state.wnext);
                  copy -= dist;
                  if (copy) {
                    utils.arraySet(state.window, src, end - copy, copy, 0);
                    state.wnext = copy;
                    state.whave = state.wsize;
                  } else {
                    state.wnext += dist;
                    if (state.wnext === state.wsize) {
                      state.wnext = 0;
                    }
                    if (state.whave < state.wsize) {
                      state.whave += dist;
                    }
                  }
                }
                return 0;
              }
              function inflate(strm, flush) {
                var state;
                var input, output;
                var next;
                var put;
                var have, left;
                var hold;
                var bits;
                var _in, _out;
                var copy;
                var from;
                var from_source;
                var here = 0;
                var here_bits, here_op, here_val;
                var last_bits, last_op, last_val;
                var len;
                var ret;
                var hbuf = new utils.Buf8(4);
                var opts;
                var n;
                var order = (
                  /* permutation of code lengths */
                  [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
                );
                if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
                  return Z_STREAM_ERROR;
                }
                state = strm.state;
                if (state.mode === TYPE) {
                  state.mode = TYPEDO;
                }
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                _in = have;
                _out = left;
                ret = Z_OK;
                inf_leave:
                  for (; ; ) {
                    switch (state.mode) {
                      case HEAD:
                        if (state.wrap === 0) {
                          state.mode = TYPEDO;
                          break;
                        }
                        while (bits < 16) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        if (state.wrap & 2 && hold === 35615) {
                          state.check = 0;
                          hbuf[0] = hold & 255;
                          hbuf[1] = hold >>> 8 & 255;
                          state.check = crc32(state.check, hbuf, 2, 0);
                          hold = 0;
                          bits = 0;
                          state.mode = FLAGS;
                          break;
                        }
                        state.flags = 0;
                        if (state.head) {
                          state.head.done = false;
                        }
                        if (!(state.wrap & 1) || /* check if zlib header allowed */
                        (((hold & 255) << 8) + (hold >> 8)) % 31) {
                          strm.msg = "incorrect header check";
                          state.mode = BAD;
                          break;
                        }
                        if ((hold & 15) !== Z_DEFLATED) {
                          strm.msg = "unknown compression method";
                          state.mode = BAD;
                          break;
                        }
                        hold >>>= 4;
                        bits -= 4;
                        len = (hold & 15) + 8;
                        if (state.wbits === 0) {
                          state.wbits = len;
                        } else if (len > state.wbits) {
                          strm.msg = "invalid window size";
                          state.mode = BAD;
                          break;
                        }
                        state.dmax = 1 << len;
                        strm.adler = state.check = 1;
                        state.mode = hold & 512 ? DICTID : TYPE;
                        hold = 0;
                        bits = 0;
                        break;
                      case FLAGS:
                        while (bits < 16) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        state.flags = hold;
                        if ((state.flags & 255) !== Z_DEFLATED) {
                          strm.msg = "unknown compression method";
                          state.mode = BAD;
                          break;
                        }
                        if (state.flags & 57344) {
                          strm.msg = "unknown header flags set";
                          state.mode = BAD;
                          break;
                        }
                        if (state.head) {
                          state.head.text = hold >> 8 & 1;
                        }
                        if (state.flags & 512) {
                          hbuf[0] = hold & 255;
                          hbuf[1] = hold >>> 8 & 255;
                          state.check = crc32(state.check, hbuf, 2, 0);
                        }
                        hold = 0;
                        bits = 0;
                        state.mode = TIME;
                      case TIME:
                        while (bits < 32) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        if (state.head) {
                          state.head.time = hold;
                        }
                        if (state.flags & 512) {
                          hbuf[0] = hold & 255;
                          hbuf[1] = hold >>> 8 & 255;
                          hbuf[2] = hold >>> 16 & 255;
                          hbuf[3] = hold >>> 24 & 255;
                          state.check = crc32(state.check, hbuf, 4, 0);
                        }
                        hold = 0;
                        bits = 0;
                        state.mode = OS;
                      case OS:
                        while (bits < 16) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        if (state.head) {
                          state.head.xflags = hold & 255;
                          state.head.os = hold >> 8;
                        }
                        if (state.flags & 512) {
                          hbuf[0] = hold & 255;
                          hbuf[1] = hold >>> 8 & 255;
                          state.check = crc32(state.check, hbuf, 2, 0);
                        }
                        hold = 0;
                        bits = 0;
                        state.mode = EXLEN;
                      case EXLEN:
                        if (state.flags & 1024) {
                          while (bits < 16) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          state.length = hold;
                          if (state.head) {
                            state.head.extra_len = hold;
                          }
                          if (state.flags & 512) {
                            hbuf[0] = hold & 255;
                            hbuf[1] = hold >>> 8 & 255;
                            state.check = crc32(state.check, hbuf, 2, 0);
                          }
                          hold = 0;
                          bits = 0;
                        } else if (state.head) {
                          state.head.extra = null;
                        }
                        state.mode = EXTRA;
                      case EXTRA:
                        if (state.flags & 1024) {
                          copy = state.length;
                          if (copy > have) {
                            copy = have;
                          }
                          if (copy) {
                            if (state.head) {
                              len = state.head.extra_len - state.length;
                              if (!state.head.extra) {
                                state.head.extra = new Array(state.head.extra_len);
                              }
                              utils.arraySet(
                                state.head.extra,
                                input,
                                next,
                                // extra field is limited to 65536 bytes
                                // - no need for additional size check
                                copy,
                                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                                len
                              );
                            }
                            if (state.flags & 512) {
                              state.check = crc32(state.check, input, copy, next);
                            }
                            have -= copy;
                            next += copy;
                            state.length -= copy;
                          }
                          if (state.length) {
                            break inf_leave;
                          }
                        }
                        state.length = 0;
                        state.mode = NAME;
                      case NAME:
                        if (state.flags & 2048) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          copy = 0;
                          do {
                            len = input[next + copy++];
                            if (state.head && len && state.length < 65536) {
                              state.head.name += String.fromCharCode(len);
                            }
                          } while (len && copy < have);
                          if (state.flags & 512) {
                            state.check = crc32(state.check, input, copy, next);
                          }
                          have -= copy;
                          next += copy;
                          if (len) {
                            break inf_leave;
                          }
                        } else if (state.head) {
                          state.head.name = null;
                        }
                        state.length = 0;
                        state.mode = COMMENT;
                      case COMMENT:
                        if (state.flags & 4096) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          copy = 0;
                          do {
                            len = input[next + copy++];
                            if (state.head && len && state.length < 65536) {
                              state.head.comment += String.fromCharCode(len);
                            }
                          } while (len && copy < have);
                          if (state.flags & 512) {
                            state.check = crc32(state.check, input, copy, next);
                          }
                          have -= copy;
                          next += copy;
                          if (len) {
                            break inf_leave;
                          }
                        } else if (state.head) {
                          state.head.comment = null;
                        }
                        state.mode = HCRC;
                      case HCRC:
                        if (state.flags & 512) {
                          while (bits < 16) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          if (hold !== (state.check & 65535)) {
                            strm.msg = "header crc mismatch";
                            state.mode = BAD;
                            break;
                          }
                          hold = 0;
                          bits = 0;
                        }
                        if (state.head) {
                          state.head.hcrc = state.flags >> 9 & 1;
                          state.head.done = true;
                        }
                        strm.adler = state.check = 0;
                        state.mode = TYPE;
                        break;
                      case DICTID:
                        while (bits < 32) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        strm.adler = state.check = zswap32(hold);
                        hold = 0;
                        bits = 0;
                        state.mode = DICT;
                      case DICT:
                        if (state.havedict === 0) {
                          strm.next_out = put;
                          strm.avail_out = left;
                          strm.next_in = next;
                          strm.avail_in = have;
                          state.hold = hold;
                          state.bits = bits;
                          return Z_NEED_DICT;
                        }
                        strm.adler = state.check = 1;
                        state.mode = TYPE;
                      case TYPE:
                        if (flush === Z_BLOCK || flush === Z_TREES) {
                          break inf_leave;
                        }
                      case TYPEDO:
                        if (state.last) {
                          hold >>>= bits & 7;
                          bits -= bits & 7;
                          state.mode = CHECK;
                          break;
                        }
                        while (bits < 3) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        state.last = hold & 1;
                        hold >>>= 1;
                        bits -= 1;
                        switch (hold & 3) {
                          case 0:
                            state.mode = STORED;
                            break;
                          case 1:
                            fixedtables(state);
                            state.mode = LEN_;
                            if (flush === Z_TREES) {
                              hold >>>= 2;
                              bits -= 2;
                              break inf_leave;
                            }
                            break;
                          case 2:
                            state.mode = TABLE;
                            break;
                          case 3:
                            strm.msg = "invalid block type";
                            state.mode = BAD;
                        }
                        hold >>>= 2;
                        bits -= 2;
                        break;
                      case STORED:
                        hold >>>= bits & 7;
                        bits -= bits & 7;
                        while (bits < 32) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                          strm.msg = "invalid stored block lengths";
                          state.mode = BAD;
                          break;
                        }
                        state.length = hold & 65535;
                        hold = 0;
                        bits = 0;
                        state.mode = COPY_;
                        if (flush === Z_TREES) {
                          break inf_leave;
                        }
                      case COPY_:
                        state.mode = COPY;
                      case COPY:
                        copy = state.length;
                        if (copy) {
                          if (copy > have) {
                            copy = have;
                          }
                          if (copy > left) {
                            copy = left;
                          }
                          if (copy === 0) {
                            break inf_leave;
                          }
                          utils.arraySet(output, input, next, copy, put);
                          have -= copy;
                          next += copy;
                          left -= copy;
                          put += copy;
                          state.length -= copy;
                          break;
                        }
                        state.mode = TYPE;
                        break;
                      case TABLE:
                        while (bits < 14) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        state.nlen = (hold & 31) + 257;
                        hold >>>= 5;
                        bits -= 5;
                        state.ndist = (hold & 31) + 1;
                        hold >>>= 5;
                        bits -= 5;
                        state.ncode = (hold & 15) + 4;
                        hold >>>= 4;
                        bits -= 4;
                        if (state.nlen > 286 || state.ndist > 30) {
                          strm.msg = "too many length or distance symbols";
                          state.mode = BAD;
                          break;
                        }
                        state.have = 0;
                        state.mode = LENLENS;
                      case LENLENS:
                        while (state.have < state.ncode) {
                          while (bits < 3) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          state.lens[order[state.have++]] = hold & 7;
                          hold >>>= 3;
                          bits -= 3;
                        }
                        while (state.have < 19) {
                          state.lens[order[state.have++]] = 0;
                        }
                        state.lencode = state.lendyn;
                        state.lenbits = 7;
                        opts = { bits: state.lenbits };
                        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                        state.lenbits = opts.bits;
                        if (ret) {
                          strm.msg = "invalid code lengths set";
                          state.mode = BAD;
                          break;
                        }
                        state.have = 0;
                        state.mode = CODELENS;
                      case CODELENS:
                        while (state.have < state.nlen + state.ndist) {
                          for (; ; ) {
                            here = state.lencode[hold & (1 << state.lenbits) - 1];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (here_bits <= bits) {
                              break;
                            }
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          if (here_val < 16) {
                            hold >>>= here_bits;
                            bits -= here_bits;
                            state.lens[state.have++] = here_val;
                          } else {
                            if (here_val === 16) {
                              n = here_bits + 2;
                              while (bits < n) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                              }
                              hold >>>= here_bits;
                              bits -= here_bits;
                              if (state.have === 0) {
                                strm.msg = "invalid bit length repeat";
                                state.mode = BAD;
                                break;
                              }
                              len = state.lens[state.have - 1];
                              copy = 3 + (hold & 3);
                              hold >>>= 2;
                              bits -= 2;
                            } else if (here_val === 17) {
                              n = here_bits + 3;
                              while (bits < n) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                              }
                              hold >>>= here_bits;
                              bits -= here_bits;
                              len = 0;
                              copy = 3 + (hold & 7);
                              hold >>>= 3;
                              bits -= 3;
                            } else {
                              n = here_bits + 7;
                              while (bits < n) {
                                if (have === 0) {
                                  break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                              }
                              hold >>>= here_bits;
                              bits -= here_bits;
                              len = 0;
                              copy = 11 + (hold & 127);
                              hold >>>= 7;
                              bits -= 7;
                            }
                            if (state.have + copy > state.nlen + state.ndist) {
                              strm.msg = "invalid bit length repeat";
                              state.mode = BAD;
                              break;
                            }
                            while (copy--) {
                              state.lens[state.have++] = len;
                            }
                          }
                        }
                        if (state.mode === BAD) {
                          break;
                        }
                        if (state.lens[256] === 0) {
                          strm.msg = "invalid code -- missing end-of-block";
                          state.mode = BAD;
                          break;
                        }
                        state.lenbits = 9;
                        opts = { bits: state.lenbits };
                        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                        state.lenbits = opts.bits;
                        if (ret) {
                          strm.msg = "invalid literal/lengths set";
                          state.mode = BAD;
                          break;
                        }
                        state.distbits = 6;
                        state.distcode = state.distdyn;
                        opts = { bits: state.distbits };
                        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                        state.distbits = opts.bits;
                        if (ret) {
                          strm.msg = "invalid distances set";
                          state.mode = BAD;
                          break;
                        }
                        state.mode = LEN_;
                        if (flush === Z_TREES) {
                          break inf_leave;
                        }
                      case LEN_:
                        state.mode = LEN;
                      case LEN:
                        if (have >= 6 && left >= 258) {
                          strm.next_out = put;
                          strm.avail_out = left;
                          strm.next_in = next;
                          strm.avail_in = have;
                          state.hold = hold;
                          state.bits = bits;
                          inflate_fast(strm, _out);
                          put = strm.next_out;
                          output = strm.output;
                          left = strm.avail_out;
                          next = strm.next_in;
                          input = strm.input;
                          have = strm.avail_in;
                          hold = state.hold;
                          bits = state.bits;
                          if (state.mode === TYPE) {
                            state.back = -1;
                          }
                          break;
                        }
                        state.back = 0;
                        for (; ; ) {
                          here = state.lencode[hold & (1 << state.lenbits) - 1];
                          here_bits = here >>> 24;
                          here_op = here >>> 16 & 255;
                          here_val = here & 65535;
                          if (here_bits <= bits) {
                            break;
                          }
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        if (here_op && (here_op & 240) === 0) {
                          last_bits = here_bits;
                          last_op = here_op;
                          last_val = here_val;
                          for (; ; ) {
                            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (last_bits + here_bits <= bits) {
                              break;
                            }
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          hold >>>= last_bits;
                          bits -= last_bits;
                          state.back += last_bits;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        state.back += here_bits;
                        state.length = here_val;
                        if (here_op === 0) {
                          state.mode = LIT;
                          break;
                        }
                        if (here_op & 32) {
                          state.back = -1;
                          state.mode = TYPE;
                          break;
                        }
                        if (here_op & 64) {
                          strm.msg = "invalid literal/length code";
                          state.mode = BAD;
                          break;
                        }
                        state.extra = here_op & 15;
                        state.mode = LENEXT;
                      case LENEXT:
                        if (state.extra) {
                          n = state.extra;
                          while (bits < n) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          state.length += hold & (1 << state.extra) - 1;
                          hold >>>= state.extra;
                          bits -= state.extra;
                          state.back += state.extra;
                        }
                        state.was = state.length;
                        state.mode = DIST;
                      case DIST:
                        for (; ; ) {
                          here = state.distcode[hold & (1 << state.distbits) - 1];
                          here_bits = here >>> 24;
                          here_op = here >>> 16 & 255;
                          here_val = here & 65535;
                          if (here_bits <= bits) {
                            break;
                          }
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        if ((here_op & 240) === 0) {
                          last_bits = here_bits;
                          last_op = here_op;
                          last_val = here_val;
                          for (; ; ) {
                            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (last_bits + here_bits <= bits) {
                              break;
                            }
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          hold >>>= last_bits;
                          bits -= last_bits;
                          state.back += last_bits;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        state.back += here_bits;
                        if (here_op & 64) {
                          strm.msg = "invalid distance code";
                          state.mode = BAD;
                          break;
                        }
                        state.offset = here_val;
                        state.extra = here_op & 15;
                        state.mode = DISTEXT;
                      case DISTEXT:
                        if (state.extra) {
                          n = state.extra;
                          while (bits < n) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          state.offset += hold & (1 << state.extra) - 1;
                          hold >>>= state.extra;
                          bits -= state.extra;
                          state.back += state.extra;
                        }
                        if (state.offset > state.dmax) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break;
                        }
                        state.mode = MATCH;
                      case MATCH:
                        if (left === 0) {
                          break inf_leave;
                        }
                        copy = _out - left;
                        if (state.offset > copy) {
                          copy = state.offset - copy;
                          if (copy > state.whave) {
                            if (state.sane) {
                              strm.msg = "invalid distance too far back";
                              state.mode = BAD;
                              break;
                            }
                          }
                          if (copy > state.wnext) {
                            copy -= state.wnext;
                            from = state.wsize - copy;
                          } else {
                            from = state.wnext - copy;
                          }
                          if (copy > state.length) {
                            copy = state.length;
                          }
                          from_source = state.window;
                        } else {
                          from_source = output;
                          from = put - state.offset;
                          copy = state.length;
                        }
                        if (copy > left) {
                          copy = left;
                        }
                        left -= copy;
                        state.length -= copy;
                        do {
                          output[put++] = from_source[from++];
                        } while (--copy);
                        if (state.length === 0) {
                          state.mode = LEN;
                        }
                        break;
                      case LIT:
                        if (left === 0) {
                          break inf_leave;
                        }
                        output[put++] = state.length;
                        left--;
                        state.mode = LEN;
                        break;
                      case CHECK:
                        if (state.wrap) {
                          while (bits < 32) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold |= input[next++] << bits;
                            bits += 8;
                          }
                          _out -= left;
                          strm.total_out += _out;
                          state.total += _out;
                          if (_out) {
                            strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                            state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                          }
                          _out = left;
                          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                            strm.msg = "incorrect data check";
                            state.mode = BAD;
                            break;
                          }
                          hold = 0;
                          bits = 0;
                        }
                        state.mode = LENGTH;
                      case LENGTH:
                        if (state.wrap && state.flags) {
                          while (bits < 32) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          if (hold !== (state.total & 4294967295)) {
                            strm.msg = "incorrect length check";
                            state.mode = BAD;
                            break;
                          }
                          hold = 0;
                          bits = 0;
                        }
                        state.mode = DONE;
                      case DONE:
                        ret = Z_STREAM_END;
                        break inf_leave;
                      case BAD:
                        ret = Z_DATA_ERROR;
                        break inf_leave;
                      case MEM:
                        return Z_MEM_ERROR;
                      case SYNC:
                      default:
                        return Z_STREAM_ERROR;
                    }
                  }
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
                  if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
                    state.mode = MEM;
                    return Z_MEM_ERROR;
                  }
                }
                _in -= strm.avail_in;
                _out -= strm.avail_out;
                strm.total_in += _in;
                strm.total_out += _out;
                state.total += _out;
                if (state.wrap && _out) {
                  strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
                }
                strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
                if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
                  ret = Z_BUF_ERROR;
                }
                return ret;
              }
              function inflateEnd(strm) {
                if (!strm || !strm.state) {
                  return Z_STREAM_ERROR;
                }
                var state = strm.state;
                if (state.window) {
                  state.window = null;
                }
                strm.state = null;
                return Z_OK;
              }
              function inflateGetHeader(strm, head) {
                var state;
                if (!strm || !strm.state) {
                  return Z_STREAM_ERROR;
                }
                state = strm.state;
                if ((state.wrap & 2) === 0) {
                  return Z_STREAM_ERROR;
                }
                state.head = head;
                head.done = false;
                return Z_OK;
              }
              function inflateSetDictionary(strm, dictionary) {
                var dictLength = dictionary.length;
                var state;
                var dictid;
                var ret;
                if (!strm || !strm.state) {
                  return Z_STREAM_ERROR;
                }
                state = strm.state;
                if (state.wrap !== 0 && state.mode !== DICT) {
                  return Z_STREAM_ERROR;
                }
                if (state.mode === DICT) {
                  dictid = 1;
                  dictid = adler32(dictid, dictionary, dictLength, 0);
                  if (dictid !== state.check) {
                    return Z_DATA_ERROR;
                  }
                }
                ret = updatewindow(strm, dictionary, dictLength, dictLength);
                if (ret) {
                  state.mode = MEM;
                  return Z_MEM_ERROR;
                }
                state.havedict = 1;
                return Z_OK;
              }
              exports2.inflateReset = inflateReset;
              exports2.inflateReset2 = inflateReset2;
              exports2.inflateResetKeep = inflateResetKeep;
              exports2.inflateInit = inflateInit;
              exports2.inflateInit2 = inflateInit2;
              exports2.inflate = inflate;
              exports2.inflateEnd = inflateEnd;
              exports2.inflateGetHeader = inflateGetHeader;
              exports2.inflateSetDictionary = inflateSetDictionary;
              exports2.inflateInfo = "pako inflate (from Nodeca project)";
            },
            /***/
            2283(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var globalThis2 = __webpack_require__2(7756);
              var isObject = __webpack_require__2(3598);
              var document2 = globalThis2.document;
              var EXISTS = isObject(document2) && isObject(document2.createElement);
              module2.exports = function(it) {
                return EXISTS ? document2.createElement(it) : {};
              };
            },
            /***/
            2333(__unused_webpack_module, exports2, __webpack_require__2) {
              "use strict";
              var DESCRIPTORS = __webpack_require__2(5144);
              var IE8_DOM_DEFINE = __webpack_require__2(7657);
              var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__2(2538);
              var anObject = __webpack_require__2(2091);
              var toPropertyKey = __webpack_require__2(1413);
              var $TypeError = TypeError;
              var $defineProperty = Object.defineProperty;
              var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
              var ENUMERABLE = "enumerable";
              var CONFIGURABLE = "configurable";
              var WRITABLE = "writable";
              exports2.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
                anObject(O);
                P = toPropertyKey(P);
                anObject(Attributes);
                if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
                  var current = $getOwnPropertyDescriptor(O, P);
                  if (current && current[WRITABLE]) {
                    O[P] = Attributes.value;
                    Attributes = {
                      configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
                      enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
                      writable: false
                    };
                  }
                }
                return $defineProperty(O, P, Attributes);
              } : $defineProperty : function defineProperty(O, P, Attributes) {
                anObject(O);
                P = toPropertyKey(P);
                anObject(Attributes);
                if (IE8_DOM_DEFINE) try {
                  return $defineProperty(O, P, Attributes);
                } catch (error) {
                }
                if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
                if ("value" in Attributes) O[P] = Attributes.value;
                return O;
              };
            },
            /***/
            2367(__unused_webpack_module, exports2, __webpack_require__2) {
              "use strict";
              var utils = __webpack_require__2(2519);
              var Z_FIXED = 4;
              var Z_BINARY = 0;
              var Z_TEXT = 1;
              var Z_UNKNOWN = 2;
              function zero(buf) {
                var len = buf.length;
                while (--len >= 0) {
                  buf[len] = 0;
                }
              }
              var STORED_BLOCK = 0;
              var STATIC_TREES = 1;
              var DYN_TREES = 2;
              var MIN_MATCH = 3;
              var MAX_MATCH = 258;
              var LENGTH_CODES = 29;
              var LITERALS = 256;
              var L_CODES = LITERALS + 1 + LENGTH_CODES;
              var D_CODES = 30;
              var BL_CODES = 19;
              var HEAP_SIZE = 2 * L_CODES + 1;
              var MAX_BITS = 15;
              var Buf_size = 16;
              var MAX_BL_BITS = 7;
              var END_BLOCK = 256;
              var REP_3_6 = 16;
              var REPZ_3_10 = 17;
              var REPZ_11_138 = 18;
              var extra_lbits = (
                /* extra bits for each length code */
                [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
              );
              var extra_dbits = (
                /* extra bits for each distance code */
                [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
              );
              var extra_blbits = (
                /* extra bits for each bit length code */
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
              );
              var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
              var DIST_CODE_LEN = 512;
              var static_ltree = new Array((L_CODES + 2) * 2);
              zero(static_ltree);
              var static_dtree = new Array(D_CODES * 2);
              zero(static_dtree);
              var _dist_code = new Array(DIST_CODE_LEN);
              zero(_dist_code);
              var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
              zero(_length_code);
              var base_length = new Array(LENGTH_CODES);
              zero(base_length);
              var base_dist = new Array(D_CODES);
              zero(base_dist);
              function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
                this.static_tree = static_tree;
                this.extra_bits = extra_bits;
                this.extra_base = extra_base;
                this.elems = elems;
                this.max_length = max_length;
                this.has_stree = static_tree && static_tree.length;
              }
              var static_l_desc;
              var static_d_desc;
              var static_bl_desc;
              function TreeDesc(dyn_tree, stat_desc) {
                this.dyn_tree = dyn_tree;
                this.max_code = 0;
                this.stat_desc = stat_desc;
              }
              function d_code(dist) {
                return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
              }
              function put_short(s, w) {
                s.pending_buf[s.pending++] = w & 255;
                s.pending_buf[s.pending++] = w >>> 8 & 255;
              }
              function send_bits(s, value, length) {
                if (s.bi_valid > Buf_size - length) {
                  s.bi_buf |= value << s.bi_valid & 65535;
                  put_short(s, s.bi_buf);
                  s.bi_buf = value >> Buf_size - s.bi_valid;
                  s.bi_valid += length - Buf_size;
                } else {
                  s.bi_buf |= value << s.bi_valid & 65535;
                  s.bi_valid += length;
                }
              }
              function send_code(s, c, tree) {
                send_bits(
                  s,
                  tree[c * 2],
                  tree[c * 2 + 1]
                  /*.Len*/
                );
              }
              function bi_reverse(code, len) {
                var res = 0;
                do {
                  res |= code & 1;
                  code >>>= 1;
                  res <<= 1;
                } while (--len > 0);
                return res >>> 1;
              }
              function bi_flush(s) {
                if (s.bi_valid === 16) {
                  put_short(s, s.bi_buf);
                  s.bi_buf = 0;
                  s.bi_valid = 0;
                } else if (s.bi_valid >= 8) {
                  s.pending_buf[s.pending++] = s.bi_buf & 255;
                  s.bi_buf >>= 8;
                  s.bi_valid -= 8;
                }
              }
              function gen_bitlen(s, desc) {
                var tree = desc.dyn_tree;
                var max_code = desc.max_code;
                var stree = desc.stat_desc.static_tree;
                var has_stree = desc.stat_desc.has_stree;
                var extra = desc.stat_desc.extra_bits;
                var base = desc.stat_desc.extra_base;
                var max_length = desc.stat_desc.max_length;
                var h;
                var n, m;
                var bits;
                var xbits;
                var f;
                var overflow = 0;
                for (bits = 0; bits <= MAX_BITS; bits++) {
                  s.bl_count[bits] = 0;
                }
                tree[s.heap[s.heap_max] * 2 + 1] = 0;
                for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
                  n = s.heap[h];
                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
                  if (bits > max_length) {
                    bits = max_length;
                    overflow++;
                  }
                  tree[n * 2 + 1] = bits;
                  if (n > max_code) {
                    continue;
                  }
                  s.bl_count[bits]++;
                  xbits = 0;
                  if (n >= base) {
                    xbits = extra[n - base];
                  }
                  f = tree[n * 2];
                  s.opt_len += f * (bits + xbits);
                  if (has_stree) {
                    s.static_len += f * (stree[n * 2 + 1] + xbits);
                  }
                }
                if (overflow === 0) {
                  return;
                }
                do {
                  bits = max_length - 1;
                  while (s.bl_count[bits] === 0) {
                    bits--;
                  }
                  s.bl_count[bits]--;
                  s.bl_count[bits + 1] += 2;
                  s.bl_count[max_length]--;
                  overflow -= 2;
                } while (overflow > 0);
                for (bits = max_length; bits !== 0; bits--) {
                  n = s.bl_count[bits];
                  while (n !== 0) {
                    m = s.heap[--h];
                    if (m > max_code) {
                      continue;
                    }
                    if (tree[m * 2 + 1] !== bits) {
                      s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                      tree[m * 2 + 1] = bits;
                    }
                    n--;
                  }
                }
              }
              function gen_codes(tree, max_code, bl_count) {
                var next_code = new Array(MAX_BITS + 1);
                var code = 0;
                var bits;
                var n;
                for (bits = 1; bits <= MAX_BITS; bits++) {
                  next_code[bits] = code = code + bl_count[bits - 1] << 1;
                }
                for (n = 0; n <= max_code; n++) {
                  var len = tree[n * 2 + 1];
                  if (len === 0) {
                    continue;
                  }
                  tree[n * 2] = bi_reverse(next_code[len]++, len);
                }
              }
              function tr_static_init() {
                var n;
                var bits;
                var length;
                var code;
                var dist;
                var bl_count = new Array(MAX_BITS + 1);
                length = 0;
                for (code = 0; code < LENGTH_CODES - 1; code++) {
                  base_length[code] = length;
                  for (n = 0; n < 1 << extra_lbits[code]; n++) {
                    _length_code[length++] = code;
                  }
                }
                _length_code[length - 1] = code;
                dist = 0;
                for (code = 0; code < 16; code++) {
                  base_dist[code] = dist;
                  for (n = 0; n < 1 << extra_dbits[code]; n++) {
                    _dist_code[dist++] = code;
                  }
                }
                dist >>= 7;
                for (; code < D_CODES; code++) {
                  base_dist[code] = dist << 7;
                  for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
                    _dist_code[256 + dist++] = code;
                  }
                }
                for (bits = 0; bits <= MAX_BITS; bits++) {
                  bl_count[bits] = 0;
                }
                n = 0;
                while (n <= 143) {
                  static_ltree[n * 2 + 1] = 8;
                  n++;
                  bl_count[8]++;
                }
                while (n <= 255) {
                  static_ltree[n * 2 + 1] = 9;
                  n++;
                  bl_count[9]++;
                }
                while (n <= 279) {
                  static_ltree[n * 2 + 1] = 7;
                  n++;
                  bl_count[7]++;
                }
                while (n <= 287) {
                  static_ltree[n * 2 + 1] = 8;
                  n++;
                  bl_count[8]++;
                }
                gen_codes(static_ltree, L_CODES + 1, bl_count);
                for (n = 0; n < D_CODES; n++) {
                  static_dtree[n * 2 + 1] = 5;
                  static_dtree[n * 2] = bi_reverse(n, 5);
                }
                static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
                static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
                static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
              }
              function init_block(s) {
                var n;
                for (n = 0; n < L_CODES; n++) {
                  s.dyn_ltree[n * 2] = 0;
                }
                for (n = 0; n < D_CODES; n++) {
                  s.dyn_dtree[n * 2] = 0;
                }
                for (n = 0; n < BL_CODES; n++) {
                  s.bl_tree[n * 2] = 0;
                }
                s.dyn_ltree[END_BLOCK * 2] = 1;
                s.opt_len = s.static_len = 0;
                s.last_lit = s.matches = 0;
              }
              function bi_windup(s) {
                if (s.bi_valid > 8) {
                  put_short(s, s.bi_buf);
                } else if (s.bi_valid > 0) {
                  s.pending_buf[s.pending++] = s.bi_buf;
                }
                s.bi_buf = 0;
                s.bi_valid = 0;
              }
              function copy_block(s, buf, len, header) {
                bi_windup(s);
                if (header) {
                  put_short(s, len);
                  put_short(s, ~len);
                }
                utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
                s.pending += len;
              }
              function smaller(tree, n, m, depth) {
                var _n2 = n * 2;
                var _m2 = m * 2;
                return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
              }
              function pqdownheap(s, tree, k) {
                var v = s.heap[k];
                var j = k << 1;
                while (j <= s.heap_len) {
                  if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
                    j++;
                  }
                  if (smaller(tree, v, s.heap[j], s.depth)) {
                    break;
                  }
                  s.heap[k] = s.heap[j];
                  k = j;
                  j <<= 1;
                }
                s.heap[k] = v;
              }
              function compress_block(s, ltree, dtree) {
                var dist;
                var lc;
                var lx = 0;
                var code;
                var extra;
                if (s.last_lit !== 0) {
                  do {
                    dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
                    lc = s.pending_buf[s.l_buf + lx];
                    lx++;
                    if (dist === 0) {
                      send_code(s, lc, ltree);
                    } else {
                      code = _length_code[lc];
                      send_code(s, code + LITERALS + 1, ltree);
                      extra = extra_lbits[code];
                      if (extra !== 0) {
                        lc -= base_length[code];
                        send_bits(s, lc, extra);
                      }
                      dist--;
                      code = d_code(dist);
                      send_code(s, code, dtree);
                      extra = extra_dbits[code];
                      if (extra !== 0) {
                        dist -= base_dist[code];
                        send_bits(s, dist, extra);
                      }
                    }
                  } while (lx < s.last_lit);
                }
                send_code(s, END_BLOCK, ltree);
              }
              function build_tree(s, desc) {
                var tree = desc.dyn_tree;
                var stree = desc.stat_desc.static_tree;
                var has_stree = desc.stat_desc.has_stree;
                var elems = desc.stat_desc.elems;
                var n, m;
                var max_code = -1;
                var node;
                s.heap_len = 0;
                s.heap_max = HEAP_SIZE;
                for (n = 0; n < elems; n++) {
                  if (tree[n * 2] !== 0) {
                    s.heap[++s.heap_len] = max_code = n;
                    s.depth[n] = 0;
                  } else {
                    tree[n * 2 + 1] = 0;
                  }
                }
                while (s.heap_len < 2) {
                  node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
                  tree[node * 2] = 1;
                  s.depth[node] = 0;
                  s.opt_len--;
                  if (has_stree) {
                    s.static_len -= stree[node * 2 + 1];
                  }
                }
                desc.max_code = max_code;
                for (n = s.heap_len >> 1; n >= 1; n--) {
                  pqdownheap(s, tree, n);
                }
                node = elems;
                do {
                  n = s.heap[
                    1
                    /*SMALLEST*/
                  ];
                  s.heap[
                    1
                    /*SMALLEST*/
                  ] = s.heap[s.heap_len--];
                  pqdownheap(
                    s,
                    tree,
                    1
                    /*SMALLEST*/
                  );
                  m = s.heap[
                    1
                    /*SMALLEST*/
                  ];
                  s.heap[--s.heap_max] = n;
                  s.heap[--s.heap_max] = m;
                  tree[node * 2] = tree[n * 2] + tree[m * 2];
                  s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
                  tree[n * 2 + 1] = tree[m * 2 + 1] = node;
                  s.heap[
                    1
                    /*SMALLEST*/
                  ] = node++;
                  pqdownheap(
                    s,
                    tree,
                    1
                    /*SMALLEST*/
                  );
                } while (s.heap_len >= 2);
                s.heap[--s.heap_max] = s.heap[
                  1
                  /*SMALLEST*/
                ];
                gen_bitlen(s, desc);
                gen_codes(tree, max_code, s.bl_count);
              }
              function scan_tree(s, tree, max_code) {
                var n;
                var prevlen = -1;
                var curlen;
                var nextlen = tree[0 * 2 + 1];
                var count = 0;
                var max_count = 7;
                var min_count = 4;
                if (nextlen === 0) {
                  max_count = 138;
                  min_count = 3;
                }
                tree[(max_code + 1) * 2 + 1] = 65535;
                for (n = 0; n <= max_code; n++) {
                  curlen = nextlen;
                  nextlen = tree[(n + 1) * 2 + 1];
                  if (++count < max_count && curlen === nextlen) {
                    continue;
                  } else if (count < min_count) {
                    s.bl_tree[curlen * 2] += count;
                  } else if (curlen !== 0) {
                    if (curlen !== prevlen) {
                      s.bl_tree[curlen * 2]++;
                    }
                    s.bl_tree[REP_3_6 * 2]++;
                  } else if (count <= 10) {
                    s.bl_tree[REPZ_3_10 * 2]++;
                  } else {
                    s.bl_tree[REPZ_11_138 * 2]++;
                  }
                  count = 0;
                  prevlen = curlen;
                  if (nextlen === 0) {
                    max_count = 138;
                    min_count = 3;
                  } else if (curlen === nextlen) {
                    max_count = 6;
                    min_count = 3;
                  } else {
                    max_count = 7;
                    min_count = 4;
                  }
                }
              }
              function send_tree(s, tree, max_code) {
                var n;
                var prevlen = -1;
                var curlen;
                var nextlen = tree[0 * 2 + 1];
                var count = 0;
                var max_count = 7;
                var min_count = 4;
                if (nextlen === 0) {
                  max_count = 138;
                  min_count = 3;
                }
                for (n = 0; n <= max_code; n++) {
                  curlen = nextlen;
                  nextlen = tree[(n + 1) * 2 + 1];
                  if (++count < max_count && curlen === nextlen) {
                    continue;
                  } else if (count < min_count) {
                    do {
                      send_code(s, curlen, s.bl_tree);
                    } while (--count !== 0);
                  } else if (curlen !== 0) {
                    if (curlen !== prevlen) {
                      send_code(s, curlen, s.bl_tree);
                      count--;
                    }
                    send_code(s, REP_3_6, s.bl_tree);
                    send_bits(s, count - 3, 2);
                  } else if (count <= 10) {
                    send_code(s, REPZ_3_10, s.bl_tree);
                    send_bits(s, count - 3, 3);
                  } else {
                    send_code(s, REPZ_11_138, s.bl_tree);
                    send_bits(s, count - 11, 7);
                  }
                  count = 0;
                  prevlen = curlen;
                  if (nextlen === 0) {
                    max_count = 138;
                    min_count = 3;
                  } else if (curlen === nextlen) {
                    max_count = 6;
                    min_count = 3;
                  } else {
                    max_count = 7;
                    min_count = 4;
                  }
                }
              }
              function build_bl_tree(s) {
                var max_blindex;
                scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
                scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
                build_tree(s, s.bl_desc);
                for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
                  if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
                    break;
                  }
                }
                s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
                return max_blindex;
              }
              function send_all_trees(s, lcodes, dcodes, blcodes) {
                var rank;
                send_bits(s, lcodes - 257, 5);
                send_bits(s, dcodes - 1, 5);
                send_bits(s, blcodes - 4, 4);
                for (rank = 0; rank < blcodes; rank++) {
                  send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
                }
                send_tree(s, s.dyn_ltree, lcodes - 1);
                send_tree(s, s.dyn_dtree, dcodes - 1);
              }
              function detect_data_type(s) {
                var black_mask = 4093624447;
                var n;
                for (n = 0; n <= 31; n++, black_mask >>>= 1) {
                  if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
                    return Z_BINARY;
                  }
                }
                if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
                  return Z_TEXT;
                }
                for (n = 32; n < LITERALS; n++) {
                  if (s.dyn_ltree[n * 2] !== 0) {
                    return Z_TEXT;
                  }
                }
                return Z_BINARY;
              }
              var static_init_done = false;
              function _tr_init(s) {
                if (!static_init_done) {
                  tr_static_init();
                  static_init_done = true;
                }
                s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
                s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
                s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
                s.bi_buf = 0;
                s.bi_valid = 0;
                init_block(s);
              }
              function _tr_stored_block(s, buf, stored_len, last) {
                send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
                copy_block(s, buf, stored_len, true);
              }
              function _tr_align(s) {
                send_bits(s, STATIC_TREES << 1, 3);
                send_code(s, END_BLOCK, static_ltree);
                bi_flush(s);
              }
              function _tr_flush_block(s, buf, stored_len, last) {
                var opt_lenb, static_lenb;
                var max_blindex = 0;
                if (s.level > 0) {
                  if (s.strm.data_type === Z_UNKNOWN) {
                    s.strm.data_type = detect_data_type(s);
                  }
                  build_tree(s, s.l_desc);
                  build_tree(s, s.d_desc);
                  max_blindex = build_bl_tree(s);
                  opt_lenb = s.opt_len + 3 + 7 >>> 3;
                  static_lenb = s.static_len + 3 + 7 >>> 3;
                  if (static_lenb <= opt_lenb) {
                    opt_lenb = static_lenb;
                  }
                } else {
                  opt_lenb = static_lenb = stored_len + 5;
                }
                if (stored_len + 4 <= opt_lenb && buf !== -1) {
                  _tr_stored_block(s, buf, stored_len, last);
                } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
                  send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
                  compress_block(s, static_ltree, static_dtree);
                } else {
                  send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
                  send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
                  compress_block(s, s.dyn_ltree, s.dyn_dtree);
                }
                init_block(s);
                if (last) {
                  bi_windup(s);
                }
              }
              function _tr_tally(s, dist, lc) {
                s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
                s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
                s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
                s.last_lit++;
                if (dist === 0) {
                  s.dyn_ltree[lc * 2]++;
                } else {
                  s.matches++;
                  dist--;
                  s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
                  s.dyn_dtree[d_code(dist) * 2]++;
                }
                return s.last_lit === s.lit_bufsize - 1;
              }
              exports2._tr_init = _tr_init;
              exports2._tr_stored_block = _tr_stored_block;
              exports2._tr_flush_block = _tr_flush_block;
              exports2._tr_tally = _tr_tally;
              exports2._tr_align = _tr_align;
            },
            /***/
            2416(module2, __unused_webpack_exports, __webpack_require__2) {
              module2.exports = __webpack_require__2(6811)["default"];
            },
            /***/
            2504(__unused_webpack_module, exports2) {
              "use strict";
              exports2.byteLength = byteLength;
              exports2.toByteArray = toByteArray;
              exports2.fromByteArray = fromByteArray;
              var lookup = [];
              var revLookup = [];
              var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
              var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
              for (var i = 0, len = code.length; i < len; ++i) {
                lookup[i] = code[i];
                revLookup[code.charCodeAt(i)] = i;
              }
              revLookup["-".charCodeAt(0)] = 62;
              revLookup["_".charCodeAt(0)] = 63;
              function getLens(b64) {
                var len2 = b64.length;
                if (len2 % 4 > 0) {
                  throw new Error("Invalid string. Length must be a multiple of 4");
                }
                var validLen = b64.indexOf("=");
                if (validLen === -1) validLen = len2;
                var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
                return [validLen, placeHoldersLen];
              }
              function byteLength(b64) {
                var lens = getLens(b64);
                var validLen = lens[0];
                var placeHoldersLen = lens[1];
                return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
              }
              function _byteLength(b64, validLen, placeHoldersLen) {
                return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
              }
              function toByteArray(b64) {
                var tmp;
                var lens = getLens(b64);
                var validLen = lens[0];
                var placeHoldersLen = lens[1];
                var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
                var curByte = 0;
                var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
                var i2;
                for (i2 = 0; i2 < len2; i2 += 4) {
                  tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
                  arr[curByte++] = tmp >> 16 & 255;
                  arr[curByte++] = tmp >> 8 & 255;
                  arr[curByte++] = tmp & 255;
                }
                if (placeHoldersLen === 2) {
                  tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
                  arr[curByte++] = tmp & 255;
                }
                if (placeHoldersLen === 1) {
                  tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
                  arr[curByte++] = tmp >> 8 & 255;
                  arr[curByte++] = tmp & 255;
                }
                return arr;
              }
              function tripletToBase64(num) {
                return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
              }
              function encodeChunk(uint8, start, end) {
                var tmp;
                var output = [];
                for (var i2 = start; i2 < end; i2 += 3) {
                  tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
                  output.push(tripletToBase64(tmp));
                }
                return output.join("");
              }
              function fromByteArray(uint8) {
                var tmp;
                var len2 = uint8.length;
                var extraBytes = len2 % 3;
                var parts = [];
                var maxChunkLength = 16383;
                for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
                  parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
                }
                if (extraBytes === 1) {
                  tmp = uint8[len2 - 1];
                  parts.push(
                    lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
                  );
                } else if (extraBytes === 2) {
                  tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
                  parts.push(
                    lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
                  );
                }
                return parts.join("");
              }
            },
            /***/
            2519(__unused_webpack_module, exports2) {
              "use strict";
              var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
              function _has(obj, key) {
                return Object.prototype.hasOwnProperty.call(obj, key);
              }
              exports2.assign = function(obj) {
                var sources = Array.prototype.slice.call(arguments, 1);
                while (sources.length) {
                  var source = sources.shift();
                  if (!source) {
                    continue;
                  }
                  if (typeof source !== "object") {
                    throw new TypeError(source + "must be non-object");
                  }
                  for (var p in source) {
                    if (_has(source, p)) {
                      obj[p] = source[p];
                    }
                  }
                }
                return obj;
              };
              exports2.shrinkBuf = function(buf, size) {
                if (buf.length === size) {
                  return buf;
                }
                if (buf.subarray) {
                  return buf.subarray(0, size);
                }
                buf.length = size;
                return buf;
              };
              var fnTyped = {
                arraySet: function(dest, src, src_offs, len, dest_offs) {
                  if (src.subarray && dest.subarray) {
                    dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
                    return;
                  }
                  for (var i = 0; i < len; i++) {
                    dest[dest_offs + i] = src[src_offs + i];
                  }
                },
                // Join array of chunks to single array.
                flattenChunks: function(chunks) {
                  var i, l, len, pos, chunk, result;
                  len = 0;
                  for (i = 0, l = chunks.length; i < l; i++) {
                    len += chunks[i].length;
                  }
                  result = new Uint8Array(len);
                  pos = 0;
                  for (i = 0, l = chunks.length; i < l; i++) {
                    chunk = chunks[i];
                    result.set(chunk, pos);
                    pos += chunk.length;
                  }
                  return result;
                }
              };
              var fnUntyped = {
                arraySet: function(dest, src, src_offs, len, dest_offs) {
                  for (var i = 0; i < len; i++) {
                    dest[dest_offs + i] = src[src_offs + i];
                  }
                },
                // Join array of chunks to single array.
                flattenChunks: function(chunks) {
                  return [].concat.apply([], chunks);
                }
              };
              exports2.setTyped = function(on) {
                if (on) {
                  exports2.Buf8 = Uint8Array;
                  exports2.Buf16 = Uint16Array;
                  exports2.Buf32 = Int32Array;
                  exports2.assign(exports2, fnTyped);
                } else {
                  exports2.Buf8 = Array;
                  exports2.Buf16 = Array;
                  exports2.Buf32 = Array;
                  exports2.assign(exports2, fnUntyped);
                }
              };
              exports2.setTyped(TYPED_OK);
            },
            /***/
            2532(module2, __unused_webpack_exports, __webpack_require__2) {
              var $kQ2hT$unicodetrie = __webpack_require__2(7571);
              var $kQ2hT$base64js = __webpack_require__2(3915);
              function $parcel$interopDefault(a) {
                return a && a.__esModule ? a.default : a;
              }
              "use strict";
              const $60ff486a304db230$export$af862512e23cb54 = 0;
              const $60ff486a304db230$export$9bf3043cb7503aa1 = 1;
              const $60ff486a304db230$export$6d0b2a5dd774590a = 2;
              const $60ff486a304db230$export$bf0b2277bd569ea1 = 3;
              const $60ff486a304db230$export$bad2a840ccda93b6 = 4;
              const $60ff486a304db230$export$fb4028874a74450 = 5;
              const $60ff486a304db230$export$463bd1ce0149c55e = 6;
              const $60ff486a304db230$export$2e8caadc521d7cbb = 7;
              const $60ff486a304db230$export$bfe27467c1de9413 = 8;
              const $60ff486a304db230$export$af5f8d68aad3cd3a = 9;
              const $60ff486a304db230$export$6b7e017d6825d38f = 10;
              const $60ff486a304db230$export$8227ca023eb0daaa = 11;
              const $60ff486a304db230$export$1bb1140fe1358b00 = 12;
              const $60ff486a304db230$export$f3e416a182673355 = 13;
              const $60ff486a304db230$export$8be180ec26319f9f = 14;
              const $60ff486a304db230$export$70824c8942178d60 = 15;
              const $60ff486a304db230$export$24aa617c849a894a = 16;
              const $60ff486a304db230$export$a73c4d14459b698d = 17;
              const $60ff486a304db230$export$921068d8846a1559 = 18;
              const $60ff486a304db230$export$8b85a4f193482778 = 19;
              const $60ff486a304db230$export$b2fd9c01d360241f = 20;
              const $60ff486a304db230$export$dcd191669c0a595f = 21;
              const $60ff486a304db230$export$9e5d732f3676a9ba = 22;
              const $60ff486a304db230$export$cb94397127ac9363 = 23;
              const $60ff486a304db230$export$746be9e3a3dfff1f = 24;
              const $60ff486a304db230$export$96e3e682276c47cf = 25;
              const $60ff486a304db230$export$fc2ff69ee2cb01bf = 26;
              const $60ff486a304db230$export$8999624a7bae9d04 = 27;
              const $60ff486a304db230$export$1dff41d5c0caca01 = 28;
              const $60ff486a304db230$export$ddb7a6c76d9d93eb = 29;
              const $60ff486a304db230$export$7e93eb3105e4786d = 30;
              const $60ff486a304db230$export$30a74a373318dec6 = 31;
              const $60ff486a304db230$export$54caeea5e6dab1f = 32;
              const $60ff486a304db230$export$d710c5f50fc7496a = 33;
              const $60ff486a304db230$export$66498d28055820a9 = 34;
              const $60ff486a304db230$export$eb6c6d0b7c8826f2 = 35;
              const $60ff486a304db230$export$de92be486109a1df = 36;
              const $60ff486a304db230$export$606cfc2a8896c91f = 37;
              const $60ff486a304db230$export$e51d3c675bb0140d = 38;
              const $60ff486a304db230$export$da51c6332ad11d7b = 39;
              const $60ff486a304db230$export$bea437c40441867d = 40;
              const $60ff486a304db230$export$c4c7eecbfed13dc9 = 41;
              const $60ff486a304db230$export$98e1f8a379849661 = 42;
              const $1b6fba3281342923$export$98f50d781a474745 = 0;
              const $1b6fba3281342923$export$12ee1f8f5315ca7e = 1;
              const $1b6fba3281342923$export$e4965ce242860454 = 2;
              const $1b6fba3281342923$export$8f14048969dcd45e = 3;
              const $1b6fba3281342923$export$133eb141bf58aff4 = 4;
              const $1b6fba3281342923$export$5bdb8ccbf5c57afc = [
                //OP   , CL    , CP    , QU    , GL    , NS    , EX    , SY    , IS    , PR    , PO    , NU    , AL    , HL    , ID    , IN    , HY    , BA    , BB    , B2    , ZW    , CM    , WJ    , H2    , H3    , JL    , JV    , JT    , RI    , EB    , EM    , ZWJ   , CB
                [
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$8f14048969dcd45e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e
                ],
                [
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ],
                [
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$e4965ce242860454,
                  $1b6fba3281342923$export$133eb141bf58aff4,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$98f50d781a474745,
                  $1b6fba3281342923$export$12ee1f8f5315ca7e,
                  $1b6fba3281342923$export$98f50d781a474745
                ]
                // CB
              ];
              const $f898ea50f3b38ab8$var$data = $parcel$interopDefault($kQ2hT$base64js).toByteArray("AAgOAAAAAAAQ4QAAAQ0P8vDtnQuMXUUZx+eyu7d7797d9m5bHoWltKVUlsjLWE0VJNigQoMVqkStEoNQQUl5GIo1KKmogEgqkKbBRki72lYabZMGKoGAjQRtJJDaCCIRiiigREBQS3z+xzOTnZ3O+3HOhd5NfpkzZx7fN9988zivu2M9hGwB28F94DnwEngd/Asc1EtIs9c/bIPDwCxwLDgezHcodyo4w5C+CCwBS8FnwSXgCnA1uFbI93XwbXAbWAfWgx+CzWAb+An4KfgFeAzsYWWfYuFz4CXwGvgb+Dfo6yNkEEwGh4CZYB44FpwI3g1OY+kfBItZOo2fB84Hy8DF4HJwNbiWpV8PVoO1LH4n2NRXyN+KcAd4kNVP9XsY4aPgcfAbsBfs6SniL4K/sPjfEf6HlanXCRkCw2BGvUh/keWfXS/CY+pFXs7x9XHmM94LTmWIeU2cgbxnS/k/B3kf86jDhU8L9V2E40vAFWAlWFUfb++NOL4F3C7JX4/4GiE+hvgWsF0oS7mXldspnN+F493gyXrh9xTav0cg3EvzgVfBG6wsmVSEkxBOBgdPGpd7JI6PnqRvJ68/xlbHof53gPeA94OzwLngk+ACsAwsByvASrAK3MB0Ws3CtQjvBJvAVrADPMDSHkb4CNijaccTwvnf4fiPEs8Lxy+D18A/QU8/xjgYBjPAbDAKTgYLwOngTHAO+EQ/8wuEF4EvsPiVCFf2+9tsFStzA8LVHuXXBsi6QyqzUYiPMR/7Mc7dAx7oL8bzw/3u/Bw8Bp4Az4AXwCtgHzsmDXP5fiF9iiVvly5d0sHngar16NKlS5cuXbp06fLmYlqHXrcd3ph4P0THUY3iXh49novju4S0tzfs5d+JPKewfAsRntZb3K9ZhOMlrO6lCC8An28U9+OuovcPcPxlVu5rCL/VmHh/iHIrzn3fIPu7SN8Axmg+8AOwEWwCm7tp3bRuWjetm5Y8bSu4B9zbKO6ZVsnORrVU3f4uXTqZ2H3sLoyx3eDXjfDndE9qyj6L838CfwVvgFpzYnof4oNgOhgBc8Fos9DrZIQLmtXPP1MmF6wGj4H+KXoWguvADkXaPil+YpuQy8Am8Ey7ODdtmJDF4HowBp4De6HDTNjhfHAHeBr0DBBy0kDxfPbcgSIusgrcWhtnJ8vL+TPix7UIOQtcBq4C28Cr4KRBnANbwSuDE+s50JgyNNFuXbp06XIgsXjIvPafjvXozKY+fVFz/z0LT1uCtKVSWbrOLWPnztG8e0Xfy7ol8XtZJi7WtG+5od2UFXQ/A12vUeS7jp27yVKHjdsU9lXB869TyNvAzt0lpP2oWbwLdjiO78bx/Sz+EMJHwK9Y/LcIfw+eZ3F67/Hl5vh9xX80J+rwX8SvRDhpgL17iPAQMHNArfPrqHPewLheI+AERV6efwV418B4nOZ/H+IfYHV8GOF5LJ3eAz0fx8sM9S0fUNud39O9CulfGZhY5huI3wzWgNvBelbHZoTbNPVpfYjKQpkHwUNgl0LWblbnk0LbbDxr0OMFpL3iqWdu9nWYPlVAWkXY39LnGdCkDbeqv1YNbfcMQ3t9oe8lzm6NH9N1ZB6Ln4BwfkJZJk7RyFnYKt6b/JDQXx9p5X+eFdqOjzM9P9MB/lUlFzr20aXIdzlY4dmn9F3YqtvoO76/2hp/D/xA5Zue88nNyL8GbFbs075X0tyUig3Qd2MCnf//HjnzpbsR3g9+1kHzzVjdnE71/qVBX9rGPUh/ysNWe1neFzvIDi5zAufV1sT0N0poR22wkFUfTOPfA4N2mbZ5fSrqOHSw+IbkSBbOGSzSRgf91/GTUWYBOB2cIZQ/G8cfBZ8CFwrnL8XxF8FKcA24jqXdiPA7Qr61OF7H4mMItwzuv2/YLth1ISt3Hzu3k4W7EH5JqPdRHD/O4k+z8A8IX5Lq3y7Z4nXE9xn6kX6vQ4bKfy+ok+hH+xf3hq9dnTTHhjKd2GmDuWA242iHMq4cC7A8kJ7i8o1+skSa7Jieo38HCWnoNjKFhdSFBxzpZ7QE6lI8N4S14aASZcryaV/WWHw66f6NHuCoxuQxmvM56GX9QMd8Q4D65ywGP+ZzRJuM+zQvx/MOS2VFeqQ4IXnH26zM9Xe6/E6D+4foAzzuajPZp8Qyw5ayZVDWuH0z0BtYRkeIDqH9KO9VbH1btd/lhNqCzvl8zeLnG0S/hnU6baHfpiuO6yy0rd+DHURo/zYF5H26j03rQsip2ndzz82u1z9N4VjWKWeb68Tedpt95HRVXp7H1R6p+/Wt4FPy/PpWwscOLRJ+PVWF/+W0iVyGzs18TIvXkOJ1Wxm66vSXz+vylenrZcj1ub439W+K8RNCGTJi2p/TJ1K23VaXr35tRpnzmjxequgfcfyk6B/TGBVlyedsNgpdd/h+W1U3P99QyFPNo1X3TwpM/WLTIWYfoBqXrv6iskHZ/RFr79R6hIyHBrH3f1nrUVnjP8SnZZ+rYtzr9Exld5MNbPNErusAPg+77u/eDOPftU9yj39TH7rezxd1LvsZQJlzkWlOirG/79zjMj/mtHUKu7vKy+3/LnXr9okyKedjX5/0He9iP/j63LwOQdarEVlfy8OO/Lqw023j6xcqmwxLiOd6heM2i9cV9LJy8jMJ23yQ+rpbfu7EQ/pXE8KYvUSqvVnb4XzZa6LrHMXHR+zcLvqWbm/Bn0/HzIs6fWPHoat8XfnDKmZGxRxeMbn2UqZ5Q94nmcZRbqqUXbZ8+lcjE+cPX11t814orvvAXNcG8vqj2vvk1MGn3anlj0bIT72v47bvE+Lc98T9b6r7AKn6j+8Duf7D0nnZx/j7Zjn0j9nbpSTndaLr9WNLivP+iN23xF7L+fqv6ZouFyb78jxVXvv5jJ9YUs9/sddO8h7KNg5jrhfaJGztT6G7KF+1d6yCmD5Kdb2fan60rSc552fZr3zeQ9DpnPp+Si5cx5Ktv2QfSzF/mMbWdOm46rFI4XstnU9xeqX4NKb7TKEdcr6pZOK3ID1k/LvFHkVczEuZLEDr499YqvqBym1aEHWgcvoYOtv0M91qQl5TfpO/in6rWx8OVpT1Wedkv3f5xom3T/xeR/6Gx6V86PWAOB4bBpqWdN+yTcVxjIyGRz/FrDGu6w/3d7kPm8StX8RyPu+uuvpNju/vTLJV37GpvoM0oZPnW87VLnL/5pDno1NoW1R6yedU6TyUv3u19a3KFnIbTLYz+ZCLP4T0tU1uivFgso0pnsJ/UtXvarNY28Xq5cvkBDrQP/E5ZaiuQwwfmTlsOiQRU1fMuqrDd/3ISSuwjOwXOfTyGUMpZIXq4GpLn3pUcdfzch2x7XO1u2uZHOPb1G6b3Xg9PH1IIWeEpJlPQtqos2EKW8b0u8rnuP1UeVLoXJb9be0uG9nnbchjU+XTszT5VeNBThPHnc5OKj1U9aj0GTHIVaGy1YhEWT4ixns00DT+XEzWn/7VAsIc63Cov3OdyhwjrnaqQqZvWKXdypRdlq+k8msZ031U+Rm4fA+3TtyeR9hwfW9G9yxDN0fZMN33F+9TE6md4hwoxumfaUzI9fN3PFT3xVV2msrQ3UsnChm6Nulk8TndpS28D3zX9tTIPsF/z7Am5OkTjm1tI1JZW74+4VgsZ0N3L1yXV3WeP5uR7TGHHdvC3JQlxybfpd22tDlk/2eofRK8TzrN/qnar/K/OUTth6I/+jAnEptNbPvFHP2gs40N3+dfMWtwqvVct7/wfd8gtQ7imifial9ZJ9/3IHLYU6eDj3+4PhsNhX+vwvcWLnu6kGfEMe8DuciPfUfGZB8X/7HJy/Gefe5n+VRGFd/wyP2ta7/LO4yh/sbLV/k9lev6kfO9Dt/5U67b1/6u/epqB1U9Me23jfHY9sscAg4tkbLl+e4/U36rJ9ddxfd6sg5vq5ice42Wpk/pb9FOJ36/W9tpv4kbC79nUbZceX8Zu6/qJ+P3WvhvA8v3reh7Jbn2d6rrNC7XNZTLma4Ba0JI9efX2uLzF5scG/w9UNU1ZxW+ymUfzELeTllXlQ1rUuhzjS5fp9c964iFBOqeSz63bU065nZKdU+mDEz3qHIjjifquw0pnb/raRtvrnsYcb46ihT3taoYz6brdNW9l6rWRnE/navdPn1XlR1km7hcz1WlH/elKuSOSvLLuE8U6m8uzwRdfcGl73VyTHuyMvzJ1Sa2cWDTP/Z63Kc94n2B1PYr24dz1JlyHLlcP+S4B6vD1c9EW4q2LWstCvUjeVy63k/LMYdUNd5D1xQfvVTzX1VjkMsUv88N8VH5fReVn/Fjn++/h6X6Q8a6b1/q3g/i/ewi0/Scs8zxXeV6mWIOUPlPzBgdFerW+bZrm2P18dnjuK6HunEp+rHvPMXbr+sHVb/lnL+pTP57jPw9Cvk3PW178JD9qChfzuvTf7Htl38L1QUf/VKu9SFjwWbTWPvFEvu7Uq76y7+31g6QlYPc669pbsm9Xur2LWI9Pu8ypfDXqm3A2z8s1FWGn4ntL9NfQu2oSlftX9uetvTtv7J8Ql4zxfXGZ3zk8PeQ9w59x2uMfqI8/q5eKh/l9cb2rwsu9rSNl06ZP2Pmxtz+rNMx93yno0n2/82rVH7rQ+y9P15H6FyRun9ViH81ATmffI7nJ5r8uXXW6enbP6b/B8/l5OifVHYLnb9S39s2zcc+Ph+rh8+eQgVPS72elzGWY/tUtbbabBpDiI7yN1q6/4th2y+ErAc5+9BVvu/7KamJbWNZeuqI/R4tRf+YyD1HmOZM1bMV3/14Sn10c0Xu+Sj1nOXb5jL73ncdy02uvlXZNde65dOHYl7Vs4KYuS6FzWLn2zJlpZqPXPVPOa5yzKOyn1VhT9lmMfdbfH7D11Wf2PXN5h9y+dD287+qxgSnaYmnIrRtIb8pJe6/Uv9OVer6Whn0zfGO/BEloZI9ojmfAlUflClDd178bTmVHVTpZXOkAlk/lb42UujmI89HH5V+cl7XtowY6vTxLVWok6UrGzoGTHN+bB+6ri05687VNpvfuvRfaP2uMlNQth1D5JjGelm/8yn+9p3p/7qk9gnfeddXZmq/Sm333PJT659Kv1zjNbZ9uv2Oi//67CV8/N1nj1DmviyXDNVeJkaeaX8UsyesYg8cu2+NvdaPfb+lLDu5tvt/");
              const $f898ea50f3b38ab8$var$classTrie = new ($parcel$interopDefault($kQ2hT$unicodetrie))($f898ea50f3b38ab8$var$data);
              const $f898ea50f3b38ab8$var$mapClass = function(c) {
                switch (c) {
                  case $60ff486a304db230$export$d710c5f50fc7496a:
                    return $60ff486a304db230$export$1bb1140fe1358b00;
                  case $60ff486a304db230$export$da51c6332ad11d7b:
                  case $60ff486a304db230$export$bea437c40441867d:
                  case $60ff486a304db230$export$98e1f8a379849661:
                    return $60ff486a304db230$export$1bb1140fe1358b00;
                  case $60ff486a304db230$export$eb6c6d0b7c8826f2:
                    return $60ff486a304db230$export$fb4028874a74450;
                  default:
                    return c;
                }
              };
              const $f898ea50f3b38ab8$var$mapFirst = function(c) {
                switch (c) {
                  case $60ff486a304db230$export$606cfc2a8896c91f:
                  case $60ff486a304db230$export$e51d3c675bb0140d:
                    return $60ff486a304db230$export$66498d28055820a9;
                  case $60ff486a304db230$export$c4c7eecbfed13dc9:
                    return $60ff486a304db230$export$9e5d732f3676a9ba;
                  default:
                    return c;
                }
              };
              class $f898ea50f3b38ab8$var$Break {
                constructor(position, required = false) {
                  this.position = position;
                  this.required = required;
                }
              }
              class $f898ea50f3b38ab8$var$LineBreaker {
                nextCodePoint() {
                  const code = this.string.charCodeAt(this.pos++);
                  const next = this.string.charCodeAt(this.pos);
                  if (55296 <= code && code <= 56319 && 56320 <= next && next <= 57343) {
                    this.pos++;
                    return (code - 55296) * 1024 + (next - 56320) + 65536;
                  }
                  return code;
                }
                nextCharClass() {
                  return $f898ea50f3b38ab8$var$mapClass($f898ea50f3b38ab8$var$classTrie.get(this.nextCodePoint()));
                }
                getSimpleBreak() {
                  switch (this.nextClass) {
                    case $60ff486a304db230$export$c4c7eecbfed13dc9:
                      return false;
                    case $60ff486a304db230$export$66498d28055820a9:
                    case $60ff486a304db230$export$606cfc2a8896c91f:
                    case $60ff486a304db230$export$e51d3c675bb0140d:
                      this.curClass = $60ff486a304db230$export$66498d28055820a9;
                      return false;
                    case $60ff486a304db230$export$de92be486109a1df:
                      this.curClass = $60ff486a304db230$export$de92be486109a1df;
                      return false;
                  }
                  return null;
                }
                getPairTableBreak(lastClass) {
                  let shouldBreak = false;
                  switch ($1b6fba3281342923$export$5bdb8ccbf5c57afc[this.curClass][this.nextClass]) {
                    case $1b6fba3281342923$export$98f50d781a474745:
                      shouldBreak = true;
                      break;
                    case $1b6fba3281342923$export$12ee1f8f5315ca7e:
                      shouldBreak = lastClass === $60ff486a304db230$export$c4c7eecbfed13dc9;
                      break;
                    case $1b6fba3281342923$export$e4965ce242860454:
                      shouldBreak = lastClass === $60ff486a304db230$export$c4c7eecbfed13dc9;
                      if (!shouldBreak) {
                        shouldBreak = false;
                        return shouldBreak;
                      }
                      break;
                    case $1b6fba3281342923$export$8f14048969dcd45e:
                      if (lastClass !== $60ff486a304db230$export$c4c7eecbfed13dc9) return shouldBreak;
                      break;
                    case $1b6fba3281342923$export$133eb141bf58aff4:
                      break;
                  }
                  if (this.LB8a) shouldBreak = false;
                  if (this.LB21a && (this.curClass === $60ff486a304db230$export$24aa617c849a894a || this.curClass === $60ff486a304db230$export$a73c4d14459b698d)) {
                    shouldBreak = false;
                    this.LB21a = false;
                  } else this.LB21a = this.curClass === $60ff486a304db230$export$f3e416a182673355;
                  if (this.curClass === $60ff486a304db230$export$1dff41d5c0caca01) {
                    this.LB30a++;
                    if (this.LB30a == 2 && this.nextClass === $60ff486a304db230$export$1dff41d5c0caca01) {
                      shouldBreak = true;
                      this.LB30a = 0;
                    }
                  } else this.LB30a = 0;
                  this.curClass = this.nextClass;
                  return shouldBreak;
                }
                nextBreak() {
                  if (this.curClass == null) {
                    let firstClass = this.nextCharClass();
                    this.curClass = $f898ea50f3b38ab8$var$mapFirst(firstClass);
                    this.nextClass = firstClass;
                    this.LB8a = firstClass === $60ff486a304db230$export$30a74a373318dec6;
                    this.LB30a = 0;
                  }
                  while (this.pos < this.string.length) {
                    this.lastPos = this.pos;
                    const lastClass = this.nextClass;
                    this.nextClass = this.nextCharClass();
                    if (this.curClass === $60ff486a304db230$export$66498d28055820a9 || this.curClass === $60ff486a304db230$export$de92be486109a1df && this.nextClass !== $60ff486a304db230$export$606cfc2a8896c91f) {
                      this.curClass = $f898ea50f3b38ab8$var$mapFirst($f898ea50f3b38ab8$var$mapClass(this.nextClass));
                      return new $f898ea50f3b38ab8$var$Break(this.lastPos, true);
                    }
                    let shouldBreak = this.getSimpleBreak();
                    if (shouldBreak === null) shouldBreak = this.getPairTableBreak(lastClass);
                    this.LB8a = this.nextClass === $60ff486a304db230$export$30a74a373318dec6;
                    if (shouldBreak) return new $f898ea50f3b38ab8$var$Break(this.lastPos);
                  }
                  if (this.lastPos < this.string.length) {
                    this.lastPos = this.string.length;
                    return new $f898ea50f3b38ab8$var$Break(this.string.length);
                  }
                  return null;
                }
                constructor(string) {
                  this.string = string;
                  this.pos = 0;
                  this.lastPos = 0;
                  this.curClass = null;
                  this.nextClass = null;
                  this.LB8a = false;
                  this.LB21a = false;
                  this.LB30a = 0;
                }
              }
              module2.exports = $f898ea50f3b38ab8$var$LineBreaker;
            },
            /***/
            2537(module2) {
              "use strict";
              var ceil = Math.ceil;
              var floor = Math.floor;
              module2.exports = Math.trunc || function trunc(x) {
                var n = +x;
                return (n > 0 ? floor : ceil)(n);
              };
            },
            /***/
            2538(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var DESCRIPTORS = __webpack_require__2(5144);
              var fails = __webpack_require__2(299);
              module2.exports = DESCRIPTORS && fails(function() {
                return Object.defineProperty(function() {
                }, "prototype", {
                  value: 42,
                  writable: false
                }).prototype !== 42;
              });
            },
            /***/
            2621(module2) {
              "use strict";
              module2.exports = function isNaN2(value) {
                return value !== value;
              };
            },
            /***/
            2657(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var isObject = __webpack_require__2(3598);
              module2.exports = function(argument) {
                return isObject(argument) || argument === null;
              };
            },
            /***/
            2719(module2) {
              "use strict";
              var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
              var toStr = Object.prototype.toString;
              var max = Math.max;
              var funcType = "[object Function]";
              var concatty = function concatty2(a, b) {
                var arr = [];
                for (var i = 0; i < a.length; i += 1) {
                  arr[i] = a[i];
                }
                for (var j = 0; j < b.length; j += 1) {
                  arr[j + a.length] = b[j];
                }
                return arr;
              };
              var slicy = function slicy2(arrLike, offset) {
                var arr = [];
                for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
                  arr[j] = arrLike[i];
                }
                return arr;
              };
              var joiny = function(arr, joiner) {
                var str = "";
                for (var i = 0; i < arr.length; i += 1) {
                  str += arr[i];
                  if (i + 1 < arr.length) {
                    str += joiner;
                  }
                }
                return str;
              };
              module2.exports = function bind(that) {
                var target = this;
                if (typeof target !== "function" || toStr.apply(target) !== funcType) {
                  throw new TypeError(ERROR_MESSAGE + target);
                }
                var args = slicy(arguments, 1);
                var bound;
                var binder = function() {
                  if (this instanceof bound) {
                    var result = target.apply(
                      this,
                      concatty(args, arguments)
                    );
                    if (Object(result) === result) {
                      return result;
                    }
                    return this;
                  }
                  return target.apply(
                    that,
                    concatty(args, arguments)
                  );
                };
                var boundLength = max(0, target.length - args.length);
                var boundArgs = [];
                for (var i = 0; i < boundLength; i++) {
                  boundArgs[i] = "$" + i;
                }
                bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
                if (target.prototype) {
                  var Empty = function Empty2() {
                  };
                  Empty.prototype = target.prototype;
                  bound.prototype = new Empty();
                  Empty.prototype = null;
                }
                return bound;
              };
            },
            /***/
            2736(module2, __unused_webpack_exports, __webpack_require__2) {
              module2.exports = __webpack_require__2(7133)["default"];
            },
            /***/
            2740(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var uncurryThis = __webpack_require__2(1212);
              module2.exports = uncurryThis([].slice);
            },
            /***/
            2774(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var GetIntrinsic = __webpack_require__2(8651);
              var callBindBasic = __webpack_require__2(6688);
              var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
              module2.exports = function callBoundIntrinsic(name, allowMissing) {
                var intrinsic = (
                  /** @type {(this: unknown, ...args: unknown[]) => unknown} */
                  GetIntrinsic(name, !!allowMissing)
                );
                if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
                  return callBindBasic(
                    /** @type {const} */
                    [intrinsic]
                  );
                }
                return intrinsic;
              };
            },
            /***/
            2843(module2) {
              "use strict";
              module2.exports = function hasSymbols() {
                if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
                  return false;
                }
                if (typeof Symbol.iterator === "symbol") {
                  return true;
                }
                var obj = {};
                var sym = Symbol("test");
                var symObj = Object(sym);
                if (typeof sym === "string") {
                  return false;
                }
                if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
                  return false;
                }
                if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
                  return false;
                }
                var symVal = 42;
                obj[sym] = symVal;
                for (var _ in obj) {
                  return false;
                }
                if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
                  return false;
                }
                if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
                  return false;
                }
                var syms = Object.getOwnPropertySymbols(obj);
                if (syms.length !== 1 || syms[0] !== sym) {
                  return false;
                }
                if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
                  return false;
                }
                if (typeof Object.getOwnPropertyDescriptor === "function") {
                  var descriptor = (
                    /** @type {PropertyDescriptor} */
                    Object.getOwnPropertyDescriptor(obj, sym)
                  );
                  if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                    return false;
                  }
                }
                return true;
              };
            },
            /***/
            2858(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(6818));
                } else {
                }
              })(void 0, function(CryptoJS) {
                CryptoJS.lib.Cipher || function(undefined2) {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var Base = C_lib.Base;
                  var WordArray = C_lib.WordArray;
                  var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
                  var C_enc = C.enc;
                  var Utf8 = C_enc.Utf8;
                  var Base64 = C_enc.Base64;
                  var C_algo = C.algo;
                  var EvpKDF = C_algo.EvpKDF;
                  var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
                    /**
                     * Configuration options.
                     *
                     * @property {WordArray} iv The IV to use for this operation.
                     */
                    cfg: Base.extend(),
                    /**
                     * Creates this cipher in encryption mode.
                     *
                     * @param {WordArray} key The key.
                     * @param {Object} cfg (Optional) The configuration options to use for this operation.
                     *
                     * @return {Cipher} A cipher instance.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
                     */
                    createEncryptor: function(key, cfg) {
                      return this.create(this._ENC_XFORM_MODE, key, cfg);
                    },
                    /**
                     * Creates this cipher in decryption mode.
                     *
                     * @param {WordArray} key The key.
                     * @param {Object} cfg (Optional) The configuration options to use for this operation.
                     *
                     * @return {Cipher} A cipher instance.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
                     */
                    createDecryptor: function(key, cfg) {
                      return this.create(this._DEC_XFORM_MODE, key, cfg);
                    },
                    /**
                     * Initializes a newly created cipher.
                     *
                     * @param {number} xformMode Either the encryption or decryption transormation mode constant.
                     * @param {WordArray} key The key.
                     * @param {Object} cfg (Optional) The configuration options to use for this operation.
                     *
                     * @example
                     *
                     *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
                     */
                    init: function(xformMode, key, cfg) {
                      this.cfg = this.cfg.extend(cfg);
                      this._xformMode = xformMode;
                      this._key = key;
                      this.reset();
                    },
                    /**
                     * Resets this cipher to its initial state.
                     *
                     * @example
                     *
                     *     cipher.reset();
                     */
                    reset: function() {
                      BufferedBlockAlgorithm.reset.call(this);
                      this._doReset();
                    },
                    /**
                     * Adds data to be encrypted or decrypted.
                     *
                     * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
                     *
                     * @return {WordArray} The data after processing.
                     *
                     * @example
                     *
                     *     var encrypted = cipher.process('data');
                     *     var encrypted = cipher.process(wordArray);
                     */
                    process: function(dataUpdate) {
                      this._append(dataUpdate);
                      return this._process();
                    },
                    /**
                     * Finalizes the encryption or decryption process.
                     * Note that the finalize operation is effectively a destructive, read-once operation.
                     *
                     * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
                     *
                     * @return {WordArray} The data after final processing.
                     *
                     * @example
                     *
                     *     var encrypted = cipher.finalize();
                     *     var encrypted = cipher.finalize('data');
                     *     var encrypted = cipher.finalize(wordArray);
                     */
                    finalize: function(dataUpdate) {
                      if (dataUpdate) {
                        this._append(dataUpdate);
                      }
                      var finalProcessedData = this._doFinalize();
                      return finalProcessedData;
                    },
                    keySize: 128 / 32,
                    ivSize: 128 / 32,
                    _ENC_XFORM_MODE: 1,
                    _DEC_XFORM_MODE: 2,
                    /**
                     * Creates shortcut functions to a cipher's object interface.
                     *
                     * @param {Cipher} cipher The cipher to create a helper for.
                     *
                     * @return {Object} An object with encrypt and decrypt shortcut functions.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
                     */
                    _createHelper: /* @__PURE__ */ function() {
                      function selectCipherStrategy(key) {
                        if (typeof key == "string") {
                          return PasswordBasedCipher;
                        } else {
                          return SerializableCipher;
                        }
                      }
                      return function(cipher) {
                        return {
                          encrypt: function(message, key, cfg) {
                            return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                          },
                          decrypt: function(ciphertext, key, cfg) {
                            return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                          }
                        };
                      };
                    }()
                  });
                  var StreamCipher = C_lib.StreamCipher = Cipher.extend({
                    _doFinalize: function() {
                      var finalProcessedBlocks = this._process(true);
                      return finalProcessedBlocks;
                    },
                    blockSize: 1
                  });
                  var C_mode = C.mode = {};
                  var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
                    /**
                     * Creates this mode for encryption.
                     *
                     * @param {Cipher} cipher A block cipher instance.
                     * @param {Array} iv The IV words.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
                     */
                    createEncryptor: function(cipher, iv) {
                      return this.Encryptor.create(cipher, iv);
                    },
                    /**
                     * Creates this mode for decryption.
                     *
                     * @param {Cipher} cipher A block cipher instance.
                     * @param {Array} iv The IV words.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
                     */
                    createDecryptor: function(cipher, iv) {
                      return this.Decryptor.create(cipher, iv);
                    },
                    /**
                     * Initializes a newly created mode.
                     *
                     * @param {Cipher} cipher A block cipher instance.
                     * @param {Array} iv The IV words.
                     *
                     * @example
                     *
                     *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
                     */
                    init: function(cipher, iv) {
                      this._cipher = cipher;
                      this._iv = iv;
                    }
                  });
                  var CBC = C_mode.CBC = function() {
                    var CBC2 = BlockCipherMode.extend();
                    CBC2.Encryptor = CBC2.extend({
                      /**
                       * Processes the data block at offset.
                       *
                       * @param {Array} words The data words to operate on.
                       * @param {number} offset The offset where the block starts.
                       *
                       * @example
                       *
                       *     mode.processBlock(data.words, offset);
                       */
                      processBlock: function(words, offset) {
                        var cipher = this._cipher;
                        var blockSize = cipher.blockSize;
                        xorBlock.call(this, words, offset, blockSize);
                        cipher.encryptBlock(words, offset);
                        this._prevBlock = words.slice(offset, offset + blockSize);
                      }
                    });
                    CBC2.Decryptor = CBC2.extend({
                      /**
                       * Processes the data block at offset.
                       *
                       * @param {Array} words The data words to operate on.
                       * @param {number} offset The offset where the block starts.
                       *
                       * @example
                       *
                       *     mode.processBlock(data.words, offset);
                       */
                      processBlock: function(words, offset) {
                        var cipher = this._cipher;
                        var blockSize = cipher.blockSize;
                        var thisBlock = words.slice(offset, offset + blockSize);
                        cipher.decryptBlock(words, offset);
                        xorBlock.call(this, words, offset, blockSize);
                        this._prevBlock = thisBlock;
                      }
                    });
                    function xorBlock(words, offset, blockSize) {
                      var block;
                      var iv = this._iv;
                      if (iv) {
                        block = iv;
                        this._iv = undefined2;
                      } else {
                        block = this._prevBlock;
                      }
                      for (var i = 0; i < blockSize; i++) {
                        words[offset + i] ^= block[i];
                      }
                    }
                    return CBC2;
                  }();
                  var C_pad = C.pad = {};
                  var Pkcs7 = C_pad.Pkcs7 = {
                    /**
                     * Pads data using the algorithm defined in PKCS #5/7.
                     *
                     * @param {WordArray} data The data to pad.
                     * @param {number} blockSize The multiple that the data should be padded to.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
                     */
                    pad: function(data, blockSize) {
                      var blockSizeBytes = blockSize * 4;
                      var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
                      var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
                      var paddingWords = [];
                      for (var i = 0; i < nPaddingBytes; i += 4) {
                        paddingWords.push(paddingWord);
                      }
                      var padding = WordArray.create(paddingWords, nPaddingBytes);
                      data.concat(padding);
                    },
                    /**
                     * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
                     *
                     * @param {WordArray} data The data to unpad.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     CryptoJS.pad.Pkcs7.unpad(wordArray);
                     */
                    unpad: function(data) {
                      var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
                      data.sigBytes -= nPaddingBytes;
                    }
                  };
                  var BlockCipher = C_lib.BlockCipher = Cipher.extend({
                    /**
                     * Configuration options.
                     *
                     * @property {Mode} mode The block mode to use. Default: CBC
                     * @property {Padding} padding The padding strategy to use. Default: Pkcs7
                     */
                    cfg: Cipher.cfg.extend({
                      mode: CBC,
                      padding: Pkcs7
                    }),
                    reset: function() {
                      var modeCreator;
                      Cipher.reset.call(this);
                      var cfg = this.cfg;
                      var iv = cfg.iv;
                      var mode = cfg.mode;
                      if (this._xformMode == this._ENC_XFORM_MODE) {
                        modeCreator = mode.createEncryptor;
                      } else {
                        modeCreator = mode.createDecryptor;
                        this._minBufferSize = 1;
                      }
                      if (this._mode && this._mode.__creator == modeCreator) {
                        this._mode.init(this, iv && iv.words);
                      } else {
                        this._mode = modeCreator.call(mode, this, iv && iv.words);
                        this._mode.__creator = modeCreator;
                      }
                    },
                    _doProcessBlock: function(words, offset) {
                      this._mode.processBlock(words, offset);
                    },
                    _doFinalize: function() {
                      var finalProcessedBlocks;
                      var padding = this.cfg.padding;
                      if (this._xformMode == this._ENC_XFORM_MODE) {
                        padding.pad(this._data, this.blockSize);
                        finalProcessedBlocks = this._process(true);
                      } else {
                        finalProcessedBlocks = this._process(true);
                        padding.unpad(finalProcessedBlocks);
                      }
                      return finalProcessedBlocks;
                    },
                    blockSize: 128 / 32
                  });
                  var CipherParams = C_lib.CipherParams = Base.extend({
                    /**
                     * Initializes a newly created cipher params object.
                     *
                     * @param {Object} cipherParams An object with any of the possible cipher parameters.
                     *
                     * @example
                     *
                     *     var cipherParams = CryptoJS.lib.CipherParams.create({
                     *         ciphertext: ciphertextWordArray,
                     *         key: keyWordArray,
                     *         iv: ivWordArray,
                     *         salt: saltWordArray,
                     *         algorithm: CryptoJS.algo.AES,
                     *         mode: CryptoJS.mode.CBC,
                     *         padding: CryptoJS.pad.PKCS7,
                     *         blockSize: 4,
                     *         formatter: CryptoJS.format.OpenSSL
                     *     });
                     */
                    init: function(cipherParams) {
                      this.mixIn(cipherParams);
                    },
                    /**
                     * Converts this cipher params object to a string.
                     *
                     * @param {Format} formatter (Optional) The formatting strategy to use.
                     *
                     * @return {string} The stringified cipher params.
                     *
                     * @throws Error If neither the formatter nor the default formatter is set.
                     *
                     * @example
                     *
                     *     var string = cipherParams + '';
                     *     var string = cipherParams.toString();
                     *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
                     */
                    toString: function(formatter) {
                      return (formatter || this.formatter).stringify(this);
                    }
                  });
                  var C_format = C.format = {};
                  var OpenSSLFormatter = C_format.OpenSSL = {
                    /**
                     * Converts a cipher params object to an OpenSSL-compatible string.
                     *
                     * @param {CipherParams} cipherParams The cipher params object.
                     *
                     * @return {string} The OpenSSL-compatible string.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
                     */
                    stringify: function(cipherParams) {
                      var wordArray;
                      var ciphertext = cipherParams.ciphertext;
                      var salt = cipherParams.salt;
                      if (salt) {
                        wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
                      } else {
                        wordArray = ciphertext;
                      }
                      return wordArray.toString(Base64);
                    },
                    /**
                     * Converts an OpenSSL-compatible string to a cipher params object.
                     *
                     * @param {string} openSSLStr The OpenSSL-compatible string.
                     *
                     * @return {CipherParams} The cipher params object.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
                     */
                    parse: function(openSSLStr) {
                      var salt;
                      var ciphertext = Base64.parse(openSSLStr);
                      var ciphertextWords = ciphertext.words;
                      if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
                        salt = WordArray.create(ciphertextWords.slice(2, 4));
                        ciphertextWords.splice(0, 4);
                        ciphertext.sigBytes -= 16;
                      }
                      return CipherParams.create({
                        ciphertext,
                        salt
                      });
                    }
                  };
                  var SerializableCipher = C_lib.SerializableCipher = Base.extend({
                    /**
                     * Configuration options.
                     *
                     * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
                     */
                    cfg: Base.extend({
                      format: OpenSSLFormatter
                    }),
                    /**
                     * Encrypts a message.
                     *
                     * @param {Cipher} cipher The cipher algorithm to use.
                     * @param {WordArray|string} message The message to encrypt.
                     * @param {WordArray} key The key.
                     * @param {Object} cfg (Optional) The configuration options to use for this operation.
                     *
                     * @return {CipherParams} A cipher params object.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
                     *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
                     *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                     */
                    encrypt: function(cipher, message, key, cfg) {
                      cfg = this.cfg.extend(cfg);
                      var encryptor = cipher.createEncryptor(key, cfg);
                      var ciphertext = encryptor.finalize(message);
                      var cipherCfg = encryptor.cfg;
                      return CipherParams.create({
                        ciphertext,
                        key,
                        iv: cipherCfg.iv,
                        algorithm: cipher,
                        mode: cipherCfg.mode,
                        padding: cipherCfg.padding,
                        blockSize: cipher.blockSize,
                        formatter: cfg.format
                      });
                    },
                    /**
                     * Decrypts serialized ciphertext.
                     *
                     * @param {Cipher} cipher The cipher algorithm to use.
                     * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
                     * @param {WordArray} key The key.
                     * @param {Object} cfg (Optional) The configuration options to use for this operation.
                     *
                     * @return {WordArray} The plaintext.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                     *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                     */
                    decrypt: function(cipher, ciphertext, key, cfg) {
                      cfg = this.cfg.extend(cfg);
                      ciphertext = this._parse(ciphertext, cfg.format);
                      var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
                      return plaintext;
                    },
                    /**
                     * Converts serialized ciphertext to CipherParams,
                     * else assumed CipherParams already and returns ciphertext unchanged.
                     *
                     * @param {CipherParams|string} ciphertext The ciphertext.
                     * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
                     *
                     * @return {CipherParams} The unserialized ciphertext.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
                     */
                    _parse: function(ciphertext, format) {
                      if (typeof ciphertext == "string") {
                        return format.parse(ciphertext, this);
                      } else {
                        return ciphertext;
                      }
                    }
                  });
                  var C_kdf = C.kdf = {};
                  var OpenSSLKdf = C_kdf.OpenSSL = {
                    /**
                     * Derives a key and IV from a password.
                     *
                     * @param {string} password The password to derive from.
                     * @param {number} keySize The size in words of the key to generate.
                     * @param {number} ivSize The size in words of the IV to generate.
                     * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
                     *
                     * @return {CipherParams} A cipher params object with the key, IV, and salt.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
                     *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
                     */
                    execute: function(password, keySize, ivSize, salt, hasher) {
                      if (!salt) {
                        salt = WordArray.random(64 / 8);
                      }
                      if (!hasher) {
                        var key = EvpKDF.create({
                          keySize: keySize + ivSize
                        }).compute(password, salt);
                      } else {
                        var key = EvpKDF.create({
                          keySize: keySize + ivSize,
                          hasher
                        }).compute(password, salt);
                      }
                      var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
                      key.sigBytes = keySize * 4;
                      return CipherParams.create({
                        key,
                        iv,
                        salt
                      });
                    }
                  };
                  var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
                    /**
                     * Configuration options.
                     *
                     * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
                     */
                    cfg: SerializableCipher.cfg.extend({
                      kdf: OpenSSLKdf
                    }),
                    /**
                     * Encrypts a message using a password.
                     *
                     * @param {Cipher} cipher The cipher algorithm to use.
                     * @param {WordArray|string} message The message to encrypt.
                     * @param {string} password The password.
                     * @param {Object} cfg (Optional) The configuration options to use for this operation.
                     *
                     * @return {CipherParams} A cipher params object.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
                     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
                     */
                    encrypt: function(cipher, message, password, cfg) {
                      cfg = this.cfg.extend(cfg);
                      var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
                      cfg.iv = derivedParams.iv;
                      var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
                      ciphertext.mixIn(derivedParams);
                      return ciphertext;
                    },
                    /**
                     * Decrypts serialized ciphertext using a password.
                     *
                     * @param {Cipher} cipher The cipher algorithm to use.
                     * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
                     * @param {string} password The password.
                     * @param {Object} cfg (Optional) The configuration options to use for this operation.
                     *
                     * @return {WordArray} The plaintext.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
                     *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
                     */
                    decrypt: function(cipher, ciphertext, password, cfg) {
                      cfg = this.cfg.extend(cfg);
                      ciphertext = this._parse(ciphertext, cfg.format);
                      var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
                      cfg.iv = derivedParams.iv;
                      var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
                      return plaintext;
                    }
                  });
                }();
              });
            },
            /***/
            2908(__unused_webpack_module, exports2, __webpack_require__2) {
              "use strict";
              var Buffer = __webpack_require__2(783)["Buffer"];
              var process = __webpack_require__2(9964);
              var assert = __webpack_require__2(7801);
              var Zstream = __webpack_require__2(7468);
              var zlib_deflate = __webpack_require__2(2925);
              var zlib_inflate = __webpack_require__2(2269);
              var constants = __webpack_require__2(1607);
              for (var key in constants) {
                exports2[key] = constants[key];
              }
              exports2.NONE = 0;
              exports2.DEFLATE = 1;
              exports2.INFLATE = 2;
              exports2.GZIP = 3;
              exports2.GUNZIP = 4;
              exports2.DEFLATERAW = 5;
              exports2.INFLATERAW = 6;
              exports2.UNZIP = 7;
              var GZIP_HEADER_ID1 = 31;
              var GZIP_HEADER_ID2 = 139;
              function Zlib(mode) {
                if (typeof mode !== "number" || mode < exports2.DEFLATE || mode > exports2.UNZIP) {
                  throw new TypeError("Bad argument");
                }
                this.dictionary = null;
                this.err = 0;
                this.flush = 0;
                this.init_done = false;
                this.level = 0;
                this.memLevel = 0;
                this.mode = mode;
                this.strategy = 0;
                this.windowBits = 0;
                this.write_in_progress = false;
                this.pending_close = false;
                this.gzip_id_bytes_read = 0;
              }
              Zlib.prototype.close = function() {
                if (this.write_in_progress) {
                  this.pending_close = true;
                  return;
                }
                this.pending_close = false;
                assert(this.init_done, "close before init");
                assert(this.mode <= exports2.UNZIP);
                if (this.mode === exports2.DEFLATE || this.mode === exports2.GZIP || this.mode === exports2.DEFLATERAW) {
                  zlib_deflate.deflateEnd(this.strm);
                } else if (this.mode === exports2.INFLATE || this.mode === exports2.GUNZIP || this.mode === exports2.INFLATERAW || this.mode === exports2.UNZIP) {
                  zlib_inflate.inflateEnd(this.strm);
                }
                this.mode = exports2.NONE;
                this.dictionary = null;
              };
              Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
                return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
              };
              Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
                return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
              };
              Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
                assert.equal(arguments.length, 8);
                assert(this.init_done, "write before init");
                assert(this.mode !== exports2.NONE, "already finalized");
                assert.equal(false, this.write_in_progress, "write already in progress");
                assert.equal(false, this.pending_close, "close is pending");
                this.write_in_progress = true;
                assert.equal(false, flush === void 0, "must provide flush value");
                this.write_in_progress = true;
                if (flush !== exports2.Z_NO_FLUSH && flush !== exports2.Z_PARTIAL_FLUSH && flush !== exports2.Z_SYNC_FLUSH && flush !== exports2.Z_FULL_FLUSH && flush !== exports2.Z_FINISH && flush !== exports2.Z_BLOCK) {
                  throw new Error("Invalid flush value");
                }
                if (input == null) {
                  input = Buffer.alloc(0);
                  in_len = 0;
                  in_off = 0;
                }
                this.strm.avail_in = in_len;
                this.strm.input = input;
                this.strm.next_in = in_off;
                this.strm.avail_out = out_len;
                this.strm.output = out;
                this.strm.next_out = out_off;
                this.flush = flush;
                if (!async) {
                  this._process();
                  if (this._checkError()) {
                    return this._afterSync();
                  }
                  return;
                }
                var self2 = this;
                process.nextTick(function() {
                  self2._process();
                  self2._after();
                });
                return this;
              };
              Zlib.prototype._afterSync = function() {
                var avail_out = this.strm.avail_out;
                var avail_in = this.strm.avail_in;
                this.write_in_progress = false;
                return [avail_in, avail_out];
              };
              Zlib.prototype._process = function() {
                var next_expected_header_byte = null;
                switch (this.mode) {
                  case exports2.DEFLATE:
                  case exports2.GZIP:
                  case exports2.DEFLATERAW:
                    this.err = zlib_deflate.deflate(this.strm, this.flush);
                    break;
                  case exports2.UNZIP:
                    if (this.strm.avail_in > 0) {
                      next_expected_header_byte = this.strm.next_in;
                    }
                    switch (this.gzip_id_bytes_read) {
                      case 0:
                        if (next_expected_header_byte === null) {
                          break;
                        }
                        if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
                          this.gzip_id_bytes_read = 1;
                          next_expected_header_byte++;
                          if (this.strm.avail_in === 1) {
                            break;
                          }
                        } else {
                          this.mode = exports2.INFLATE;
                          break;
                        }
                      case 1:
                        if (next_expected_header_byte === null) {
                          break;
                        }
                        if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
                          this.gzip_id_bytes_read = 2;
                          this.mode = exports2.GUNZIP;
                        } else {
                          this.mode = exports2.INFLATE;
                        }
                        break;
                      default:
                        throw new Error("invalid number of gzip magic number bytes read");
                    }
                  case exports2.INFLATE:
                  case exports2.GUNZIP:
                  case exports2.INFLATERAW:
                    this.err = zlib_inflate.inflate(
                      this.strm,
                      this.flush
                      // If data was encoded with dictionary
                    );
                    if (this.err === exports2.Z_NEED_DICT && this.dictionary) {
                      this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
                      if (this.err === exports2.Z_OK) {
                        this.err = zlib_inflate.inflate(this.strm, this.flush);
                      } else if (this.err === exports2.Z_DATA_ERROR) {
                        this.err = exports2.Z_NEED_DICT;
                      }
                    }
                    while (this.strm.avail_in > 0 && this.mode === exports2.GUNZIP && this.err === exports2.Z_STREAM_END && this.strm.next_in[0] !== 0) {
                      this.reset();
                      this.err = zlib_inflate.inflate(this.strm, this.flush);
                    }
                    break;
                  default:
                    throw new Error("Unknown mode " + this.mode);
                }
              };
              Zlib.prototype._checkError = function() {
                switch (this.err) {
                  case exports2.Z_OK:
                  case exports2.Z_BUF_ERROR:
                    if (this.strm.avail_out !== 0 && this.flush === exports2.Z_FINISH) {
                      this._error("unexpected end of file");
                      return false;
                    }
                    break;
                  case exports2.Z_STREAM_END:
                    break;
                  case exports2.Z_NEED_DICT:
                    if (this.dictionary == null) {
                      this._error("Missing dictionary");
                    } else {
                      this._error("Bad dictionary");
                    }
                    return false;
                  default:
                    this._error("Zlib error");
                    return false;
                }
                return true;
              };
              Zlib.prototype._after = function() {
                if (!this._checkError()) {
                  return;
                }
                var avail_out = this.strm.avail_out;
                var avail_in = this.strm.avail_in;
                this.write_in_progress = false;
                this.callback(avail_in, avail_out);
                if (this.pending_close) {
                  this.close();
                }
              };
              Zlib.prototype._error = function(message) {
                if (this.strm.msg) {
                  message = this.strm.msg;
                }
                this.onerror(
                  message,
                  this.err
                  // no hope of rescue.
                );
                this.write_in_progress = false;
                if (this.pending_close) {
                  this.close();
                }
              };
              Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
                assert(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
                assert(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
                assert(level >= -1 && level <= 9, "invalid compression level");
                assert(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
                assert(strategy === exports2.Z_FILTERED || strategy === exports2.Z_HUFFMAN_ONLY || strategy === exports2.Z_RLE || strategy === exports2.Z_FIXED || strategy === exports2.Z_DEFAULT_STRATEGY, "invalid strategy");
                this._init(level, windowBits, memLevel, strategy, dictionary);
                this._setDictionary();
              };
              Zlib.prototype.params = function() {
                throw new Error("deflateParams Not supported");
              };
              Zlib.prototype.reset = function() {
                this._reset();
                this._setDictionary();
              };
              Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
                this.level = level;
                this.windowBits = windowBits;
                this.memLevel = memLevel;
                this.strategy = strategy;
                this.flush = exports2.Z_NO_FLUSH;
                this.err = exports2.Z_OK;
                if (this.mode === exports2.GZIP || this.mode === exports2.GUNZIP) {
                  this.windowBits += 16;
                }
                if (this.mode === exports2.UNZIP) {
                  this.windowBits += 32;
                }
                if (this.mode === exports2.DEFLATERAW || this.mode === exports2.INFLATERAW) {
                  this.windowBits = -1 * this.windowBits;
                }
                this.strm = new Zstream();
                switch (this.mode) {
                  case exports2.DEFLATE:
                  case exports2.GZIP:
                  case exports2.DEFLATERAW:
                    this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports2.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
                    break;
                  case exports2.INFLATE:
                  case exports2.GUNZIP:
                  case exports2.INFLATERAW:
                  case exports2.UNZIP:
                    this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
                    break;
                  default:
                    throw new Error("Unknown mode " + this.mode);
                }
                if (this.err !== exports2.Z_OK) {
                  this._error("Init error");
                }
                this.dictionary = dictionary;
                this.write_in_progress = false;
                this.init_done = true;
              };
              Zlib.prototype._setDictionary = function() {
                if (this.dictionary == null) {
                  return;
                }
                this.err = exports2.Z_OK;
                switch (this.mode) {
                  case exports2.DEFLATE:
                  case exports2.DEFLATERAW:
                    this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
                    break;
                  default:
                    break;
                }
                if (this.err !== exports2.Z_OK) {
                  this._error("Failed to set dictionary");
                }
              };
              Zlib.prototype._reset = function() {
                this.err = exports2.Z_OK;
                switch (this.mode) {
                  case exports2.DEFLATE:
                  case exports2.DEFLATERAW:
                  case exports2.GZIP:
                    this.err = zlib_deflate.deflateReset(this.strm);
                    break;
                  case exports2.INFLATE:
                  case exports2.INFLATERAW:
                  case exports2.GUNZIP:
                    this.err = zlib_inflate.inflateReset(this.strm);
                    break;
                  default:
                    break;
                }
                if (this.err !== exports2.Z_OK) {
                  this._error("Failed to reset stream");
                }
              };
              exports2.Zlib = Zlib;
            },
            /***/
            2920(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var utils = __webpack_require__2(2519);
              var MAXBITS = 15;
              var ENOUGH_LENS = 852;
              var ENOUGH_DISTS = 592;
              var CODES = 0;
              var LENS = 1;
              var DISTS = 2;
              var lbase = [
                /* Length codes 257..285 base */
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                13,
                15,
                17,
                19,
                23,
                27,
                31,
                35,
                43,
                51,
                59,
                67,
                83,
                99,
                115,
                131,
                163,
                195,
                227,
                258,
                0,
                0
              ];
              var lext = [
                /* Length codes 257..285 extra */
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                17,
                17,
                17,
                17,
                18,
                18,
                18,
                18,
                19,
                19,
                19,
                19,
                20,
                20,
                20,
                20,
                21,
                21,
                21,
                21,
                16,
                72,
                78
              ];
              var dbase = [
                /* Distance codes 0..29 base */
                1,
                2,
                3,
                4,
                5,
                7,
                9,
                13,
                17,
                25,
                33,
                49,
                65,
                97,
                129,
                193,
                257,
                385,
                513,
                769,
                1025,
                1537,
                2049,
                3073,
                4097,
                6145,
                8193,
                12289,
                16385,
                24577,
                0,
                0
              ];
              var dext = [
                /* Distance codes 0..29 extra */
                16,
                16,
                16,
                16,
                17,
                17,
                18,
                18,
                19,
                19,
                20,
                20,
                21,
                21,
                22,
                22,
                23,
                23,
                24,
                24,
                25,
                25,
                26,
                26,
                27,
                27,
                28,
                28,
                29,
                29,
                64,
                64
              ];
              module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
                var bits = opts.bits;
                var len = 0;
                var sym = 0;
                var min = 0, max = 0;
                var root = 0;
                var curr = 0;
                var drop = 0;
                var left = 0;
                var used = 0;
                var huff = 0;
                var incr;
                var fill;
                var low;
                var mask;
                var next;
                var base = null;
                var base_index = 0;
                var end;
                var count = new utils.Buf16(MAXBITS + 1);
                var offs = new utils.Buf16(MAXBITS + 1);
                var extra = null;
                var extra_index = 0;
                var here_bits, here_op, here_val;
                for (len = 0; len <= MAXBITS; len++) {
                  count[len] = 0;
                }
                for (sym = 0; sym < codes; sym++) {
                  count[lens[lens_index + sym]]++;
                }
                root = bits;
                for (max = MAXBITS; max >= 1; max--) {
                  if (count[max] !== 0) {
                    break;
                  }
                }
                if (root > max) {
                  root = max;
                }
                if (max === 0) {
                  table[table_index++] = 1 << 24 | 64 << 16 | 0;
                  table[table_index++] = 1 << 24 | 64 << 16 | 0;
                  opts.bits = 1;
                  return 0;
                }
                for (min = 1; min < max; min++) {
                  if (count[min] !== 0) {
                    break;
                  }
                }
                if (root < min) {
                  root = min;
                }
                left = 1;
                for (len = 1; len <= MAXBITS; len++) {
                  left <<= 1;
                  left -= count[len];
                  if (left < 0) {
                    return -1;
                  }
                }
                if (left > 0 && (type === CODES || max !== 1)) {
                  return -1;
                }
                offs[1] = 0;
                for (len = 1; len < MAXBITS; len++) {
                  offs[len + 1] = offs[len] + count[len];
                }
                for (sym = 0; sym < codes; sym++) {
                  if (lens[lens_index + sym] !== 0) {
                    work[offs[lens[lens_index + sym]]++] = sym;
                  }
                }
                if (type === CODES) {
                  base = extra = work;
                  end = 19;
                } else if (type === LENS) {
                  base = lbase;
                  base_index -= 257;
                  extra = lext;
                  extra_index -= 257;
                  end = 256;
                } else {
                  base = dbase;
                  extra = dext;
                  end = -1;
                }
                huff = 0;
                sym = 0;
                len = min;
                next = table_index;
                curr = root;
                drop = 0;
                low = -1;
                used = 1 << root;
                mask = used - 1;
                if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
                  return 1;
                }
                for (; ; ) {
                  here_bits = len - drop;
                  if (work[sym] < end) {
                    here_op = 0;
                    here_val = work[sym];
                  } else if (work[sym] > end) {
                    here_op = extra[extra_index + work[sym]];
                    here_val = base[base_index + work[sym]];
                  } else {
                    here_op = 32 + 64;
                    here_val = 0;
                  }
                  incr = 1 << len - drop;
                  fill = 1 << curr;
                  min = fill;
                  do {
                    fill -= incr;
                    table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
                  } while (fill !== 0);
                  incr = 1 << len - 1;
                  while (huff & incr) {
                    incr >>= 1;
                  }
                  if (incr !== 0) {
                    huff &= incr - 1;
                    huff += incr;
                  } else {
                    huff = 0;
                  }
                  sym++;
                  if (--count[len] === 0) {
                    if (len === max) {
                      break;
                    }
                    len = lens[lens_index + work[sym]];
                  }
                  if (len > root && (huff & mask) !== low) {
                    if (drop === 0) {
                      drop = root;
                    }
                    next += min;
                    curr = len - drop;
                    left = 1 << curr;
                    while (curr + drop < max) {
                      left -= count[curr + drop];
                      if (left <= 0) {
                        break;
                      }
                      curr++;
                      left <<= 1;
                    }
                    used += 1 << curr;
                    if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
                      return 1;
                    }
                    low = huff & mask;
                    table[low] = root << 24 | curr << 16 | next - table_index | 0;
                  }
                }
                if (huff !== 0) {
                  table[next + huff] = len - drop << 24 | 64 << 16 | 0;
                }
                opts.bits = root;
                return 0;
              };
            },
            /***/
            2925(__unused_webpack_module, exports2, __webpack_require__2) {
              "use strict";
              var utils = __webpack_require__2(2519);
              var trees = __webpack_require__2(2367);
              var adler32 = __webpack_require__2(6911);
              var crc32 = __webpack_require__2(9049);
              var msg = __webpack_require__2(6228);
              var Z_NO_FLUSH = 0;
              var Z_PARTIAL_FLUSH = 1;
              var Z_FULL_FLUSH = 3;
              var Z_FINISH = 4;
              var Z_BLOCK = 5;
              var Z_OK = 0;
              var Z_STREAM_END = 1;
              var Z_STREAM_ERROR = -2;
              var Z_DATA_ERROR = -3;
              var Z_BUF_ERROR = -5;
              var Z_DEFAULT_COMPRESSION = -1;
              var Z_FILTERED = 1;
              var Z_HUFFMAN_ONLY = 2;
              var Z_RLE = 3;
              var Z_FIXED = 4;
              var Z_DEFAULT_STRATEGY = 0;
              var Z_UNKNOWN = 2;
              var Z_DEFLATED = 8;
              var MAX_MEM_LEVEL = 9;
              var MAX_WBITS = 15;
              var DEF_MEM_LEVEL = 8;
              var LENGTH_CODES = 29;
              var LITERALS = 256;
              var L_CODES = LITERALS + 1 + LENGTH_CODES;
              var D_CODES = 30;
              var BL_CODES = 19;
              var HEAP_SIZE = 2 * L_CODES + 1;
              var MAX_BITS = 15;
              var MIN_MATCH = 3;
              var MAX_MATCH = 258;
              var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
              var PRESET_DICT = 32;
              var INIT_STATE = 42;
              var EXTRA_STATE = 69;
              var NAME_STATE = 73;
              var COMMENT_STATE = 91;
              var HCRC_STATE = 103;
              var BUSY_STATE = 113;
              var FINISH_STATE = 666;
              var BS_NEED_MORE = 1;
              var BS_BLOCK_DONE = 2;
              var BS_FINISH_STARTED = 3;
              var BS_FINISH_DONE = 4;
              var OS_CODE = 3;
              function err(strm, errorCode) {
                strm.msg = msg[errorCode];
                return errorCode;
              }
              function rank(f) {
                return (f << 1) - (f > 4 ? 9 : 0);
              }
              function zero(buf) {
                var len = buf.length;
                while (--len >= 0) {
                  buf[len] = 0;
                }
              }
              function flush_pending(strm) {
                var s = strm.state;
                var len = s.pending;
                if (len > strm.avail_out) {
                  len = strm.avail_out;
                }
                if (len === 0) {
                  return;
                }
                utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
                strm.next_out += len;
                s.pending_out += len;
                strm.total_out += len;
                strm.avail_out -= len;
                s.pending -= len;
                if (s.pending === 0) {
                  s.pending_out = 0;
                }
              }
              function flush_block_only(s, last) {
                trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
                s.block_start = s.strstart;
                flush_pending(s.strm);
              }
              function put_byte(s, b) {
                s.pending_buf[s.pending++] = b;
              }
              function putShortMSB(s, b) {
                s.pending_buf[s.pending++] = b >>> 8 & 255;
                s.pending_buf[s.pending++] = b & 255;
              }
              function read_buf(strm, buf, start, size) {
                var len = strm.avail_in;
                if (len > size) {
                  len = size;
                }
                if (len === 0) {
                  return 0;
                }
                strm.avail_in -= len;
                utils.arraySet(buf, strm.input, strm.next_in, len, start);
                if (strm.state.wrap === 1) {
                  strm.adler = adler32(strm.adler, buf, len, start);
                } else if (strm.state.wrap === 2) {
                  strm.adler = crc32(strm.adler, buf, len, start);
                }
                strm.next_in += len;
                strm.total_in += len;
                return len;
              }
              function longest_match(s, cur_match) {
                var chain_length = s.max_chain_length;
                var scan = s.strstart;
                var match;
                var len;
                var best_len = s.prev_length;
                var nice_match = s.nice_match;
                var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
                var _win = s.window;
                var wmask = s.w_mask;
                var prev = s.prev;
                var strend = s.strstart + MAX_MATCH;
                var scan_end1 = _win[scan + best_len - 1];
                var scan_end = _win[scan + best_len];
                if (s.prev_length >= s.good_match) {
                  chain_length >>= 2;
                }
                if (nice_match > s.lookahead) {
                  nice_match = s.lookahead;
                }
                do {
                  match = cur_match;
                  if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
                    continue;
                  }
                  scan += 2;
                  match++;
                  do {
                  } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
                  len = MAX_MATCH - (strend - scan);
                  scan = strend - MAX_MATCH;
                  if (len > best_len) {
                    s.match_start = cur_match;
                    best_len = len;
                    if (len >= nice_match) {
                      break;
                    }
                    scan_end1 = _win[scan + best_len - 1];
                    scan_end = _win[scan + best_len];
                  }
                } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
                if (best_len <= s.lookahead) {
                  return best_len;
                }
                return s.lookahead;
              }
              function fill_window(s) {
                var _w_size = s.w_size;
                var p, n, m, more, str;
                do {
                  more = s.window_size - s.lookahead - s.strstart;
                  if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
                    utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
                    s.match_start -= _w_size;
                    s.strstart -= _w_size;
                    s.block_start -= _w_size;
                    n = s.hash_size;
                    p = n;
                    do {
                      m = s.head[--p];
                      s.head[p] = m >= _w_size ? m - _w_size : 0;
                    } while (--n);
                    n = _w_size;
                    p = n;
                    do {
                      m = s.prev[--p];
                      s.prev[p] = m >= _w_size ? m - _w_size : 0;
                    } while (--n);
                    more += _w_size;
                  }
                  if (s.strm.avail_in === 0) {
                    break;
                  }
                  n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
                  s.lookahead += n;
                  if (s.lookahead + s.insert >= MIN_MATCH) {
                    str = s.strstart - s.insert;
                    s.ins_h = s.window[str];
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
                    while (s.insert) {
                      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                      s.prev[str & s.w_mask] = s.head[s.ins_h];
                      s.head[s.ins_h] = str;
                      str++;
                      s.insert--;
                      if (s.lookahead + s.insert < MIN_MATCH) {
                        break;
                      }
                    }
                  }
                } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
              }
              function deflate_stored(s, flush) {
                var max_block_size = 65535;
                if (max_block_size > s.pending_buf_size - 5) {
                  max_block_size = s.pending_buf_size - 5;
                }
                for (; ; ) {
                  if (s.lookahead <= 1) {
                    fill_window(s);
                    if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                      return BS_NEED_MORE;
                    }
                    if (s.lookahead === 0) {
                      break;
                    }
                  }
                  s.strstart += s.lookahead;
                  s.lookahead = 0;
                  var max_start = s.block_start + max_block_size;
                  if (s.strstart === 0 || s.strstart >= max_start) {
                    s.lookahead = s.strstart - max_start;
                    s.strstart = max_start;
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  }
                  if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  }
                }
                s.insert = 0;
                if (flush === Z_FINISH) {
                  flush_block_only(s, true);
                  if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                  }
                  return BS_FINISH_DONE;
                }
                if (s.strstart > s.block_start) {
                  flush_block_only(s, false);
                  if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                  }
                }
                return BS_NEED_MORE;
              }
              function deflate_fast(s, flush) {
                var hash_head;
                var bflush;
                for (; ; ) {
                  if (s.lookahead < MIN_LOOKAHEAD) {
                    fill_window(s);
                    if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                      return BS_NEED_MORE;
                    }
                    if (s.lookahead === 0) {
                      break;
                    }
                  }
                  hash_head = 0;
                  if (s.lookahead >= MIN_MATCH) {
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                  }
                  if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                    s.match_length = longest_match(s, hash_head);
                  }
                  if (s.match_length >= MIN_MATCH) {
                    bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
                    s.lookahead -= s.match_length;
                    if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                      s.match_length--;
                      do {
                        s.strstart++;
                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                      } while (--s.match_length !== 0);
                      s.strstart++;
                    } else {
                      s.strstart += s.match_length;
                      s.match_length = 0;
                      s.ins_h = s.window[s.strstart];
                      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
                    }
                  } else {
                    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                    s.lookahead--;
                    s.strstart++;
                  }
                  if (bflush) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  }
                }
                s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
                if (flush === Z_FINISH) {
                  flush_block_only(s, true);
                  if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                  }
                  return BS_FINISH_DONE;
                }
                if (s.last_lit) {
                  flush_block_only(s, false);
                  if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                  }
                }
                return BS_BLOCK_DONE;
              }
              function deflate_slow(s, flush) {
                var hash_head;
                var bflush;
                var max_insert;
                for (; ; ) {
                  if (s.lookahead < MIN_LOOKAHEAD) {
                    fill_window(s);
                    if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                      return BS_NEED_MORE;
                    }
                    if (s.lookahead === 0) {
                      break;
                    }
                  }
                  hash_head = 0;
                  if (s.lookahead >= MIN_MATCH) {
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                  }
                  s.prev_length = s.match_length;
                  s.prev_match = s.match_start;
                  s.match_length = MIN_MATCH - 1;
                  if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                    s.match_length = longest_match(s, hash_head);
                    if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
                      s.match_length = MIN_MATCH - 1;
                    }
                  }
                  if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                    max_insert = s.strstart + s.lookahead - MIN_MATCH;
                    bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
                    s.lookahead -= s.prev_length - 1;
                    s.prev_length -= 2;
                    do {
                      if (++s.strstart <= max_insert) {
                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                      }
                    } while (--s.prev_length !== 0);
                    s.match_available = 0;
                    s.match_length = MIN_MATCH - 1;
                    s.strstart++;
                    if (bflush) {
                      flush_block_only(s, false);
                      if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                      }
                    }
                  } else if (s.match_available) {
                    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
                    if (bflush) {
                      flush_block_only(s, false);
                    }
                    s.strstart++;
                    s.lookahead--;
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  } else {
                    s.match_available = 1;
                    s.strstart++;
                    s.lookahead--;
                  }
                }
                if (s.match_available) {
                  bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
                  s.match_available = 0;
                }
                s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
                if (flush === Z_FINISH) {
                  flush_block_only(s, true);
                  if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                  }
                  return BS_FINISH_DONE;
                }
                if (s.last_lit) {
                  flush_block_only(s, false);
                  if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                  }
                }
                return BS_BLOCK_DONE;
              }
              function deflate_rle(s, flush) {
                var bflush;
                var prev;
                var scan, strend;
                var _win = s.window;
                for (; ; ) {
                  if (s.lookahead <= MAX_MATCH) {
                    fill_window(s);
                    if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                      return BS_NEED_MORE;
                    }
                    if (s.lookahead === 0) {
                      break;
                    }
                  }
                  s.match_length = 0;
                  if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                    scan = s.strstart - 1;
                    prev = _win[scan];
                    if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                      strend = s.strstart + MAX_MATCH;
                      do {
                      } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                      s.match_length = MAX_MATCH - (strend - scan);
                      if (s.match_length > s.lookahead) {
                        s.match_length = s.lookahead;
                      }
                    }
                  }
                  if (s.match_length >= MIN_MATCH) {
                    bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
                    s.lookahead -= s.match_length;
                    s.strstart += s.match_length;
                    s.match_length = 0;
                  } else {
                    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                    s.lookahead--;
                    s.strstart++;
                  }
                  if (bflush) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  }
                }
                s.insert = 0;
                if (flush === Z_FINISH) {
                  flush_block_only(s, true);
                  if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                  }
                  return BS_FINISH_DONE;
                }
                if (s.last_lit) {
                  flush_block_only(s, false);
                  if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                  }
                }
                return BS_BLOCK_DONE;
              }
              function deflate_huff(s, flush) {
                var bflush;
                for (; ; ) {
                  if (s.lookahead === 0) {
                    fill_window(s);
                    if (s.lookahead === 0) {
                      if (flush === Z_NO_FLUSH) {
                        return BS_NEED_MORE;
                      }
                      break;
                    }
                  }
                  s.match_length = 0;
                  bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                  s.lookahead--;
                  s.strstart++;
                  if (bflush) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  }
                }
                s.insert = 0;
                if (flush === Z_FINISH) {
                  flush_block_only(s, true);
                  if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                  }
                  return BS_FINISH_DONE;
                }
                if (s.last_lit) {
                  flush_block_only(s, false);
                  if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                  }
                }
                return BS_BLOCK_DONE;
              }
              function Config(good_length, max_lazy, nice_length, max_chain, func) {
                this.good_length = good_length;
                this.max_lazy = max_lazy;
                this.nice_length = nice_length;
                this.max_chain = max_chain;
                this.func = func;
              }
              var configuration_table;
              configuration_table = [
                /*      good lazy nice chain */
                new Config(0, 0, 0, 0, deflate_stored),
                /* 0 store only */
                new Config(4, 4, 8, 4, deflate_fast),
                /* 1 max speed, no lazy matches */
                new Config(4, 5, 16, 8, deflate_fast),
                /* 2 */
                new Config(4, 6, 32, 32, deflate_fast),
                /* 3 */
                new Config(4, 4, 16, 16, deflate_slow),
                /* 4 lazy matches */
                new Config(8, 16, 32, 32, deflate_slow),
                /* 5 */
                new Config(8, 16, 128, 128, deflate_slow),
                /* 6 */
                new Config(8, 32, 128, 256, deflate_slow),
                /* 7 */
                new Config(32, 128, 258, 1024, deflate_slow),
                /* 8 */
                new Config(32, 258, 258, 4096, deflate_slow)
                /* 9 max compression */
              ];
              function lm_init(s) {
                s.window_size = 2 * s.w_size;
                zero(s.head);
                s.max_lazy_match = configuration_table[s.level].max_lazy;
                s.good_match = configuration_table[s.level].good_length;
                s.nice_match = configuration_table[s.level].nice_length;
                s.max_chain_length = configuration_table[s.level].max_chain;
                s.strstart = 0;
                s.block_start = 0;
                s.lookahead = 0;
                s.insert = 0;
                s.match_length = s.prev_length = MIN_MATCH - 1;
                s.match_available = 0;
                s.ins_h = 0;
              }
              function DeflateState() {
                this.strm = null;
                this.status = 0;
                this.pending_buf = null;
                this.pending_buf_size = 0;
                this.pending_out = 0;
                this.pending = 0;
                this.wrap = 0;
                this.gzhead = null;
                this.gzindex = 0;
                this.method = Z_DEFLATED;
                this.last_flush = -1;
                this.w_size = 0;
                this.w_bits = 0;
                this.w_mask = 0;
                this.window = null;
                this.window_size = 0;
                this.prev = null;
                this.head = null;
                this.ins_h = 0;
                this.hash_size = 0;
                this.hash_bits = 0;
                this.hash_mask = 0;
                this.hash_shift = 0;
                this.block_start = 0;
                this.match_length = 0;
                this.prev_match = 0;
                this.match_available = 0;
                this.strstart = 0;
                this.match_start = 0;
                this.lookahead = 0;
                this.prev_length = 0;
                this.max_chain_length = 0;
                this.max_lazy_match = 0;
                this.level = 0;
                this.strategy = 0;
                this.good_match = 0;
                this.nice_match = 0;
                this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
                this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
                this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
                zero(this.dyn_ltree);
                zero(this.dyn_dtree);
                zero(this.bl_tree);
                this.l_desc = null;
                this.d_desc = null;
                this.bl_desc = null;
                this.bl_count = new utils.Buf16(MAX_BITS + 1);
                this.heap = new utils.Buf16(2 * L_CODES + 1);
                zero(this.heap);
                this.heap_len = 0;
                this.heap_max = 0;
                this.depth = new utils.Buf16(2 * L_CODES + 1);
                zero(this.depth);
                this.l_buf = 0;
                this.lit_bufsize = 0;
                this.last_lit = 0;
                this.d_buf = 0;
                this.opt_len = 0;
                this.static_len = 0;
                this.matches = 0;
                this.insert = 0;
                this.bi_buf = 0;
                this.bi_valid = 0;
              }
              function deflateResetKeep(strm) {
                var s;
                if (!strm || !strm.state) {
                  return err(strm, Z_STREAM_ERROR);
                }
                strm.total_in = strm.total_out = 0;
                strm.data_type = Z_UNKNOWN;
                s = strm.state;
                s.pending = 0;
                s.pending_out = 0;
                if (s.wrap < 0) {
                  s.wrap = -s.wrap;
                }
                s.status = s.wrap ? INIT_STATE : BUSY_STATE;
                strm.adler = s.wrap === 2 ? 0 : 1;
                s.last_flush = Z_NO_FLUSH;
                trees._tr_init(s);
                return Z_OK;
              }
              function deflateReset(strm) {
                var ret = deflateResetKeep(strm);
                if (ret === Z_OK) {
                  lm_init(strm.state);
                }
                return ret;
              }
              function deflateSetHeader(strm, head) {
                if (!strm || !strm.state) {
                  return Z_STREAM_ERROR;
                }
                if (strm.state.wrap !== 2) {
                  return Z_STREAM_ERROR;
                }
                strm.state.gzhead = head;
                return Z_OK;
              }
              function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
                if (!strm) {
                  return Z_STREAM_ERROR;
                }
                var wrap = 1;
                if (level === Z_DEFAULT_COMPRESSION) {
                  level = 6;
                }
                if (windowBits < 0) {
                  wrap = 0;
                  windowBits = -windowBits;
                } else if (windowBits > 15) {
                  wrap = 2;
                  windowBits -= 16;
                }
                if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
                  return err(strm, Z_STREAM_ERROR);
                }
                if (windowBits === 8) {
                  windowBits = 9;
                }
                var s = new DeflateState();
                strm.state = s;
                s.strm = strm;
                s.wrap = wrap;
                s.gzhead = null;
                s.w_bits = windowBits;
                s.w_size = 1 << s.w_bits;
                s.w_mask = s.w_size - 1;
                s.hash_bits = memLevel + 7;
                s.hash_size = 1 << s.hash_bits;
                s.hash_mask = s.hash_size - 1;
                s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
                s.window = new utils.Buf8(s.w_size * 2);
                s.head = new utils.Buf16(s.hash_size);
                s.prev = new utils.Buf16(s.w_size);
                s.lit_bufsize = 1 << memLevel + 6;
                s.pending_buf_size = s.lit_bufsize * 4;
                s.pending_buf = new utils.Buf8(s.pending_buf_size);
                s.d_buf = 1 * s.lit_bufsize;
                s.l_buf = (1 + 2) * s.lit_bufsize;
                s.level = level;
                s.strategy = strategy;
                s.method = method;
                return deflateReset(strm);
              }
              function deflateInit(strm, level) {
                return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
              }
              function deflate(strm, flush) {
                var old_flush, s;
                var beg, val;
                if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
                  return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
                }
                s = strm.state;
                if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
                  return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
                }
                s.strm = strm;
                old_flush = s.last_flush;
                s.last_flush = flush;
                if (s.status === INIT_STATE) {
                  if (s.wrap === 2) {
                    strm.adler = 0;
                    put_byte(s, 31);
                    put_byte(s, 139);
                    put_byte(s, 8);
                    if (!s.gzhead) {
                      put_byte(s, 0);
                      put_byte(s, 0);
                      put_byte(s, 0);
                      put_byte(s, 0);
                      put_byte(s, 0);
                      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                      put_byte(s, OS_CODE);
                      s.status = BUSY_STATE;
                    } else {
                      put_byte(
                        s,
                        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
                      );
                      put_byte(s, s.gzhead.time & 255);
                      put_byte(s, s.gzhead.time >> 8 & 255);
                      put_byte(s, s.gzhead.time >> 16 & 255);
                      put_byte(s, s.gzhead.time >> 24 & 255);
                      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                      put_byte(s, s.gzhead.os & 255);
                      if (s.gzhead.extra && s.gzhead.extra.length) {
                        put_byte(s, s.gzhead.extra.length & 255);
                        put_byte(s, s.gzhead.extra.length >> 8 & 255);
                      }
                      if (s.gzhead.hcrc) {
                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                      }
                      s.gzindex = 0;
                      s.status = EXTRA_STATE;
                    }
                  } else {
                    var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
                    var level_flags = -1;
                    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                      level_flags = 0;
                    } else if (s.level < 6) {
                      level_flags = 1;
                    } else if (s.level === 6) {
                      level_flags = 2;
                    } else {
                      level_flags = 3;
                    }
                    header |= level_flags << 6;
                    if (s.strstart !== 0) {
                      header |= PRESET_DICT;
                    }
                    header += 31 - header % 31;
                    s.status = BUSY_STATE;
                    putShortMSB(s, header);
                    if (s.strstart !== 0) {
                      putShortMSB(s, strm.adler >>> 16);
                      putShortMSB(s, strm.adler & 65535);
                    }
                    strm.adler = 1;
                  }
                }
                if (s.status === EXTRA_STATE) {
                  if (s.gzhead.extra) {
                    beg = s.pending;
                    while (s.gzindex < (s.gzhead.extra.length & 65535)) {
                      if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        beg = s.pending;
                        if (s.pending === s.pending_buf_size) {
                          break;
                        }
                      }
                      put_byte(s, s.gzhead.extra[s.gzindex] & 255);
                      s.gzindex++;
                    }
                    if (s.gzhead.hcrc && s.pending > beg) {
                      strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    if (s.gzindex === s.gzhead.extra.length) {
                      s.gzindex = 0;
                      s.status = NAME_STATE;
                    }
                  } else {
                    s.status = NAME_STATE;
                  }
                }
                if (s.status === NAME_STATE) {
                  if (s.gzhead.name) {
                    beg = s.pending;
                    do {
                      if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        beg = s.pending;
                        if (s.pending === s.pending_buf_size) {
                          val = 1;
                          break;
                        }
                      }
                      if (s.gzindex < s.gzhead.name.length) {
                        val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
                      } else {
                        val = 0;
                      }
                      put_byte(s, val);
                    } while (val !== 0);
                    if (s.gzhead.hcrc && s.pending > beg) {
                      strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    if (val === 0) {
                      s.gzindex = 0;
                      s.status = COMMENT_STATE;
                    }
                  } else {
                    s.status = COMMENT_STATE;
                  }
                }
                if (s.status === COMMENT_STATE) {
                  if (s.gzhead.comment) {
                    beg = s.pending;
                    do {
                      if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        beg = s.pending;
                        if (s.pending === s.pending_buf_size) {
                          val = 1;
                          break;
                        }
                      }
                      if (s.gzindex < s.gzhead.comment.length) {
                        val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
                      } else {
                        val = 0;
                      }
                      put_byte(s, val);
                    } while (val !== 0);
                    if (s.gzhead.hcrc && s.pending > beg) {
                      strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    if (val === 0) {
                      s.status = HCRC_STATE;
                    }
                  } else {
                    s.status = HCRC_STATE;
                  }
                }
                if (s.status === HCRC_STATE) {
                  if (s.gzhead.hcrc) {
                    if (s.pending + 2 > s.pending_buf_size) {
                      flush_pending(strm);
                    }
                    if (s.pending + 2 <= s.pending_buf_size) {
                      put_byte(s, strm.adler & 255);
                      put_byte(s, strm.adler >> 8 & 255);
                      strm.adler = 0;
                      s.status = BUSY_STATE;
                    }
                  } else {
                    s.status = BUSY_STATE;
                  }
                }
                if (s.pending !== 0) {
                  flush_pending(strm);
                  if (strm.avail_out === 0) {
                    s.last_flush = -1;
                    return Z_OK;
                  }
                } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
                  return err(strm, Z_BUF_ERROR);
                }
                if (s.status === FINISH_STATE && strm.avail_in !== 0) {
                  return err(strm, Z_BUF_ERROR);
                }
                if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
                  var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
                  if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                    s.status = FINISH_STATE;
                  }
                  if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                    if (strm.avail_out === 0) {
                      s.last_flush = -1;
                    }
                    return Z_OK;
                  }
                  if (bstate === BS_BLOCK_DONE) {
                    if (flush === Z_PARTIAL_FLUSH) {
                      trees._tr_align(s);
                    } else if (flush !== Z_BLOCK) {
                      trees._tr_stored_block(s, 0, 0, false);
                      if (flush === Z_FULL_FLUSH) {
                        zero(s.head);
                        if (s.lookahead === 0) {
                          s.strstart = 0;
                          s.block_start = 0;
                          s.insert = 0;
                        }
                      }
                    }
                    flush_pending(strm);
                    if (strm.avail_out === 0) {
                      s.last_flush = -1;
                      return Z_OK;
                    }
                  }
                }
                if (flush !== Z_FINISH) {
                  return Z_OK;
                }
                if (s.wrap <= 0) {
                  return Z_STREAM_END;
                }
                if (s.wrap === 2) {
                  put_byte(s, strm.adler & 255);
                  put_byte(s, strm.adler >> 8 & 255);
                  put_byte(s, strm.adler >> 16 & 255);
                  put_byte(s, strm.adler >> 24 & 255);
                  put_byte(s, strm.total_in & 255);
                  put_byte(s, strm.total_in >> 8 & 255);
                  put_byte(s, strm.total_in >> 16 & 255);
                  put_byte(s, strm.total_in >> 24 & 255);
                } else {
                  putShortMSB(s, strm.adler >>> 16);
                  putShortMSB(s, strm.adler & 65535);
                }
                flush_pending(strm);
                if (s.wrap > 0) {
                  s.wrap = -s.wrap;
                }
                return s.pending !== 0 ? Z_OK : Z_STREAM_END;
              }
              function deflateEnd(strm) {
                var status;
                if (!strm || !strm.state) {
                  return Z_STREAM_ERROR;
                }
                status = strm.state.status;
                if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
                  return err(strm, Z_STREAM_ERROR);
                }
                strm.state = null;
                return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
              }
              function deflateSetDictionary(strm, dictionary) {
                var dictLength = dictionary.length;
                var s;
                var str, n;
                var wrap;
                var avail;
                var next;
                var input;
                var tmpDict;
                if (!strm || !strm.state) {
                  return Z_STREAM_ERROR;
                }
                s = strm.state;
                wrap = s.wrap;
                if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
                  return Z_STREAM_ERROR;
                }
                if (wrap === 1) {
                  strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
                }
                s.wrap = 0;
                if (dictLength >= s.w_size) {
                  if (wrap === 0) {
                    zero(s.head);
                    s.strstart = 0;
                    s.block_start = 0;
                    s.insert = 0;
                  }
                  tmpDict = new utils.Buf8(s.w_size);
                  utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
                  dictionary = tmpDict;
                  dictLength = s.w_size;
                }
                avail = strm.avail_in;
                next = strm.next_in;
                input = strm.input;
                strm.avail_in = dictLength;
                strm.next_in = 0;
                strm.input = dictionary;
                fill_window(s);
                while (s.lookahead >= MIN_MATCH) {
                  str = s.strstart;
                  n = s.lookahead - (MIN_MATCH - 1);
                  do {
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                    s.prev[str & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = str;
                    str++;
                  } while (--n);
                  s.strstart = str;
                  s.lookahead = MIN_MATCH - 1;
                  fill_window(s);
                }
                s.strstart += s.lookahead;
                s.block_start = s.strstart;
                s.insert = s.lookahead;
                s.lookahead = 0;
                s.match_length = s.prev_length = MIN_MATCH - 1;
                s.match_available = 0;
                strm.next_in = next;
                strm.input = input;
                strm.avail_in = avail;
                s.wrap = wrap;
                return Z_OK;
              }
              exports2.deflateInit = deflateInit;
              exports2.deflateInit2 = deflateInit2;
              exports2.deflateReset = deflateReset;
              exports2.deflateResetKeep = deflateResetKeep;
              exports2.deflateSetHeader = deflateSetHeader;
              exports2.deflate = deflate;
              exports2.deflateEnd = deflateEnd;
              exports2.deflateSetDictionary = deflateSetDictionary;
              exports2.deflateInfo = "pako deflate (from Nodeca project)";
            },
            /***/
            2993(module2) {
              "use strict";
              module2.exports = {};
            },
            /***/
            3011(module2) {
              "use strict";
              const cached = (
                /** @type {GeneratorFunctionConstructor} */
                (function* () {
                }).constructor
              );
              module2.exports = () => cached;
            },
            /***/
            3018(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var toPrimitive = __webpack_require__2(3301);
              var $TypeError = TypeError;
              module2.exports = function(argument) {
                var prim = toPrimitive(argument, "number");
                if (typeof prim == "number") throw new $TypeError("Can't convert number to bigint");
                return BigInt(prim);
              };
            },
            /***/
            3032(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(4866), __webpack_require__2(3532), __webpack_require__2(6818), __webpack_require__2(2858));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function() {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var BlockCipher = C_lib.BlockCipher;
                  var C_algo = C.algo;
                  const N = 16;
                  const ORIG_P = [608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832, 137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300, 3232508343, 3380367581, 1065670069, 3041331479, 2450970073, 2306472731];
                  const ORIG_S = [[3509652390, 2564797868, 805139163, 3491422135, 3101798381, 1780907670, 3128725573, 4046225305, 614570311, 3012652279, 134345442, 2240740374, 1667834072, 1901547113, 2757295779, 4103290238, 227898511, 1921955416, 1904987480, 2182433518, 2069144605, 3260701109, 2620446009, 720527379, 3318853667, 677414384, 3393288472, 3101374703, 2390351024, 1614419982, 1822297739, 2954791486, 3608508353, 3174124327, 2024746970, 1432378464, 3864339955, 2857741204, 1464375394, 1676153920, 1439316330, 715854006, 3033291828, 289532110, 2706671279, 2087905683, 3018724369, 1668267050, 732546397, 1947742710, 3462151702, 2609353502, 2950085171, 1814351708, 2050118529, 680887927, 999245976, 1800124847, 3300911131, 1713906067, 1641548236, 4213287313, 1216130144, 1575780402, 4018429277, 3917837745, 3693486850, 3949271944, 596196993, 3549867205, 258830323, 2213823033, 772490370, 2760122372, 1774776394, 2652871518, 566650946, 4142492826, 1728879713, 2882767088, 1783734482, 3629395816, 2517608232, 2874225571, 1861159788, 326777828, 3124490320, 2130389656, 2716951837, 967770486, 1724537150, 2185432712, 2364442137, 1164943284, 2105845187, 998989502, 3765401048, 2244026483, 1075463327, 1455516326, 1322494562, 910128902, 469688178, 1117454909, 936433444, 3490320968, 3675253459, 1240580251, 122909385, 2157517691, 634681816, 4142456567, 3825094682, 3061402683, 2540495037, 79693498, 3249098678, 1084186820, 1583128258, 426386531, 1761308591, 1047286709, 322548459, 995290223, 1845252383, 2603652396, 3431023940, 2942221577, 3202600964, 3727903485, 1712269319, 422464435, 3234572375, 1170764815, 3523960633, 3117677531, 1434042557, 442511882, 3600875718, 1076654713, 1738483198, 4213154764, 2393238008, 3677496056, 1014306527, 4251020053, 793779912, 2902807211, 842905082, 4246964064, 1395751752, 1040244610, 2656851899, 3396308128, 445077038, 3742853595, 3577915638, 679411651, 2892444358, 2354009459, 1767581616, 3150600392, 3791627101, 3102740896, 284835224, 4246832056, 1258075500, 768725851, 2589189241, 3069724005, 3532540348, 1274779536, 3789419226, 2764799539, 1660621633, 3471099624, 4011903706, 913787905, 3497959166, 737222580, 2514213453, 2928710040, 3937242737, 1804850592, 3499020752, 2949064160, 2386320175, 2390070455, 2415321851, 4061277028, 2290661394, 2416832540, 1336762016, 1754252060, 3520065937, 3014181293, 791618072, 3188594551, 3933548030, 2332172193, 3852520463, 3043980520, 413987798, 3465142937, 3030929376, 4245938359, 2093235073, 3534596313, 375366246, 2157278981, 2479649556, 555357303, 3870105701, 2008414854, 3344188149, 4221384143, 3956125452, 2067696032, 3594591187, 2921233993, 2428461, 544322398, 577241275, 1471733935, 610547355, 4027169054, 1432588573, 1507829418, 2025931657, 3646575487, 545086370, 48609733, 2200306550, 1653985193, 298326376, 1316178497, 3007786442, 2064951626, 458293330, 2589141269, 3591329599, 3164325604, 727753846, 2179363840, 146436021, 1461446943, 4069977195, 705550613, 3059967265, 3887724982, 4281599278, 3313849956, 1404054877, 2845806497, 146425753, 1854211946], [1266315497, 3048417604, 3681880366, 3289982499, 290971e4, 1235738493, 2632868024, 2414719590, 3970600049, 1771706367, 1449415276, 3266420449, 422970021, 1963543593, 2690192192, 3826793022, 1062508698, 1531092325, 1804592342, 2583117782, 2714934279, 4024971509, 1294809318, 4028980673, 1289560198, 2221992742, 1669523910, 35572830, 157838143, 1052438473, 1016535060, 1802137761, 1753167236, 1386275462, 3080475397, 2857371447, 1040679964, 2145300060, 2390574316, 1461121720, 2956646967, 4031777805, 4028374788, 33600511, 2920084762, 1018524850, 629373528, 3691585981, 3515945977, 2091462646, 2486323059, 586499841, 988145025, 935516892, 3367335476, 2599673255, 2839830854, 265290510, 3972581182, 2759138881, 3795373465, 1005194799, 847297441, 406762289, 1314163512, 1332590856, 1866599683, 4127851711, 750260880, 613907577, 1450815602, 3165620655, 3734664991, 3650291728, 3012275730, 3704569646, 1427272223, 778793252, 1343938022, 2676280711, 2052605720, 1946737175, 3164576444, 3914038668, 3967478842, 3682934266, 1661551462, 3294938066, 4011595847, 840292616, 3712170807, 616741398, 312560963, 711312465, 1351876610, 322626781, 1910503582, 271666773, 2175563734, 1594956187, 70604529, 3617834859, 1007753275, 1495573769, 4069517037, 2549218298, 2663038764, 504708206, 2263041392, 3941167025, 2249088522, 1514023603, 1998579484, 1312622330, 694541497, 2582060303, 2151582166, 1382467621, 776784248, 2618340202, 3323268794, 2497899128, 2784771155, 503983604, 4076293799, 907881277, 423175695, 432175456, 1378068232, 4145222326, 3954048622, 3938656102, 3820766613, 2793130115, 2977904593, 26017576, 3274890735, 3194772133, 1700274565, 1756076034, 4006520079, 3677328699, 720338349, 1533947780, 354530856, 688349552, 3973924725, 1637815568, 332179504, 3949051286, 53804574, 2852348879, 3044236432, 1282449977, 3583942155, 3416972820, 4006381244, 1617046695, 2628476075, 3002303598, 1686838959, 431878346, 2686675385, 1700445008, 1080580658, 1009431731, 832498133, 3223435511, 2605976345, 2271191193, 2516031870, 1648197032, 4164389018, 2548247927, 300782431, 375919233, 238389289, 3353747414, 2531188641, 2019080857, 1475708069, 455242339, 2609103871, 448939670, 3451063019, 1395535956, 2413381860, 1841049896, 1491858159, 885456874, 4264095073, 4001119347, 1565136089, 3898914787, 1108368660, 540939232, 1173283510, 2745871338, 3681308437, 4207628240, 3343053890, 4016749493, 1699691293, 1103962373, 3625875870, 2256883143, 3830138730, 1031889488, 3479347698, 1535977030, 4236805024, 3251091107, 2132092099, 1774941330, 1199868427, 1452454533, 157007616, 2904115357, 342012276, 595725824, 1480756522, 206960106, 497939518, 591360097, 863170706, 2375253569, 3596610801, 1814182875, 2094937945, 3421402208, 1082520231, 3463918190, 2785509508, 435703966, 3908032597, 1641649973, 2842273706, 3305899714, 1510255612, 2148256476, 2655287854, 3276092548, 4258621189, 236887753, 3681803219, 274041037, 1734335097, 3815195456, 3317970021, 1899903192, 1026095262, 4050517792, 356393447, 2410691914, 3873677099, 3682840055], [3913112168, 2491498743, 4132185628, 2489919796, 1091903735, 1979897079, 3170134830, 3567386728, 3557303409, 857797738, 1136121015, 1342202287, 507115054, 2535736646, 337727348, 3213592640, 1301675037, 2528481711, 1895095763, 1721773893, 3216771564, 62756741, 2142006736, 835421444, 2531993523, 1442658625, 3659876326, 2882144922, 676362277, 1392781812, 170690266, 3921047035, 1759253602, 3611846912, 1745797284, 664899054, 1329594018, 3901205900, 3045908486, 2062866102, 2865634940, 3543621612, 3464012697, 1080764994, 553557557, 3656615353, 3996768171, 991055499, 499776247, 1265440854, 648242737, 3940784050, 980351604, 3713745714, 1749149687, 3396870395, 4211799374, 3640570775, 1161844396, 3125318951, 1431517754, 545492359, 4268468663, 3499529547, 1437099964, 2702547544, 3433638243, 2581715763, 2787789398, 1060185593, 1593081372, 2418618748, 4260947970, 69676912, 2159744348, 86519011, 2512459080, 3838209314, 1220612927, 3339683548, 133810670, 1090789135, 1078426020, 1569222167, 845107691, 3583754449, 4072456591, 1091646820, 628848692, 1613405280, 3757631651, 526609435, 236106946, 48312990, 2942717905, 3402727701, 1797494240, 859738849, 992217954, 4005476642, 2243076622, 3870952857, 3732016268, 765654824, 3490871365, 2511836413, 1685915746, 3888969200, 1414112111, 2273134842, 3281911079, 4080962846, 172450625, 2569994100, 980381355, 4109958455, 2819808352, 2716589560, 2568741196, 3681446669, 3329971472, 1835478071, 660984891, 3704678404, 4045999559, 3422617507, 3040415634, 1762651403, 1719377915, 3470491036, 2693910283, 3642056355, 3138596744, 1364962596, 2073328063, 1983633131, 926494387, 3423689081, 2150032023, 4096667949, 1749200295, 3328846651, 309677260, 2016342300, 1779581495, 3079819751, 111262694, 1274766160, 443224088, 298511866, 1025883608, 3806446537, 1145181785, 168956806, 3641502830, 3584813610, 1689216846, 3666258015, 3200248200, 1692713982, 2646376535, 4042768518, 1618508792, 1610833997, 3523052358, 4130873264, 2001055236, 3610705100, 2202168115, 4028541809, 2961195399, 1006657119, 2006996926, 3186142756, 1430667929, 3210227297, 1314452623, 4074634658, 4101304120, 2273951170, 1399257539, 3367210612, 3027628629, 1190975929, 2062231137, 2333990788, 2221543033, 2438960610, 1181637006, 548689776, 2362791313, 3372408396, 3104550113, 3145860560, 296247880, 1970579870, 3078560182, 3769228297, 1714227617, 3291629107, 3898220290, 166772364, 1251581989, 493813264, 448347421, 195405023, 2709975567, 677966185, 3703036547, 1463355134, 2715995803, 1338867538, 1343315457, 2802222074, 2684532164, 233230375, 2599980071, 2000651841, 3277868038, 1638401717, 4028070440, 3237316320, 6314154, 819756386, 300326615, 590932579, 1405279636, 3267499572, 3150704214, 2428286686, 3959192993, 3461946742, 1862657033, 1266418056, 963775037, 2089974820, 2263052895, 1917689273, 448879540, 3550394620, 3981727096, 150775221, 3627908307, 1303187396, 508620638, 2975983352, 2726630617, 1817252668, 1876281319, 1457606340, 908771278, 3720792119, 3617206836, 2455994898, 1729034894, 1080033504], [976866871, 3556439503, 2881648439, 1522871579, 1555064734, 1336096578, 3548522304, 2579274686, 3574697629, 3205460757, 3593280638, 3338716283, 3079412587, 564236357, 2993598910, 1781952180, 1464380207, 3163844217, 3332601554, 1699332808, 1393555694, 1183702653, 3581086237, 1288719814, 691649499, 2847557200, 2895455976, 3193889540, 2717570544, 1781354906, 1676643554, 2592534050, 3230253752, 1126444790, 2770207658, 2633158820, 2210423226, 2615765581, 2414155088, 3127139286, 673620729, 2805611233, 1269405062, 4015350505, 3341807571, 4149409754, 1057255273, 2012875353, 2162469141, 2276492801, 2601117357, 993977747, 3918593370, 2654263191, 753973209, 36408145, 2530585658, 25011837, 3520020182, 2088578344, 530523599, 2918365339, 1524020338, 1518925132, 3760827505, 3759777254, 1202760957, 3985898139, 3906192525, 674977740, 4174734889, 2031300136, 2019492241, 3983892565, 4153806404, 3822280332, 352677332, 2297720250, 60907813, 90501309, 3286998549, 1016092578, 2535922412, 2839152426, 457141659, 509813237, 4120667899, 652014361, 1966332200, 2975202805, 55981186, 2327461051, 676427537, 3255491064, 2882294119, 3433927263, 1307055953, 942726286, 933058658, 2468411793, 3933900994, 4215176142, 1361170020, 2001714738, 2830558078, 3274259782, 1222529897, 1679025792, 2729314320, 3714953764, 1770335741, 151462246, 3013232138, 1682292957, 1483529935, 471910574, 1539241949, 458788160, 3436315007, 1807016891, 3718408830, 978976581, 1043663428, 3165965781, 1927990952, 4200891579, 2372276910, 3208408903, 3533431907, 1412390302, 2931980059, 4132332400, 1947078029, 3881505623, 4168226417, 2941484381, 1077988104, 1320477388, 886195818, 18198404, 3786409e3, 2509781533, 112762804, 3463356488, 1866414978, 891333506, 18488651, 661792760, 1628790961, 3885187036, 3141171499, 876946877, 2693282273, 1372485963, 791857591, 2686433993, 3759982718, 3167212022, 3472953795, 2716379847, 445679433, 3561995674, 3504004811, 3574258232, 54117162, 3331405415, 2381918588, 3769707343, 4154350007, 1140177722, 4074052095, 668550556, 3214352940, 367459370, 261225585, 2610173221, 4209349473, 3468074219, 3265815641, 314222801, 3066103646, 3808782860, 282218597, 3406013506, 3773591054, 379116347, 1285071038, 846784868, 2669647154, 3771962079, 3550491691, 2305946142, 453669953, 1268987020, 3317592352, 3279303384, 3744833421, 2610507566, 3859509063, 266596637, 3847019092, 517658769, 3462560207, 3443424879, 370717030, 4247526661, 2224018117, 4143653529, 4112773975, 2788324899, 2477274417, 1456262402, 2901442914, 1517677493, 1846949527, 2295493580, 3734397586, 2176403920, 1280348187, 1908823572, 3871786941, 846861322, 1172426758, 3287448474, 3383383037, 1655181056, 3139813346, 901632758, 1897031941, 2986607138, 3066810236, 3447102507, 1393639104, 373351379, 950779232, 625454576, 3124240540, 4148612726, 2007998917, 544563296, 2244738638, 2330496472, 2058025392, 1291430526, 424198748, 50039436, 29584100, 3605783033, 2429876329, 2791104160, 1057563949, 3255363231, 3075367218, 3463963227, 1469046755, 985887462]];
                  var BLOWFISH_CTX = {
                    pbox: [],
                    sbox: []
                  };
                  function F(ctx, x) {
                    let a = x >> 24 & 255;
                    let b = x >> 16 & 255;
                    let c = x >> 8 & 255;
                    let d = x & 255;
                    let y = ctx.sbox[0][a] + ctx.sbox[1][b];
                    y = y ^ ctx.sbox[2][c];
                    y = y + ctx.sbox[3][d];
                    return y;
                  }
                  function BlowFish_Encrypt(ctx, left, right) {
                    let Xl = left;
                    let Xr = right;
                    let temp;
                    for (let i = 0; i < N; ++i) {
                      Xl = Xl ^ ctx.pbox[i];
                      Xr = F(ctx, Xl) ^ Xr;
                      temp = Xl;
                      Xl = Xr;
                      Xr = temp;
                    }
                    temp = Xl;
                    Xl = Xr;
                    Xr = temp;
                    Xr = Xr ^ ctx.pbox[N];
                    Xl = Xl ^ ctx.pbox[N + 1];
                    return {
                      left: Xl,
                      right: Xr
                    };
                  }
                  function BlowFish_Decrypt(ctx, left, right) {
                    let Xl = left;
                    let Xr = right;
                    let temp;
                    for (let i = N + 1; i > 1; --i) {
                      Xl = Xl ^ ctx.pbox[i];
                      Xr = F(ctx, Xl) ^ Xr;
                      temp = Xl;
                      Xl = Xr;
                      Xr = temp;
                    }
                    temp = Xl;
                    Xl = Xr;
                    Xr = temp;
                    Xr = Xr ^ ctx.pbox[1];
                    Xl = Xl ^ ctx.pbox[0];
                    return {
                      left: Xl,
                      right: Xr
                    };
                  }
                  function BlowFishInit(ctx, key, keysize) {
                    for (let Row = 0; Row < 4; Row++) {
                      ctx.sbox[Row] = [];
                      for (let Col = 0; Col < 256; Col++) {
                        ctx.sbox[Row][Col] = ORIG_S[Row][Col];
                      }
                    }
                    let keyIndex = 0;
                    for (let index = 0; index < N + 2; index++) {
                      ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex];
                      keyIndex++;
                      if (keyIndex >= keysize) {
                        keyIndex = 0;
                      }
                    }
                    let Data1 = 0;
                    let Data2 = 0;
                    let res = 0;
                    for (let i = 0; i < N + 2; i += 2) {
                      res = BlowFish_Encrypt(ctx, Data1, Data2);
                      Data1 = res.left;
                      Data2 = res.right;
                      ctx.pbox[i] = Data1;
                      ctx.pbox[i + 1] = Data2;
                    }
                    for (let i = 0; i < 4; i++) {
                      for (let j = 0; j < 256; j += 2) {
                        res = BlowFish_Encrypt(ctx, Data1, Data2);
                        Data1 = res.left;
                        Data2 = res.right;
                        ctx.sbox[i][j] = Data1;
                        ctx.sbox[i][j + 1] = Data2;
                      }
                    }
                    return true;
                  }
                  var Blowfish = C_algo.Blowfish = BlockCipher.extend({
                    _doReset: function() {
                      if (this._keyPriorReset === this._key) {
                        return;
                      }
                      var key = this._keyPriorReset = this._key;
                      var keyWords = key.words;
                      var keySize = key.sigBytes / 4;
                      BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
                    },
                    encryptBlock: function(M, offset) {
                      var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
                      M[offset] = res.left;
                      M[offset + 1] = res.right;
                    },
                    decryptBlock: function(M, offset) {
                      var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
                      M[offset] = res.left;
                      M[offset + 1] = res.right;
                    },
                    blockSize: 64 / 32,
                    keySize: 128 / 32,
                    ivSize: 64 / 32
                  });
                  C.Blowfish = BlockCipher._createHelper(Blowfish);
                })();
                return CryptoJS.Blowfish;
              });
            },
            /***/
            3036(module2) {
              "use strict";
              module2.exports = Function.prototype.apply;
            },
            /***/
            3143(__unused_webpack_module, exports2, __webpack_require__2) {
              "use strict";
              var Buffer = __webpack_require__2(5691).Buffer;
              var isEncoding = Buffer.isEncoding || function(encoding) {
                encoding = "" + encoding;
                switch (encoding && encoding.toLowerCase()) {
                  case "hex":
                  case "utf8":
                  case "utf-8":
                  case "ascii":
                  case "binary":
                  case "base64":
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                  case "raw":
                    return true;
                  default:
                    return false;
                }
              };
              function _normalizeEncoding(enc) {
                if (!enc) return "utf8";
                var retried;
                while (true) {
                  switch (enc) {
                    case "utf8":
                    case "utf-8":
                      return "utf8";
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return "utf16le";
                    case "latin1":
                    case "binary":
                      return "latin1";
                    case "base64":
                    case "ascii":
                    case "hex":
                      return enc;
                    default:
                      if (retried) return;
                      enc = ("" + enc).toLowerCase();
                      retried = true;
                  }
                }
              }
              ;
              function normalizeEncoding(enc) {
                var nenc = _normalizeEncoding(enc);
                if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
                return nenc || enc;
              }
              exports2.I = StringDecoder;
              function StringDecoder(encoding) {
                this.encoding = normalizeEncoding(encoding);
                var nb;
                switch (this.encoding) {
                  case "utf16le":
                    this.text = utf16Text;
                    this.end = utf16End;
                    nb = 4;
                    break;
                  case "utf8":
                    this.fillLast = utf8FillLast;
                    nb = 4;
                    break;
                  case "base64":
                    this.text = base64Text;
                    this.end = base64End;
                    nb = 3;
                    break;
                  default:
                    this.write = simpleWrite;
                    this.end = simpleEnd;
                    return;
                }
                this.lastNeed = 0;
                this.lastTotal = 0;
                this.lastChar = Buffer.allocUnsafe(nb);
              }
              StringDecoder.prototype.write = function(buf) {
                if (buf.length === 0) return "";
                var r;
                var i;
                if (this.lastNeed) {
                  r = this.fillLast(buf);
                  if (r === void 0) return "";
                  i = this.lastNeed;
                  this.lastNeed = 0;
                } else {
                  i = 0;
                }
                if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
                return r || "";
              };
              StringDecoder.prototype.end = utf8End;
              StringDecoder.prototype.text = utf8Text;
              StringDecoder.prototype.fillLast = function(buf) {
                if (this.lastNeed <= buf.length) {
                  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
                  return this.lastChar.toString(this.encoding, 0, this.lastTotal);
                }
                buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
                this.lastNeed -= buf.length;
              };
              function utf8CheckByte(byte) {
                if (byte <= 127) return 0;
                else if (byte >> 5 === 6) return 2;
                else if (byte >> 4 === 14) return 3;
                else if (byte >> 3 === 30) return 4;
                return byte >> 6 === 2 ? -1 : -2;
              }
              function utf8CheckIncomplete(self2, buf, i) {
                var j = buf.length - 1;
                if (j < i) return 0;
                var nb = utf8CheckByte(buf[j]);
                if (nb >= 0) {
                  if (nb > 0) self2.lastNeed = nb - 1;
                  return nb;
                }
                if (--j < i || nb === -2) return 0;
                nb = utf8CheckByte(buf[j]);
                if (nb >= 0) {
                  if (nb > 0) self2.lastNeed = nb - 2;
                  return nb;
                }
                if (--j < i || nb === -2) return 0;
                nb = utf8CheckByte(buf[j]);
                if (nb >= 0) {
                  if (nb > 0) {
                    if (nb === 2) nb = 0;
                    else self2.lastNeed = nb - 3;
                  }
                  return nb;
                }
                return 0;
              }
              function utf8CheckExtraBytes(self2, buf, p) {
                if ((buf[0] & 192) !== 128) {
                  self2.lastNeed = 0;
                  return "";
                }
                if (self2.lastNeed > 1 && buf.length > 1) {
                  if ((buf[1] & 192) !== 128) {
                    self2.lastNeed = 1;
                    return "";
                  }
                  if (self2.lastNeed > 2 && buf.length > 2) {
                    if ((buf[2] & 192) !== 128) {
                      self2.lastNeed = 2;
                      return "";
                    }
                  }
                }
              }
              function utf8FillLast(buf) {
                var p = this.lastTotal - this.lastNeed;
                var r = utf8CheckExtraBytes(this, buf, p);
                if (r !== void 0) return r;
                if (this.lastNeed <= buf.length) {
                  buf.copy(this.lastChar, p, 0, this.lastNeed);
                  return this.lastChar.toString(this.encoding, 0, this.lastTotal);
                }
                buf.copy(this.lastChar, p, 0, buf.length);
                this.lastNeed -= buf.length;
              }
              function utf8Text(buf, i) {
                var total = utf8CheckIncomplete(this, buf, i);
                if (!this.lastNeed) return buf.toString("utf8", i);
                this.lastTotal = total;
                var end = buf.length - (total - this.lastNeed);
                buf.copy(this.lastChar, 0, end);
                return buf.toString("utf8", i, end);
              }
              function utf8End(buf) {
                var r = buf && buf.length ? this.write(buf) : "";
                if (this.lastNeed) return r + "";
                return r;
              }
              function utf16Text(buf, i) {
                if ((buf.length - i) % 2 === 0) {
                  var r = buf.toString("utf16le", i);
                  if (r) {
                    var c = r.charCodeAt(r.length - 1);
                    if (c >= 55296 && c <= 56319) {
                      this.lastNeed = 2;
                      this.lastTotal = 4;
                      this.lastChar[0] = buf[buf.length - 2];
                      this.lastChar[1] = buf[buf.length - 1];
                      return r.slice(0, -1);
                    }
                  }
                  return r;
                }
                this.lastNeed = 1;
                this.lastTotal = 2;
                this.lastChar[0] = buf[buf.length - 1];
                return buf.toString("utf16le", i, buf.length - 1);
              }
              function utf16End(buf) {
                var r = buf && buf.length ? this.write(buf) : "";
                if (this.lastNeed) {
                  var end = this.lastTotal - this.lastNeed;
                  return r + this.lastChar.toString("utf16le", 0, end);
                }
                return r;
              }
              function base64Text(buf, i) {
                var n = (buf.length - i) % 3;
                if (n === 0) return buf.toString("base64", i);
                this.lastNeed = 3 - n;
                this.lastTotal = 3;
                if (n === 1) {
                  this.lastChar[0] = buf[buf.length - 1];
                } else {
                  this.lastChar[0] = buf[buf.length - 2];
                  this.lastChar[1] = buf[buf.length - 1];
                }
                return buf.toString("base64", i, buf.length - n);
              }
              function base64End(buf) {
                var r = buf && buf.length ? this.write(buf) : "";
                if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
                return r;
              }
              function simpleWrite(buf) {
                return buf.toString(this.encoding);
              }
              function simpleEnd(buf) {
                return buf && buf.length ? this.write(buf) : "";
              }
            },
            /***/
            3144(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function(undefined2) {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var Base = C_lib.Base;
                  var X32WordArray = C_lib.WordArray;
                  var C_x64 = C.x64 = {};
                  var X64Word = C_x64.Word = Base.extend({
                    /**
                     * Initializes a newly created 64-bit word.
                     *
                     * @param {number} high The high 32 bits.
                     * @param {number} low The low 32 bits.
                     *
                     * @example
                     *
                     *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
                     */
                    init: function(high, low) {
                      this.high = high;
                      this.low = low;
                    }
                    /**
                     * Bitwise NOTs this word.
                     *
                     * @return {X64Word} A new x64-Word object after negating.
                     *
                     * @example
                     *
                     *     var negated = x64Word.not();
                     */
                    // not: function () {
                    // var high = ~this.high;
                    // var low = ~this.low;
                    // return X64Word.create(high, low);
                    // },
                    /**
                     * Bitwise ANDs this word with the passed word.
                     *
                     * @param {X64Word} word The x64-Word to AND with this word.
                     *
                     * @return {X64Word} A new x64-Word object after ANDing.
                     *
                     * @example
                     *
                     *     var anded = x64Word.and(anotherX64Word);
                     */
                    // and: function (word) {
                    // var high = this.high & word.high;
                    // var low = this.low & word.low;
                    // return X64Word.create(high, low);
                    // },
                    /**
                     * Bitwise ORs this word with the passed word.
                     *
                     * @param {X64Word} word The x64-Word to OR with this word.
                     *
                     * @return {X64Word} A new x64-Word object after ORing.
                     *
                     * @example
                     *
                     *     var ored = x64Word.or(anotherX64Word);
                     */
                    // or: function (word) {
                    // var high = this.high | word.high;
                    // var low = this.low | word.low;
                    // return X64Word.create(high, low);
                    // },
                    /**
                     * Bitwise XORs this word with the passed word.
                     *
                     * @param {X64Word} word The x64-Word to XOR with this word.
                     *
                     * @return {X64Word} A new x64-Word object after XORing.
                     *
                     * @example
                     *
                     *     var xored = x64Word.xor(anotherX64Word);
                     */
                    // xor: function (word) {
                    // var high = this.high ^ word.high;
                    // var low = this.low ^ word.low;
                    // return X64Word.create(high, low);
                    // },
                    /**
                     * Shifts this word n bits to the left.
                     *
                     * @param {number} n The number of bits to shift.
                     *
                     * @return {X64Word} A new x64-Word object after shifting.
                     *
                     * @example
                     *
                     *     var shifted = x64Word.shiftL(25);
                     */
                    // shiftL: function (n) {
                    // if (n < 32) {
                    // var high = (this.high << n) | (this.low >>> (32 - n));
                    // var low = this.low << n;
                    // } else {
                    // var high = this.low << (n - 32);
                    // var low = 0;
                    // }
                    // return X64Word.create(high, low);
                    // },
                    /**
                     * Shifts this word n bits to the right.
                     *
                     * @param {number} n The number of bits to shift.
                     *
                     * @return {X64Word} A new x64-Word object after shifting.
                     *
                     * @example
                     *
                     *     var shifted = x64Word.shiftR(7);
                     */
                    // shiftR: function (n) {
                    // if (n < 32) {
                    // var low = (this.low >>> n) | (this.high << (32 - n));
                    // var high = this.high >>> n;
                    // } else {
                    // var low = this.high >>> (n - 32);
                    // var high = 0;
                    // }
                    // return X64Word.create(high, low);
                    // },
                    /**
                     * Rotates this word n bits to the left.
                     *
                     * @param {number} n The number of bits to rotate.
                     *
                     * @return {X64Word} A new x64-Word object after rotating.
                     *
                     * @example
                     *
                     *     var rotated = x64Word.rotL(25);
                     */
                    // rotL: function (n) {
                    // return this.shiftL(n).or(this.shiftR(64 - n));
                    // },
                    /**
                     * Rotates this word n bits to the right.
                     *
                     * @param {number} n The number of bits to rotate.
                     *
                     * @return {X64Word} A new x64-Word object after rotating.
                     *
                     * @example
                     *
                     *     var rotated = x64Word.rotR(7);
                     */
                    // rotR: function (n) {
                    // return this.shiftR(n).or(this.shiftL(64 - n));
                    // },
                    /**
                     * Adds this word with the passed word.
                     *
                     * @param {X64Word} word The x64-Word to add with this word.
                     *
                     * @return {X64Word} A new x64-Word object after adding.
                     *
                     * @example
                     *
                     *     var added = x64Word.add(anotherX64Word);
                     */
                    // add: function (word) {
                    // var low = (this.low + word.low) | 0;
                    // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
                    // var high = (this.high + word.high + carry) | 0;
                    // return X64Word.create(high, low);
                    // }
                  });
                  var X64WordArray = C_x64.WordArray = Base.extend({
                    /**
                     * Initializes a newly created word array.
                     *
                     * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
                     * @param {number} sigBytes (Optional) The number of significant bytes in the words.
                     *
                     * @example
                     *
                     *     var wordArray = CryptoJS.x64.WordArray.create();
                     *
                     *     var wordArray = CryptoJS.x64.WordArray.create([
                     *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
                     *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
                     *     ]);
                     *
                     *     var wordArray = CryptoJS.x64.WordArray.create([
                     *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
                     *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
                     *     ], 10);
                     */
                    init: function(words, sigBytes) {
                      words = this.words = words || [];
                      if (sigBytes != undefined2) {
                        this.sigBytes = sigBytes;
                      } else {
                        this.sigBytes = words.length * 8;
                      }
                    },
                    /**
                     * Converts this 64-bit word array to a 32-bit word array.
                     *
                     * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
                     *
                     * @example
                     *
                     *     var x32WordArray = x64WordArray.toX32();
                     */
                    toX32: function() {
                      var x64Words = this.words;
                      var x64WordsLength = x64Words.length;
                      var x32Words = [];
                      for (var i = 0; i < x64WordsLength; i++) {
                        var x64Word = x64Words[i];
                        x32Words.push(x64Word.high);
                        x32Words.push(x64Word.low);
                      }
                      return X32WordArray.create(x32Words, this.sigBytes);
                    },
                    /**
                     * Creates a copy of this word array.
                     *
                     * @return {X64WordArray} The clone.
                     *
                     * @example
                     *
                     *     var clone = x64WordArray.clone();
                     */
                    clone: function() {
                      var clone = Base.clone.call(this);
                      var words = clone.words = this.words.slice(0);
                      var wordsLength = words.length;
                      for (var i = 0; i < wordsLength; i++) {
                        words[i] = words[i].clone();
                      }
                      return clone;
                    }
                  });
                })();
                return CryptoJS;
              });
            },
            /***/
            3161(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var toObject = __webpack_require__2(3297);
              var toAbsoluteIndex = __webpack_require__2(4918);
              var lengthOfArrayLike = __webpack_require__2(4730);
              module2.exports = function fill(value) {
                var O = toObject(this);
                var length = lengthOfArrayLike(O);
                var argumentsLength = arguments.length;
                var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : void 0, length);
                var end = argumentsLength > 2 ? arguments[2] : void 0;
                var endPos = end === void 0 ? length : toAbsoluteIndex(end, length);
                while (endPos > index) O[index++] = value;
                return O;
              };
            },
            /***/
            3232(__unused_webpack_module, exports2, __webpack_require__2) {
              "use strict";
              var __webpack_unused_export__;
              var __webpack_dirname__ = "/";
              var Buffer = __webpack_require__2(783)["Buffer"];
              __webpack_unused_export__ = {
                value: true
              };
              exports2.A = void 0;
              __webpack_require__2(8376);
              __webpack_require__2(6401);
              __webpack_require__2(2017);
              var _stream = _interopRequireDefault(__webpack_require__2(9760));
              var _zlib = _interopRequireDefault(__webpack_require__2(6729));
              var _cryptoJs = _interopRequireDefault(__webpack_require__2(5348));
              var fontkit = _interopRequireWildcard(__webpack_require__2(1715));
              var _events = __webpack_require__2(4785);
              var _linebreak = _interopRequireDefault(__webpack_require__2(2532));
              var _jpegExif = _interopRequireDefault(__webpack_require__2(8834));
              var _pngJs = _interopRequireDefault(__webpack_require__2(336));
              function _interopRequireWildcard(e, t) {
                if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
                return (_interopRequireWildcard = function(e2, t2) {
                  if (!t2 && e2 && e2.__esModule) return e2;
                  var o, i, f = { __proto__: null, default: e2 };
                  if (null === e2 || "object" != typeof e2 && "function" != typeof e2) return f;
                  if (o = t2 ? n : r) {
                    if (o.has(e2)) return o.get(e2);
                    o.set(e2, f);
                  }
                  for (const t3 in e2) "default" !== t3 && {}.hasOwnProperty.call(e2, t3) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e2, t3)) && (i.get || i.set) ? o(f, t3, i) : f[t3] = e2[t3]);
                  return f;
                })(e, t);
              }
              function _interopRequireDefault(e) {
                return e && e.__esModule ? e : { default: e };
              }
              var fs = __webpack_require__2(2416);
              class PDFAbstractReference {
                toString() {
                  throw new Error("Must be implemented by subclasses");
                }
              }
              class PDFTree {
                constructor() {
                  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  this._items = {};
                  this.limits = typeof options.limits === "boolean" ? options.limits : true;
                }
                add(key, val) {
                  return this._items[key] = val;
                }
                get(key) {
                  return this._items[key];
                }
                toString() {
                  const sortedKeys = Object.keys(this._items).sort((a, b) => this._compareKeys(a, b));
                  const out = ["<<"];
                  if (this.limits && sortedKeys.length > 1) {
                    const first2 = sortedKeys[0], last2 = sortedKeys[sortedKeys.length - 1];
                    out.push(`  /Limits ${PDFObject.convert([this._dataForKey(first2), this._dataForKey(last2)])}`);
                  }
                  out.push(`  /${this._keysName()} [`);
                  for (let key of sortedKeys) {
                    out.push(`    ${PDFObject.convert(this._dataForKey(key))} ${PDFObject.convert(this._items[key])}`);
                  }
                  out.push("]");
                  out.push(">>");
                  return out.join("\n");
                }
                _compareKeys() {
                  throw new Error("Must be implemented by subclasses");
                }
                _keysName() {
                  throw new Error("Must be implemented by subclasses");
                }
                _dataForKey() {
                  throw new Error("Must be implemented by subclasses");
                }
              }
              class SpotColor {
                constructor(doc, name, C, M, Y, K) {
                  this.id = "CS" + Object.keys(doc.spotColors).length;
                  this.name = name;
                  this.values = [C, M, Y, K];
                  this.ref = doc.ref(["Separation", this.name, "DeviceCMYK", {
                    Range: [0, 1, 0, 1, 0, 1, 0, 1],
                    C0: [0, 0, 0, 0],
                    C1: this.values.map((value) => value / 100),
                    FunctionType: 2,
                    Domain: [0, 1],
                    N: 1
                  }]);
                  this.ref.end();
                }
                toString() {
                  return `${this.ref.id} 0 R`;
                }
              }
              const pad = (str, length) => (Array(length + 1).join("0") + str).slice(-length);
              const escapableRe = /[\n\r\t\b\f()\\]/g;
              const escapable = {
                "\n": "\\n",
                "\r": "\\r",
                "	": "\\t",
                "\b": "\\b",
                "\f": "\\f",
                "\\": "\\\\",
                "(": "\\(",
                ")": "\\)"
              };
              const swapBytes = function(buff) {
                const l = buff.length;
                if (l & 1) {
                  throw new Error("Buffer length must be even");
                } else {
                  for (let i = 0, end = l - 1; i < end; i += 2) {
                    const a = buff[i];
                    buff[i] = buff[i + 1];
                    buff[i + 1] = a;
                  }
                }
                return buff;
              };
              class PDFObject {
                static convert(object) {
                  let encryptFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  if (typeof object === "string") {
                    return `/${object}`;
                  } else if (object instanceof String) {
                    let string = object;
                    let isUnicode = false;
                    for (let i = 0, end = string.length; i < end; i++) {
                      if (string.charCodeAt(i) > 127) {
                        isUnicode = true;
                        break;
                      }
                    }
                    let stringBuffer;
                    if (isUnicode) {
                      stringBuffer = swapBytes(Buffer.from(`\uFEFF${string}`, "utf16le"));
                    } else {
                      stringBuffer = Buffer.from(string.valueOf(), "ascii");
                    }
                    if (encryptFn) {
                      string = encryptFn(stringBuffer).toString("binary");
                    } else {
                      string = stringBuffer.toString("binary");
                    }
                    string = string.replace(escapableRe, (c) => escapable[c]);
                    return `(${string})`;
                  } else if (Buffer.isBuffer(object)) {
                    return `<${object.toString("hex")}>`;
                  } else if (object instanceof PDFAbstractReference || object instanceof PDFTree || object instanceof SpotColor) {
                    return object.toString();
                  } else if (object instanceof Date) {
                    let string = `D:${pad(object.getUTCFullYear(), 4)}` + pad(object.getUTCMonth() + 1, 2) + pad(object.getUTCDate(), 2) + pad(object.getUTCHours(), 2) + pad(object.getUTCMinutes(), 2) + pad(object.getUTCSeconds(), 2) + "Z";
                    if (encryptFn) {
                      string = encryptFn(Buffer.from(string, "ascii")).toString("binary");
                      string = string.replace(escapableRe, (c) => escapable[c]);
                    }
                    return `(${string})`;
                  } else if (Array.isArray(object)) {
                    const items = object.map((e) => PDFObject.convert(e, encryptFn)).join(" ");
                    return `[${items}]`;
                  } else if ({}.toString.call(object) === "[object Object]") {
                    const out = ["<<"];
                    for (let key in object) {
                      const val = object[key];
                      out.push(`/${key} ${PDFObject.convert(val, encryptFn)}`);
                    }
                    out.push(">>");
                    return out.join("\n");
                  } else if (typeof object === "number") {
                    return PDFObject.number(object);
                  } else {
                    return `${object}`;
                  }
                }
                static number(n) {
                  if (n > -1e21 && n < 1e21) {
                    return Math.round(n * 1e6) / 1e6;
                  }
                  throw new Error(`unsupported number: ${n}`);
                }
              }
              class PDFReference extends PDFAbstractReference {
                constructor(document2, id) {
                  let data = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                  super();
                  this.document = document2;
                  this.id = id;
                  this.data = data;
                  this.gen = 0;
                  this.compress = this.document.compress && !this.data.Filter;
                  this.uncompressedLength = 0;
                  this.buffer = [];
                }
                write(chunk) {
                  if (!(chunk instanceof Uint8Array)) {
                    chunk = Buffer.from(chunk + "\n", "binary");
                  }
                  this.uncompressedLength += chunk.length;
                  if (this.data.Length == null) {
                    this.data.Length = 0;
                  }
                  this.buffer.push(chunk);
                  this.data.Length += chunk.length;
                  if (this.compress) {
                    this.data.Filter = "FlateDecode";
                  }
                }
                end(chunk) {
                  if (chunk) {
                    this.write(chunk);
                  }
                  this.finalize();
                }
                finalize() {
                  this.offset = this.document._offset;
                  const encryptFn = this.document._security ? this.document._security.getEncryptFn(this.id, this.gen) : null;
                  if (this.buffer.length) {
                    this.buffer = Buffer.concat(this.buffer);
                    if (this.compress) {
                      this.buffer = _zlib.default.deflateSync(this.buffer);
                    }
                    if (encryptFn) {
                      this.buffer = encryptFn(this.buffer);
                    }
                    this.data.Length = this.buffer.length;
                  }
                  this.document._write(`${this.id} ${this.gen} obj`);
                  this.document._write(PDFObject.convert(this.data, encryptFn));
                  if (this.buffer.length) {
                    this.document._write("stream");
                    this.document._write(this.buffer);
                    this.buffer = [];
                    this.document._write("\nendstream");
                  }
                  this.document._write("endobj");
                  this.document._refEnd(this);
                }
                toString() {
                  return `${this.id} ${this.gen} R`;
                }
              }
              const fArray = new Float32Array(1);
              const uArray = new Uint32Array(fArray.buffer);
              function PDFNumber(n) {
                const rounded = Math.fround(n);
                if (rounded <= n) return rounded;
                fArray[0] = n;
                if (n <= 0) {
                  uArray[0] += 1;
                } else {
                  uArray[0] -= 1;
                }
                return fArray[0];
              }
              function normalizeSides(sides) {
                let defaultDefinition = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
                let transformer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (v) => v;
                if (sides == null || typeof sides === "object" && Object.keys(sides).length === 0) {
                  sides = defaultDefinition;
                }
                if (sides == null || typeof sides !== "object") {
                  sides = {
                    top: sides,
                    right: sides,
                    bottom: sides,
                    left: sides
                  };
                } else if (Array.isArray(sides)) {
                  if (sides.length === 2) {
                    sides = {
                      vertical: sides[0],
                      horizontal: sides[1]
                    };
                  } else {
                    sides = {
                      top: sides[0],
                      right: sides[1],
                      bottom: sides[2],
                      left: sides[3]
                    };
                  }
                }
                if ("vertical" in sides || "horizontal" in sides) {
                  sides = {
                    top: sides.vertical,
                    right: sides.horizontal,
                    bottom: sides.vertical,
                    left: sides.horizontal
                  };
                }
                return {
                  top: transformer(sides.top),
                  right: transformer(sides.right),
                  bottom: transformer(sides.bottom),
                  left: transformer(sides.left)
                };
              }
              const MM_TO_CM = 1 / 10;
              const CM_TO_IN = 1 / 2.54;
              const PX_TO_IN = 1 / 96;
              const IN_TO_PT = 72;
              const PC_TO_PT = 12;
              function cosine(a) {
                if (a === 0) return 1;
                if (a === 90) return 0;
                if (a === 180) return -1;
                if (a === 270) return 0;
                return Math.cos(a * Math.PI / 180);
              }
              function sine(a) {
                if (a === 0) return 0;
                if (a === 90) return 1;
                if (a === 180) return 0;
                if (a === 270) return -1;
                return Math.sin(a * Math.PI / 180);
              }
              const DEFAULT_MARGINS = {
                top: 72,
                left: 72,
                bottom: 72,
                right: 72
              };
              const SIZES = {
                "4A0": [4767.87, 6740.79],
                "2A0": [3370.39, 4767.87],
                A0: [2383.94, 3370.39],
                A1: [1683.78, 2383.94],
                A2: [1190.55, 1683.78],
                A3: [841.89, 1190.55],
                A4: [595.28, 841.89],
                A5: [419.53, 595.28],
                A6: [297.64, 419.53],
                A7: [209.76, 297.64],
                A8: [147.4, 209.76],
                A9: [104.88, 147.4],
                A10: [73.7, 104.88],
                B0: [2834.65, 4008.19],
                B1: [2004.09, 2834.65],
                B2: [1417.32, 2004.09],
                B3: [1000.63, 1417.32],
                B4: [708.66, 1000.63],
                B5: [498.9, 708.66],
                B6: [354.33, 498.9],
                B7: [249.45, 354.33],
                B8: [175.75, 249.45],
                B9: [124.72, 175.75],
                B10: [87.87, 124.72],
                C0: [2599.37, 3676.54],
                C1: [1836.85, 2599.37],
                C2: [1298.27, 1836.85],
                C3: [918.43, 1298.27],
                C4: [649.13, 918.43],
                C5: [459.21, 649.13],
                C6: [323.15, 459.21],
                C7: [229.61, 323.15],
                C8: [161.57, 229.61],
                C9: [113.39, 161.57],
                C10: [79.37, 113.39],
                RA0: [2437.8, 3458.27],
                RA1: [1729.13, 2437.8],
                RA2: [1218.9, 1729.13],
                RA3: [864.57, 1218.9],
                RA4: [609.45, 864.57],
                SRA0: [2551.18, 3628.35],
                SRA1: [1814.17, 2551.18],
                SRA2: [1275.59, 1814.17],
                SRA3: [907.09, 1275.59],
                SRA4: [637.8, 907.09],
                EXECUTIVE: [521.86, 756],
                FOLIO: [612, 936],
                LEGAL: [612, 1008],
                LETTER: [612, 792],
                TABLOID: [792, 1224]
              };
              class PDFPage {
                constructor(document2) {
                  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  this.document = document2;
                  this._options = options;
                  this.size = options.size || "letter";
                  this.layout = options.layout || "portrait";
                  const dimensions = Array.isArray(this.size) ? this.size : SIZES[this.size.toUpperCase()];
                  this.width = dimensions[this.layout === "portrait" ? 0 : 1];
                  this.height = dimensions[this.layout === "portrait" ? 1 : 0];
                  this.content = this.document.ref();
                  if (options.font) document2.font(options.font, options.fontFamily);
                  if (options.fontSize) document2.fontSize(options.fontSize);
                  this.margins = normalizeSides(options.margin ?? options.margins, DEFAULT_MARGINS, (x) => document2.sizeToPoint(x, 0, this));
                  this.resources = this.document.ref({
                    ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"]
                  });
                  this.dictionary = this.document.ref({
                    Type: "Page",
                    Parent: this.document._root.data.Pages,
                    MediaBox: [0, 0, this.width, this.height],
                    Contents: this.content,
                    Resources: this.resources
                  });
                  this.markings = [];
                }
                get fonts() {
                  const data = this.resources.data;
                  return data.Font != null ? data.Font : data.Font = {};
                }
                get xobjects() {
                  const data = this.resources.data;
                  return data.XObject != null ? data.XObject : data.XObject = {};
                }
                get ext_gstates() {
                  const data = this.resources.data;
                  return data.ExtGState != null ? data.ExtGState : data.ExtGState = {};
                }
                get patterns() {
                  const data = this.resources.data;
                  return data.Pattern != null ? data.Pattern : data.Pattern = {};
                }
                get colorSpaces() {
                  const data = this.resources.data;
                  return data.ColorSpace || (data.ColorSpace = {});
                }
                get annotations() {
                  const data = this.dictionary.data;
                  return data.Annots != null ? data.Annots : data.Annots = [];
                }
                get structParentTreeKey() {
                  const data = this.dictionary.data;
                  return data.StructParents != null ? data.StructParents : data.StructParents = this.document.createStructParentTreeNextKey();
                }
                get contentWidth() {
                  return this.width - this.margins.left - this.margins.right;
                }
                get contentHeight() {
                  return this.height - this.margins.top - this.margins.bottom;
                }
                maxY() {
                  return this.height - this.margins.bottom;
                }
                write(chunk) {
                  return this.content.write(chunk);
                }
                _setTabOrder() {
                  if (!this.dictionary.Tabs && this.document.hasMarkInfoDictionary()) {
                    this.dictionary.data.Tabs = "S";
                  }
                }
                end() {
                  this._setTabOrder();
                  this.dictionary.end();
                  this.resources.data.ColorSpace = this.resources.data.ColorSpace || {};
                  for (let color of Object.values(this.document.spotColors)) {
                    this.resources.data.ColorSpace[color.id] = color;
                  }
                  this.resources.end();
                  return this.content.end();
                }
              }
              class PDFNameTree extends PDFTree {
                _compareKeys(a, b) {
                  return a.localeCompare(b);
                }
                _keysName() {
                  return "Names";
                }
                _dataForKey(k) {
                  return new String(k);
                }
              }
              function inRange(value, rangeGroup) {
                if (value < rangeGroup[0]) return false;
                let startRange = 0;
                let endRange = rangeGroup.length / 2;
                while (startRange <= endRange) {
                  const middleRange = Math.floor((startRange + endRange) / 2);
                  const arrayIndex = middleRange * 2;
                  if (value >= rangeGroup[arrayIndex] && value <= rangeGroup[arrayIndex + 1]) {
                    return true;
                  }
                  if (value > rangeGroup[arrayIndex + 1]) {
                    startRange = middleRange + 1;
                  } else {
                    endRange = middleRange - 1;
                  }
                }
                return false;
              }
              const unassigned_code_points = [545, 545, 564, 591, 686, 687, 751, 767, 848, 863, 880, 883, 886, 889, 891, 893, 895, 899, 907, 907, 909, 909, 930, 930, 975, 975, 1015, 1023, 1159, 1159, 1231, 1231, 1270, 1271, 1274, 1279, 1296, 1328, 1367, 1368, 1376, 1376, 1416, 1416, 1419, 1424, 1442, 1442, 1466, 1466, 1477, 1487, 1515, 1519, 1525, 1547, 1549, 1562, 1564, 1566, 1568, 1568, 1595, 1599, 1622, 1631, 1774, 1775, 1791, 1791, 1806, 1806, 1837, 1839, 1867, 1919, 1970, 2304, 2308, 2308, 2362, 2363, 2382, 2383, 2389, 2391, 2417, 2432, 2436, 2436, 2445, 2446, 2449, 2450, 2473, 2473, 2481, 2481, 2483, 2485, 2490, 2491, 2493, 2493, 2501, 2502, 2505, 2506, 2510, 2518, 2520, 2523, 2526, 2526, 2532, 2533, 2555, 2561, 2563, 2564, 2571, 2574, 2577, 2578, 2601, 2601, 2609, 2609, 2612, 2612, 2615, 2615, 2618, 2619, 2621, 2621, 2627, 2630, 2633, 2634, 2638, 2648, 2653, 2653, 2655, 2661, 2677, 2688, 2692, 2692, 2700, 2700, 2702, 2702, 2706, 2706, 2729, 2729, 2737, 2737, 2740, 2740, 2746, 2747, 2758, 2758, 2762, 2762, 2766, 2767, 2769, 2783, 2785, 2789, 2800, 2816, 2820, 2820, 2829, 2830, 2833, 2834, 2857, 2857, 2865, 2865, 2868, 2869, 2874, 2875, 2884, 2886, 2889, 2890, 2894, 2901, 2904, 2907, 2910, 2910, 2914, 2917, 2929, 2945, 2948, 2948, 2955, 2957, 2961, 2961, 2966, 2968, 2971, 2971, 2973, 2973, 2976, 2978, 2981, 2983, 2987, 2989, 2998, 2998, 3002, 3005, 3011, 3013, 3017, 3017, 3022, 3030, 3032, 3046, 3059, 3072, 3076, 3076, 3085, 3085, 3089, 3089, 3113, 3113, 3124, 3124, 3130, 3133, 3141, 3141, 3145, 3145, 3150, 3156, 3159, 3167, 3170, 3173, 3184, 3201, 3204, 3204, 3213, 3213, 3217, 3217, 3241, 3241, 3252, 3252, 3258, 3261, 3269, 3269, 3273, 3273, 3278, 3284, 3287, 3293, 3295, 3295, 3298, 3301, 3312, 3329, 3332, 3332, 3341, 3341, 3345, 3345, 3369, 3369, 3386, 3389, 3396, 3397, 3401, 3401, 3406, 3414, 3416, 3423, 3426, 3429, 3440, 3457, 3460, 3460, 3479, 3481, 3506, 3506, 3516, 3516, 3518, 3519, 3527, 3529, 3531, 3534, 3541, 3541, 3543, 3543, 3552, 3569, 3573, 3584, 3643, 3646, 3676, 3712, 3715, 3715, 3717, 3718, 3721, 3721, 3723, 3724, 3726, 3731, 3736, 3736, 3744, 3744, 3748, 3748, 3750, 3750, 3752, 3753, 3756, 3756, 3770, 3770, 3774, 3775, 3781, 3781, 3783, 3783, 3790, 3791, 3802, 3803, 3806, 3839, 3912, 3912, 3947, 3952, 3980, 3983, 3992, 3992, 4029, 4029, 4045, 4046, 4048, 4095, 4130, 4130, 4136, 4136, 4139, 4139, 4147, 4149, 4154, 4159, 4186, 4255, 4294, 4303, 4345, 4346, 4348, 4351, 4442, 4446, 4515, 4519, 4602, 4607, 4615, 4615, 4679, 4679, 4681, 4681, 4686, 4687, 4695, 4695, 4697, 4697, 4702, 4703, 4743, 4743, 4745, 4745, 4750, 4751, 4783, 4783, 4785, 4785, 4790, 4791, 4799, 4799, 4801, 4801, 4806, 4807, 4815, 4815, 4823, 4823, 4847, 4847, 4879, 4879, 4881, 4881, 4886, 4887, 4895, 4895, 4935, 4935, 4955, 4960, 4989, 5023, 5109, 5120, 5751, 5759, 5789, 5791, 5873, 5887, 5901, 5901, 5909, 5919, 5943, 5951, 5972, 5983, 5997, 5997, 6001, 6001, 6004, 6015, 6109, 6111, 6122, 6143, 6159, 6159, 6170, 6175, 6264, 6271, 6314, 7679, 7836, 7839, 7930, 7935, 7958, 7959, 7966, 7967, 8006, 8007, 8014, 8015, 8024, 8024, 8026, 8026, 8028, 8028, 8030, 8030, 8062, 8063, 8117, 8117, 8133, 8133, 8148, 8149, 8156, 8156, 8176, 8177, 8181, 8181, 8191, 8191, 8275, 8278, 8280, 8286, 8292, 8297, 8306, 8307, 8335, 8351, 8370, 8399, 8427, 8447, 8507, 8508, 8524, 8530, 8580, 8591, 9167, 9215, 9255, 9279, 9291, 9311, 9471, 9471, 9748, 9749, 9752, 9752, 9854, 9855, 9866, 9984, 9989, 9989, 9994, 9995, 10024, 10024, 10060, 10060, 10062, 10062, 10067, 10069, 10071, 10071, 10079, 10080, 10133, 10135, 10160, 10160, 10175, 10191, 10220, 10223, 11008, 11903, 11930, 11930, 12020, 12031, 12246, 12271, 12284, 12287, 12352, 12352, 12439, 12440, 12544, 12548, 12589, 12592, 12687, 12687, 12728, 12783, 12829, 12831, 12868, 12880, 12924, 12926, 13004, 13007, 13055, 13055, 13175, 13178, 13278, 13279, 13311, 13311, 19894, 19967, 40870, 40959, 42125, 42127, 42183, 44031, 55204, 55295, 64046, 64047, 64107, 64255, 64263, 64274, 64280, 64284, 64311, 64311, 64317, 64317, 64319, 64319, 64322, 64322, 64325, 64325, 64434, 64466, 64832, 64847, 64912, 64913, 64968, 64975, 65021, 65023, 65040, 65055, 65060, 65071, 65095, 65096, 65107, 65107, 65127, 65127, 65132, 65135, 65141, 65141, 65277, 65278, 65280, 65280, 65471, 65473, 65480, 65481, 65488, 65489, 65496, 65497, 65501, 65503, 65511, 65511, 65519, 65528, 65536, 66303, 66335, 66335, 66340, 66351, 66379, 66559, 66598, 66599, 66638, 118783, 119030, 119039, 119079, 119081, 119262, 119807, 119893, 119893, 119965, 119965, 119968, 119969, 119971, 119972, 119975, 119976, 119981, 119981, 119994, 119994, 119996, 119996, 120001, 120001, 120004, 120004, 120070, 120070, 120075, 120076, 120085, 120085, 120093, 120093, 120122, 120122, 120127, 120127, 120133, 120133, 120135, 120137, 120145, 120145, 120484, 120487, 120778, 120781, 120832, 131069, 173783, 194559, 195102, 196605, 196608, 262141, 262144, 327677, 327680, 393213, 393216, 458749, 458752, 524285, 524288, 589821, 589824, 655357, 655360, 720893, 720896, 786429, 786432, 851965, 851968, 917501, 917504, 917504, 917506, 917535, 917632, 983037];
              const isUnassignedCodePoint = (character) => inRange(character, unassigned_code_points);
              const commonly_mapped_to_nothing = [173, 173, 847, 847, 6150, 6150, 6155, 6155, 6156, 6156, 6157, 6157, 8203, 8203, 8204, 8204, 8205, 8205, 8288, 8288, 65024, 65024, 65025, 65025, 65026, 65026, 65027, 65027, 65028, 65028, 65029, 65029, 65030, 65030, 65031, 65031, 65032, 65032, 65033, 65033, 65034, 65034, 65035, 65035, 65036, 65036, 65037, 65037, 65038, 65038, 65039, 65039, 65279, 65279];
              const isCommonlyMappedToNothing = (character) => inRange(character, commonly_mapped_to_nothing);
              const non_ASCII_space_characters = [160, 160, 5760, 5760, 8192, 8192, 8193, 8193, 8194, 8194, 8195, 8195, 8196, 8196, 8197, 8197, 8198, 8198, 8199, 8199, 8200, 8200, 8201, 8201, 8202, 8202, 8203, 8203, 8239, 8239, 8287, 8287, 12288, 12288];
              const isNonASCIISpaceCharacter = (character) => inRange(character, non_ASCII_space_characters);
              const non_ASCII_controls_characters = [128, 159, 1757, 1757, 1807, 1807, 6158, 6158, 8204, 8204, 8205, 8205, 8232, 8232, 8233, 8233, 8288, 8288, 8289, 8289, 8290, 8290, 8291, 8291, 8298, 8303, 65279, 65279, 65529, 65532, 119155, 119162];
              const non_character_codepoints = [64976, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1114110, 1114111];
              const prohibited_characters = [0, 31, 127, 127, 832, 832, 833, 833, 8206, 8206, 8207, 8207, 8234, 8234, 8235, 8235, 8236, 8236, 8237, 8237, 8238, 8238, 8298, 8298, 8299, 8299, 8300, 8300, 8301, 8301, 8302, 8302, 8303, 8303, 12272, 12283, 55296, 57343, 57344, 63743, 65529, 65529, 65530, 65530, 65531, 65531, 65532, 65532, 65533, 65533, 917505, 917505, 917536, 917631, 983040, 1048573, 1048576, 1114109];
              const isProhibitedCharacter = (character) => inRange(character, non_ASCII_space_characters) || inRange(character, prohibited_characters) || inRange(character, non_ASCII_controls_characters) || inRange(character, non_character_codepoints);
              const bidirectional_r_al = [1470, 1470, 1472, 1472, 1475, 1475, 1488, 1514, 1520, 1524, 1563, 1563, 1567, 1567, 1569, 1594, 1600, 1610, 1645, 1647, 1649, 1749, 1757, 1757, 1765, 1766, 1786, 1790, 1792, 1805, 1808, 1808, 1810, 1836, 1920, 1957, 1969, 1969, 8207, 8207, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65020, 65136, 65140, 65142, 65276];
              const isBidirectionalRAL = (character) => inRange(character, bidirectional_r_al);
              const bidirectional_l = [65, 90, 97, 122, 170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 544, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 1013, 1024, 1154, 1162, 1230, 1232, 1269, 1272, 1273, 1280, 1295, 1329, 1366, 1369, 1375, 1377, 1415, 1417, 1417, 2307, 2307, 2309, 2361, 2365, 2368, 2377, 2380, 2384, 2384, 2392, 2401, 2404, 2416, 2434, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2494, 2496, 2503, 2504, 2507, 2508, 2519, 2519, 2524, 2525, 2527, 2529, 2534, 2545, 2548, 2554, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2622, 2624, 2649, 2652, 2654, 2654, 2662, 2671, 2674, 2676, 2691, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2752, 2761, 2761, 2763, 2764, 2768, 2768, 2784, 2784, 2790, 2799, 2818, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2878, 2880, 2880, 2887, 2888, 2891, 2892, 2903, 2903, 2908, 2909, 2911, 2913, 2918, 2928, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3007, 3009, 3010, 3014, 3016, 3018, 3020, 3031, 3031, 3047, 3058, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3137, 3140, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3262, 3264, 3268, 3271, 3272, 3274, 3275, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3392, 3398, 3400, 3402, 3404, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3535, 3537, 3544, 3551, 3570, 3572, 3585, 3632, 3634, 3635, 3648, 3654, 3663, 3675, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3792, 3801, 3804, 3805, 3840, 3863, 3866, 3892, 3894, 3894, 3896, 3896, 3902, 3911, 3913, 3946, 3967, 3967, 3973, 3973, 3976, 3979, 4030, 4037, 4039, 4044, 4047, 4047, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4140, 4145, 4145, 4152, 4152, 4160, 4183, 4256, 4293, 4304, 4344, 4347, 4347, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4961, 4988, 5024, 5108, 5121, 5750, 5761, 5786, 5792, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5941, 5942, 5952, 5969, 5984, 5996, 5998, 6e3, 6016, 6070, 6078, 6085, 6087, 6088, 6100, 6106, 6108, 6108, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8206, 8206, 8305, 8305, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8509, 8511, 8517, 8521, 8544, 8579, 9014, 9082, 9109, 9109, 9372, 9449, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12588, 12593, 12686, 12688, 12727, 12784, 12828, 12832, 12867, 12896, 12923, 12927, 12976, 12992, 13003, 13008, 13054, 13056, 13174, 13179, 13277, 13280, 13310, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 55296, 64045, 64048, 64106, 64256, 64262, 64275, 64279, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 66304, 66334, 66336, 66339, 66352, 66378, 66560, 66597, 66600, 66637, 118784, 119029, 119040, 119078, 119082, 119142, 119146, 119154, 119171, 119172, 119180, 119209, 119214, 119261, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 12e4, 120002, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120483, 120488, 120777, 131072, 173782, 194560, 195101, 983040, 1048573, 1048576, 1114109];
              const isBidirectionalL = (character) => inRange(character, bidirectional_l);
              const mapping2space = isNonASCIISpaceCharacter;
              const mapping2nothing = isCommonlyMappedToNothing;
              const getCodePoint = (character) => character.codePointAt(0);
              const first = (x) => x[0];
              const last = (x) => x[x.length - 1];
              function toCodePoints(input) {
                const codepoints = [];
                const size = input.length;
                for (let i = 0; i < size; i += 1) {
                  const before = input.charCodeAt(i);
                  if (before >= 55296 && before <= 56319 && size > i + 1) {
                    const next = input.charCodeAt(i + 1);
                    if (next >= 56320 && next <= 57343) {
                      codepoints.push((before - 55296) * 1024 + next - 56320 + 65536);
                      i += 1;
                      continue;
                    }
                  }
                  codepoints.push(before);
                }
                return codepoints;
              }
              function saslprep(input) {
                let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                if (typeof input !== "string") {
                  throw new TypeError("Expected string.");
                }
                if (input.length === 0) {
                  return "";
                }
                const mapped_input = toCodePoints(input).map((character) => mapping2space(character) ? 32 : character).filter((character) => !mapping2nothing(character));
                const normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize("NFKC");
                const normalized_map = toCodePoints(normalized_input);
                const hasProhibited = normalized_map.some(isProhibitedCharacter);
                if (hasProhibited) {
                  throw new Error("Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3");
                }
                if (opts.allowUnassigned !== true) {
                  const hasUnassigned = normalized_map.some(isUnassignedCodePoint);
                  if (hasUnassigned) {
                    throw new Error("Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5");
                  }
                }
                const hasBidiRAL = normalized_map.some(isBidirectionalRAL);
                const hasBidiL = normalized_map.some(isBidirectionalL);
                if (hasBidiRAL && hasBidiL) {
                  throw new Error("String must not contain RandALCat and LCat at the same time, see https://tools.ietf.org/html/rfc3454#section-6");
                }
                const isFirstBidiRAL = isBidirectionalRAL(getCodePoint(first(normalized_input)));
                const isLastBidiRAL = isBidirectionalRAL(getCodePoint(last(normalized_input)));
                if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {
                  throw new Error("Bidirectional RandALCat character must be the first and the last character of the string, see https://tools.ietf.org/html/rfc3454#section-6");
                }
                return normalized_input;
              }
              class PDFSecurity {
                static generateFileID() {
                  let info = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  let infoStr = `${info.CreationDate.getTime()}
`;
                  for (let key in info) {
                    if (!info.hasOwnProperty(key)) {
                      continue;
                    }
                    infoStr += `${key}: ${info[key].valueOf()}
`;
                  }
                  return wordArrayToBuffer(_cryptoJs.default.MD5(infoStr));
                }
                static generateRandomWordArray(bytes) {
                  return _cryptoJs.default.lib.WordArray.random(bytes);
                }
                static create(document2) {
                  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  if (!options.ownerPassword && !options.userPassword) {
                    return null;
                  }
                  return new PDFSecurity(document2, options);
                }
                constructor(document2) {
                  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  if (!options.ownerPassword && !options.userPassword) {
                    throw new Error("None of owner password and user password is defined.");
                  }
                  this.document = document2;
                  this._setupEncryption(options);
                }
                _setupEncryption(options) {
                  switch (options.pdfVersion) {
                    case "1.4":
                    case "1.5":
                      this.version = 2;
                      break;
                    case "1.6":
                    case "1.7":
                      this.version = 4;
                      break;
                    case "1.7ext3":
                      this.version = 5;
                      break;
                    default:
                      this.version = 1;
                      break;
                  }
                  const encDict = {
                    Filter: "Standard"
                  };
                  switch (this.version) {
                    case 1:
                    case 2:
                    case 4:
                      this._setupEncryptionV1V2V4(this.version, encDict, options);
                      break;
                    case 5:
                      this._setupEncryptionV5(encDict, options);
                      break;
                  }
                  this.dictionary = this.document.ref(encDict);
                }
                _setupEncryptionV1V2V4(v, encDict, options) {
                  let r, permissions;
                  switch (v) {
                    case 1:
                      r = 2;
                      this.keyBits = 40;
                      permissions = getPermissionsR2(options.permissions);
                      break;
                    case 2:
                      r = 3;
                      this.keyBits = 128;
                      permissions = getPermissionsR3(options.permissions);
                      break;
                    case 4:
                      r = 4;
                      this.keyBits = 128;
                      permissions = getPermissionsR3(options.permissions);
                      break;
                  }
                  const paddedUserPassword = processPasswordR2R3R4(options.userPassword);
                  const paddedOwnerPassword = options.ownerPassword ? processPasswordR2R3R4(options.ownerPassword) : paddedUserPassword;
                  const ownerPasswordEntry = getOwnerPasswordR2R3R4(r, this.keyBits, paddedUserPassword, paddedOwnerPassword);
                  this.encryptionKey = getEncryptionKeyR2R3R4(r, this.keyBits, this.document._id, paddedUserPassword, ownerPasswordEntry, permissions);
                  let userPasswordEntry;
                  if (r === 2) {
                    userPasswordEntry = getUserPasswordR2(this.encryptionKey);
                  } else {
                    userPasswordEntry = getUserPasswordR3R4(this.document._id, this.encryptionKey);
                  }
                  encDict.V = v;
                  if (v >= 2) {
                    encDict.Length = this.keyBits;
                  }
                  if (v === 4) {
                    encDict.CF = {
                      StdCF: {
                        AuthEvent: "DocOpen",
                        CFM: "AESV2",
                        Length: this.keyBits / 8
                      }
                    };
                    encDict.StmF = "StdCF";
                    encDict.StrF = "StdCF";
                  }
                  encDict.R = r;
                  encDict.O = wordArrayToBuffer(ownerPasswordEntry);
                  encDict.U = wordArrayToBuffer(userPasswordEntry);
                  encDict.P = permissions;
                }
                _setupEncryptionV5(encDict, options) {
                  this.keyBits = 256;
                  const permissions = getPermissionsR3(options.permissions);
                  const processedUserPassword = processPasswordR5(options.userPassword);
                  const processedOwnerPassword = options.ownerPassword ? processPasswordR5(options.ownerPassword) : processedUserPassword;
                  this.encryptionKey = getEncryptionKeyR5(PDFSecurity.generateRandomWordArray);
                  const userPasswordEntry = getUserPasswordR5(processedUserPassword, PDFSecurity.generateRandomWordArray);
                  const userKeySalt = _cryptoJs.default.lib.WordArray.create(userPasswordEntry.words.slice(10, 12), 8);
                  const userEncryptionKeyEntry = getUserEncryptionKeyR5(processedUserPassword, userKeySalt, this.encryptionKey);
                  const ownerPasswordEntry = getOwnerPasswordR5(processedOwnerPassword, userPasswordEntry, PDFSecurity.generateRandomWordArray);
                  const ownerKeySalt = _cryptoJs.default.lib.WordArray.create(ownerPasswordEntry.words.slice(10, 12), 8);
                  const ownerEncryptionKeyEntry = getOwnerEncryptionKeyR5(processedOwnerPassword, ownerKeySalt, userPasswordEntry, this.encryptionKey);
                  const permsEntry = getEncryptedPermissionsR5(permissions, this.encryptionKey, PDFSecurity.generateRandomWordArray);
                  encDict.V = 5;
                  encDict.Length = this.keyBits;
                  encDict.CF = {
                    StdCF: {
                      AuthEvent: "DocOpen",
                      CFM: "AESV3",
                      Length: this.keyBits / 8
                    }
                  };
                  encDict.StmF = "StdCF";
                  encDict.StrF = "StdCF";
                  encDict.R = 5;
                  encDict.O = wordArrayToBuffer(ownerPasswordEntry);
                  encDict.OE = wordArrayToBuffer(ownerEncryptionKeyEntry);
                  encDict.U = wordArrayToBuffer(userPasswordEntry);
                  encDict.UE = wordArrayToBuffer(userEncryptionKeyEntry);
                  encDict.P = permissions;
                  encDict.Perms = wordArrayToBuffer(permsEntry);
                }
                getEncryptFn(obj, gen) {
                  let digest;
                  if (this.version < 5) {
                    digest = this.encryptionKey.clone().concat(_cryptoJs.default.lib.WordArray.create([(obj & 255) << 24 | (obj & 65280) << 8 | obj >> 8 & 65280 | gen & 255, (gen & 65280) << 16], 5));
                  }
                  if (this.version === 1 || this.version === 2) {
                    let key2 = _cryptoJs.default.MD5(digest);
                    key2.sigBytes = Math.min(16, this.keyBits / 8 + 5);
                    return (buffer) => wordArrayToBuffer(_cryptoJs.default.RC4.encrypt(_cryptoJs.default.lib.WordArray.create(buffer), key2).ciphertext);
                  }
                  let key;
                  if (this.version === 4) {
                    key = _cryptoJs.default.MD5(digest.concat(_cryptoJs.default.lib.WordArray.create([1933667412], 4)));
                  } else {
                    key = this.encryptionKey;
                  }
                  const iv = PDFSecurity.generateRandomWordArray(16);
                  const options = {
                    mode: _cryptoJs.default.mode.CBC,
                    padding: _cryptoJs.default.pad.Pkcs7,
                    iv
                  };
                  return (buffer) => wordArrayToBuffer(iv.clone().concat(_cryptoJs.default.AES.encrypt(_cryptoJs.default.lib.WordArray.create(buffer), key, options).ciphertext));
                }
                end() {
                  this.dictionary.end();
                }
              }
              function getPermissionsR2() {
                let permissionObject = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                let permissions = 4294967232 >> 0;
                if (permissionObject.printing) {
                  permissions |= 4;
                }
                if (permissionObject.modifying) {
                  permissions |= 8;
                }
                if (permissionObject.copying) {
                  permissions |= 16;
                }
                if (permissionObject.annotating) {
                  permissions |= 32;
                }
                return permissions;
              }
              function getPermissionsR3() {
                let permissionObject = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                let permissions = 4294963392 >> 0;
                if (permissionObject.printing === "lowResolution") {
                  permissions |= 4;
                }
                if (permissionObject.printing === "highResolution") {
                  permissions |= 2052;
                }
                if (permissionObject.modifying) {
                  permissions |= 8;
                }
                if (permissionObject.copying) {
                  permissions |= 16;
                }
                if (permissionObject.annotating) {
                  permissions |= 32;
                }
                if (permissionObject.fillingForms) {
                  permissions |= 256;
                }
                if (permissionObject.contentAccessibility) {
                  permissions |= 512;
                }
                if (permissionObject.documentAssembly) {
                  permissions |= 1024;
                }
                return permissions;
              }
              function getUserPasswordR2(encryptionKey) {
                return _cryptoJs.default.RC4.encrypt(processPasswordR2R3R4(), encryptionKey).ciphertext;
              }
              function getUserPasswordR3R4(documentId, encryptionKey) {
                const key = encryptionKey.clone();
                let cipher = _cryptoJs.default.MD5(processPasswordR2R3R4().concat(_cryptoJs.default.lib.WordArray.create(documentId)));
                for (let i = 0; i < 20; i++) {
                  const xorRound = Math.ceil(key.sigBytes / 4);
                  for (let j = 0; j < xorRound; j++) {
                    key.words[j] = encryptionKey.words[j] ^ (i | i << 8 | i << 16 | i << 24);
                  }
                  cipher = _cryptoJs.default.RC4.encrypt(cipher, key).ciphertext;
                }
                return cipher.concat(_cryptoJs.default.lib.WordArray.create(null, 16));
              }
              function getOwnerPasswordR2R3R4(r, keyBits, paddedUserPassword, paddedOwnerPassword) {
                let digest = paddedOwnerPassword;
                let round = r >= 3 ? 51 : 1;
                for (let i = 0; i < round; i++) {
                  digest = _cryptoJs.default.MD5(digest);
                }
                const key = digest.clone();
                key.sigBytes = keyBits / 8;
                let cipher = paddedUserPassword;
                round = r >= 3 ? 20 : 1;
                for (let i = 0; i < round; i++) {
                  const xorRound = Math.ceil(key.sigBytes / 4);
                  for (let j = 0; j < xorRound; j++) {
                    key.words[j] = digest.words[j] ^ (i | i << 8 | i << 16 | i << 24);
                  }
                  cipher = _cryptoJs.default.RC4.encrypt(cipher, key).ciphertext;
                }
                return cipher;
              }
              function getEncryptionKeyR2R3R4(r, keyBits, documentId, paddedUserPassword, ownerPasswordEntry, permissions) {
                let key = paddedUserPassword.clone().concat(ownerPasswordEntry).concat(_cryptoJs.default.lib.WordArray.create([lsbFirstWord(permissions)], 4)).concat(_cryptoJs.default.lib.WordArray.create(documentId));
                const round = r >= 3 ? 51 : 1;
                for (let i = 0; i < round; i++) {
                  key = _cryptoJs.default.MD5(key);
                  key.sigBytes = keyBits / 8;
                }
                return key;
              }
              function getUserPasswordR5(processedUserPassword, generateRandomWordArray) {
                const validationSalt = generateRandomWordArray(8);
                const keySalt = generateRandomWordArray(8);
                return _cryptoJs.default.SHA256(processedUserPassword.clone().concat(validationSalt)).concat(validationSalt).concat(keySalt);
              }
              function getUserEncryptionKeyR5(processedUserPassword, userKeySalt, encryptionKey) {
                const key = _cryptoJs.default.SHA256(processedUserPassword.clone().concat(userKeySalt));
                const options = {
                  mode: _cryptoJs.default.mode.CBC,
                  padding: _cryptoJs.default.pad.NoPadding,
                  iv: _cryptoJs.default.lib.WordArray.create(null, 16)
                };
                return _cryptoJs.default.AES.encrypt(encryptionKey, key, options).ciphertext;
              }
              function getOwnerPasswordR5(processedOwnerPassword, userPasswordEntry, generateRandomWordArray) {
                const validationSalt = generateRandomWordArray(8);
                const keySalt = generateRandomWordArray(8);
                return _cryptoJs.default.SHA256(processedOwnerPassword.clone().concat(validationSalt).concat(userPasswordEntry)).concat(validationSalt).concat(keySalt);
              }
              function getOwnerEncryptionKeyR5(processedOwnerPassword, ownerKeySalt, userPasswordEntry, encryptionKey) {
                const key = _cryptoJs.default.SHA256(processedOwnerPassword.clone().concat(ownerKeySalt).concat(userPasswordEntry));
                const options = {
                  mode: _cryptoJs.default.mode.CBC,
                  padding: _cryptoJs.default.pad.NoPadding,
                  iv: _cryptoJs.default.lib.WordArray.create(null, 16)
                };
                return _cryptoJs.default.AES.encrypt(encryptionKey, key, options).ciphertext;
              }
              function getEncryptionKeyR5(generateRandomWordArray) {
                return generateRandomWordArray(32);
              }
              function getEncryptedPermissionsR5(permissions, encryptionKey, generateRandomWordArray) {
                const cipher = _cryptoJs.default.lib.WordArray.create([lsbFirstWord(permissions), 4294967295, 1415668834], 12).concat(generateRandomWordArray(4));
                const options = {
                  mode: _cryptoJs.default.mode.ECB,
                  padding: _cryptoJs.default.pad.NoPadding
                };
                return _cryptoJs.default.AES.encrypt(cipher, encryptionKey, options).ciphertext;
              }
              function processPasswordR2R3R4() {
                let password = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
                const out = Buffer.alloc(32);
                const length = password.length;
                let index = 0;
                while (index < length && index < 32) {
                  const code = password.charCodeAt(index);
                  if (code > 255) {
                    throw new Error("Password contains one or more invalid characters.");
                  }
                  out[index] = code;
                  index++;
                }
                while (index < 32) {
                  out[index] = PASSWORD_PADDING[index - length];
                  index++;
                }
                return _cryptoJs.default.lib.WordArray.create(out);
              }
              function processPasswordR5() {
                let password = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
                password = unescape(encodeURIComponent(saslprep(password)));
                const length = Math.min(127, password.length);
                const out = Buffer.alloc(length);
                for (let i = 0; i < length; i++) {
                  out[i] = password.charCodeAt(i);
                }
                return _cryptoJs.default.lib.WordArray.create(out);
              }
              function lsbFirstWord(data) {
                return (data & 255) << 24 | (data & 65280) << 8 | data >> 8 & 65280 | data >> 24 & 255;
              }
              function wordArrayToBuffer(wordArray) {
                const byteArray = [];
                for (let i = 0; i < wordArray.sigBytes; i++) {
                  byteArray.push(wordArray.words[Math.floor(i / 4)] >> 8 * (3 - i % 4) & 255);
                }
                return Buffer.from(byteArray);
              }
              const PASSWORD_PADDING = [40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122];
              const {
                number: number$2
              } = PDFObject;
              class PDFGradient$1 {
                constructor(doc) {
                  this.doc = doc;
                  this.stops = [];
                  this.embedded = false;
                  this.transform = [1, 0, 0, 1, 0, 0];
                }
                stop(pos, color, opacity) {
                  if (opacity == null) {
                    opacity = 1;
                  }
                  color = this.doc._normalizeColor(color);
                  if (this.stops.length === 0) {
                    if (color.length === 3) {
                      this._colorSpace = "DeviceRGB";
                    } else if (color.length === 4) {
                      this._colorSpace = "DeviceCMYK";
                    } else if (color.length === 1) {
                      this._colorSpace = "DeviceGray";
                    } else {
                      throw new Error("Unknown color space");
                    }
                  } else if (this._colorSpace === "DeviceRGB" && color.length !== 3 || this._colorSpace === "DeviceCMYK" && color.length !== 4 || this._colorSpace === "DeviceGray" && color.length !== 1) {
                    throw new Error("All gradient stops must use the same color space");
                  }
                  opacity = Math.max(0, Math.min(1, opacity));
                  this.stops.push([pos, color, opacity]);
                  return this;
                }
                setTransform(m11, m12, m21, m22, dx, dy) {
                  this.transform = [m11, m12, m21, m22, dx, dy];
                  return this;
                }
                embed(m) {
                  let fn;
                  const stopsLength = this.stops.length;
                  if (stopsLength === 0) {
                    return;
                  }
                  this.embedded = true;
                  this.matrix = m;
                  const last2 = this.stops[stopsLength - 1];
                  if (last2[0] < 1) {
                    this.stops.push([1, last2[1], last2[2]]);
                  }
                  const bounds = [];
                  const encode = [];
                  const stops = [];
                  for (let i = 0; i < stopsLength - 1; i++) {
                    encode.push(0, 1);
                    if (i + 2 !== stopsLength) {
                      bounds.push(this.stops[i + 1][0]);
                    }
                    fn = this.doc.ref({
                      FunctionType: 2,
                      Domain: [0, 1],
                      C0: this.stops[i + 0][1],
                      C1: this.stops[i + 1][1],
                      N: 1
                    });
                    stops.push(fn);
                    fn.end();
                  }
                  if (stopsLength === 1) {
                    fn = stops[0];
                  } else {
                    fn = this.doc.ref({
                      FunctionType: 3,
                      Domain: [0, 1],
                      Functions: stops,
                      Bounds: bounds,
                      Encode: encode
                    });
                    fn.end();
                  }
                  this.id = `Sh${++this.doc._gradCount}`;
                  const shader = this.shader(fn);
                  shader.end();
                  const pattern2 = this.doc.ref({
                    Type: "Pattern",
                    PatternType: 2,
                    Shading: shader,
                    Matrix: this.matrix.map(number$2)
                  });
                  pattern2.end();
                  if (this.stops.some((stop) => stop[2] < 1)) {
                    let grad = this.opacityGradient();
                    grad._colorSpace = "DeviceGray";
                    for (let stop of this.stops) {
                      grad.stop(stop[0], [stop[2]]);
                    }
                    grad = grad.embed(this.matrix);
                    const pageBBox = [0, 0, this.doc.page.width, this.doc.page.height];
                    const form = this.doc.ref({
                      Type: "XObject",
                      Subtype: "Form",
                      FormType: 1,
                      BBox: pageBBox,
                      Group: {
                        Type: "Group",
                        S: "Transparency",
                        CS: "DeviceGray"
                      },
                      Resources: {
                        ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
                        Pattern: {
                          Sh1: grad
                        }
                      }
                    });
                    form.write("/Pattern cs /Sh1 scn");
                    form.end(`${pageBBox.join(" ")} re f`);
                    const gstate = this.doc.ref({
                      Type: "ExtGState",
                      SMask: {
                        Type: "Mask",
                        S: "Luminosity",
                        G: form
                      }
                    });
                    gstate.end();
                    const opacityPattern = this.doc.ref({
                      Type: "Pattern",
                      PatternType: 1,
                      PaintType: 1,
                      TilingType: 2,
                      BBox: pageBBox,
                      XStep: pageBBox[2],
                      YStep: pageBBox[3],
                      Resources: {
                        ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
                        Pattern: {
                          Sh1: pattern2
                        },
                        ExtGState: {
                          Gs1: gstate
                        }
                      }
                    });
                    opacityPattern.write("/Gs1 gs /Pattern cs /Sh1 scn");
                    opacityPattern.end(`${pageBBox.join(" ")} re f`);
                    this.doc.page.patterns[this.id] = opacityPattern;
                  } else {
                    this.doc.page.patterns[this.id] = pattern2;
                  }
                  return pattern2;
                }
                apply(stroke) {
                  const [m0, m1, m2, m3, m4, m5] = this.doc._ctm;
                  const [m11, m12, m21, m22, dx, dy] = this.transform;
                  const m = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];
                  if (!this.embedded || m.join(" ") !== this.matrix.join(" ")) {
                    this.embed(m);
                  }
                  this.doc._setColorSpace("Pattern", stroke);
                  const op = stroke ? "SCN" : "scn";
                  return this.doc.addContent(`/${this.id} ${op}`);
                }
              }
              class PDFLinearGradient$1 extends PDFGradient$1 {
                constructor(doc, x1, y1, x2, y2) {
                  super(doc);
                  this.x1 = x1;
                  this.y1 = y1;
                  this.x2 = x2;
                  this.y2 = y2;
                }
                shader(fn) {
                  return this.doc.ref({
                    ShadingType: 2,
                    ColorSpace: this._colorSpace,
                    Coords: [this.x1, this.y1, this.x2, this.y2],
                    Function: fn,
                    Extend: [true, true]
                  });
                }
                opacityGradient() {
                  return new PDFLinearGradient$1(this.doc, this.x1, this.y1, this.x2, this.y2);
                }
              }
              class PDFRadialGradient$1 extends PDFGradient$1 {
                constructor(doc, x1, y1, r1, x2, y2, r2) {
                  super(doc);
                  this.doc = doc;
                  this.x1 = x1;
                  this.y1 = y1;
                  this.r1 = r1;
                  this.x2 = x2;
                  this.y2 = y2;
                  this.r2 = r2;
                }
                shader(fn) {
                  return this.doc.ref({
                    ShadingType: 3,
                    ColorSpace: this._colorSpace,
                    Coords: [this.x1, this.y1, this.r1, this.x2, this.y2, this.r2],
                    Function: fn,
                    Extend: [true, true]
                  });
                }
                opacityGradient() {
                  return new PDFRadialGradient$1(this.doc, this.x1, this.y1, this.r1, this.x2, this.y2, this.r2);
                }
              }
              var Gradient = {
                PDFGradient: PDFGradient$1,
                PDFLinearGradient: PDFLinearGradient$1,
                PDFRadialGradient: PDFRadialGradient$1
              };
              const underlyingColorSpaces = ["DeviceCMYK", "DeviceRGB"];
              class PDFTilingPattern$1 {
                constructor(doc, bBox, xStep, yStep, stream) {
                  this.doc = doc;
                  this.bBox = bBox;
                  this.xStep = xStep;
                  this.yStep = yStep;
                  this.stream = stream;
                }
                createPattern() {
                  const resources = this.doc.ref();
                  resources.end();
                  const [m0, m1, m2, m3, m4, m5] = this.doc._ctm;
                  const [m11, m12, m21, m22, dx, dy] = [1, 0, 0, 1, 0, 0];
                  const m = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];
                  const pattern2 = this.doc.ref({
                    Type: "Pattern",
                    PatternType: 1,
                    PaintType: 2,
                    TilingType: 2,
                    BBox: this.bBox,
                    XStep: this.xStep,
                    YStep: this.yStep,
                    Matrix: m.map((v) => +v.toFixed(5)),
                    Resources: resources
                  });
                  pattern2.end(this.stream);
                  return pattern2;
                }
                embedPatternColorSpaces() {
                  underlyingColorSpaces.forEach((csName) => {
                    const csId = this.getPatternColorSpaceId(csName);
                    if (this.doc.page.colorSpaces[csId]) return;
                    const cs = this.doc.ref(["Pattern", csName]);
                    cs.end();
                    this.doc.page.colorSpaces[csId] = cs;
                  });
                }
                getPatternColorSpaceId(underlyingColorspace) {
                  return `CsP${underlyingColorspace}`;
                }
                embed() {
                  if (!this.id) {
                    this.doc._patternCount = this.doc._patternCount + 1;
                    this.id = "P" + this.doc._patternCount;
                    this.pattern = this.createPattern();
                  }
                  if (!this.doc.page.patterns[this.id]) {
                    this.doc.page.patterns[this.id] = this.pattern;
                  }
                }
                apply(stroke, patternColor) {
                  this.embedPatternColorSpaces();
                  this.embed();
                  const normalizedColor = this.doc._normalizeColor(patternColor);
                  if (!normalizedColor) throw Error(`invalid pattern color. (value: ${patternColor})`);
                  const csId = this.getPatternColorSpaceId(this.doc._getColorSpace(normalizedColor));
                  this.doc._setColorSpace(csId, stroke);
                  const op = stroke ? "SCN" : "scn";
                  return this.doc.addContent(`${normalizedColor.join(" ")} /${this.id} ${op}`);
                }
              }
              var pattern = {
                PDFTilingPattern: PDFTilingPattern$1
              };
              const {
                PDFGradient,
                PDFLinearGradient,
                PDFRadialGradient
              } = Gradient;
              const {
                PDFTilingPattern
              } = pattern;
              var ColorMixin = {
                initColor() {
                  this.spotColors = {};
                  this._opacityRegistry = {};
                  this._opacityCount = 0;
                  this._patternCount = 0;
                  this._gradCount = 0;
                },
                _normalizeColor(color) {
                  if (typeof color === "string") {
                    if (color.charAt(0) === "#") {
                      if (color.length === 4) {
                        color = color.replace(/#([0-9A-F])([0-9A-F])([0-9A-F])/i, "#$1$1$2$2$3$3");
                      }
                      const hex = parseInt(color.slice(1), 16);
                      color = [hex >> 16, hex >> 8 & 255, hex & 255];
                    } else if (namedColors[color]) {
                      color = namedColors[color];
                    } else if (this.spotColors[color]) {
                      return this.spotColors[color];
                    }
                  }
                  if (Array.isArray(color)) {
                    if (color.length === 3) {
                      color = color.map((part) => part / 255);
                    } else if (color.length === 4) {
                      color = color.map((part) => part / 100);
                    }
                    return color;
                  }
                  return null;
                },
                _setColor(color, stroke) {
                  if (color instanceof PDFGradient) {
                    color.apply(stroke);
                    return true;
                  } else if (Array.isArray(color) && color[0] instanceof PDFTilingPattern) {
                    color[0].apply(stroke, color[1]);
                    return true;
                  }
                  return this._setColorCore(color, stroke);
                },
                _setColorCore(color, stroke) {
                  color = this._normalizeColor(color);
                  if (!color) {
                    return false;
                  }
                  const op = stroke ? "SCN" : "scn";
                  const space = this._getColorSpace(color);
                  this._setColorSpace(space, stroke);
                  if (color instanceof SpotColor) {
                    this.page.colorSpaces[color.id] = color.ref;
                    this.addContent(`1 ${op}`);
                  } else {
                    this.addContent(`${color.join(" ")} ${op}`);
                  }
                  return true;
                },
                _setColorSpace(space, stroke) {
                  const op = stroke ? "CS" : "cs";
                  return this.addContent(`/${space} ${op}`);
                },
                _getColorSpace(color) {
                  if (color instanceof SpotColor) {
                    return color.id;
                  }
                  return color.length === 4 ? "DeviceCMYK" : "DeviceRGB";
                },
                fillColor(color, opacity) {
                  const set = this._setColor(color, false);
                  if (set) {
                    this.fillOpacity(opacity);
                  }
                  this._fillColor = [color, opacity];
                  return this;
                },
                strokeColor(color, opacity) {
                  const set = this._setColor(color, true);
                  if (set) {
                    this.strokeOpacity(opacity);
                  }
                  return this;
                },
                opacity(opacity) {
                  this._doOpacity(opacity, opacity);
                  return this;
                },
                fillOpacity(opacity) {
                  this._doOpacity(opacity, null);
                  return this;
                },
                strokeOpacity(opacity) {
                  this._doOpacity(null, opacity);
                  return this;
                },
                _doOpacity(fillOpacity, strokeOpacity) {
                  let dictionary, name;
                  if (fillOpacity == null && strokeOpacity == null) {
                    return;
                  }
                  if (fillOpacity != null) {
                    fillOpacity = Math.max(0, Math.min(1, fillOpacity));
                  }
                  if (strokeOpacity != null) {
                    strokeOpacity = Math.max(0, Math.min(1, strokeOpacity));
                  }
                  const key = `${fillOpacity}_${strokeOpacity}`;
                  if (this._opacityRegistry[key]) {
                    [dictionary, name] = this._opacityRegistry[key];
                  } else {
                    dictionary = {
                      Type: "ExtGState"
                    };
                    if (fillOpacity != null) {
                      dictionary.ca = fillOpacity;
                    }
                    if (strokeOpacity != null) {
                      dictionary.CA = strokeOpacity;
                    }
                    dictionary = this.ref(dictionary);
                    dictionary.end();
                    const id = ++this._opacityCount;
                    name = `Gs${id}`;
                    this._opacityRegistry[key] = [dictionary, name];
                  }
                  this.page.ext_gstates[name] = dictionary;
                  return this.addContent(`/${name} gs`);
                },
                linearGradient(x1, y1, x2, y2) {
                  return new PDFLinearGradient(this, x1, y1, x2, y2);
                },
                radialGradient(x1, y1, r1, x2, y2, r2) {
                  return new PDFRadialGradient(this, x1, y1, r1, x2, y2, r2);
                },
                pattern(bbox, xStep, yStep, stream) {
                  return new PDFTilingPattern(this, bbox, xStep, yStep, stream);
                },
                addSpotColor(name, C, M, Y, K) {
                  const color = new SpotColor(this, name, C, M, Y, K);
                  this.spotColors[name] = color;
                  return this;
                }
              };
              var namedColors = {
                aliceblue: [240, 248, 255],
                antiquewhite: [250, 235, 215],
                aqua: [0, 255, 255],
                aquamarine: [127, 255, 212],
                azure: [240, 255, 255],
                beige: [245, 245, 220],
                bisque: [255, 228, 196],
                black: [0, 0, 0],
                blanchedalmond: [255, 235, 205],
                blue: [0, 0, 255],
                blueviolet: [138, 43, 226],
                brown: [165, 42, 42],
                burlywood: [222, 184, 135],
                cadetblue: [95, 158, 160],
                chartreuse: [127, 255, 0],
                chocolate: [210, 105, 30],
                coral: [255, 127, 80],
                cornflowerblue: [100, 149, 237],
                cornsilk: [255, 248, 220],
                crimson: [220, 20, 60],
                cyan: [0, 255, 255],
                darkblue: [0, 0, 139],
                darkcyan: [0, 139, 139],
                darkgoldenrod: [184, 134, 11],
                darkgray: [169, 169, 169],
                darkgreen: [0, 100, 0],
                darkgrey: [169, 169, 169],
                darkkhaki: [189, 183, 107],
                darkmagenta: [139, 0, 139],
                darkolivegreen: [85, 107, 47],
                darkorange: [255, 140, 0],
                darkorchid: [153, 50, 204],
                darkred: [139, 0, 0],
                darksalmon: [233, 150, 122],
                darkseagreen: [143, 188, 143],
                darkslateblue: [72, 61, 139],
                darkslategray: [47, 79, 79],
                darkslategrey: [47, 79, 79],
                darkturquoise: [0, 206, 209],
                darkviolet: [148, 0, 211],
                deeppink: [255, 20, 147],
                deepskyblue: [0, 191, 255],
                dimgray: [105, 105, 105],
                dimgrey: [105, 105, 105],
                dodgerblue: [30, 144, 255],
                firebrick: [178, 34, 34],
                floralwhite: [255, 250, 240],
                forestgreen: [34, 139, 34],
                fuchsia: [255, 0, 255],
                gainsboro: [220, 220, 220],
                ghostwhite: [248, 248, 255],
                gold: [255, 215, 0],
                goldenrod: [218, 165, 32],
                gray: [128, 128, 128],
                grey: [128, 128, 128],
                green: [0, 128, 0],
                greenyellow: [173, 255, 47],
                honeydew: [240, 255, 240],
                hotpink: [255, 105, 180],
                indianred: [205, 92, 92],
                indigo: [75, 0, 130],
                ivory: [255, 255, 240],
                khaki: [240, 230, 140],
                lavender: [230, 230, 250],
                lavenderblush: [255, 240, 245],
                lawngreen: [124, 252, 0],
                lemonchiffon: [255, 250, 205],
                lightblue: [173, 216, 230],
                lightcoral: [240, 128, 128],
                lightcyan: [224, 255, 255],
                lightgoldenrodyellow: [250, 250, 210],
                lightgray: [211, 211, 211],
                lightgreen: [144, 238, 144],
                lightgrey: [211, 211, 211],
                lightpink: [255, 182, 193],
                lightsalmon: [255, 160, 122],
                lightseagreen: [32, 178, 170],
                lightskyblue: [135, 206, 250],
                lightslategray: [119, 136, 153],
                lightslategrey: [119, 136, 153],
                lightsteelblue: [176, 196, 222],
                lightyellow: [255, 255, 224],
                lime: [0, 255, 0],
                limegreen: [50, 205, 50],
                linen: [250, 240, 230],
                magenta: [255, 0, 255],
                maroon: [128, 0, 0],
                mediumaquamarine: [102, 205, 170],
                mediumblue: [0, 0, 205],
                mediumorchid: [186, 85, 211],
                mediumpurple: [147, 112, 219],
                mediumseagreen: [60, 179, 113],
                mediumslateblue: [123, 104, 238],
                mediumspringgreen: [0, 250, 154],
                mediumturquoise: [72, 209, 204],
                mediumvioletred: [199, 21, 133],
                midnightblue: [25, 25, 112],
                mintcream: [245, 255, 250],
                mistyrose: [255, 228, 225],
                moccasin: [255, 228, 181],
                navajowhite: [255, 222, 173],
                navy: [0, 0, 128],
                oldlace: [253, 245, 230],
                olive: [128, 128, 0],
                olivedrab: [107, 142, 35],
                orange: [255, 165, 0],
                orangered: [255, 69, 0],
                orchid: [218, 112, 214],
                palegoldenrod: [238, 232, 170],
                palegreen: [152, 251, 152],
                paleturquoise: [175, 238, 238],
                palevioletred: [219, 112, 147],
                papayawhip: [255, 239, 213],
                peachpuff: [255, 218, 185],
                peru: [205, 133, 63],
                pink: [255, 192, 203],
                plum: [221, 160, 221],
                powderblue: [176, 224, 230],
                purple: [128, 0, 128],
                red: [255, 0, 0],
                rosybrown: [188, 143, 143],
                royalblue: [65, 105, 225],
                saddlebrown: [139, 69, 19],
                salmon: [250, 128, 114],
                sandybrown: [244, 164, 96],
                seagreen: [46, 139, 87],
                seashell: [255, 245, 238],
                sienna: [160, 82, 45],
                silver: [192, 192, 192],
                skyblue: [135, 206, 235],
                slateblue: [106, 90, 205],
                slategray: [112, 128, 144],
                slategrey: [112, 128, 144],
                snow: [255, 250, 250],
                springgreen: [0, 255, 127],
                steelblue: [70, 130, 180],
                tan: [210, 180, 140],
                teal: [0, 128, 128],
                thistle: [216, 191, 216],
                tomato: [255, 99, 71],
                turquoise: [64, 224, 208],
                violet: [238, 130, 238],
                wheat: [245, 222, 179],
                white: [255, 255, 255],
                whitesmoke: [245, 245, 245],
                yellow: [255, 255, 0],
                yellowgreen: [154, 205, 50]
              };
              let cx, cy, px, py, sx, sy;
              cx = cy = px = py = sx = sy = 0;
              const parameters = {
                A: 7,
                a: 7,
                C: 6,
                c: 6,
                H: 1,
                h: 1,
                L: 2,
                l: 2,
                M: 2,
                m: 2,
                Q: 4,
                q: 4,
                S: 4,
                s: 4,
                T: 2,
                t: 2,
                V: 1,
                v: 1,
                Z: 0,
                z: 0
              };
              const parse = function(path) {
                let cmd;
                const ret = [];
                let args = [];
                let curArg = "";
                let foundDecimal = false;
                let params = 0;
                for (let c of path) {
                  if (parameters[c] != null) {
                    params = parameters[c];
                    if (cmd) {
                      if (curArg.length > 0) {
                        args[args.length] = +curArg;
                      }
                      ret[ret.length] = {
                        cmd,
                        args
                      };
                      args = [];
                      curArg = "";
                      foundDecimal = false;
                    }
                    cmd = c;
                  } else if ([" ", ","].includes(c) || c === "-" && curArg.length > 0 && curArg[curArg.length - 1] !== "e" || c === "." && foundDecimal) {
                    if (curArg.length === 0) {
                      continue;
                    }
                    if (args.length === params) {
                      ret[ret.length] = {
                        cmd,
                        args
                      };
                      args = [+curArg];
                      if (cmd === "M") {
                        cmd = "L";
                      }
                      if (cmd === "m") {
                        cmd = "l";
                      }
                    } else {
                      args[args.length] = +curArg;
                    }
                    foundDecimal = c === ".";
                    curArg = ["-", "."].includes(c) ? c : "";
                  } else {
                    curArg += c;
                    if (c === ".") {
                      foundDecimal = true;
                    }
                  }
                }
                if (curArg.length > 0) {
                  if (args.length === params) {
                    ret[ret.length] = {
                      cmd,
                      args
                    };
                    args = [+curArg];
                    if (cmd === "M") {
                      cmd = "L";
                    }
                    if (cmd === "m") {
                      cmd = "l";
                    }
                  } else {
                    args[args.length] = +curArg;
                  }
                }
                ret[ret.length] = {
                  cmd,
                  args
                };
                return ret;
              };
              const apply = function(commands, doc) {
                cx = cy = px = py = sx = sy = 0;
                for (let i = 0; i < commands.length; i++) {
                  const c = commands[i];
                  if (typeof runners[c.cmd] === "function") {
                    runners[c.cmd](doc, c.args);
                  }
                }
              };
              const runners = {
                M(doc, a) {
                  cx = a[0];
                  cy = a[1];
                  px = py = null;
                  sx = cx;
                  sy = cy;
                  return doc.moveTo(cx, cy);
                },
                m(doc, a) {
                  cx += a[0];
                  cy += a[1];
                  px = py = null;
                  sx = cx;
                  sy = cy;
                  return doc.moveTo(cx, cy);
                },
                C(doc, a) {
                  cx = a[4];
                  cy = a[5];
                  px = a[2];
                  py = a[3];
                  return doc.bezierCurveTo(...a);
                },
                c(doc, a) {
                  doc.bezierCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy, a[4] + cx, a[5] + cy);
                  px = cx + a[2];
                  py = cy + a[3];
                  cx += a[4];
                  return cy += a[5];
                },
                S(doc, a) {
                  if (px === null) {
                    px = cx;
                    py = cy;
                  }
                  doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), a[0], a[1], a[2], a[3]);
                  px = a[0];
                  py = a[1];
                  cx = a[2];
                  return cy = a[3];
                },
                s(doc, a) {
                  if (px === null) {
                    px = cx;
                    py = cy;
                  }
                  doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), cx + a[0], cy + a[1], cx + a[2], cy + a[3]);
                  px = cx + a[0];
                  py = cy + a[1];
                  cx += a[2];
                  return cy += a[3];
                },
                Q(doc, a) {
                  px = a[0];
                  py = a[1];
                  cx = a[2];
                  cy = a[3];
                  return doc.quadraticCurveTo(a[0], a[1], cx, cy);
                },
                q(doc, a) {
                  doc.quadraticCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy);
                  px = cx + a[0];
                  py = cy + a[1];
                  cx += a[2];
                  return cy += a[3];
                },
                T(doc, a) {
                  if (px === null) {
                    px = cx;
                    py = cy;
                  } else {
                    px = cx - (px - cx);
                    py = cy - (py - cy);
                  }
                  doc.quadraticCurveTo(px, py, a[0], a[1]);
                  px = cx - (px - cx);
                  py = cy - (py - cy);
                  cx = a[0];
                  return cy = a[1];
                },
                t(doc, a) {
                  if (px === null) {
                    px = cx;
                    py = cy;
                  } else {
                    px = cx - (px - cx);
                    py = cy - (py - cy);
                  }
                  doc.quadraticCurveTo(px, py, cx + a[0], cy + a[1]);
                  cx += a[0];
                  return cy += a[1];
                },
                A(doc, a) {
                  solveArc(doc, cx, cy, a);
                  cx = a[5];
                  return cy = a[6];
                },
                a(doc, a) {
                  a[5] += cx;
                  a[6] += cy;
                  solveArc(doc, cx, cy, a);
                  cx = a[5];
                  return cy = a[6];
                },
                L(doc, a) {
                  cx = a[0];
                  cy = a[1];
                  px = py = null;
                  return doc.lineTo(cx, cy);
                },
                l(doc, a) {
                  cx += a[0];
                  cy += a[1];
                  px = py = null;
                  return doc.lineTo(cx, cy);
                },
                H(doc, a) {
                  cx = a[0];
                  px = py = null;
                  return doc.lineTo(cx, cy);
                },
                h(doc, a) {
                  cx += a[0];
                  px = py = null;
                  return doc.lineTo(cx, cy);
                },
                V(doc, a) {
                  cy = a[0];
                  px = py = null;
                  return doc.lineTo(cx, cy);
                },
                v(doc, a) {
                  cy += a[0];
                  px = py = null;
                  return doc.lineTo(cx, cy);
                },
                Z(doc) {
                  doc.closePath();
                  cx = sx;
                  return cy = sy;
                },
                z(doc) {
                  doc.closePath();
                  cx = sx;
                  return cy = sy;
                }
              };
              const solveArc = function(doc, x, y, coords) {
                const [rx, ry, rot, large, sweep, ex, ey] = coords;
                const segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);
                for (let seg of segs) {
                  const bez = segmentToBezier(...seg);
                  doc.bezierCurveTo(...bez);
                }
              };
              const arcToSegments = function(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
                const th = rotateX * (Math.PI / 180);
                const sin_th = Math.sin(th);
                const cos_th = Math.cos(th);
                rx = Math.abs(rx);
                ry = Math.abs(ry);
                px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
                py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
                let pl = px * px / (rx * rx) + py * py / (ry * ry);
                if (pl > 1) {
                  pl = Math.sqrt(pl);
                  rx *= pl;
                  ry *= pl;
                }
                const a00 = cos_th / rx;
                const a01 = sin_th / rx;
                const a10 = -sin_th / ry;
                const a11 = cos_th / ry;
                const x0 = a00 * ox + a01 * oy;
                const y0 = a10 * ox + a11 * oy;
                const x1 = a00 * x + a01 * y;
                const y1 = a10 * x + a11 * y;
                const d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
                let sfactor_sq = 1 / d - 0.25;
                if (sfactor_sq < 0) {
                  sfactor_sq = 0;
                }
                let sfactor = Math.sqrt(sfactor_sq);
                if (sweep === large) {
                  sfactor = -sfactor;
                }
                const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
                const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
                const th0 = Math.atan2(y0 - yc, x0 - xc);
                const th1 = Math.atan2(y1 - yc, x1 - xc);
                let th_arc = th1 - th0;
                if (th_arc < 0 && sweep === 1) {
                  th_arc += 2 * Math.PI;
                } else if (th_arc > 0 && sweep === 0) {
                  th_arc -= 2 * Math.PI;
                }
                const segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 1e-3)));
                const result = [];
                for (let i = 0; i < segments; i++) {
                  const th2 = th0 + i * th_arc / segments;
                  const th3 = th0 + (i + 1) * th_arc / segments;
                  result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
                }
                return result;
              };
              const segmentToBezier = function(cx2, cy2, th0, th1, rx, ry, sin_th, cos_th) {
                const a00 = cos_th * rx;
                const a01 = -sin_th * ry;
                const a10 = sin_th * rx;
                const a11 = cos_th * ry;
                const th_half = 0.5 * (th1 - th0);
                const t = 8 / 3 * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half);
                const x1 = cx2 + Math.cos(th0) - t * Math.sin(th0);
                const y1 = cy2 + Math.sin(th0) + t * Math.cos(th0);
                const x3 = cx2 + Math.cos(th1);
                const y3 = cy2 + Math.sin(th1);
                const x2 = x3 + t * Math.sin(th1);
                const y2 = y3 - t * Math.cos(th1);
                return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
              };
              class SVGPath {
                static apply(doc, path) {
                  const commands = parse(path);
                  apply(commands, doc);
                }
              }
              const {
                number: number$1
              } = PDFObject;
              const KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
              var VectorMixin = {
                initVector() {
                  this._ctm = [1, 0, 0, 1, 0, 0];
                  this._ctmStack = [];
                },
                save() {
                  this._ctmStack.push(this._ctm.slice());
                  return this.addContent("q");
                },
                restore() {
                  this._ctm = this._ctmStack.pop() || [1, 0, 0, 1, 0, 0];
                  return this.addContent("Q");
                },
                closePath() {
                  return this.addContent("h");
                },
                lineWidth(w) {
                  return this.addContent(`${number$1(w)} w`);
                },
                _CAP_STYLES: {
                  BUTT: 0,
                  ROUND: 1,
                  SQUARE: 2
                },
                lineCap(c) {
                  if (typeof c === "string") {
                    c = this._CAP_STYLES[c.toUpperCase()];
                  }
                  return this.addContent(`${c} J`);
                },
                _JOIN_STYLES: {
                  MITER: 0,
                  ROUND: 1,
                  BEVEL: 2
                },
                lineJoin(j) {
                  if (typeof j === "string") {
                    j = this._JOIN_STYLES[j.toUpperCase()];
                  }
                  return this.addContent(`${j} j`);
                },
                miterLimit(m) {
                  return this.addContent(`${number$1(m)} M`);
                },
                dash(length) {
                  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  const originalLength = length;
                  if (!Array.isArray(length)) {
                    length = [length, options.space || length];
                  }
                  const valid = length.every((x) => Number.isFinite(x) && x > 0);
                  if (!valid) {
                    throw new Error(`dash(${JSON.stringify(originalLength)}, ${JSON.stringify(options)}) invalid, lengths must be numeric and greater than zero`);
                  }
                  length = length.map(number$1).join(" ");
                  return this.addContent(`[${length}] ${number$1(options.phase || 0)} d`);
                },
                undash() {
                  return this.addContent("[] 0 d");
                },
                moveTo(x, y) {
                  return this.addContent(`${number$1(x)} ${number$1(y)} m`);
                },
                lineTo(x, y) {
                  return this.addContent(`${number$1(x)} ${number$1(y)} l`);
                },
                bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
                  return this.addContent(`${number$1(cp1x)} ${number$1(cp1y)} ${number$1(cp2x)} ${number$1(cp2y)} ${number$1(x)} ${number$1(y)} c`);
                },
                quadraticCurveTo(cpx, cpy, x, y) {
                  return this.addContent(`${number$1(cpx)} ${number$1(cpy)} ${number$1(x)} ${number$1(y)} v`);
                },
                rect(x, y, w, h) {
                  return this.addContent(`${number$1(x)} ${number$1(y)} ${number$1(w)} ${number$1(h)} re`);
                },
                roundedRect(x, y, w, h, r) {
                  if (r == null) {
                    r = 0;
                  }
                  r = Math.min(r, 0.5 * w, 0.5 * h);
                  const c = r * (1 - KAPPA);
                  this.moveTo(x + r, y);
                  this.lineTo(x + w - r, y);
                  this.bezierCurveTo(x + w - c, y, x + w, y + c, x + w, y + r);
                  this.lineTo(x + w, y + h - r);
                  this.bezierCurveTo(x + w, y + h - c, x + w - c, y + h, x + w - r, y + h);
                  this.lineTo(x + r, y + h);
                  this.bezierCurveTo(x + c, y + h, x, y + h - c, x, y + h - r);
                  this.lineTo(x, y + r);
                  this.bezierCurveTo(x, y + c, x + c, y, x + r, y);
                  return this.closePath();
                },
                ellipse(x, y, r1, r2) {
                  if (r2 == null) {
                    r2 = r1;
                  }
                  x -= r1;
                  y -= r2;
                  const ox = r1 * KAPPA;
                  const oy = r2 * KAPPA;
                  const xe = x + r1 * 2;
                  const ye = y + r2 * 2;
                  const xm = x + r1;
                  const ym = y + r2;
                  this.moveTo(x, ym);
                  this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                  this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                  this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                  this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                  return this.closePath();
                },
                circle(x, y, radius) {
                  return this.ellipse(x, y, radius);
                },
                arc(x, y, radius, startAngle, endAngle, anticlockwise) {
                  if (anticlockwise == null) {
                    anticlockwise = false;
                  }
                  const TWO_PI = 2 * Math.PI;
                  const HALF_PI = 0.5 * Math.PI;
                  let deltaAng = endAngle - startAngle;
                  if (Math.abs(deltaAng) > TWO_PI) {
                    deltaAng = TWO_PI;
                  } else if (deltaAng !== 0 && anticlockwise !== deltaAng < 0) {
                    const dir = anticlockwise ? -1 : 1;
                    deltaAng = dir * TWO_PI + deltaAng;
                  }
                  const numSegs = Math.ceil(Math.abs(deltaAng) / HALF_PI);
                  const segAng = deltaAng / numSegs;
                  const handleLen = segAng / HALF_PI * KAPPA * radius;
                  let curAng = startAngle;
                  let deltaCx = -Math.sin(curAng) * handleLen;
                  let deltaCy = Math.cos(curAng) * handleLen;
                  let ax = x + Math.cos(curAng) * radius;
                  let ay = y + Math.sin(curAng) * radius;
                  this.moveTo(ax, ay);
                  for (let segIdx = 0; segIdx < numSegs; segIdx++) {
                    const cp1x = ax + deltaCx;
                    const cp1y = ay + deltaCy;
                    curAng += segAng;
                    ax = x + Math.cos(curAng) * radius;
                    ay = y + Math.sin(curAng) * radius;
                    deltaCx = -Math.sin(curAng) * handleLen;
                    deltaCy = Math.cos(curAng) * handleLen;
                    const cp2x = ax - deltaCx;
                    const cp2y = ay - deltaCy;
                    this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ax, ay);
                  }
                  return this;
                },
                polygon() {
                  for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {
                    points[_key] = arguments[_key];
                  }
                  this.moveTo(...points.shift() || []);
                  for (let point of points) {
                    this.lineTo(...point || []);
                  }
                  return this.closePath();
                },
                path(path) {
                  SVGPath.apply(this, path);
                  return this;
                },
                _windingRule(rule) {
                  if (/even-?odd/.test(rule)) {
                    return "*";
                  }
                  return "";
                },
                fill(color, rule) {
                  if (/(even-?odd)|(non-?zero)/.test(color)) {
                    rule = color;
                    color = null;
                  }
                  if (color) {
                    this.fillColor(color);
                  }
                  return this.addContent(`f${this._windingRule(rule)}`);
                },
                stroke(color) {
                  if (color) {
                    this.strokeColor(color);
                  }
                  return this.addContent("S");
                },
                fillAndStroke(fillColor, strokeColor, rule) {
                  if (strokeColor == null) {
                    strokeColor = fillColor;
                  }
                  const isFillRule = /(even-?odd)|(non-?zero)/;
                  if (isFillRule.test(fillColor)) {
                    rule = fillColor;
                    fillColor = null;
                  }
                  if (isFillRule.test(strokeColor)) {
                    rule = strokeColor;
                    strokeColor = fillColor;
                  }
                  if (fillColor) {
                    this.fillColor(fillColor);
                    this.strokeColor(strokeColor);
                  }
                  return this.addContent(`B${this._windingRule(rule)}`);
                },
                clip(rule) {
                  return this.addContent(`W${this._windingRule(rule)} n`);
                },
                transform(m11, m12, m21, m22, dx, dy) {
                  if (m11 === 1 && m12 === 0 && m21 === 0 && m22 === 1 && dx === 0 && dy === 0) {
                    return this;
                  }
                  const m = this._ctm;
                  const [m0, m1, m2, m3, m4, m5] = m;
                  m[0] = m0 * m11 + m2 * m12;
                  m[1] = m1 * m11 + m3 * m12;
                  m[2] = m0 * m21 + m2 * m22;
                  m[3] = m1 * m21 + m3 * m22;
                  m[4] = m0 * dx + m2 * dy + m4;
                  m[5] = m1 * dx + m3 * dy + m5;
                  const values = [m11, m12, m21, m22, dx, dy].map((v) => number$1(v)).join(" ");
                  return this.addContent(`${values} cm`);
                },
                translate(x, y) {
                  return this.transform(1, 0, 0, 1, x, y);
                },
                rotate(angle) {
                  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  let y;
                  const rad = angle * Math.PI / 180;
                  const cos = Math.cos(rad);
                  const sin = Math.sin(rad);
                  let x = y = 0;
                  if (options.origin != null) {
                    [x, y] = options.origin;
                    const x1 = x * cos - y * sin;
                    const y1 = x * sin + y * cos;
                    x -= x1;
                    y -= y1;
                  }
                  return this.transform(cos, sin, -sin, cos, x, y);
                },
                scale(xFactor, yFactor) {
                  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                  let y;
                  if (yFactor == null) {
                    yFactor = xFactor;
                  }
                  if (typeof yFactor === "object") {
                    options = yFactor;
                    yFactor = xFactor;
                  }
                  let x = y = 0;
                  if (options.origin != null) {
                    [x, y] = options.origin;
                    x -= xFactor * x;
                    y -= yFactor * y;
                  }
                  return this.transform(xFactor, 0, 0, yFactor, x, y);
                }
              };
              const WIN_ANSI_MAP = {
                402: 131,
                8211: 150,
                8212: 151,
                8216: 145,
                8217: 146,
                8218: 130,
                8220: 147,
                8221: 148,
                8222: 132,
                8224: 134,
                8225: 135,
                8226: 149,
                8230: 133,
                8364: 128,
                8240: 137,
                8249: 139,
                8250: 155,
                710: 136,
                8482: 153,
                338: 140,
                339: 156,
                732: 152,
                352: 138,
                353: 154,
                376: 159,
                381: 142,
                382: 158
              };
              const characters = `.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
  
space         exclam         quotedbl       numbersign
dollar        percent        ampersand      quotesingle
parenleft     parenright     asterisk       plus
comma         hyphen         period         slash
zero          one            two            three
four          five           six            seven
eight         nine           colon          semicolon
less          equal          greater        question
  
at            A              B              C
D             E              F              G
H             I              J              K
L             M              N              O
P             Q              R              S
T             U              V              W
X             Y              Z              bracketleft
backslash     bracketright   asciicircum    underscore
  
grave         a              b              c
d             e              f              g
h             i              j              k
l             m              n              o
p             q              r              s
t             u              v              w
x             y              z              braceleft
bar           braceright     asciitilde     .notdef
  
Euro          .notdef        quotesinglbase florin
quotedblbase  ellipsis       dagger         daggerdbl
circumflex    perthousand    Scaron         guilsinglleft
OE            .notdef        Zcaron         .notdef
.notdef       quoteleft      quoteright     quotedblleft
quotedblright bullet         endash         emdash
tilde         trademark      scaron         guilsinglright
oe            .notdef        zcaron         ydieresis
  
space         exclamdown     cent           sterling
currency      yen            brokenbar      section
dieresis      copyright      ordfeminine    guillemotleft
logicalnot    hyphen         registered     macron
degree        plusminus      twosuperior    threesuperior
acute         mu             paragraph      periodcentered
cedilla       onesuperior    ordmasculine   guillemotright
onequarter    onehalf        threequarters  questiondown
  
Agrave        Aacute         Acircumflex    Atilde
Adieresis     Aring          AE             Ccedilla
Egrave        Eacute         Ecircumflex    Edieresis
Igrave        Iacute         Icircumflex    Idieresis
Eth           Ntilde         Ograve         Oacute
Ocircumflex   Otilde         Odieresis      multiply
Oslash        Ugrave         Uacute         Ucircumflex
Udieresis     Yacute         Thorn          germandbls
  
agrave        aacute         acircumflex    atilde
adieresis     aring          ae             ccedilla
egrave        eacute         ecircumflex    edieresis
igrave        iacute         icircumflex    idieresis
eth           ntilde         ograve         oacute
ocircumflex   otilde         odieresis      divide
oslash        ugrave         uacute         ucircumflex
udieresis     yacute         thorn          ydieresis`.split(/\s+/);
              class AFMFont {
                constructor(contents) {
                  this.attributes = {};
                  this.glyphWidths = {};
                  this.boundingBoxes = {};
                  this.kernPairs = {};
                  this.parse(contents);
                  this.bbox = this.attributes["FontBBox"].split(/\s+/).map((e) => +e);
                  this.ascender = +(this.attributes["Ascender"] || 0);
                  this.descender = +(this.attributes["Descender"] || 0);
                  this.xHeight = +(this.attributes["XHeight"] || 0);
                  this.capHeight = +(this.attributes["CapHeight"] || 0);
                  this.lineGap = this.bbox[3] - this.bbox[1] - (this.ascender - this.descender);
                }
                parse(contents) {
                  let section = "";
                  for (let line of contents.split("\n")) {
                    var match;
                    var a;
                    if (match = line.match(/^Start(\w+)/)) {
                      section = match[1];
                      continue;
                    } else if (match = line.match(/^End(\w+)/)) {
                      section = "";
                      continue;
                    }
                    switch (section) {
                      case "FontMetrics":
                        match = line.match(/(^\w+)\s+(.*)/);
                        var key = match[1];
                        var value = match[2];
                        if (a = this.attributes[key]) {
                          if (!Array.isArray(a)) {
                            a = this.attributes[key] = [a];
                          }
                          a.push(value);
                        } else {
                          this.attributes[key] = value;
                        }
                        break;
                      case "CharMetrics":
                        if (!/^CH?\s/.test(line)) {
                          continue;
                        }
                        var name = line.match(/\bN\s+(\.?\w+)\s*;/)[1];
                        this.glyphWidths[name] = +line.match(/\bWX\s+(\d+)\s*;/)[1];
                        break;
                      case "KernPairs":
                        match = line.match(/^KPX\s+(\.?\w+)\s+(\.?\w+)\s+(-?\d+)/);
                        if (match) {
                          this.kernPairs[match[1] + "\0" + match[2]] = parseInt(match[3]);
                        }
                        break;
                    }
                  }
                }
                encodeText(text) {
                  const res = [];
                  for (let i = 0, len = text.length; i < len; i++) {
                    let char = text.charCodeAt(i);
                    char = WIN_ANSI_MAP[char] || char;
                    res.push(char.toString(16));
                  }
                  return res;
                }
                glyphsForString(string) {
                  const glyphs = [];
                  for (let i = 0, len = string.length; i < len; i++) {
                    const charCode = string.charCodeAt(i);
                    glyphs.push(this.characterToGlyph(charCode));
                  }
                  return glyphs;
                }
                characterToGlyph(character) {
                  return characters[WIN_ANSI_MAP[character] || character] || ".notdef";
                }
                widthOfGlyph(glyph) {
                  return this.glyphWidths[glyph] || 0;
                }
                getKernPair(left, right) {
                  return this.kernPairs[left + "\0" + right] || 0;
                }
                advancesForGlyphs(glyphs) {
                  const advances = [];
                  for (let index = 0; index < glyphs.length; index++) {
                    const left = glyphs[index];
                    const right = glyphs[index + 1];
                    advances.push(this.widthOfGlyph(left) + this.getKernPair(left, right));
                  }
                  return advances;
                }
              }
              class PDFFont {
                constructor() {
                }
                encode() {
                  throw new Error("Must be implemented by subclasses");
                }
                widthOfString() {
                  throw new Error("Must be implemented by subclasses");
                }
                ref() {
                  return this.dictionary != null ? this.dictionary : this.dictionary = this.document.ref();
                }
                finalize() {
                  if (this.embedded || this.dictionary == null) {
                    return;
                  }
                  this.embed();
                  this.embedded = true;
                }
                embed() {
                  throw new Error("Must be implemented by subclasses");
                }
                lineHeight(size) {
                  let includeGap = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  const gap = includeGap ? this.lineGap : 0;
                  return (this.ascender + gap - this.descender) / 1e3 * size;
                }
              }
              const STANDARD_FONTS = {
                Courier() {
                  return fs.readFileSync(__webpack_dirname__ + "/data/Courier.afm", "utf8");
                },
                "Courier-Bold"() {
                  return fs.readFileSync(__webpack_dirname__ + "/data/Courier-Bold.afm", "utf8");
                },
                "Courier-Oblique"() {
                  return fs.readFileSync(__webpack_dirname__ + "/data/Courier-Oblique.afm", "utf8");
                },
                "Courier-BoldOblique"() {
                  return fs.readFileSync(__webpack_dirname__ + "/data/Courier-BoldOblique.afm", "utf8");
                },
                Helvetica() {
                  return fs.readFileSync(__webpack_dirname__ + "/data/Helvetica.afm", "utf8");
                },
                "Helvetica-Bold"() {
                  return fs.readFileSync(__webpack_dirname__ + "/data/Helvetica-Bold.afm", "utf8");
                },
                "Helvetica-Oblique"() {
                  return fs.readFileSync(__webpack_dirname__ + "/data/Helvetica-Oblique.afm", "utf8");
                },
                "Helvetica-BoldOblique"() {
                  return fs.readFileSync(__webpack_dirname__ + "/data/Helvetica-BoldOblique.afm", "utf8");
                },
                "Times-Roman"() {
                  return fs.readFileSync(__webpack_dirname__ + "/data/Times-Roman.afm", "utf8");
                },
                "Times-Bold"() {
                  return fs.readFileSync(__webpack_dirname__ + "/data/Times-Bold.afm", "utf8");
                },
                "Times-Italic"() {
                  return fs.readFileSync(__webpack_dirname__ + "/data/Times-Italic.afm", "utf8");
                },
                "Times-BoldItalic"() {
                  return fs.readFileSync(__webpack_dirname__ + "/data/Times-BoldItalic.afm", "utf8");
                },
                Symbol() {
                  return fs.readFileSync(__webpack_dirname__ + "/data/Symbol.afm", "utf8");
                },
                ZapfDingbats() {
                  return fs.readFileSync(__webpack_dirname__ + "/data/ZapfDingbats.afm", "utf8");
                }
              };
              class StandardFont extends PDFFont {
                constructor(document2, name, id) {
                  super();
                  this.document = document2;
                  this.name = name;
                  this.id = id;
                  this.font = new AFMFont(STANDARD_FONTS[this.name]());
                  ({
                    ascender: this.ascender,
                    descender: this.descender,
                    bbox: this.bbox,
                    lineGap: this.lineGap,
                    xHeight: this.xHeight,
                    capHeight: this.capHeight
                  } = this.font);
                }
                embed() {
                  this.dictionary.data = {
                    Type: "Font",
                    BaseFont: this.name,
                    Subtype: "Type1",
                    Encoding: "WinAnsiEncoding"
                  };
                  return this.dictionary.end();
                }
                encode(text) {
                  const encoded = this.font.encodeText(text);
                  const glyphs = this.font.glyphsForString(`${text}`);
                  const advances = this.font.advancesForGlyphs(glyphs);
                  const positions = [];
                  for (let i = 0; i < glyphs.length; i++) {
                    const glyph = glyphs[i];
                    positions.push({
                      xAdvance: advances[i],
                      yAdvance: 0,
                      xOffset: 0,
                      yOffset: 0,
                      advanceWidth: this.font.widthOfGlyph(glyph)
                    });
                  }
                  return [encoded, positions];
                }
                widthOfString(string, size) {
                  const glyphs = this.font.glyphsForString(`${string}`);
                  const advances = this.font.advancesForGlyphs(glyphs);
                  let width = 0;
                  for (let advance of advances) {
                    width += advance;
                  }
                  const scale = size / 1e3;
                  return width * scale;
                }
                static isStandardFont(name) {
                  return name in STANDARD_FONTS;
                }
              }
              const toHex = function(num) {
                return `0000${num.toString(16)}`.slice(-4);
              };
              class EmbeddedFont extends PDFFont {
                constructor(document2, font, id) {
                  super();
                  this.document = document2;
                  this.font = font;
                  this.id = id;
                  this.subset = this.font.createSubset();
                  this.unicode = [[0]];
                  this.widths = [this.font.getGlyph(0).advanceWidth];
                  this.name = this.font.postscriptName;
                  this.scale = 1e3 / this.font.unitsPerEm;
                  this.ascender = this.font.ascent * this.scale;
                  this.descender = this.font.descent * this.scale;
                  this.xHeight = this.font.xHeight * this.scale;
                  this.capHeight = this.font.capHeight * this.scale;
                  this.lineGap = this.font.lineGap * this.scale;
                  this.bbox = this.font.bbox;
                  if (document2.options.fontLayoutCache !== false) {
                    this.layoutCache = /* @__PURE__ */ Object.create(null);
                  }
                }
                layoutRun(text, features) {
                  const run = this.font.layout(text, features);
                  for (let i = 0; i < run.positions.length; i++) {
                    const position = run.positions[i];
                    for (let key in position) {
                      position[key] *= this.scale;
                    }
                    position.advanceWidth = run.glyphs[i].advanceWidth * this.scale;
                  }
                  return run;
                }
                layoutCached(text) {
                  if (!this.layoutCache) {
                    return this.layoutRun(text);
                  }
                  let cached;
                  if (cached = this.layoutCache[text]) {
                    return cached;
                  }
                  const run = this.layoutRun(text);
                  this.layoutCache[text] = run;
                  return run;
                }
                layout(text, features, onlyWidth) {
                  if (features) {
                    return this.layoutRun(text, features);
                  }
                  let glyphs = onlyWidth ? null : [];
                  let positions = onlyWidth ? null : [];
                  let advanceWidth = 0;
                  let last2 = 0;
                  let index = 0;
                  while (index <= text.length) {
                    var needle;
                    if (index === text.length && last2 < index || (needle = text.charAt(index), [" ", "	"].includes(needle))) {
                      const run = this.layoutCached(text.slice(last2, ++index));
                      if (!onlyWidth) {
                        glyphs = glyphs.concat(run.glyphs);
                        positions = positions.concat(run.positions);
                      }
                      advanceWidth += run.advanceWidth;
                      last2 = index;
                    } else {
                      index++;
                    }
                  }
                  return {
                    glyphs,
                    positions,
                    advanceWidth
                  };
                }
                encode(text, features) {
                  const {
                    glyphs,
                    positions
                  } = this.layout(text, features);
                  const res = [];
                  for (let i = 0; i < glyphs.length; i++) {
                    const glyph = glyphs[i];
                    const gid = this.subset.includeGlyph(glyph.id);
                    res.push(`0000${gid.toString(16)}`.slice(-4));
                    if (this.widths[gid] == null) {
                      this.widths[gid] = glyph.advanceWidth * this.scale;
                    }
                    if (this.unicode[gid] == null) {
                      this.unicode[gid] = glyph.codePoints;
                    }
                  }
                  return [res, positions];
                }
                widthOfString(string, size, features) {
                  const width = this.layout(string, features, true).advanceWidth;
                  const scale = size / 1e3;
                  return width * scale;
                }
                embed() {
                  var _a;
                  const isCFF = this.subset.cff != null;
                  const fontFile = this.document.ref();
                  if (isCFF) {
                    fontFile.data.Subtype = "CIDFontType0C";
                  }
                  fontFile.end(this.subset.encode());
                  const familyClass = ((this.font["OS/2"] != null ? this.font["OS/2"].sFamilyClass : void 0) || 0) >> 8;
                  let flags = 0;
                  if (this.font.post.isFixedPitch) {
                    flags |= 1 << 0;
                  }
                  if (1 <= familyClass && familyClass <= 7) {
                    flags |= 1 << 1;
                  }
                  flags |= 1 << 2;
                  if (familyClass === 10) {
                    flags |= 1 << 3;
                  }
                  if (this.font.head.macStyle.italic) {
                    flags |= 1 << 6;
                  }
                  const tag = [1, 2, 3, 4, 5, 6].map((i) => String.fromCharCode((this.id.charCodeAt(i) || 73) + 17)).join("");
                  const name = tag + "+" + ((_a = this.font.postscriptName) == null ? void 0 : _a.replaceAll(" ", "_"));
                  const {
                    bbox
                  } = this.font;
                  const descriptor = this.document.ref({
                    Type: "FontDescriptor",
                    FontName: name,
                    Flags: flags,
                    FontBBox: [bbox.minX * this.scale, bbox.minY * this.scale, bbox.maxX * this.scale, bbox.maxY * this.scale],
                    ItalicAngle: this.font.italicAngle,
                    Ascent: this.ascender,
                    Descent: this.descender,
                    CapHeight: (this.font.capHeight || this.font.ascent) * this.scale,
                    XHeight: (this.font.xHeight || 0) * this.scale,
                    StemV: 0
                  });
                  if (isCFF) {
                    descriptor.data.FontFile3 = fontFile;
                  } else {
                    descriptor.data.FontFile2 = fontFile;
                  }
                  if (this.document.subset && this.document.subset === 1) {
                    const CIDSet = Buffer.from("FFFFFFFFC0", "hex");
                    const CIDSetRef = this.document.ref();
                    CIDSetRef.write(CIDSet);
                    CIDSetRef.end();
                    descriptor.data.CIDSet = CIDSetRef;
                  }
                  descriptor.end();
                  const descendantFontData = {
                    Type: "Font",
                    Subtype: "CIDFontType0",
                    BaseFont: name,
                    CIDSystemInfo: {
                      Registry: new String("Adobe"),
                      Ordering: new String("Identity"),
                      Supplement: 0
                    },
                    FontDescriptor: descriptor,
                    W: [0, this.widths]
                  };
                  if (!isCFF) {
                    descendantFontData.Subtype = "CIDFontType2";
                    descendantFontData.CIDToGIDMap = "Identity";
                  }
                  const descendantFont = this.document.ref(descendantFontData);
                  descendantFont.end();
                  this.dictionary.data = {
                    Type: "Font",
                    Subtype: "Type0",
                    BaseFont: name,
                    Encoding: "Identity-H",
                    DescendantFonts: [descendantFont],
                    ToUnicode: this.toUnicodeCmap()
                  };
                  return this.dictionary.end();
                }
                toUnicodeCmap() {
                  const cmap = this.document.ref();
                  const entries = [];
                  for (let codePoints of this.unicode) {
                    const encoded = [];
                    for (let value of codePoints) {
                      if (value > 65535) {
                        value -= 65536;
                        encoded.push(toHex(value >>> 10 & 1023 | 55296));
                        value = 56320 | value & 1023;
                      }
                      encoded.push(toHex(value));
                    }
                    entries.push(`<${encoded.join(" ")}>`);
                  }
                  const chunkSize = 256;
                  const chunks = Math.ceil(entries.length / chunkSize);
                  const ranges = [];
                  for (let i = 0; i < chunks; i++) {
                    const start = i * chunkSize;
                    const end = Math.min((i + 1) * chunkSize, entries.length);
                    ranges.push(`<${toHex(start)}> <${toHex(end - 1)}> [${entries.slice(start, end).join(" ")}]`);
                  }
                  cmap.end(`/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange
1 beginbfrange
${ranges.join("\n")}
endbfrange
endcmap
CMapName currentdict /CMap defineresource pop
end
end`);
                  return cmap;
                }
              }
              class PDFFontFactory {
                static open(document2, src, family, id) {
                  let font;
                  if (typeof src === "string") {
                    if (StandardFont.isStandardFont(src)) {
                      return new StandardFont(document2, src, id);
                    }
                    src = fs.readFileSync(src);
                  }
                  if (src instanceof Uint8Array) {
                    font = fontkit.create(src, family);
                  } else if (src instanceof ArrayBuffer) {
                    font = fontkit.create(new Uint8Array(src), family);
                  }
                  if (font == null) {
                    throw new Error("Not a supported font format or standard PDF font.");
                  }
                  return new EmbeddedFont(document2, font, id);
                }
              }
              const isEqualFont = (font1, font2) => {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                if (((_b = (_a = font1.font._tables) == null ? void 0 : _a.head) == null ? void 0 : _b.checkSumAdjustment) !== ((_d = (_c = font2.font._tables) == null ? void 0 : _c.head) == null ? void 0 : _d.checkSumAdjustment)) {
                  return false;
                }
                if (JSON.stringify((_f = (_e = font1.font._tables) == null ? void 0 : _e.name) == null ? void 0 : _f.records) !== JSON.stringify((_h = (_g = font2.font._tables) == null ? void 0 : _g.name) == null ? void 0 : _h.records)) {
                  return false;
                }
                return true;
              };
              var FontsMixin = {
                initFonts() {
                  let defaultFont = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "Helvetica";
                  let defaultFontFamily = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  let defaultFontSize = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 12;
                  this._fontFamilies = {};
                  this._fontCount = 0;
                  this._fontSource = defaultFont;
                  this._fontFamily = defaultFontFamily;
                  this._fontSize = defaultFontSize;
                  this._font = null;
                  this._remSize = defaultFontSize;
                  this._registeredFonts = {};
                  if (defaultFont) {
                    this.font(defaultFont, defaultFontFamily);
                  }
                },
                font(src, family, size) {
                  let cacheKey, font;
                  if (typeof family === "number") {
                    size = family;
                    family = null;
                  }
                  if (typeof src === "string" && this._registeredFonts[src]) {
                    cacheKey = src;
                    ({
                      src,
                      family
                    } = this._registeredFonts[src]);
                  } else {
                    cacheKey = family || src;
                    if (typeof cacheKey !== "string") {
                      cacheKey = null;
                    }
                  }
                  this._fontSource = src;
                  this._fontFamily = family;
                  if (size != null) {
                    this.fontSize(size);
                  }
                  if (font = this._fontFamilies[cacheKey]) {
                    this._font = font;
                    return this;
                  }
                  const id = `F${++this._fontCount}`;
                  this._font = PDFFontFactory.open(this, src, family, id);
                  if ((font = this._fontFamilies[this._font.name]) && isEqualFont(this._font, font)) {
                    this._font = font;
                    return this;
                  }
                  if (cacheKey) {
                    this._fontFamilies[cacheKey] = this._font;
                  }
                  if (this._font.name) {
                    this._fontFamilies[this._font.name] = this._font;
                  }
                  return this;
                },
                fontSize(_fontSize) {
                  this._fontSize = this.sizeToPoint(_fontSize);
                  return this;
                },
                currentLineHeight(includeGap) {
                  return this._font.lineHeight(this._fontSize, includeGap);
                },
                registerFont(name, src, family) {
                  this._registeredFonts[name] = {
                    src,
                    family
                  };
                  return this;
                },
                sizeToPoint(size) {
                  let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                  let page = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.page;
                  let percentageWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : void 0;
                  if (!percentageWidth) percentageWidth = this._fontSize;
                  if (typeof defaultValue !== "number") defaultValue = this.sizeToPoint(defaultValue);
                  if (size === void 0) return defaultValue;
                  if (typeof size === "number") return size;
                  if (typeof size === "boolean") return Number(size);
                  const match = String(size).match(/((\d+)?(\.\d+)?)(em|in|px|cm|mm|pc|ex|ch|rem|vw|vh|vmin|vmax|%|pt)?/);
                  if (!match) throw new Error(`Unsupported size '${size}'`);
                  let multiplier;
                  switch (match[4]) {
                    case "em":
                      multiplier = this._fontSize;
                      break;
                    case "in":
                      multiplier = IN_TO_PT;
                      break;
                    case "px":
                      multiplier = PX_TO_IN * IN_TO_PT;
                      break;
                    case "cm":
                      multiplier = CM_TO_IN * IN_TO_PT;
                      break;
                    case "mm":
                      multiplier = MM_TO_CM * CM_TO_IN * IN_TO_PT;
                      break;
                    case "pc":
                      multiplier = PC_TO_PT;
                      break;
                    case "ex":
                      multiplier = this.currentLineHeight();
                      break;
                    case "ch":
                      multiplier = this.widthOfString("0");
                      break;
                    case "rem":
                      multiplier = this._remSize;
                      break;
                    case "vw":
                      multiplier = page.width / 100;
                      break;
                    case "vh":
                      multiplier = page.height / 100;
                      break;
                    case "vmin":
                      multiplier = Math.min(page.width, page.height) / 100;
                      break;
                    case "vmax":
                      multiplier = Math.max(page.width, page.height) / 100;
                      break;
                    case "%":
                      multiplier = percentageWidth / 100;
                      break;
                    case "pt":
                    default:
                      multiplier = 1;
                  }
                  return multiplier * Number(match[1]);
                }
              };
              const SOFT_HYPHEN = "";
              const HYPHEN = "-";
              class LineWrapper extends _events.EventEmitter {
                constructor(document2, options) {
                  super();
                  this.document = document2;
                  this.horizontalScaling = options.horizontalScaling || 100;
                  this.indent = (options.indent || 0) * this.horizontalScaling / 100;
                  this.characterSpacing = (options.characterSpacing || 0) * this.horizontalScaling / 100;
                  this.wordSpacing = (options.wordSpacing === 0) * this.horizontalScaling / 100;
                  this.columns = options.columns || 1;
                  this.columnGap = (options.columnGap != null ? options.columnGap : 18) * this.horizontalScaling / 100;
                  this.lineWidth = (options.width * this.horizontalScaling / 100 - this.columnGap * (this.columns - 1)) / this.columns;
                  this.spaceLeft = this.lineWidth;
                  this.startX = this.document.x;
                  this.startY = this.document.y;
                  this.column = 1;
                  this.ellipsis = options.ellipsis;
                  this.continuedX = 0;
                  this.features = options.features;
                  if (options.height != null) {
                    this.height = options.height;
                    this.maxY = PDFNumber(this.startY + options.height);
                  } else {
                    this.maxY = PDFNumber(this.document.page.maxY());
                  }
                  this.on("firstLine", (options2) => {
                    const indent = this.continuedX || this.indent;
                    this.document.x += indent;
                    this.lineWidth -= indent;
                    if (options2.indentAllLines) {
                      return;
                    }
                    this.once("line", () => {
                      this.document.x -= indent;
                      this.lineWidth += indent;
                      if (options2.continued && !this.continuedX) {
                        this.continuedX = this.indent;
                      }
                      if (!options2.continued) {
                        this.continuedX = 0;
                      }
                    });
                  });
                  this.on("lastLine", (options2) => {
                    const {
                      align
                    } = options2;
                    if (align === "justify") {
                      options2.align = "left";
                    }
                    this.lastLine = true;
                    this.once("line", () => {
                      this.document.y += options2.paragraphGap || 0;
                      options2.align = align;
                      return this.lastLine = false;
                    });
                  });
                }
                wordWidth(word) {
                  return PDFNumber(this.document.widthOfString(word, this) + this.characterSpacing + this.wordSpacing);
                }
                canFit(word, w) {
                  if (word[word.length - 1] != SOFT_HYPHEN) {
                    return w <= this.spaceLeft;
                  }
                  return w + this.wordWidth(HYPHEN) <= this.spaceLeft;
                }
                eachWord(text, fn) {
                  let bk;
                  const breaker = new _linebreak.default(text);
                  let last2 = null;
                  const wordWidths = /* @__PURE__ */ Object.create(null);
                  while (bk = breaker.nextBreak()) {
                    var shouldContinue;
                    let word = text.slice((last2 != null ? last2.position : void 0) || 0, bk.position);
                    let w = wordWidths[word] != null ? wordWidths[word] : wordWidths[word] = this.wordWidth(word);
                    if (w > this.lineWidth + this.continuedX) {
                      let lbk = last2;
                      const fbk = {};
                      while (word.length) {
                        var l, mightGrow;
                        if (w > this.spaceLeft) {
                          l = Math.ceil(this.spaceLeft / (w / word.length));
                          w = this.wordWidth(word.slice(0, l));
                          mightGrow = w <= this.spaceLeft && l < word.length;
                        } else {
                          l = word.length;
                        }
                        let mustShrink = w > this.spaceLeft && l > 0;
                        while (mustShrink || mightGrow) {
                          if (mustShrink) {
                            w = this.wordWidth(word.slice(0, --l));
                            mustShrink = w > this.spaceLeft && l > 0;
                          } else {
                            w = this.wordWidth(word.slice(0, ++l));
                            mustShrink = w > this.spaceLeft && l > 0;
                            mightGrow = w <= this.spaceLeft && l < word.length;
                          }
                        }
                        if (l === 0 && this.spaceLeft === this.lineWidth) {
                          l = 1;
                        }
                        fbk.required = bk.required || l < word.length;
                        shouldContinue = fn(word.slice(0, l), w, fbk, lbk);
                        lbk = {
                          required: false
                        };
                        word = word.slice(l);
                        w = this.wordWidth(word);
                        if (shouldContinue === false) {
                          break;
                        }
                      }
                    } else {
                      shouldContinue = fn(word, w, bk, last2);
                    }
                    if (shouldContinue === false) {
                      break;
                    }
                    last2 = bk;
                  }
                }
                wrap(text, options) {
                  this.horizontalScaling = options.horizontalScaling || 100;
                  if (options.indent != null) {
                    this.indent = options.indent * this.horizontalScaling / 100;
                  }
                  if (options.characterSpacing != null) {
                    this.characterSpacing = options.characterSpacing * this.horizontalScaling / 100;
                  }
                  if (options.wordSpacing != null) {
                    this.wordSpacing = options.wordSpacing * this.horizontalScaling / 100;
                  }
                  if (options.ellipsis != null) {
                    this.ellipsis = options.ellipsis;
                  }
                  const nextY = this.document.y + this.document.currentLineHeight(true);
                  if (this.document.y > this.maxY || nextY > this.maxY) {
                    this.nextSection();
                  }
                  let buffer = "";
                  let textWidth = 0;
                  let wc = 0;
                  let lc = 0;
                  let {
                    y
                  } = this.document;
                  const emitLine = () => {
                    options.textWidth = textWidth + this.wordSpacing * (wc - 1);
                    options.wordCount = wc;
                    options.lineWidth = this.lineWidth;
                    ({
                      y
                    } = this.document);
                    this.emit("line", buffer, options, this);
                    return lc++;
                  };
                  this.emit("sectionStart", options, this);
                  this.eachWord(text, (word, w, bk, last2) => {
                    if (last2 == null || last2.required) {
                      this.emit("firstLine", options, this);
                      this.spaceLeft = this.lineWidth;
                    }
                    if (this.canFit(word, w)) {
                      buffer += word;
                      textWidth += w;
                      wc++;
                    }
                    if (bk.required || !this.canFit(word, w)) {
                      const lh = this.document.currentLineHeight(true);
                      if (this.height != null && this.ellipsis && PDFNumber(this.document.y + lh * 2) > this.maxY && this.column >= this.columns) {
                        if (this.ellipsis === true) {
                          this.ellipsis = "";
                        }
                        buffer = buffer.replace(/\s+$/, "");
                        textWidth = this.wordWidth(buffer + this.ellipsis);
                        while (buffer && textWidth > this.lineWidth) {
                          buffer = buffer.slice(0, -1).replace(/\s+$/, "");
                          textWidth = this.wordWidth(buffer + this.ellipsis);
                        }
                        if (textWidth <= this.lineWidth) {
                          buffer = buffer + this.ellipsis;
                        }
                        textWidth = this.wordWidth(buffer);
                      }
                      if (bk.required) {
                        if (w > this.spaceLeft) {
                          emitLine();
                          buffer = word;
                          textWidth = w;
                          wc = 1;
                        }
                        this.emit("lastLine", options, this);
                      }
                      if (buffer[buffer.length - 1] == SOFT_HYPHEN) {
                        buffer = buffer.slice(0, -1) + HYPHEN;
                        this.spaceLeft -= this.wordWidth(HYPHEN);
                      }
                      emitLine();
                      if (PDFNumber(this.document.y + lh) > this.maxY) {
                        this.emit("sectionEnd", options, this);
                        const shouldContinue = this.nextSection();
                        if (!shouldContinue) {
                          wc = 0;
                          buffer = "";
                          return false;
                        }
                        this.emit("sectionStart", options, this);
                      }
                      if (bk.required) {
                        this.spaceLeft = this.lineWidth;
                        buffer = "";
                        textWidth = 0;
                        return wc = 0;
                      } else {
                        this.spaceLeft = this.lineWidth - w;
                        buffer = word;
                        textWidth = w;
                        return wc = 1;
                      }
                    } else {
                      return this.spaceLeft -= w;
                    }
                  });
                  if (wc > 0) {
                    this.emit("lastLine", options, this);
                    emitLine();
                  }
                  this.emit("sectionEnd", options, this);
                  if (options.continued === true) {
                    if (lc > 1) {
                      this.continuedX = 0;
                    }
                    this.continuedX += options.textWidth || 0;
                    this.document.y = y;
                  } else {
                    this.document.x = this.startX;
                  }
                }
                nextSection(options) {
                  if (++this.column > this.columns) {
                    if (this.height != null) {
                      return false;
                    }
                    this.document.continueOnNewPage();
                    this.column = 1;
                    this.startY = this.document.page.margins.top;
                    this.maxY = this.document.page.maxY();
                    this.document.x = this.startX;
                    if (this.document._fillColor) {
                      this.document.fillColor(...this.document._fillColor);
                    }
                    this.emit("pageBreak", options, this);
                  } else {
                    this.document.x += this.lineWidth + this.columnGap;
                    this.document.y = this.startY;
                    this.emit("columnBreak", options, this);
                  }
                  return true;
                }
              }
              const {
                number
              } = PDFObject;
              function formatListLabel(n, listType) {
                if (listType === "numbered") {
                  return `${n}.`;
                }
                var letter = String.fromCharCode((n - 1) % 26 + 65);
                var times = Math.floor((n - 1) / 26 + 1);
                var text = Array(times + 1).join(letter);
                return `${text}.`;
              }
              var TextMixin = {
                initText() {
                  this._line = this._line.bind(this);
                  this.x = 0;
                  this.y = 0;
                  this._lineGap = 0;
                },
                lineGap(_lineGap) {
                  this._lineGap = _lineGap;
                  return this;
                },
                moveDown(lines) {
                  if (lines == null) {
                    lines = 1;
                  }
                  this.y += this.currentLineHeight(true) * lines + this._lineGap;
                  return this;
                },
                moveUp(lines) {
                  if (lines == null) {
                    lines = 1;
                  }
                  this.y -= this.currentLineHeight(true) * lines + this._lineGap;
                  return this;
                },
                _text(text, x, y, options, lineCallback) {
                  options = this._initOptions(x, y, options);
                  text = text == null ? "" : `${text}`;
                  if (options.wordSpacing) {
                    text = text.replace(/\s{2,}/g, " ");
                  }
                  const addStructure = () => {
                    if (options.structParent) {
                      options.structParent.add(this.struct(options.structType || "P", [this.markStructureContent(options.structType || "P")]));
                    }
                  };
                  if (options.rotation !== 0) {
                    this.save();
                    this.rotate(-options.rotation, {
                      origin: [this.x, this.y]
                    });
                  }
                  if (options.width) {
                    let wrapper = this._wrapper;
                    if (!wrapper) {
                      wrapper = new LineWrapper(this, options);
                      wrapper.on("line", lineCallback);
                      wrapper.on("firstLine", addStructure);
                    }
                    this._wrapper = options.continued ? wrapper : null;
                    this._textOptions = options.continued ? options : null;
                    wrapper.wrap(text, options);
                  } else {
                    for (let line of text.split("\n")) {
                      addStructure();
                      lineCallback(line, options);
                    }
                  }
                  if (options.rotation !== 0) this.restore();
                  return this;
                },
                text(text, x, y, options) {
                  return this._text(text, x, y, options, this._line);
                },
                widthOfString(string) {
                  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  const horizontalScaling = options.horizontalScaling || 100;
                  return (this._font.widthOfString(string, this._fontSize, options.features) + (options.characterSpacing || 0) * (string.length - 1)) * horizontalScaling / 100;
                },
                boundsOfString(string, x, y, options) {
                  options = this._initOptions(x, y, options);
                  ({
                    x,
                    y
                  } = this);
                  const lineGap = options.lineGap ?? this._lineGap ?? 0;
                  const lineHeight = this.currentLineHeight(true) + lineGap;
                  let contentWidth = 0;
                  string = String(string ?? "");
                  if (options.wordSpacing) {
                    string = string.replace(/\s{2,}/g, " ");
                  }
                  if (options.width) {
                    let wrapper = new LineWrapper(this, options);
                    wrapper.on("line", (text, options2) => {
                      this.y += lineHeight;
                      text = text.replace(/\n/g, "");
                      if (text.length) {
                        let wordSpacing = options2.wordSpacing ?? 0;
                        const characterSpacing = options2.characterSpacing ?? 0;
                        if (options2.width && options2.align === "justify") {
                          const words = text.trim().split(/\s+/);
                          const textWidth = this.widthOfString(text.replace(/\s+/g, ""), options2);
                          const spaceWidth = this.widthOfString(" ") + characterSpacing;
                          wordSpacing = Math.max(0, (options2.lineWidth - textWidth) / Math.max(1, words.length - 1) - spaceWidth);
                        }
                        contentWidth = Math.max(contentWidth, options2.textWidth + wordSpacing * (options2.wordCount - 1) + characterSpacing * (text.length - 1));
                      }
                    });
                    wrapper.wrap(string, options);
                  } else {
                    for (let line of string.split("\n")) {
                      const lineWidth = this.widthOfString(line, options);
                      this.y += lineHeight;
                      contentWidth = Math.max(contentWidth, lineWidth);
                    }
                  }
                  let contentHeight = this.y - y;
                  if (options.height) contentHeight = Math.min(contentHeight, options.height);
                  this.x = x;
                  this.y = y;
                  if (options.rotation === 0) {
                    return {
                      x,
                      y,
                      width: contentWidth,
                      height: contentHeight
                    };
                  } else if (options.rotation === 90) {
                    return {
                      x,
                      y: y - contentWidth,
                      width: contentHeight,
                      height: contentWidth
                    };
                  } else if (options.rotation === 180) {
                    return {
                      x: x - contentWidth,
                      y: y - contentHeight,
                      width: contentWidth,
                      height: contentHeight
                    };
                  } else if (options.rotation === 270) {
                    return {
                      x: x - contentHeight,
                      y,
                      width: contentHeight,
                      height: contentWidth
                    };
                  }
                  const cos = cosine(options.rotation);
                  const sin = sine(options.rotation);
                  const x1 = x;
                  const y1 = y;
                  const x2 = x + contentWidth * cos;
                  const y2 = y - contentWidth * sin;
                  const x3 = x + contentWidth * cos + contentHeight * sin;
                  const y3 = y - contentWidth * sin + contentHeight * cos;
                  const x4 = x + contentHeight * sin;
                  const y4 = y + contentHeight * cos;
                  const xMin = Math.min(x1, x2, x3, x4);
                  const xMax = Math.max(x1, x2, x3, x4);
                  const yMin = Math.min(y1, y2, y3, y4);
                  const yMax = Math.max(y1, y2, y3, y4);
                  return {
                    x: xMin,
                    y: yMin,
                    width: xMax - xMin,
                    height: yMax - yMin
                  };
                },
                heightOfString(text, options) {
                  const {
                    x,
                    y
                  } = this;
                  options = this._initOptions(options);
                  options.height = Infinity;
                  const lineGap = options.lineGap || this._lineGap || 0;
                  this._text(text, this.x, this.y, options, () => {
                    this.y += this.currentLineHeight(true) + lineGap;
                  });
                  const height = this.y - y;
                  this.x = x;
                  this.y = y;
                  return height;
                },
                list(list, x, y, options) {
                  options = this._initOptions(x, y, options);
                  const listType = options.listType || "bullet";
                  const unit = Math.round(this._font.ascender / 1e3 * this._fontSize);
                  const midLine = unit / 2;
                  const r = options.bulletRadius || unit / 3;
                  const indent = options.textIndent || (listType === "bullet" ? r * 5 : unit * 2);
                  const itemIndent = options.bulletIndent || (listType === "bullet" ? r * 8 : unit * 2);
                  let level = 1;
                  const items = [];
                  const levels = [];
                  const numbers = [];
                  var flatten = function(list2) {
                    let n = 1;
                    for (let i = 0; i < list2.length; i++) {
                      const item = list2[i];
                      if (Array.isArray(item)) {
                        level++;
                        flatten(item);
                        level--;
                      } else {
                        items.push(item);
                        levels.push(level);
                        if (listType !== "bullet") {
                          numbers.push(n++);
                        }
                      }
                    }
                  };
                  flatten(list);
                  const drawListItem = function(listItem, i) {
                    const wrapper = new LineWrapper(this, options);
                    wrapper.on("line", this._line);
                    level = 1;
                    wrapper.once("firstLine", () => {
                      let item, itemType, labelType, bodyType;
                      if (options.structParent) {
                        if (options.structTypes) {
                          [itemType, labelType, bodyType] = options.structTypes;
                        } else {
                          [itemType, labelType, bodyType] = ["LI", "Lbl", "LBody"];
                        }
                      }
                      if (itemType) {
                        item = this.struct(itemType);
                        options.structParent.add(item);
                      } else if (options.structParent) {
                        item = options.structParent;
                      }
                      let l;
                      if ((l = levels[i++]) !== level) {
                        const diff = itemIndent * (l - level);
                        this.x += diff;
                        wrapper.lineWidth -= diff;
                        level = l;
                      }
                      if (item && (labelType || bodyType)) {
                        item.add(this.struct(labelType || bodyType, [this.markStructureContent(labelType || bodyType)]));
                      }
                      switch (listType) {
                        case "bullet":
                          this.circle(this.x - indent + r, this.y + midLine, r);
                          this.fill();
                          break;
                        case "numbered":
                        case "lettered":
                          var text = formatListLabel(numbers[i - 1], listType);
                          this._fragment(text, this.x - indent, this.y, options);
                          break;
                      }
                      if (item && labelType && bodyType) {
                        item.add(this.struct(bodyType, [this.markStructureContent(bodyType)]));
                      }
                      if (item && item !== options.structParent) {
                        item.end();
                      }
                    });
                    wrapper.on("sectionStart", () => {
                      const pos = indent + itemIndent * (level - 1);
                      this.x += pos;
                      wrapper.lineWidth -= pos;
                    });
                    wrapper.on("sectionEnd", () => {
                      const pos = indent + itemIndent * (level - 1);
                      this.x -= pos;
                      wrapper.lineWidth += pos;
                    });
                    wrapper.wrap(listItem, options);
                  };
                  for (let i = 0; i < items.length; i++) {
                    drawListItem.call(this, items[i], i);
                  }
                  return this;
                },
                _initOptions() {
                  let x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  let y = arguments.length > 1 ? arguments[1] : void 0;
                  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                  if (typeof x === "object") {
                    options = x;
                    x = null;
                  }
                  const result = Object.assign({}, options);
                  if (this._textOptions) {
                    for (let key in this._textOptions) {
                      const val = this._textOptions[key];
                      if (key !== "continued") {
                        if (result[key] === void 0) {
                          result[key] = val;
                        }
                      }
                    }
                  }
                  if (x != null) {
                    this.x = x;
                  }
                  if (y != null) {
                    this.y = y;
                  }
                  if (result.lineBreak !== false) {
                    if (result.width == null) {
                      result.width = this.page.width - this.x - this.page.margins.right;
                    }
                    result.width = Math.max(result.width, 0);
                  }
                  if (!result.columns) {
                    result.columns = 0;
                  }
                  if (result.columnGap == null) {
                    result.columnGap = 18;
                  }
                  result.rotation = Number(options.rotation ?? 0) % 360;
                  if (result.rotation < 0) result.rotation += 360;
                  return result;
                },
                _line(text) {
                  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  let wrapper = arguments.length > 2 ? arguments[2] : void 0;
                  this._fragment(text, this.x, this.y, options);
                  if (wrapper) {
                    const lineGap = options.lineGap || this._lineGap || 0;
                    this.y += this.currentLineHeight(true) + lineGap;
                  } else {
                    this.x += this.widthOfString(text, options);
                  }
                },
                _fragment(text, x, y, options) {
                  let dy, encoded, i, positions, textWidth, words;
                  text = `${text}`.replace(/\n/g, "");
                  if (text.length === 0) {
                    return;
                  }
                  const align = options.align || "left";
                  let wordSpacing = options.wordSpacing || 0;
                  const characterSpacing = options.characterSpacing || 0;
                  const horizontalScaling = options.horizontalScaling || 100;
                  if (options.width) {
                    switch (align) {
                      case "right":
                        textWidth = this.widthOfString(text.replace(/\s+$/, ""), options);
                        x += options.lineWidth - textWidth;
                        break;
                      case "center":
                        x += options.lineWidth / 2 - options.textWidth / 2;
                        break;
                      case "justify":
                        words = text.trim().split(/\s+/);
                        textWidth = this.widthOfString(text.replace(/\s+/g, ""), options);
                        var spaceWidth = this.widthOfString(" ") + characterSpacing;
                        wordSpacing = Math.max(0, (options.lineWidth - textWidth) / Math.max(1, words.length - 1) - spaceWidth);
                        break;
                    }
                  }
                  if (typeof options.baseline === "number") {
                    dy = -options.baseline;
                  } else {
                    switch (options.baseline) {
                      case "svg-middle":
                        dy = 0.5 * this._font.xHeight;
                        break;
                      case "middle":
                      case "svg-central":
                        dy = 0.5 * (this._font.descender + this._font.ascender);
                        break;
                      case "bottom":
                      case "ideographic":
                        dy = this._font.descender;
                        break;
                      case "alphabetic":
                        dy = 0;
                        break;
                      case "mathematical":
                        dy = 0.5 * this._font.ascender;
                        break;
                      case "hanging":
                        dy = 0.8 * this._font.ascender;
                        break;
                      case "top":
                        dy = this._font.ascender;
                        break;
                      default:
                        dy = this._font.ascender;
                    }
                    dy = dy / 1e3 * this._fontSize;
                  }
                  const renderedWidth = options.textWidth + wordSpacing * (options.wordCount - 1) + characterSpacing * (text.length - 1);
                  if (options.link != null) {
                    this.link(x, y, renderedWidth, this.currentLineHeight(), options.link);
                  }
                  if (options.goTo != null) {
                    this.goTo(x, y, renderedWidth, this.currentLineHeight(), options.goTo);
                  }
                  if (options.destination != null) {
                    this.addNamedDestination(options.destination, "XYZ", x, y, null);
                  }
                  if (options.underline) {
                    this.save();
                    if (!options.stroke) {
                      this.strokeColor(...this._fillColor || []);
                    }
                    const lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);
                    this.lineWidth(lineWidth);
                    let lineY = y + this.currentLineHeight() - lineWidth;
                    this.moveTo(x, lineY);
                    this.lineTo(x + renderedWidth, lineY);
                    this.stroke();
                    this.restore();
                  }
                  if (options.strike) {
                    this.save();
                    if (!options.stroke) {
                      this.strokeColor(...this._fillColor || []);
                    }
                    const lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);
                    this.lineWidth(lineWidth);
                    let lineY = y + this.currentLineHeight() / 2;
                    this.moveTo(x, lineY);
                    this.lineTo(x + renderedWidth, lineY);
                    this.stroke();
                    this.restore();
                  }
                  this.save();
                  if (options.oblique) {
                    let skew;
                    if (typeof options.oblique === "number") {
                      skew = -Math.tan(options.oblique * Math.PI / 180);
                    } else {
                      skew = -0.25;
                    }
                    this.transform(1, 0, 0, 1, x, y);
                    this.transform(1, 0, skew, 1, -skew * dy, 0);
                    this.transform(1, 0, 0, 1, -x, -y);
                  }
                  this.transform(1, 0, 0, -1, 0, this.page.height);
                  y = this.page.height - y - dy;
                  if (this.page.fonts[this._font.id] == null) {
                    this.page.fonts[this._font.id] = this._font.ref();
                  }
                  this.addContent("BT");
                  this.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);
                  this.addContent(`/${this._font.id} ${number(this._fontSize)} Tf`);
                  const mode = options.fill && options.stroke ? 2 : options.stroke ? 1 : 0;
                  if (mode) {
                    this.addContent(`${mode} Tr`);
                  }
                  if (characterSpacing) {
                    this.addContent(`${number(characterSpacing)} Tc`);
                  }
                  if (horizontalScaling !== 100) {
                    this.addContent(`${horizontalScaling} Tz`);
                  }
                  if (wordSpacing) {
                    words = text.trim().split(/\s+/);
                    wordSpacing += this.widthOfString(" ") + characterSpacing;
                    wordSpacing *= 1e3 / this._fontSize;
                    encoded = [];
                    positions = [];
                    for (let word of words) {
                      const [encodedWord, positionsWord] = this._font.encode(word, options.features);
                      encoded = encoded.concat(encodedWord);
                      positions = positions.concat(positionsWord);
                      const space = {};
                      const object = positions[positions.length - 1];
                      for (let key in object) {
                        const val = object[key];
                        space[key] = val;
                      }
                      space.xAdvance += wordSpacing;
                      positions[positions.length - 1] = space;
                    }
                  } else {
                    [encoded, positions] = this._font.encode(text, options.features);
                  }
                  const scale = this._fontSize / 1e3;
                  const commands = [];
                  let last2 = 0;
                  let hadOffset = false;
                  const addSegment = (cur) => {
                    if (last2 < cur) {
                      const hex = encoded.slice(last2, cur).join("");
                      const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;
                      commands.push(`<${hex}> ${number(-advance)}`);
                    }
                    last2 = cur;
                  };
                  const flush = (i2) => {
                    addSegment(i2);
                    if (commands.length > 0) {
                      this.addContent(`[${commands.join(" ")}] TJ`);
                      commands.length = 0;
                    }
                  };
                  for (i = 0; i < positions.length; i++) {
                    const pos = positions[i];
                    if (pos.xOffset || pos.yOffset) {
                      flush(i);
                      this.addContent(`1 0 0 1 ${number(x + pos.xOffset * scale)} ${number(y + pos.yOffset * scale)} Tm`);
                      flush(i + 1);
                      hadOffset = true;
                    } else {
                      if (hadOffset) {
                        this.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);
                        hadOffset = false;
                      }
                      if (pos.xAdvance - pos.advanceWidth !== 0) {
                        addSegment(i + 1);
                      }
                    }
                    x += pos.xAdvance * scale;
                  }
                  flush(i);
                  this.addContent("ET");
                  this.restore();
                }
              };
              const MARKERS = [65472, 65473, 65474, 65475, 65477, 65478, 65479, 65480, 65481, 65482, 65483, 65484, 65485, 65486, 65487];
              const COLOR_SPACE_MAP = {
                1: "DeviceGray",
                3: "DeviceRGB",
                4: "DeviceCMYK"
              };
              class JPEG {
                constructor(data, label) {
                  let marker;
                  this.data = data;
                  this.label = label;
                  if (this.data.readUInt16BE(0) !== 65496) {
                    throw "SOI not found in JPEG";
                  }
                  this.orientation = _jpegExif.default.fromBuffer(this.data).Orientation || 1;
                  let pos = 2;
                  while (pos < this.data.length) {
                    marker = this.data.readUInt16BE(pos);
                    pos += 2;
                    if (MARKERS.includes(marker)) {
                      break;
                    }
                    pos += this.data.readUInt16BE(pos);
                  }
                  if (!MARKERS.includes(marker)) {
                    throw "Invalid JPEG.";
                  }
                  pos += 2;
                  this.bits = this.data[pos++];
                  this.height = this.data.readUInt16BE(pos);
                  pos += 2;
                  this.width = this.data.readUInt16BE(pos);
                  pos += 2;
                  const channels = this.data[pos++];
                  this.colorSpace = COLOR_SPACE_MAP[channels];
                  this.obj = null;
                }
                embed(document2) {
                  if (this.obj) {
                    return;
                  }
                  this.obj = document2.ref({
                    Type: "XObject",
                    Subtype: "Image",
                    BitsPerComponent: this.bits,
                    Width: this.width,
                    Height: this.height,
                    ColorSpace: this.colorSpace,
                    Filter: "DCTDecode"
                  });
                  if (this.colorSpace === "DeviceCMYK") {
                    this.obj.data["Decode"] = [1, 0, 1, 0, 1, 0, 1, 0];
                  }
                  this.obj.end(this.data);
                  return this.data = null;
                }
              }
              class PNGImage {
                constructor(data, label) {
                  this.label = label;
                  this.image = new _pngJs.default(data);
                  this.width = this.image.width;
                  this.height = this.image.height;
                  this.imgData = this.image.imgData;
                  this.obj = null;
                }
                embed(document2) {
                  let dataDecoded = false;
                  this.document = document2;
                  if (this.obj) {
                    return;
                  }
                  const hasAlphaChannel = this.image.hasAlphaChannel;
                  const isInterlaced = this.image.interlaceMethod === 1;
                  this.obj = this.document.ref({
                    Type: "XObject",
                    Subtype: "Image",
                    BitsPerComponent: hasAlphaChannel ? 8 : this.image.bits,
                    Width: this.width,
                    Height: this.height,
                    Filter: "FlateDecode"
                  });
                  if (!hasAlphaChannel) {
                    const params = this.document.ref({
                      Predictor: isInterlaced ? 1 : 15,
                      Colors: this.image.colors,
                      BitsPerComponent: this.image.bits,
                      Columns: this.width
                    });
                    this.obj.data["DecodeParms"] = params;
                    params.end();
                  }
                  if (this.image.palette.length === 0) {
                    this.obj.data["ColorSpace"] = this.image.colorSpace;
                  } else {
                    const palette = this.document.ref();
                    palette.end(Buffer.from(this.image.palette));
                    this.obj.data["ColorSpace"] = ["Indexed", "DeviceRGB", this.image.palette.length / 3 - 1, palette];
                  }
                  if (this.image.transparency.grayscale != null) {
                    const val = this.image.transparency.grayscale;
                    this.obj.data["Mask"] = [val, val];
                  } else if (this.image.transparency.rgb) {
                    const {
                      rgb
                    } = this.image.transparency;
                    const mask = [];
                    for (let x of rgb) {
                      mask.push(x, x);
                    }
                    this.obj.data["Mask"] = mask;
                  } else if (this.image.transparency.indexed) {
                    dataDecoded = true;
                    return this.loadIndexedAlphaChannel();
                  } else if (hasAlphaChannel) {
                    dataDecoded = true;
                    return this.splitAlphaChannel();
                  }
                  if (isInterlaced && !dataDecoded) {
                    return this.decodeData();
                  }
                  this.finalize();
                }
                finalize() {
                  if (this.alphaChannel) {
                    const sMask = this.document.ref({
                      Type: "XObject",
                      Subtype: "Image",
                      Height: this.height,
                      Width: this.width,
                      BitsPerComponent: 8,
                      Filter: "FlateDecode",
                      ColorSpace: "DeviceGray",
                      Decode: [0, 1]
                    });
                    sMask.end(this.alphaChannel);
                    this.obj.data["SMask"] = sMask;
                  }
                  this.obj.end(this.imgData);
                  this.image = null;
                  return this.imgData = null;
                }
                splitAlphaChannel() {
                  return this.image.decodePixels((pixels) => {
                    let a, p;
                    const colorCount = this.image.colors;
                    const pixelCount = this.width * this.height;
                    const imgData = Buffer.alloc(pixelCount * colorCount);
                    const alphaChannel = Buffer.alloc(pixelCount);
                    let i = p = a = 0;
                    const len = pixels.length;
                    const skipByteCount = this.image.bits === 16 ? 1 : 0;
                    while (i < len) {
                      for (let colorIndex = 0; colorIndex < colorCount; colorIndex++) {
                        imgData[p++] = pixels[i++];
                        i += skipByteCount;
                      }
                      alphaChannel[a++] = pixels[i++];
                      i += skipByteCount;
                    }
                    this.imgData = _zlib.default.deflateSync(imgData);
                    this.alphaChannel = _zlib.default.deflateSync(alphaChannel);
                    return this.finalize();
                  });
                }
                loadIndexedAlphaChannel() {
                  const transparency = this.image.transparency.indexed;
                  return this.image.decodePixels((pixels) => {
                    const alphaChannel = Buffer.alloc(this.width * this.height);
                    let i = 0;
                    for (let j = 0, end = pixels.length; j < end; j++) {
                      alphaChannel[i++] = transparency[pixels[j]];
                    }
                    this.alphaChannel = _zlib.default.deflateSync(alphaChannel);
                    return this.finalize();
                  });
                }
                decodeData() {
                  this.image.decodePixels((pixels) => {
                    this.imgData = _zlib.default.deflateSync(pixels);
                    this.finalize();
                  });
                }
              }
              class PDFImage {
                static open(src, label) {
                  let data;
                  if (Buffer.isBuffer(src)) {
                    data = src;
                  } else if (src instanceof ArrayBuffer) {
                    data = Buffer.from(new Uint8Array(src));
                  } else {
                    const match = /^data:.+?;base64,(.*)$/.exec(src);
                    if (match) {
                      data = Buffer.from(match[1], "base64");
                    } else {
                      data = fs.readFileSync(src);
                      if (!data) {
                        return;
                      }
                    }
                  }
                  if (data[0] === 255 && data[1] === 216) {
                    return new JPEG(data, label);
                  } else if (data[0] === 137 && data.toString("ascii", 1, 4) === "PNG") {
                    return new PNGImage(data, label);
                  } else {
                    throw new Error("Unknown image format.");
                  }
                }
              }
              var ImagesMixin = {
                initImages() {
                  this._imageRegistry = {};
                  this._imageCount = 0;
                },
                image(src, x, y) {
                  let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
                  let bh, bp, bw, image, ip, left, left1, originX, originY;
                  if (typeof x === "object") {
                    options = x;
                    x = null;
                  }
                  const ignoreOrientation = options.ignoreOrientation || options.ignoreOrientation !== false && this.options.ignoreOrientation;
                  const inDocumentFlow = typeof y !== "number";
                  x = (left = x != null ? x : options.x) != null ? left : this.x;
                  y = (left1 = y != null ? y : options.y) != null ? left1 : this.y;
                  if (typeof src === "string") {
                    image = this._imageRegistry[src];
                  }
                  if (!image) {
                    if (src.width && src.height) {
                      image = src;
                    } else {
                      image = this.openImage(src);
                    }
                  }
                  if (!image.obj) {
                    image.embed(this);
                  }
                  if (this.page.xobjects[image.label] == null) {
                    this.page.xobjects[image.label] = image.obj;
                  }
                  let {
                    width,
                    height
                  } = image;
                  if (!ignoreOrientation && image.orientation > 4) {
                    [width, height] = [height, width];
                  }
                  let w = options.width || width;
                  let h = options.height || height;
                  if (options.width && !options.height) {
                    const wp = w / width;
                    w = width * wp;
                    h = height * wp;
                  } else if (options.height && !options.width) {
                    const hp = h / height;
                    w = width * hp;
                    h = height * hp;
                  } else if (options.scale) {
                    w = width * options.scale;
                    h = height * options.scale;
                  } else if (options.fit) {
                    [bw, bh] = options.fit;
                    bp = bw / bh;
                    ip = width / height;
                    if (ip > bp) {
                      w = bw;
                      h = bw / ip;
                    } else {
                      h = bh;
                      w = bh * ip;
                    }
                  } else if (options.cover) {
                    [bw, bh] = options.cover;
                    bp = bw / bh;
                    ip = width / height;
                    if (ip > bp) {
                      h = bh;
                      w = bh * ip;
                    } else {
                      w = bw;
                      h = bw / ip;
                    }
                  }
                  if (options.fit || options.cover) {
                    if (options.align === "center") {
                      x = x + bw / 2 - w / 2;
                    } else if (options.align === "right") {
                      x = x + bw - w;
                    }
                    if (options.valign === "center") {
                      y = y + bh / 2 - h / 2;
                    } else if (options.valign === "bottom") {
                      y = y + bh - h;
                    }
                  }
                  let rotateAngle = 0;
                  let xTransform = x;
                  let yTransform = y;
                  let hTransform = h;
                  let wTransform = w;
                  if (!ignoreOrientation) {
                    switch (image.orientation) {
                      default:
                      case 1:
                        hTransform = -h;
                        yTransform += h;
                        break;
                      case 2:
                        wTransform = -w;
                        hTransform = -h;
                        xTransform += w;
                        yTransform += h;
                        break;
                      case 3:
                        originX = x;
                        originY = y;
                        hTransform = -h;
                        xTransform -= w;
                        rotateAngle = 180;
                        break;
                      case 4:
                        break;
                      case 5:
                        originX = x;
                        originY = y;
                        wTransform = h;
                        hTransform = w;
                        yTransform -= hTransform;
                        rotateAngle = 90;
                        break;
                      case 6:
                        originX = x;
                        originY = y;
                        wTransform = h;
                        hTransform = -w;
                        rotateAngle = 90;
                        break;
                      case 7:
                        originX = x;
                        originY = y;
                        hTransform = -w;
                        wTransform = -h;
                        xTransform += h;
                        rotateAngle = 90;
                        break;
                      case 8:
                        originX = x;
                        originY = y;
                        wTransform = h;
                        hTransform = -w;
                        xTransform -= h;
                        yTransform += w;
                        rotateAngle = -90;
                        break;
                    }
                  } else {
                    hTransform = -h;
                    yTransform += h;
                  }
                  if (options.link != null) {
                    this.link(x, y, w, h, options.link);
                  }
                  if (options.goTo != null) {
                    this.goTo(x, y, w, h, options.goTo);
                  }
                  if (options.destination != null) {
                    this.addNamedDestination(options.destination, "XYZ", x, y, null);
                  }
                  if (inDocumentFlow) {
                    this.y += h;
                  }
                  this.save();
                  if (rotateAngle) {
                    this.rotate(rotateAngle, {
                      origin: [originX, originY]
                    });
                  }
                  this.transform(wTransform, 0, 0, hTransform, xTransform, yTransform);
                  this.addContent(`/${image.label} Do`);
                  this.restore();
                  return this;
                },
                openImage(src) {
                  let image;
                  if (typeof src === "string") {
                    image = this._imageRegistry[src];
                  }
                  if (!image) {
                    image = PDFImage.open(src, `I${++this._imageCount}`);
                    if (typeof src === "string") {
                      this._imageRegistry[src] = image;
                    }
                  }
                  return image;
                }
              };
              var AnnotationsMixin = {
                annotate(x, y, w, h, options) {
                  options.Type = "Annot";
                  options.Rect = this._convertRect(x, y, w, h);
                  options.Border = [0, 0, 0];
                  if (options.Subtype === "Link" && typeof options.F === "undefined") {
                    options.F = 1 << 2;
                  }
                  if (options.Subtype !== "Link") {
                    if (options.C == null) {
                      options.C = this._normalizeColor(options.color || [0, 0, 0]);
                    }
                  }
                  delete options.color;
                  if (typeof options.Dest === "string") {
                    options.Dest = new String(options.Dest);
                  }
                  for (let key in options) {
                    const val = options[key];
                    options[key[0].toUpperCase() + key.slice(1)] = val;
                  }
                  const ref = this.ref(options);
                  this.page.annotations.push(ref);
                  ref.end();
                  return this;
                },
                note(x, y, w, h, contents) {
                  let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                  options.Subtype = "Text";
                  options.Contents = new String(contents);
                  if (options.Name == null) {
                    options.Name = "Comment";
                  }
                  if (options.color == null) {
                    options.color = [243, 223, 92];
                  }
                  return this.annotate(x, y, w, h, options);
                },
                goTo(x, y, w, h, name) {
                  let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                  options.Subtype = "Link";
                  options.A = this.ref({
                    S: "GoTo",
                    D: new String(name)
                  });
                  options.A.end();
                  return this.annotate(x, y, w, h, options);
                },
                link(x, y, w, h, url) {
                  let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                  options.Subtype = "Link";
                  if (typeof url === "number") {
                    const pages = this._root.data.Pages.data;
                    if (url >= 0 && url < pages.Kids.length) {
                      options.A = this.ref({
                        S: "GoTo",
                        D: [pages.Kids[url], "XYZ", null, null, null]
                      });
                      options.A.end();
                    } else {
                      throw new Error(`The document has no page ${url}`);
                    }
                  } else {
                    options.A = this.ref({
                      S: "URI",
                      URI: new String(url)
                    });
                    options.A.end();
                  }
                  return this.annotate(x, y, w, h, options);
                },
                _markup(x, y, w, h) {
                  let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
                  const [x1, y1, x2, y2] = this._convertRect(x, y, w, h);
                  options.QuadPoints = [x1, y2, x2, y2, x1, y1, x2, y1];
                  options.Contents = new String();
                  return this.annotate(x, y, w, h, options);
                },
                highlight(x, y, w, h) {
                  let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
                  options.Subtype = "Highlight";
                  if (options.color == null) {
                    options.color = [241, 238, 148];
                  }
                  return this._markup(x, y, w, h, options);
                },
                underline(x, y, w, h) {
                  let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
                  options.Subtype = "Underline";
                  return this._markup(x, y, w, h, options);
                },
                strike(x, y, w, h) {
                  let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
                  options.Subtype = "StrikeOut";
                  return this._markup(x, y, w, h, options);
                },
                lineAnnotation(x1, y1, x2, y2) {
                  let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
                  options.Subtype = "Line";
                  options.Contents = new String();
                  options.L = [x1, this.page.height - y1, x2, this.page.height - y2];
                  return this.annotate(x1, y1, x2, y2, options);
                },
                rectAnnotation(x, y, w, h) {
                  let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
                  options.Subtype = "Square";
                  options.Contents = new String();
                  return this.annotate(x, y, w, h, options);
                },
                ellipseAnnotation(x, y, w, h) {
                  let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
                  options.Subtype = "Circle";
                  options.Contents = new String();
                  return this.annotate(x, y, w, h, options);
                },
                textAnnotation(x, y, w, h, text) {
                  let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                  options.Subtype = "FreeText";
                  options.Contents = new String(text);
                  options.DA = new String();
                  return this.annotate(x, y, w, h, options);
                },
                fileAnnotation(x, y, w, h) {
                  let file = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
                  let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                  const filespec = this.file(file.src, Object.assign({
                    hidden: true
                  }, file));
                  options.Subtype = "FileAttachment";
                  options.FS = filespec;
                  if (options.Contents) {
                    options.Contents = new String(options.Contents);
                  } else if (filespec.data.Desc) {
                    options.Contents = filespec.data.Desc;
                  }
                  return this.annotate(x, y, w, h, options);
                },
                _convertRect(x1, y1, w, h) {
                  let y2 = y1;
                  y1 += h;
                  let x2 = x1 + w;
                  const [m0, m1, m2, m3, m4, m5] = this._ctm;
                  x1 = m0 * x1 + m2 * y1 + m4;
                  y1 = m1 * x1 + m3 * y1 + m5;
                  x2 = m0 * x2 + m2 * y2 + m4;
                  y2 = m1 * x2 + m3 * y2 + m5;
                  return [x1, y1, x2, y2];
                }
              };
              class PDFOutline {
                constructor(document2, parent, title, dest) {
                  let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
                    expanded: false
                  };
                  this.document = document2;
                  this.options = options;
                  this.outlineData = {};
                  if (dest !== null) {
                    this.outlineData["Dest"] = [dest.dictionary, "Fit"];
                  }
                  if (parent !== null) {
                    this.outlineData["Parent"] = parent;
                  }
                  if (title !== null) {
                    this.outlineData["Title"] = new String(title);
                  }
                  this.dictionary = this.document.ref(this.outlineData);
                  this.children = [];
                }
                addItem(title) {
                  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                    expanded: false
                  };
                  const result = new PDFOutline(this.document, this.dictionary, title, this.document.page, options);
                  this.children.push(result);
                  return result;
                }
                endOutline() {
                  if (this.children.length > 0) {
                    if (this.options.expanded) {
                      this.outlineData.Count = this.children.length;
                    }
                    const first2 = this.children[0], last2 = this.children[this.children.length - 1];
                    this.outlineData.First = first2.dictionary;
                    this.outlineData.Last = last2.dictionary;
                    for (let i = 0, len = this.children.length; i < len; i++) {
                      const child = this.children[i];
                      if (i > 0) {
                        child.outlineData.Prev = this.children[i - 1].dictionary;
                      }
                      if (i < this.children.length - 1) {
                        child.outlineData.Next = this.children[i + 1].dictionary;
                      }
                      child.endOutline();
                    }
                  }
                  return this.dictionary.end();
                }
              }
              var OutlineMixin = {
                initOutline() {
                  this.outline = new PDFOutline(this, null, null, null);
                },
                endOutline() {
                  this.outline.endOutline();
                  if (this.outline.children.length > 0) {
                    this._root.data.Outlines = this.outline.dictionary;
                    return this._root.data.PageMode = "UseOutlines";
                  }
                }
              };
              class PDFStructureContent {
                constructor(pageRef, mcid) {
                  this.refs = [{
                    pageRef,
                    mcid
                  }];
                }
                push(structContent) {
                  structContent.refs.forEach((ref) => this.refs.push(ref));
                }
              }
              class PDFStructureElement {
                constructor(document2, type) {
                  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                  let children = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                  this.document = document2;
                  this._attached = false;
                  this._ended = false;
                  this._flushed = false;
                  this.dictionary = document2.ref({
                    S: type
                  });
                  const data = this.dictionary.data;
                  if (Array.isArray(options) || this._isValidChild(options)) {
                    children = options;
                    options = {};
                  }
                  if (typeof options.title !== "undefined") {
                    data.T = new String(options.title);
                  }
                  if (typeof options.lang !== "undefined") {
                    data.Lang = new String(options.lang);
                  }
                  if (typeof options.alt !== "undefined") {
                    data.Alt = new String(options.alt);
                  }
                  if (typeof options.expanded !== "undefined") {
                    data.E = new String(options.expanded);
                  }
                  if (typeof options.actual !== "undefined") {
                    data.ActualText = new String(options.actual);
                  }
                  this._children = [];
                  if (children) {
                    if (!Array.isArray(children)) {
                      children = [children];
                    }
                    children.forEach((child) => this.add(child));
                    this.end();
                  }
                }
                add(child) {
                  if (this._ended) {
                    throw new Error(`Cannot add child to already-ended structure element`);
                  }
                  if (!this._isValidChild(child)) {
                    throw new Error(`Invalid structure element child`);
                  }
                  if (child instanceof PDFStructureElement) {
                    child.setParent(this.dictionary);
                    if (this._attached) {
                      child.setAttached();
                    }
                  }
                  if (child instanceof PDFStructureContent) {
                    this._addContentToParentTree(child);
                  }
                  if (typeof child === "function" && this._attached) {
                    child = this._contentForClosure(child);
                  }
                  this._children.push(child);
                  return this;
                }
                _addContentToParentTree(content) {
                  content.refs.forEach((_ref) => {
                    let {
                      pageRef,
                      mcid
                    } = _ref;
                    const pageStructParents = this.document.getStructParentTree().get(pageRef.data.StructParents);
                    pageStructParents[mcid] = this.dictionary;
                  });
                }
                setParent(parentRef) {
                  if (this.dictionary.data.P) {
                    throw new Error(`Structure element added to more than one parent`);
                  }
                  this.dictionary.data.P = parentRef;
                  this._flush();
                }
                setAttached() {
                  if (this._attached) {
                    return;
                  }
                  this._children.forEach((child, index) => {
                    if (child instanceof PDFStructureElement) {
                      child.setAttached();
                    }
                    if (typeof child === "function") {
                      this._children[index] = this._contentForClosure(child);
                    }
                  });
                  this._attached = true;
                  this._flush();
                }
                end() {
                  if (this._ended) {
                    return;
                  }
                  this._children.filter((child) => child instanceof PDFStructureElement).forEach((child) => child.end());
                  this._ended = true;
                  this._flush();
                }
                _isValidChild(child) {
                  return child instanceof PDFStructureElement || child instanceof PDFStructureContent || typeof child === "function";
                }
                _contentForClosure(closure) {
                  const content = this.document.markStructureContent(this.dictionary.data.S);
                  closure();
                  this.document.endMarkedContent();
                  this._addContentToParentTree(content);
                  return content;
                }
                _isFlushable() {
                  if (!this.dictionary.data.P || !this._ended) {
                    return false;
                  }
                  return this._children.every((child) => {
                    if (typeof child === "function") {
                      return false;
                    }
                    if (child instanceof PDFStructureElement) {
                      return child._isFlushable();
                    }
                    return true;
                  });
                }
                _flush() {
                  if (this._flushed || !this._isFlushable()) {
                    return;
                  }
                  this.dictionary.data.K = [];
                  this._children.forEach((child) => this._flushChild(child));
                  this.dictionary.end();
                  this._children = [];
                  this.dictionary.data.K = null;
                  this._flushed = true;
                }
                _flushChild(child) {
                  if (child instanceof PDFStructureElement) {
                    this.dictionary.data.K.push(child.dictionary);
                  }
                  if (child instanceof PDFStructureContent) {
                    child.refs.forEach((_ref2) => {
                      let {
                        pageRef,
                        mcid
                      } = _ref2;
                      if (!this.dictionary.data.Pg) {
                        this.dictionary.data.Pg = pageRef;
                      }
                      if (this.dictionary.data.Pg === pageRef) {
                        this.dictionary.data.K.push(mcid);
                      } else {
                        this.dictionary.data.K.push({
                          Type: "MCR",
                          Pg: pageRef,
                          MCID: mcid
                        });
                      }
                    });
                  }
                }
              }
              class PDFNumberTree extends PDFTree {
                _compareKeys(a, b) {
                  return parseInt(a) - parseInt(b);
                }
                _keysName() {
                  return "Nums";
                }
                _dataForKey(k) {
                  return parseInt(k);
                }
              }
              var MarkingsMixin = {
                initMarkings(options) {
                  this.structChildren = [];
                  if (options.tagged) {
                    this.getMarkInfoDictionary().data.Marked = true;
                    this.getStructTreeRoot();
                  }
                },
                markContent(tag) {
                  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                  if (tag === "Artifact" || options && options.mcid) {
                    let toClose = 0;
                    this.page.markings.forEach((marking) => {
                      if (toClose || marking.structContent || marking.tag === "Artifact") {
                        toClose++;
                      }
                    });
                    while (toClose--) {
                      this.endMarkedContent();
                    }
                  }
                  if (!options) {
                    this.page.markings.push({
                      tag
                    });
                    this.addContent(`/${tag} BMC`);
                    return this;
                  }
                  this.page.markings.push({
                    tag,
                    options
                  });
                  const dictionary = {};
                  if (typeof options.mcid !== "undefined") {
                    dictionary.MCID = options.mcid;
                  }
                  if (tag === "Artifact") {
                    if (typeof options.type === "string") {
                      dictionary.Type = options.type;
                    }
                    if (Array.isArray(options.bbox)) {
                      dictionary.BBox = [options.bbox[0], this.page.height - options.bbox[3], options.bbox[2], this.page.height - options.bbox[1]];
                    }
                    if (Array.isArray(options.attached) && options.attached.every((val) => typeof val === "string")) {
                      dictionary.Attached = options.attached;
                    }
                  }
                  if (tag === "Span") {
                    if (options.lang) {
                      dictionary.Lang = new String(options.lang);
                    }
                    if (options.alt) {
                      dictionary.Alt = new String(options.alt);
                    }
                    if (options.expanded) {
                      dictionary.E = new String(options.expanded);
                    }
                    if (options.actual) {
                      dictionary.ActualText = new String(options.actual);
                    }
                  }
                  this.addContent(`/${tag} ${PDFObject.convert(dictionary)} BDC`);
                  return this;
                },
                markStructureContent(tag) {
                  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  const pageStructParents = this.getStructParentTree().get(this.page.structParentTreeKey);
                  const mcid = pageStructParents.length;
                  pageStructParents.push(null);
                  this.markContent(tag, {
                    ...options,
                    mcid
                  });
                  const structContent = new PDFStructureContent(this.page.dictionary, mcid);
                  this.page.markings.slice(-1)[0].structContent = structContent;
                  return structContent;
                },
                endMarkedContent() {
                  this.page.markings.pop();
                  this.addContent("EMC");
                  return this;
                },
                struct(type) {
                  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  let children = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                  return new PDFStructureElement(this, type, options, children);
                },
                addStructure(structElem) {
                  const structTreeRoot = this.getStructTreeRoot();
                  structElem.setParent(structTreeRoot);
                  structElem.setAttached();
                  this.structChildren.push(structElem);
                  if (!structTreeRoot.data.K) {
                    structTreeRoot.data.K = [];
                  }
                  structTreeRoot.data.K.push(structElem.dictionary);
                  return this;
                },
                initPageMarkings(pageMarkings) {
                  pageMarkings.forEach((marking) => {
                    if (marking.structContent) {
                      const structContent = marking.structContent;
                      const newStructContent = this.markStructureContent(marking.tag, marking.options);
                      structContent.push(newStructContent);
                      this.page.markings.slice(-1)[0].structContent = structContent;
                    } else {
                      this.markContent(marking.tag, marking.options);
                    }
                  });
                },
                endPageMarkings(page) {
                  const pageMarkings = page.markings;
                  pageMarkings.forEach(() => page.write("EMC"));
                  page.markings = [];
                  return pageMarkings;
                },
                getMarkInfoDictionary() {
                  if (!this._root.data.MarkInfo) {
                    this._root.data.MarkInfo = this.ref({});
                  }
                  return this._root.data.MarkInfo;
                },
                hasMarkInfoDictionary() {
                  return !!this._root.data.MarkInfo;
                },
                getStructTreeRoot() {
                  if (!this._root.data.StructTreeRoot) {
                    this._root.data.StructTreeRoot = this.ref({
                      Type: "StructTreeRoot",
                      ParentTree: new PDFNumberTree(),
                      ParentTreeNextKey: 0
                    });
                  }
                  return this._root.data.StructTreeRoot;
                },
                getStructParentTree() {
                  return this.getStructTreeRoot().data.ParentTree;
                },
                createStructParentTreeNextKey() {
                  this.getMarkInfoDictionary();
                  const structTreeRoot = this.getStructTreeRoot();
                  const key = structTreeRoot.data.ParentTreeNextKey++;
                  structTreeRoot.data.ParentTree.add(key, []);
                  return key;
                },
                endMarkings() {
                  const structTreeRoot = this._root.data.StructTreeRoot;
                  if (structTreeRoot) {
                    structTreeRoot.end();
                    this.structChildren.forEach((structElem) => structElem.end());
                  }
                  if (this._root.data.MarkInfo) {
                    this._root.data.MarkInfo.end();
                  }
                }
              };
              const FIELD_FLAGS = {
                readOnly: 1,
                required: 2,
                noExport: 4,
                multiline: 4096,
                password: 8192,
                toggleToOffButton: 16384,
                radioButton: 32768,
                pushButton: 65536,
                combo: 131072,
                edit: 262144,
                sort: 524288,
                multiSelect: 2097152,
                noSpell: 4194304
              };
              const FIELD_JUSTIFY = {
                left: 0,
                center: 1,
                right: 2
              };
              const VALUE_MAP = {
                value: "V",
                defaultValue: "DV"
              };
              const FORMAT_SPECIAL = {
                zip: "0",
                zipPlus4: "1",
                zip4: "1",
                phone: "2",
                ssn: "3"
              };
              const FORMAT_DEFAULT = {
                number: {
                  nDec: 0,
                  sepComma: false,
                  negStyle: "MinusBlack",
                  currency: "",
                  currencyPrepend: true
                },
                percent: {
                  nDec: 0,
                  sepComma: false
                }
              };
              var AcroFormMixin = {
                initForm() {
                  if (!this._font) {
                    throw new Error("Must set a font before calling initForm method");
                  }
                  this._acroform = {
                    fonts: {},
                    defaultFont: this._font.name
                  };
                  this._acroform.fonts[this._font.id] = this._font.ref();
                  let data = {
                    Fields: [],
                    NeedAppearances: true,
                    DA: new String(`/${this._font.id} 0 Tf 0 g`),
                    DR: {
                      Font: {}
                    }
                  };
                  data.DR.Font[this._font.id] = this._font.ref();
                  const AcroForm = this.ref(data);
                  this._root.data.AcroForm = AcroForm;
                  return this;
                },
                endAcroForm() {
                  if (this._root.data.AcroForm) {
                    if (!Object.keys(this._acroform.fonts).length && !this._acroform.defaultFont) {
                      throw new Error("No fonts specified for PDF form");
                    }
                    let fontDict = this._root.data.AcroForm.data.DR.Font;
                    Object.keys(this._acroform.fonts).forEach((name) => {
                      fontDict[name] = this._acroform.fonts[name];
                    });
                    this._root.data.AcroForm.data.Fields.forEach((fieldRef) => {
                      this._endChild(fieldRef);
                    });
                    this._root.data.AcroForm.end();
                  }
                  return this;
                },
                _endChild(ref) {
                  if (Array.isArray(ref.data.Kids)) {
                    ref.data.Kids.forEach((childRef) => {
                      this._endChild(childRef);
                    });
                    ref.end();
                  }
                  return this;
                },
                formField(name) {
                  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  let fieldDict = this._fieldDict(name, null, options);
                  let fieldRef = this.ref(fieldDict);
                  this._addToParent(fieldRef);
                  return fieldRef;
                },
                formAnnotation(name, type, x, y, w, h) {
                  let options = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : {};
                  let fieldDict = this._fieldDict(name, type, options);
                  fieldDict.Subtype = "Widget";
                  if (fieldDict.F === void 0) {
                    fieldDict.F = 4;
                  }
                  this.annotate(x, y, w, h, fieldDict);
                  let annotRef = this.page.annotations[this.page.annotations.length - 1];
                  return this._addToParent(annotRef);
                },
                formText(name, x, y, w, h) {
                  let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                  return this.formAnnotation(name, "text", x, y, w, h, options);
                },
                formPushButton(name, x, y, w, h) {
                  let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                  return this.formAnnotation(name, "pushButton", x, y, w, h, options);
                },
                formCombo(name, x, y, w, h) {
                  let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                  return this.formAnnotation(name, "combo", x, y, w, h, options);
                },
                formList(name, x, y, w, h) {
                  let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                  return this.formAnnotation(name, "list", x, y, w, h, options);
                },
                formRadioButton(name, x, y, w, h) {
                  let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                  return this.formAnnotation(name, "radioButton", x, y, w, h, options);
                },
                formCheckbox(name, x, y, w, h) {
                  let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                  return this.formAnnotation(name, "checkbox", x, y, w, h, options);
                },
                _addToParent(fieldRef) {
                  let parent = fieldRef.data.Parent;
                  if (parent) {
                    if (!parent.data.Kids) {
                      parent.data.Kids = [];
                    }
                    parent.data.Kids.push(fieldRef);
                  } else {
                    this._root.data.AcroForm.data.Fields.push(fieldRef);
                  }
                  return this;
                },
                _fieldDict(name, type) {
                  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                  if (!this._acroform) {
                    throw new Error("Call document.initForm() method before adding form elements to document");
                  }
                  let opts = Object.assign({}, options);
                  if (type !== null) {
                    opts = this._resolveType(type, options);
                  }
                  opts = this._resolveFlags(opts);
                  opts = this._resolveJustify(opts);
                  opts = this._resolveFont(opts);
                  opts = this._resolveStrings(opts);
                  opts = this._resolveColors(opts);
                  opts = this._resolveFormat(opts);
                  opts.T = new String(name);
                  if (opts.parent) {
                    opts.Parent = opts.parent;
                    delete opts.parent;
                  }
                  return opts;
                },
                _resolveType(type, opts) {
                  if (type === "text") {
                    opts.FT = "Tx";
                  } else if (type === "pushButton") {
                    opts.FT = "Btn";
                    opts.pushButton = true;
                  } else if (type === "radioButton") {
                    opts.FT = "Btn";
                    opts.radioButton = true;
                  } else if (type === "checkbox") {
                    opts.FT = "Btn";
                  } else if (type === "combo") {
                    opts.FT = "Ch";
                    opts.combo = true;
                  } else if (type === "list") {
                    opts.FT = "Ch";
                  } else {
                    throw new Error(`Invalid form annotation type '${type}'`);
                  }
                  return opts;
                },
                _resolveFormat(opts) {
                  const f = opts.format;
                  if (f && f.type) {
                    let fnKeystroke;
                    let fnFormat;
                    let params = "";
                    if (FORMAT_SPECIAL[f.type] !== void 0) {
                      fnKeystroke = `AFSpecial_Keystroke`;
                      fnFormat = `AFSpecial_Format`;
                      params = FORMAT_SPECIAL[f.type];
                    } else {
                      let format = f.type.charAt(0).toUpperCase() + f.type.slice(1);
                      fnKeystroke = `AF${format}_Keystroke`;
                      fnFormat = `AF${format}_Format`;
                      if (f.type === "date") {
                        fnKeystroke += "Ex";
                        params = String(f.param);
                      } else if (f.type === "time") {
                        params = String(f.param);
                      } else if (f.type === "number") {
                        let p = Object.assign({}, FORMAT_DEFAULT.number, f);
                        params = String([String(p.nDec), p.sepComma ? "0" : "1", '"' + p.negStyle + '"', "null", '"' + p.currency + '"', String(p.currencyPrepend)].join(","));
                      } else if (f.type === "percent") {
                        let p = Object.assign({}, FORMAT_DEFAULT.percent, f);
                        params = String([String(p.nDec), p.sepComma ? "0" : "1"].join(","));
                      }
                    }
                    opts.AA = opts.AA ? opts.AA : {};
                    opts.AA.K = {
                      S: "JavaScript",
                      JS: new String(`${fnKeystroke}(${params});`)
                    };
                    opts.AA.F = {
                      S: "JavaScript",
                      JS: new String(`${fnFormat}(${params});`)
                    };
                  }
                  delete opts.format;
                  return opts;
                },
                _resolveColors(opts) {
                  let color = this._normalizeColor(opts.backgroundColor);
                  if (color) {
                    if (!opts.MK) {
                      opts.MK = {};
                    }
                    opts.MK.BG = color;
                  }
                  color = this._normalizeColor(opts.borderColor);
                  if (color) {
                    if (!opts.MK) {
                      opts.MK = {};
                    }
                    opts.MK.BC = color;
                  }
                  delete opts.backgroundColor;
                  delete opts.borderColor;
                  return opts;
                },
                _resolveFlags(options) {
                  let result = 0;
                  Object.keys(options).forEach((key) => {
                    if (FIELD_FLAGS[key]) {
                      if (options[key]) {
                        result |= FIELD_FLAGS[key];
                      }
                      delete options[key];
                    }
                  });
                  if (result !== 0) {
                    options.Ff = options.Ff ? options.Ff : 0;
                    options.Ff |= result;
                  }
                  return options;
                },
                _resolveJustify(options) {
                  let result = 0;
                  if (options.align !== void 0) {
                    if (typeof FIELD_JUSTIFY[options.align] === "number") {
                      result = FIELD_JUSTIFY[options.align];
                    }
                    delete options.align;
                  }
                  if (result !== 0) {
                    options.Q = result;
                  }
                  return options;
                },
                _resolveFont(options) {
                  if (this._acroform.fonts[this._font.id] == null) {
                    this._acroform.fonts[this._font.id] = this._font.ref();
                  }
                  if (this._acroform.defaultFont !== this._font.name) {
                    options.DR = {
                      Font: {}
                    };
                    const fontSize = options.fontSize || 0;
                    options.DR.Font[this._font.id] = this._font.ref();
                    options.DA = new String(`/${this._font.id} ${fontSize} Tf 0 g`);
                  }
                  return options;
                },
                _resolveStrings(options) {
                  let select = [];
                  function appendChoices(a) {
                    if (Array.isArray(a)) {
                      for (let idx = 0; idx < a.length; idx++) {
                        if (typeof a[idx] === "string") {
                          select.push(new String(a[idx]));
                        } else {
                          select.push(a[idx]);
                        }
                      }
                    }
                  }
                  appendChoices(options.Opt);
                  if (options.select) {
                    appendChoices(options.select);
                    delete options.select;
                  }
                  if (select.length) {
                    options.Opt = select;
                  }
                  Object.keys(VALUE_MAP).forEach((key) => {
                    if (options[key] !== void 0) {
                      options[VALUE_MAP[key]] = options[key];
                      delete options[key];
                    }
                  });
                  ["V", "DV"].forEach((key) => {
                    if (typeof options[key] === "string") {
                      options[key] = new String(options[key]);
                    }
                  });
                  if (options.MK && options.MK.CA) {
                    options.MK.CA = new String(options.MK.CA);
                  }
                  if (options.label) {
                    options.MK = options.MK ? options.MK : {};
                    options.MK.CA = new String(options.label);
                    delete options.label;
                  }
                  return options;
                }
              };
              var AttachmentsMixin = {
                file(src) {
                  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  options.name = options.name || src;
                  options.relationship = options.relationship || "Unspecified";
                  const refBody = {
                    Type: "EmbeddedFile",
                    Params: {}
                  };
                  let data;
                  if (!src) {
                    throw new Error("No src specified");
                  }
                  if (Buffer.isBuffer(src)) {
                    data = src;
                  } else if (src instanceof ArrayBuffer) {
                    data = Buffer.from(new Uint8Array(src));
                  } else {
                    const match = /^data:(.*?);base64,(.*)$/.exec(src);
                    if (match) {
                      if (match[1]) {
                        refBody.Subtype = match[1].replace("/", "#2F");
                      }
                      data = Buffer.from(match[2], "base64");
                    } else {
                      data = fs.readFileSync(src);
                      if (!data) {
                        throw new Error(`Could not read contents of file at filepath ${src}`);
                      }
                      const {
                        birthtime,
                        ctime
                      } = fs.statSync(src);
                      refBody.Params.CreationDate = birthtime;
                      refBody.Params.ModDate = ctime;
                    }
                  }
                  if (options.creationDate instanceof Date) {
                    refBody.Params.CreationDate = options.creationDate;
                  }
                  if (options.modifiedDate instanceof Date) {
                    refBody.Params.ModDate = options.modifiedDate;
                  }
                  if (options.type) {
                    refBody.Subtype = options.type.replace("/", "#2F");
                  }
                  const checksum = _cryptoJs.default.MD5(_cryptoJs.default.lib.WordArray.create(new Uint8Array(data)));
                  refBody.Params.CheckSum = new String(checksum);
                  refBody.Params.Size = data.byteLength;
                  let ref;
                  if (!this._fileRegistry) this._fileRegistry = {};
                  let file = this._fileRegistry[options.name];
                  if (file && isEqual(refBody, file)) {
                    ref = file.ref;
                  } else {
                    ref = this.ref(refBody);
                    ref.end(data);
                    this._fileRegistry[options.name] = {
                      ...refBody,
                      ref
                    };
                  }
                  const fileSpecBody = {
                    Type: "Filespec",
                    AFRelationship: options.relationship,
                    F: new String(options.name),
                    EF: {
                      F: ref
                    },
                    UF: new String(options.name)
                  };
                  if (options.description) {
                    fileSpecBody.Desc = new String(options.description);
                  }
                  const filespec = this.ref(fileSpecBody);
                  filespec.end();
                  if (!options.hidden) {
                    this.addNamedEmbeddedFile(options.name, filespec);
                  }
                  if (this._root.data.AF) {
                    this._root.data.AF.push(filespec);
                  } else {
                    this._root.data.AF = [filespec];
                  }
                  return filespec;
                }
              };
              function isEqual(a, b) {
                return a.Subtype === b.Subtype && a.Params.CheckSum.toString() === b.Params.CheckSum.toString() && a.Params.Size === b.Params.Size && a.Params.CreationDate.getTime() === b.Params.CreationDate.getTime() && (a.Params.ModDate === void 0 && b.Params.ModDate === void 0 || a.Params.ModDate.getTime() === b.Params.ModDate.getTime());
              }
              var PDFA = {
                initPDFA(pSubset) {
                  if (pSubset.charAt(pSubset.length - 3) === "-") {
                    this.subset_conformance = pSubset.charAt(pSubset.length - 1).toUpperCase();
                    this.subset = parseInt(pSubset.charAt(pSubset.length - 2));
                  } else {
                    this.subset_conformance = "B";
                    this.subset = parseInt(pSubset.charAt(pSubset.length - 1));
                  }
                },
                endSubset() {
                  this._addPdfaMetadata();
                  this._addColorOutputIntent();
                },
                _addColorOutputIntent() {
                  const iccProfile = Buffer("AAAL0AAAAAACAAAAbW50clJHQiBYWVogB98AAgAPAAAAAAAAYWNzcAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAPbWAAEAAAAA0y0AAAAAPQ6y3q6Tl76bZybOjApDzgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQZGVzYwAAAUQAAABjYlhZWgAAAagAAAAUYlRSQwAAAbwAAAgMZ1RSQwAAAbwAAAgMclRSQwAAAbwAAAgMZG1kZAAACcgAAACIZ1hZWgAAClAAAAAUbHVtaQAACmQAAAAUbWVhcwAACngAAAAkYmtwdAAACpwAAAAUclhZWgAACrAAAAAUdGVjaAAACsQAAAAMdnVlZAAACtAAAACHd3RwdAAAC1gAAAAUY3BydAAAC2wAAAA3Y2hhZAAAC6QAAAAsZGVzYwAAAAAAAAAJc1JHQjIwMTQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFhZWiAAAAAAAAAkoAAAD4QAALbPY3VydgAAAAAAAAQAAAAABQAKAA8AFAAZAB4AIwAoAC0AMgA3ADsAQABFAEoATwBUAFkAXgBjAGgAbQByAHcAfACBAIYAiwCQAJUAmgCfAKQAqQCuALIAtwC8AMEAxgDLANAA1QDbAOAA5QDrAPAA9gD7AQEBBwENARMBGQEfASUBKwEyATgBPgFFAUwBUgFZAWABZwFuAXUBfAGDAYsBkgGaAaEBqQGxAbkBwQHJAdEB2QHhAekB8gH6AgMCDAIUAh0CJgIvAjgCQQJLAlQCXQJnAnECegKEAo4CmAKiAqwCtgLBAssC1QLgAusC9QMAAwsDFgMhAy0DOANDA08DWgNmA3IDfgOKA5YDogOuA7oDxwPTA+AD7AP5BAYEEwQgBC0EOwRIBFUEYwRxBH4EjASaBKgEtgTEBNME4QTwBP4FDQUcBSsFOgVJBVgFZwV3BYYFlgWmBbUFxQXVBeUF9gYGBhYGJwY3BkgGWQZqBnsGjAadBq8GwAbRBuMG9QcHBxkHKwc9B08HYQd0B4YHmQesB78H0gflB/gICwgfCDIIRghaCG4IggiWCKoIvgjSCOcI+wkQCSUJOglPCWQJeQmPCaQJugnPCeUJ+woRCicKPQpUCmoKgQqYCq4KxQrcCvMLCwsiCzkLUQtpC4ALmAuwC8gL4Qv5DBIMKgxDDFwMdQyODKcMwAzZDPMNDQ0mDUANWg10DY4NqQ3DDd4N+A4TDi4OSQ5kDn8Omw62DtIO7g8JDyUPQQ9eD3oPlg+zD88P7BAJECYQQxBhEH4QmxC5ENcQ9RETETERTxFtEYwRqhHJEegSBxImEkUSZBKEEqMSwxLjEwMTIxNDE2MTgxOkE8UT5RQGFCcUSRRqFIsUrRTOFPAVEhU0FVYVeBWbFb0V4BYDFiYWSRZsFo8WshbWFvoXHRdBF2UXiReuF9IX9xgbGEAYZRiKGK8Y1Rj6GSAZRRlrGZEZtxndGgQaKhpRGncanhrFGuwbFBs7G2MbihuyG9ocAhwqHFIcexyjHMwc9R0eHUcdcB2ZHcMd7B4WHkAeah6UHr4e6R8THz4faR+UH78f6iAVIEEgbCCYIMQg8CEcIUghdSGhIc4h+yInIlUigiKvIt0jCiM4I2YjlCPCI/AkHyRNJHwkqyTaJQklOCVoJZclxyX3JicmVyaHJrcm6CcYJ0kneierJ9woDSg/KHEooijUKQYpOClrKZ0p0CoCKjUqaCqbKs8rAis2K2krnSvRLAUsOSxuLKIs1y0MLUEtdi2rLeEuFi5MLoIuty7uLyQvWi+RL8cv/jA1MGwwpDDbMRIxSjGCMbox8jIqMmMymzLUMw0zRjN/M7gz8TQrNGU0njTYNRM1TTWHNcI1/TY3NnI2rjbpNyQ3YDecN9c4FDhQOIw4yDkFOUI5fzm8Ofk6Njp0OrI67zstO2s7qjvoPCc8ZTykPOM9Ij1hPaE94D4gPmA+oD7gPyE/YT+iP+JAI0BkQKZA50EpQWpBrEHuQjBCckK1QvdDOkN9Q8BEA0RHRIpEzkUSRVVFmkXeRiJGZ0arRvBHNUd7R8BIBUhLSJFI10kdSWNJqUnwSjdKfUrESwxLU0uaS+JMKkxyTLpNAk1KTZNN3E4lTm5Ot08AT0lPk0/dUCdQcVC7UQZRUFGbUeZSMVJ8UsdTE1NfU6pT9lRCVI9U21UoVXVVwlYPVlxWqVb3V0RXklfgWC9YfVjLWRpZaVm4WgdaVlqmWvVbRVuVW+VcNVyGXNZdJ114XcleGl5sXr1fD19hX7NgBWBXYKpg/GFPYaJh9WJJYpxi8GNDY5dj62RAZJRk6WU9ZZJl52Y9ZpJm6Gc9Z5Nn6Wg/aJZo7GlDaZpp8WpIap9q92tPa6dr/2xXbK9tCG1gbbluEm5rbsRvHm94b9FwK3CGcOBxOnGVcfByS3KmcwFzXXO4dBR0cHTMdSh1hXXhdj52m3b4d1Z3s3gReG54zHkqeYl553pGeqV7BHtje8J8IXyBfOF9QX2hfgF+Yn7CfyN/hH/lgEeAqIEKgWuBzYIwgpKC9INXg7qEHYSAhOOFR4Wrhg6GcobXhzuHn4gEiGmIzokziZmJ/opkisqLMIuWi/yMY4zKjTGNmI3/jmaOzo82j56QBpBukNaRP5GokhGSepLjk02TtpQglIqU9JVflcmWNJaflwqXdZfgmEyYuJkkmZCZ/JpomtWbQpuvnByciZz3nWSd0p5Anq6fHZ+Ln/qgaaDYoUehtqImopajBqN2o+akVqTHpTilqaYapoum/adup+CoUqjEqTepqaocqo+rAqt1q+msXKzQrUStuK4trqGvFq+LsACwdbDqsWCx1rJLssKzOLOutCW0nLUTtYq2AbZ5tvC3aLfguFm40blKucK6O7q1uy67p7whvJu9Fb2Pvgq+hL7/v3q/9cBwwOzBZ8Hjwl/C28NYw9TEUcTOxUvFyMZGxsPHQce/yD3IvMk6ybnKOMq3yzbLtsw1zLXNNc21zjbOts83z7jQOdC60TzRvtI/0sHTRNPG1EnUy9VO1dHWVdbY11zX4Nhk2OjZbNnx2nba+9uA3AXcit0Q3ZbeHN6i3ynfr+A24L3hROHM4lPi2+Nj4+vkc+T85YTmDeaW5x/nqegy6LzpRunQ6lvq5etw6/vshu0R7ZzuKO6070DvzPBY8OXxcvH/8ozzGfOn9DT0wvVQ9d72bfb794r4Gfio+Tj5x/pX+uf7d/wH/Jj9Kf26/kv+3P9t//9kZXNjAAAAAAAAAC5JRUMgNjE5NjYtMi0xIERlZmF1bHQgUkdCIENvbG91ciBTcGFjZSAtIHNSR0IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWFlaIAAAAAAAAGKZAAC3hQAAGNpYWVogAAAAAAAAAAAAUAAAAAAAAG1lYXMAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlhZWiAAAAAAAAAAngAAAKQAAACHWFlaIAAAAAAAAG+iAAA49QAAA5BzaWcgAAAAAENSVCBkZXNjAAAAAAAAAC1SZWZlcmVuY2UgVmlld2luZyBDb25kaXRpb24gaW4gSUVDIDYxOTY2LTItMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWFlaIAAAAAAAAPbWAAEAAAAA0y10ZXh0AAAAAENvcHlyaWdodCBJbnRlcm5hdGlvbmFsIENvbG9yIENvbnNvcnRpdW0sIDIwMTUAAHNmMzIAAAAAAAEMRAAABd////MmAAAHlAAA/Y////uh///9ogAAA9sAAMB1", "base64");
                  ;
                  const colorProfileRef = this.ref({
                    Length: iccProfile.length,
                    N: 3
                  });
                  colorProfileRef.write(iccProfile);
                  colorProfileRef.end();
                  const intentRef = this.ref({
                    Type: "OutputIntent",
                    S: "GTS_PDFA1",
                    Info: new String("sRGB IEC61966-2.1"),
                    OutputConditionIdentifier: new String("sRGB IEC61966-2.1"),
                    DestOutputProfile: colorProfileRef
                  });
                  intentRef.end();
                  this._root.data.OutputIntents = [intentRef];
                },
                _getPdfaid() {
                  return `
        <rdf:Description xmlns:pdfaid="http://www.aiim.org/pdfa/ns/id/" rdf:about="">
            <pdfaid:part>${this.subset}</pdfaid:part>
            <pdfaid:conformance>${this.subset_conformance}</pdfaid:conformance>
        </rdf:Description>
        `;
                },
                _addPdfaMetadata() {
                  this.appendXML(this._getPdfaid());
                }
              };
              var PDFUA = {
                initPDFUA() {
                  this.subset = 1;
                },
                endSubset() {
                  this._addPdfuaMetadata();
                },
                _addPdfuaMetadata() {
                  this.appendXML(this._getPdfuaid());
                },
                _getPdfuaid() {
                  return `
        <rdf:Description xmlns:pdfuaid="http://www.aiim.org/pdfua/ns/id/" rdf:about="">
            <pdfuaid:part>${this.subset}</pdfuaid:part>
        </rdf:Description>
        `;
                }
              };
              var SubsetMixin = {
                _importSubset(subset) {
                  Object.assign(this, subset);
                },
                initSubset(options) {
                  switch (options.subset) {
                    case "PDF/A-1":
                    case "PDF/A-1a":
                    case "PDF/A-1b":
                    case "PDF/A-2":
                    case "PDF/A-2a":
                    case "PDF/A-2b":
                    case "PDF/A-3":
                    case "PDF/A-3a":
                    case "PDF/A-3b":
                      this._importSubset(PDFA);
                      this.initPDFA(options.subset);
                      break;
                    case "PDF/UA":
                      this._importSubset(PDFUA);
                      this.initPDFUA();
                      break;
                  }
                }
              };
              const ROW_FIELDS = ["height", "minHeight", "maxHeight"];
              const COLUMN_FIELDS = ["width", "minWidth", "maxWidth"];
              function memoize(fn, maxSize) {
                const cache = /* @__PURE__ */ new Map();
                return function() {
                  const key = arguments.length <= 0 ? void 0 : arguments[0];
                  if (!cache.has(key)) {
                    cache.set(key, fn(...arguments));
                    if (cache.size > maxSize) cache.delete(cache.keys().next());
                  }
                  return cache.get(key);
                };
              }
              function isObject(item) {
                return item && typeof item === "object" && !Array.isArray(item);
              }
              function deepMerge(target) {
                if (!isObject(target)) return target;
                target = deepClone(target);
                for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  sources[_key - 1] = arguments[_key];
                }
                for (const source of sources) {
                  if (isObject(source)) {
                    for (const key in source) {
                      if (isObject(source[key])) {
                        if (!(key in target)) target[key] = {};
                        target[key] = deepMerge(target[key], source[key]);
                      } else if (source[key] !== void 0) {
                        target[key] = deepClone(source[key]);
                      }
                    }
                  }
                }
                return target;
              }
              function deepClone(obj) {
                let result = obj;
                if (obj && typeof obj == "object") {
                  result = Array.isArray(obj) ? [] : {};
                  for (const key in obj) result[key] = deepClone(obj[key]);
                }
                return result;
              }
              function normalizedDefaultStyle(defaultStyleInternal) {
                let defaultStyle = defaultStyleInternal;
                if (typeof defaultStyle !== "object") defaultStyle = {
                  text: defaultStyle
                };
                const defaultRowStyle = Object.fromEntries(Object.entries(defaultStyle).filter((_ref) => {
                  let [k] = _ref;
                  return ROW_FIELDS.includes(k);
                }));
                const defaultColStyle = Object.fromEntries(Object.entries(defaultStyle).filter((_ref2) => {
                  let [k] = _ref2;
                  return COLUMN_FIELDS.includes(k);
                }));
                defaultStyle.padding = normalizeSides(defaultStyle.padding);
                defaultStyle.border = normalizeSides(defaultStyle.border);
                defaultStyle.borderColor = normalizeSides(defaultStyle.borderColor);
                defaultStyle.align = normalizeAlignment(defaultStyle.align);
                return {
                  defaultStyle,
                  defaultRowStyle,
                  defaultColStyle
                };
              }
              function normalizedRowStyle(defaultRowStyle, rowStyleInternal, i) {
                let rowStyle = rowStyleInternal(i);
                if (rowStyle == null || typeof rowStyle !== "object") {
                  rowStyle = {
                    height: rowStyle
                  };
                }
                rowStyle.padding = normalizeSides(rowStyle.padding);
                rowStyle.border = normalizeSides(rowStyle.border);
                rowStyle.borderColor = normalizeSides(rowStyle.borderColor);
                rowStyle.align = normalizeAlignment(rowStyle.align);
                rowStyle = deepMerge(defaultRowStyle, rowStyle);
                const document2 = this.document;
                const page = document2.page;
                const contentHeight = page.contentHeight;
                if (rowStyle.height == null || rowStyle.height === "auto") {
                  rowStyle.height = "auto";
                } else {
                  rowStyle.height = document2.sizeToPoint(rowStyle.height, 0, page, contentHeight);
                }
                rowStyle.minHeight = document2.sizeToPoint(rowStyle.minHeight, 0, page, contentHeight);
                rowStyle.maxHeight = document2.sizeToPoint(rowStyle.maxHeight, 0, page, contentHeight);
                return rowStyle;
              }
              function normalizedColumnStyle(defaultColStyle, colStyleInternal, i) {
                let colStyle = colStyleInternal(i);
                if (colStyle == null || typeof colStyle !== "object") {
                  colStyle = {
                    width: colStyle
                  };
                }
                colStyle.padding = normalizeSides(colStyle.padding);
                colStyle.border = normalizeSides(colStyle.border);
                colStyle.borderColor = normalizeSides(colStyle.borderColor);
                colStyle.align = normalizeAlignment(colStyle.align);
                colStyle = deepMerge(defaultColStyle, colStyle);
                if (colStyle.width == null || colStyle.width === "*") {
                  colStyle.width = "*";
                } else {
                  colStyle.width = this.document.sizeToPoint(colStyle.width, 0, this.document.page, this._maxWidth);
                }
                colStyle.minWidth = this.document.sizeToPoint(colStyle.minWidth, 0, this.document.page, this._maxWidth);
                colStyle.maxWidth = this.document.sizeToPoint(colStyle.maxWidth, 0, this.document.page, this._maxWidth);
                return colStyle;
              }
              function normalizeAlignment(align) {
                return align == null || typeof align === "string" ? {
                  x: align,
                  y: align
                } : align;
              }
              function normalizeTable() {
                var _a, _b;
                const doc = this.document;
                const opts = this.opts;
                let index = doc._tableIndex++;
                this._id = new String(opts.id ?? `table-${index}`);
                this._position = {
                  x: doc.sizeToPoint((_a = opts.position) == null ? void 0 : _a.x, doc.x),
                  y: doc.sizeToPoint((_b = opts.position) == null ? void 0 : _b.y, doc.y)
                };
                this._maxWidth = doc.sizeToPoint(opts.maxWidth, doc.page.width - doc.page.margins.right - this._position.x);
                const {
                  defaultStyle,
                  defaultColStyle,
                  defaultRowStyle
                } = normalizedDefaultStyle(opts.defaultStyle);
                this._defaultStyle = defaultStyle;
                let colStyle;
                if (opts.columnStyles) {
                  if (Array.isArray(opts.columnStyles)) {
                    colStyle = (i) => opts.columnStyles[i];
                  } else if (typeof opts.columnStyles === "function") {
                    colStyle = memoize((i) => opts.columnStyles(i), Infinity);
                  } else if (typeof opts.columnStyles === "object") {
                    colStyle = () => opts.columnStyles;
                  }
                }
                if (!colStyle) colStyle = () => ({});
                this._colStyle = normalizedColumnStyle.bind(this, defaultColStyle, colStyle);
                let rowStyle;
                if (opts.rowStyles) {
                  if (Array.isArray(opts.rowStyles)) {
                    rowStyle = (i) => opts.rowStyles[i];
                  } else if (typeof opts.rowStyles === "function") {
                    rowStyle = memoize((i) => opts.rowStyles(i), 10);
                  } else if (typeof opts.rowStyles === "object") {
                    rowStyle = () => opts.rowStyles;
                  }
                }
                if (!rowStyle) rowStyle = () => ({});
                this._rowStyle = normalizedRowStyle.bind(this, defaultRowStyle, rowStyle);
              }
              function normalizeText(text) {
                if (text != null) text = `${text}`;
                return text;
              }
              function normalizeCell(cell, rowIndex, colIndex) {
                var _a;
                const colStyle = this._colStyle(colIndex);
                let rowStyle = this._rowStyle(rowIndex);
                const font = deepMerge({}, colStyle.font, rowStyle.font, cell.font);
                const customFont = Object.values(font).filter((v) => v != null).length > 0;
                const doc = this.document;
                const rollbackFont = doc._fontSource;
                const rollbackFontSize = doc._fontSize;
                const rollbackFontFamily = doc._fontFamily;
                if (customFont) {
                  if (font.src) doc.font(font.src, font.family);
                  if (font.size) doc.fontSize(font.size);
                  rowStyle = this._rowStyle(rowIndex);
                }
                cell.padding = normalizeSides(cell.padding);
                cell.border = normalizeSides(cell.border);
                cell.borderColor = normalizeSides(cell.borderColor);
                const config = deepMerge(this._defaultStyle, colStyle, rowStyle, cell);
                config.rowIndex = rowIndex;
                config.colIndex = colIndex;
                config.font = font ?? {};
                config.customFont = customFont;
                config.text = normalizeText(config.text);
                config.rowSpan = config.rowSpan ?? 1;
                config.colSpan = config.colSpan ?? 1;
                config.padding = normalizeSides(config.padding, "0.25em", (x) => doc.sizeToPoint(x, "0.25em"));
                config.border = normalizeSides(config.border, 1, (x) => doc.sizeToPoint(x, 1));
                config.borderColor = normalizeSides(config.borderColor, "black", (x) => x ?? "black");
                config.align = normalizeAlignment(config.align);
                config.align.x = config.align.x ?? "left";
                config.align.y = config.align.y ?? "top";
                config.textStroke = doc.sizeToPoint(config.textStroke, 0);
                config.textStrokeColor = config.textStrokeColor ?? "black";
                config.textColor = config.textColor ?? "black";
                config.textOptions = config.textOptions ?? {};
                config.id = new String(config.id ?? `${this._id}-${rowIndex}-${colIndex}`);
                config.type = ((_a = config.type) == null ? void 0 : _a.toUpperCase()) === "TH" ? "TH" : "TD";
                if (config.scope) {
                  config.scope = config.scope.toLowerCase();
                  if (config.scope === "row") config.scope = "Row";
                  else if (config.scope === "both") config.scope = "Both";
                  else if (config.scope === "column") config.scope = "Column";
                }
                if (typeof this.opts.debug === "boolean") config.debug = this.opts.debug;
                if (customFont) doc.font(rollbackFont, rollbackFontFamily, rollbackFontSize);
                return config;
              }
              function normalizeRow(row, rowIndex) {
                if (!this._cellClaim) this._cellClaim = /* @__PURE__ */ new Set();
                let colIndex = 0;
                return row.map((cell) => {
                  if (cell == null || typeof cell !== "object") cell = {
                    text: cell
                  };
                  while (this._cellClaim.has(`${rowIndex},${colIndex}`)) {
                    colIndex++;
                  }
                  cell = normalizeCell.call(this, cell, rowIndex, colIndex);
                  for (let i = 0; i < cell.rowSpan; i++) {
                    for (let j = 0; j < cell.colSpan; j++) {
                      this._cellClaim.add(`${rowIndex + i},${colIndex + j}`);
                    }
                  }
                  colIndex += cell.colSpan;
                  return cell;
                });
              }
              function ensure(row) {
                this._columnWidths = [];
                ensureColumnWidths.call(this, row.reduce((a, cell) => a + cell.colSpan, 0));
                this._rowHeights = [];
                this._rowYPos = [this._position.y];
                this._rowBuffer = /* @__PURE__ */ new Set();
              }
              function ensureColumnWidths(numCols) {
                let starColumnIndexes = [];
                let starMinAcc = 0;
                let unclaimedWidth = this._maxWidth;
                for (let i = 0; i < numCols; i++) {
                  let col = this._colStyle(i);
                  if (col.width === "*") {
                    starColumnIndexes[i] = col;
                    starMinAcc += col.minWidth;
                  } else {
                    unclaimedWidth -= col.width;
                    this._columnWidths[i] = col.width;
                  }
                }
                let starColCount = starColumnIndexes.reduce((x) => x + 1, 0);
                if (starMinAcc >= unclaimedWidth) {
                  starColumnIndexes.forEach((cell, i) => {
                    this._columnWidths[i] = cell.minWidth;
                  });
                } else if (starColCount > 0) {
                  starColumnIndexes.forEach((col, i) => {
                    let starSize = unclaimedWidth / starColCount;
                    this._columnWidths[i] = Math.max(starSize, col.minWidth);
                    if (col.maxWidth > 0) {
                      this._columnWidths[i] = Math.min(this._columnWidths[i], col.maxWidth);
                    }
                    unclaimedWidth -= this._columnWidths[i];
                    starColCount--;
                  });
                }
                let tempX = this._position.x;
                this._columnXPos = Array.from(this._columnWidths, (v) => {
                  const t = tempX;
                  tempX += v;
                  return t;
                });
              }
              function measure(row, rowIndex) {
                row.forEach((cell) => this._rowBuffer.add(cell));
                if (rowIndex > 0) {
                  this._rowYPos[rowIndex] = this._rowYPos[rowIndex - 1] + this._rowHeights[rowIndex - 1];
                }
                const rowStyle = this._rowStyle(rowIndex);
                let toRender = [];
                this._rowBuffer.forEach((cell) => {
                  if (cell.rowIndex + cell.rowSpan - 1 === rowIndex) {
                    toRender.push(measureCell.call(this, cell, rowStyle.height));
                    this._rowBuffer.delete(cell);
                  }
                });
                let rowHeight = rowStyle.height;
                if (rowHeight === "auto") {
                  rowHeight = toRender.reduce((acc, cell) => {
                    let minHeight = cell.textBounds.height + cell.padding.top + cell.padding.bottom;
                    for (let i = 0; i < cell.rowSpan - 1; i++) {
                      minHeight -= this._rowHeights[cell.rowIndex + i];
                    }
                    return Math.max(acc, minHeight);
                  }, 0);
                }
                rowHeight = Math.max(rowHeight, rowStyle.minHeight);
                if (rowStyle.maxHeight > 0) {
                  rowHeight = Math.min(rowHeight, rowStyle.maxHeight);
                }
                this._rowHeights[rowIndex] = rowHeight;
                let newPage = false;
                if (rowHeight > this.document.page.contentHeight) {
                  console.warn(new Error(`Row ${rowIndex} requested more than the safe page height, row has been clamped`).stack.slice(7));
                  this._rowHeights[rowIndex] = this.document.page.maxY() - this._rowYPos[rowIndex];
                } else if (this._rowYPos[rowIndex] + rowHeight >= this.document.page.maxY()) {
                  this._rowYPos[rowIndex] = this.document.page.margins.top;
                  newPage = true;
                }
                return {
                  newPage,
                  toRender: toRender.map((cell) => measureCell.call(this, cell, rowHeight))
                };
              }
              function measureCell(cell, rowHeight) {
                var _a, _b, _c;
                let cellWidth = 0;
                for (let i = 0; i < cell.colSpan; i++) {
                  cellWidth += this._columnWidths[cell.colIndex + i];
                }
                let cellHeight = rowHeight;
                if (cellHeight === "auto") {
                  cellHeight = this.document.page.contentHeight;
                } else {
                  for (let i = 0; i < cell.rowSpan - 1; i++) {
                    cellHeight += this._rowHeights[cell.rowIndex + i];
                  }
                }
                const textAllocatedWidth = cellWidth - cell.padding.left - cell.padding.right;
                const textAllocatedHeight = cellHeight - cell.padding.top - cell.padding.bottom;
                const rotation = cell.textOptions.rotation ?? 0;
                const {
                  width: textMaxWidth,
                  height: textMaxHeight
                } = computeBounds(rotation, textAllocatedWidth, textAllocatedHeight);
                const textOptions = {
                  align: cell.align.x,
                  ellipsis: true,
                  stroke: cell.textStroke > 0,
                  fill: true,
                  width: textMaxWidth,
                  height: textMaxHeight,
                  rotation,
                  ...cell.textOptions
                };
                let textBounds = {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                };
                if (cell.text) {
                  const rollbackFont = this.document._fontSource;
                  const rollbackFontSize = this.document._fontSize;
                  const rollbackFontFamily = this.document._fontFamily;
                  if ((_a = cell.font) == null ? void 0 : _a.src) this.document.font(cell.font.src, (_b = cell.font) == null ? void 0 : _b.family);
                  if ((_c = cell.font) == null ? void 0 : _c.size) this.document.fontSize(cell.font.size);
                  const unRotatedTextBounds = this.document.boundsOfString(cell.text, 0, 0, {
                    ...textOptions,
                    rotation: 0
                  });
                  textOptions.width = unRotatedTextBounds.width;
                  textOptions.height = unRotatedTextBounds.height;
                  textBounds = this.document.boundsOfString(cell.text, 0, 0, textOptions);
                  this.document.font(rollbackFont, rollbackFontFamily, rollbackFontSize);
                }
                return {
                  ...cell,
                  textOptions,
                  x: this._columnXPos[cell.colIndex],
                  y: this._rowYPos[cell.rowIndex],
                  textX: this._columnXPos[cell.colIndex] + cell.padding.left,
                  textY: this._rowYPos[cell.rowIndex] + cell.padding.top,
                  width: cellWidth,
                  height: cellHeight,
                  textAllocatedHeight,
                  textAllocatedWidth,
                  textBounds
                };
              }
              function computeBounds(rotation, allocWidth, allocHeight) {
                let textMaxWidth, textMaxHeight;
                const cos = cosine(rotation);
                const sin = sine(rotation);
                if (rotation === 0 || rotation === 180) {
                  textMaxWidth = allocWidth;
                  textMaxHeight = allocHeight;
                } else if (rotation === 90 || rotation === 270) {
                  textMaxWidth = allocHeight;
                  textMaxHeight = allocWidth;
                } else if (rotation < 90 || rotation > 180 && rotation < 270) {
                  textMaxWidth = allocWidth / (2 * cos);
                  textMaxHeight = allocWidth / (2 * sin);
                } else {
                  textMaxHeight = allocWidth / (2 * cos);
                  textMaxWidth = allocWidth / (2 * sin);
                }
                const EF = sin * textMaxWidth;
                const FG = cos * textMaxHeight;
                if (EF + FG > allocHeight) {
                  const denominator = cos * cos - sin * sin;
                  if (rotation === 0 || rotation === 180) {
                    textMaxWidth = allocWidth;
                    textMaxHeight = allocHeight;
                  } else if (rotation === 90 || rotation === 270) {
                    textMaxWidth = allocHeight;
                    textMaxHeight = allocWidth;
                  } else if (rotation < 90 || rotation > 180 && rotation < 270) {
                    textMaxWidth = (allocWidth * cos - allocHeight * sin) / denominator;
                    textMaxHeight = (allocHeight * cos - allocWidth * sin) / denominator;
                  } else {
                    textMaxHeight = (allocWidth * cos - allocHeight * sin) / denominator;
                    textMaxWidth = (allocHeight * cos - allocWidth * sin) / denominator;
                  }
                }
                return {
                  width: Math.abs(textMaxWidth),
                  height: Math.abs(textMaxHeight)
                };
              }
              function accommodateTable() {
                const structParent = this.opts.structParent;
                if (structParent) {
                  this._tableStruct = this.document.struct("Table");
                  this._tableStruct.dictionary.data.ID = this._id;
                  if (structParent instanceof PDFStructureElement) {
                    structParent.add(this._tableStruct);
                  } else if (structParent instanceof PDFDocument) {
                    structParent.addStructure(this._tableStruct);
                  }
                  this._headerRowLookup = {};
                  this._headerColumnLookup = {};
                }
              }
              function accommodateCleanup() {
                if (this._tableStruct) this._tableStruct.end();
              }
              function accessibleRow(row, rowIndex, renderCell2) {
                const rowStruct = this.document.struct("TR");
                rowStruct.dictionary.data.ID = new String(`${this._id}-${rowIndex}`);
                this._tableStruct.add(rowStruct);
                row.forEach((cell) => renderCell2(cell, rowStruct));
                rowStruct.end();
              }
              function accessibleCell(cell, rowStruct, callback) {
                const doc = this.document;
                const cellStruct = doc.struct(cell.type, {
                  title: cell.title
                });
                cellStruct.dictionary.data.ID = cell.id;
                rowStruct.add(cellStruct);
                const padding = cell.padding;
                const border = cell.border;
                const attributes = {
                  O: "Table",
                  Width: cell.width,
                  Height: cell.height,
                  Padding: [padding.top, padding.bottom, padding.left, padding.right],
                  RowSpan: cell.rowSpan > 1 ? cell.rowSpan : void 0,
                  ColSpan: cell.colSpan > 1 ? cell.colSpan : void 0,
                  BorderThickness: [border.top, border.bottom, border.left, border.right]
                };
                if (cell.type === "TH") {
                  if (cell.scope === "Row" || cell.scope === "Both") {
                    for (let i = 0; i < cell.rowSpan; i++) {
                      if (!this._headerRowLookup[cell.rowIndex + i]) {
                        this._headerRowLookup[cell.rowIndex + i] = [];
                      }
                      this._headerRowLookup[cell.rowIndex + i].push(cell.id);
                    }
                    attributes.Scope = cell.scope;
                  }
                  if (cell.scope === "Column" || cell.scope === "Both") {
                    for (let i = 0; i < cell.colSpan; i++) {
                      if (!this._headerColumnLookup[cell.colIndex + i]) {
                        this._headerColumnLookup[cell.colIndex + i] = [];
                      }
                      this._headerColumnLookup[cell.colIndex + i].push(cell.id);
                    }
                    attributes.Scope = cell.scope;
                  }
                }
                const Headers = new Set([...Array.from({
                  length: cell.colSpan
                }, (_, i) => this._headerColumnLookup[cell.colIndex + i]).flat(), ...Array.from({
                  length: cell.rowSpan
                }, (_, i) => this._headerRowLookup[cell.rowIndex + i]).flat()].filter(Boolean));
                if (Headers.size) attributes.Headers = Array.from(Headers);
                const normalizeColor = doc._normalizeColor;
                if (cell.backgroundColor != null) {
                  attributes.BackgroundColor = normalizeColor(cell.backgroundColor);
                }
                const hasBorder = [border.top, border.bottom, border.left, border.right];
                if (hasBorder.some((x) => x)) {
                  const borderColor = cell.borderColor;
                  attributes.BorderColor = [hasBorder[0] ? normalizeColor(borderColor.top) : null, hasBorder[1] ? normalizeColor(borderColor.bottom) : null, hasBorder[2] ? normalizeColor(borderColor.left) : null, hasBorder[3] ? normalizeColor(borderColor.right) : null];
                }
                Object.keys(attributes).forEach((key) => attributes[key] === void 0 && delete attributes[key]);
                cellStruct.dictionary.data.A = doc.ref(attributes);
                cellStruct.add(callback);
                cellStruct.end();
                cellStruct.dictionary.data.A.end();
              }
              function renderRow(row, rowIndex) {
                if (this._tableStruct) {
                  accessibleRow.call(this, row, rowIndex, renderCell.bind(this));
                } else {
                  row.forEach((cell) => renderCell.call(this, cell));
                }
                return this._rowYPos[rowIndex] + this._rowHeights[rowIndex];
              }
              function renderCell(cell, rowStruct) {
                const cellRenderer = () => {
                  if (cell.backgroundColor != null) {
                    this.document.save().rect(cell.x, cell.y, cell.width, cell.height).fill(cell.backgroundColor).restore();
                  }
                  renderBorder.call(this, cell.border, cell.borderColor, cell.x, cell.y, cell.width, cell.height);
                  if (cell.debug) {
                    this.document.save();
                    this.document.dash(1, {
                      space: 1
                    }).lineWidth(1).strokeOpacity(0.3);
                    this.document.rect(cell.x, cell.y, cell.width, cell.height).stroke("green");
                    this.document.restore();
                  }
                  if (cell.text) renderCellText.call(this, cell);
                };
                if (rowStruct) accessibleCell.call(this, cell, rowStruct, cellRenderer);
                else cellRenderer();
              }
              function renderCellText(cell) {
                const doc = this.document;
                const rollbackFont = doc._fontSource;
                const rollbackFontSize = doc._fontSize;
                const rollbackFontFamily = doc._fontFamily;
                if (cell.customFont) {
                  if (cell.font.src) doc.font(cell.font.src, cell.font.family);
                  if (cell.font.size) doc.fontSize(cell.font.size);
                }
                const x = cell.textX;
                const y = cell.textY;
                const Ah = cell.textAllocatedHeight;
                const Aw = cell.textAllocatedWidth;
                const Cw = cell.textBounds.width;
                const Ch = cell.textBounds.height;
                const Ox = -cell.textBounds.x;
                const Oy = -cell.textBounds.y;
                const PxScale = cell.align.x === "right" ? 1 : cell.align.x === "center" ? 0.5 : 0;
                const Px = (Aw - Cw) * PxScale;
                const PyScale = cell.align.y === "bottom" ? 1 : cell.align.y === "center" ? 0.5 : 0;
                const Py = (Ah - Ch) * PyScale;
                const dx = Px + Ox;
                const dy = Py + Oy;
                if (cell.debug) {
                  doc.save();
                  doc.dash(1, {
                    space: 1
                  }).lineWidth(1).strokeOpacity(0.3);
                  if (cell.text) {
                    doc.moveTo(x + Px, y).lineTo(x + Px, y + Ah).moveTo(x + Px + Cw, y).lineTo(x + Px + Cw, y + Ah).stroke("blue").moveTo(x, y + Py).lineTo(x + Aw, y + Py).moveTo(x, y + Py + Ch).lineTo(x + Aw, y + Py + Ch).stroke("green");
                  }
                  doc.rect(x, y, Aw, Ah).stroke("orange");
                  doc.restore();
                }
                doc.save().rect(x, y, Aw, Ah).clip();
                doc.fillColor(cell.textColor).strokeColor(cell.textStrokeColor);
                if (cell.textStroke > 0) doc.lineWidth(cell.textStroke);
                doc.text(cell.text, x + dx, y + dy, cell.textOptions);
                doc.restore();
                if (cell.font) doc.font(rollbackFont, rollbackFontFamily, rollbackFontSize);
              }
              function renderBorder(border, borderColor, x, y, width, height, mask) {
                border = Object.fromEntries(Object.entries(border).map((_ref) => {
                  let [k, v] = _ref;
                  return [k, mask && !mask[k] ? 0 : v];
                }));
                const doc = this.document;
                if ([border.right, border.bottom, border.left].every((val) => val === border.top)) {
                  if (border.top > 0) {
                    doc.save().lineWidth(border.top).rect(x, y, width, height).stroke(borderColor.top).restore();
                  }
                } else {
                  if (border.top > 0) {
                    doc.save().lineWidth(border.top).moveTo(x, y).lineTo(x + width, y).stroke(borderColor.top).restore();
                  }
                  if (border.right > 0) {
                    doc.save().lineWidth(border.right).moveTo(x + width, y).lineTo(x + width, y + height).stroke(borderColor.right).restore();
                  }
                  if (border.bottom > 0) {
                    doc.save().lineWidth(border.bottom).moveTo(x + width, y + height).lineTo(x, y + height).stroke(borderColor.bottom).restore();
                  }
                  if (border.left > 0) {
                    doc.save().lineWidth(border.left).moveTo(x, y + height).lineTo(x, y).stroke(borderColor.left).restore();
                  }
                }
              }
              class PDFTable {
                constructor(document2) {
                  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  this.document = document2;
                  this.opts = Object.freeze(opts);
                  normalizeTable.call(this);
                  accommodateTable.call(this);
                  this._currRowIndex = 0;
                  this._ended = false;
                  if (opts.data) {
                    for (const row of opts.data) this.row(row);
                    return this.end();
                  }
                }
                row(row) {
                  let lastRow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  if (this._ended) {
                    throw new Error(`Table was marked as ended on row ${this._currRowIndex}`);
                  }
                  row = Array.from(row);
                  row = normalizeRow.call(this, row, this._currRowIndex);
                  if (this._currRowIndex === 0) ensure.call(this, row);
                  const {
                    newPage,
                    toRender
                  } = measure.call(this, row, this._currRowIndex);
                  if (newPage) this.document.continueOnNewPage();
                  const yPos = renderRow.call(this, toRender, this._currRowIndex);
                  this.document.x = this._position.x;
                  this.document.y = yPos;
                  if (lastRow) return this.end();
                  this._currRowIndex++;
                  return this;
                }
                end() {
                  var _a;
                  while ((_a = this._rowBuffer) == null ? void 0 : _a.size) this.row([]);
                  this._ended = true;
                  accommodateCleanup.call(this);
                  return this.document;
                }
              }
              var TableMixin = {
                initTables() {
                  this._tableIndex = 0;
                },
                table(opts) {
                  return new PDFTable(this, opts);
                }
              };
              class PDFMetadata {
                constructor() {
                  this._metadata = `
        <?xpacket begin="\uFEFF" id="W5M0MpCehiHzreSzNTczkc9d"?>
            <x:xmpmeta xmlns:x="adobe:ns:meta/">
                <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
        `;
                }
                _closeTags() {
                  this._metadata = this._metadata.concat(`
                </rdf:RDF>
            </x:xmpmeta>
        <?xpacket end="w"?>
        `);
                }
                append(xml) {
                  let newline = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  this._metadata = this._metadata.concat(xml);
                  if (newline) this._metadata = this._metadata.concat("\n");
                }
                getXML() {
                  return this._metadata;
                }
                getLength() {
                  return this._metadata.length;
                }
                end() {
                  this._closeTags();
                  this._metadata = this._metadata.trim();
                }
              }
              var MetadataMixin = {
                initMetadata() {
                  this.metadata = new PDFMetadata();
                },
                appendXML(xml) {
                  let newline = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  this.metadata.append(xml, newline);
                },
                _addInfo() {
                  this.appendXML(`
        <rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/">
            <xmp:CreateDate>${this.info.CreationDate.toISOString().split(".")[0] + "Z"}</xmp:CreateDate>
            <xmp:CreatorTool>${this.info.Creator}</xmp:CreatorTool>
        </rdf:Description>
        `);
                  if (this.info.Title || this.info.Author || this.info.Subject) {
                    this.appendXML(`
            <rdf:Description rdf:about="" xmlns:dc="http://purl.org/dc/elements/1.1/">
            `);
                    if (this.info.Title) {
                      this.appendXML(`
                <dc:title>
                    <rdf:Alt>
                        <rdf:li xml:lang="x-default">${this.info.Title}</rdf:li>
                    </rdf:Alt>
                </dc:title>
                `);
                    }
                    if (this.info.Author) {
                      this.appendXML(`
                <dc:creator>
                    <rdf:Seq>
                        <rdf:li>${this.info.Author}</rdf:li>
                    </rdf:Seq>
                </dc:creator>
                `);
                    }
                    if (this.info.Subject) {
                      this.appendXML(`
                <dc:description>
                    <rdf:Alt>
                        <rdf:li xml:lang="x-default">${this.info.Subject}</rdf:li>
                    </rdf:Alt>
                </dc:description>
                `);
                    }
                    this.appendXML(`
            </rdf:Description>
            `);
                  }
                  this.appendXML(`
        <rdf:Description rdf:about="" xmlns:pdf="http://ns.adobe.com/pdf/1.3/">
            <pdf:Producer>${this.info.Creator}</pdf:Producer>`, false);
                  if (this.info.Keywords) {
                    this.appendXML(`
            <pdf:Keywords>${this.info.Keywords}</pdf:Keywords>`, false);
                  }
                  this.appendXML(`
        </rdf:Description>
        `);
                },
                endMetadata() {
                  this._addInfo();
                  this.metadata.end();
                  if (this.version != 1.3) {
                    this.metadataRef = this.ref({
                      length: this.metadata.getLength(),
                      Type: "Metadata",
                      Subtype: "XML"
                    });
                    this.metadataRef.compress = false;
                    this.metadataRef.write(Buffer.from(this.metadata.getXML(), "utf-8"));
                    this.metadataRef.end();
                    this._root.data.Metadata = this.metadataRef;
                  }
                }
              };
              class PDFDocument extends _stream.default.Readable {
                constructor() {
                  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  super(options);
                  this.options = options;
                  switch (options.pdfVersion) {
                    case "1.4":
                      this.version = 1.4;
                      break;
                    case "1.5":
                      this.version = 1.5;
                      break;
                    case "1.6":
                      this.version = 1.6;
                      break;
                    case "1.7":
                    case "1.7ext3":
                      this.version = 1.7;
                      break;
                    default:
                      this.version = 1.3;
                      break;
                  }
                  this.compress = this.options.compress != null ? this.options.compress : true;
                  this._pageBuffer = [];
                  this._pageBufferStart = 0;
                  this._offsets = [];
                  this._waiting = 0;
                  this._ended = false;
                  this._offset = 0;
                  const Pages = this.ref({
                    Type: "Pages",
                    Count: 0,
                    Kids: []
                  });
                  const Names = this.ref({
                    Dests: new PDFNameTree()
                  });
                  this._root = this.ref({
                    Type: "Catalog",
                    Pages,
                    Names
                  });
                  if (this.options.lang) {
                    this._root.data.Lang = new String(this.options.lang);
                  }
                  this.page = null;
                  this.initMetadata();
                  this.initColor();
                  this.initVector();
                  this.initFonts(options.font);
                  this.initText();
                  this.initImages();
                  this.initOutline();
                  this.initMarkings(options);
                  this.initTables();
                  this.initSubset(options);
                  this.info = {
                    Producer: "PDFKit",
                    Creator: "PDFKit",
                    CreationDate: /* @__PURE__ */ new Date()
                  };
                  if (this.options.info) {
                    for (let key in this.options.info) {
                      const val = this.options.info[key];
                      this.info[key] = val;
                    }
                  }
                  if (this.options.displayTitle) {
                    this._root.data.ViewerPreferences = this.ref({
                      DisplayDocTitle: true
                    });
                  }
                  this._id = PDFSecurity.generateFileID(this.info);
                  this._security = PDFSecurity.create(this, options);
                  this._write(`%PDF-${this.version}`);
                  this._write("%");
                  if (this.options.autoFirstPage !== false) {
                    this.addPage();
                  }
                }
                addPage(options) {
                  if (options == null) {
                    ({
                      options
                    } = this);
                  }
                  if (!this.options.bufferPages) {
                    this.flushPages();
                  }
                  this.page = new PDFPage(this, options);
                  this._pageBuffer.push(this.page);
                  const pages = this._root.data.Pages.data;
                  pages.Kids.push(this.page.dictionary);
                  pages.Count++;
                  this.x = this.page.margins.left;
                  this.y = this.page.margins.top;
                  this._ctm = [1, 0, 0, 1, 0, 0];
                  this.transform(1, 0, 0, -1, 0, this.page.height);
                  this.emit("pageAdded");
                  return this;
                }
                continueOnNewPage(options) {
                  const pageMarkings = this.endPageMarkings(this.page);
                  this.addPage(options ?? this.page._options);
                  this.initPageMarkings(pageMarkings);
                  return this;
                }
                bufferedPageRange() {
                  return {
                    start: this._pageBufferStart,
                    count: this._pageBuffer.length
                  };
                }
                switchToPage(n) {
                  let page;
                  if (!(page = this._pageBuffer[n - this._pageBufferStart])) {
                    throw new Error(`switchToPage(${n}) out of bounds, current buffer covers pages ${this._pageBufferStart} to ${this._pageBufferStart + this._pageBuffer.length - 1}`);
                  }
                  return this.page = page;
                }
                flushPages() {
                  const pages = this._pageBuffer;
                  this._pageBuffer = [];
                  this._pageBufferStart += pages.length;
                  for (let page of pages) {
                    this.endPageMarkings(page);
                    page.end();
                  }
                }
                addNamedDestination(name) {
                  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                  }
                  if (args.length === 0) {
                    args = ["XYZ", null, null, null];
                  }
                  if (args[0] === "XYZ" && args[2] !== null) {
                    args[2] = this.page.height - args[2];
                  }
                  args.unshift(this.page.dictionary);
                  this._root.data.Names.data.Dests.add(name, args);
                }
                addNamedEmbeddedFile(name, ref) {
                  if (!this._root.data.Names.data.EmbeddedFiles) {
                    this._root.data.Names.data.EmbeddedFiles = new PDFNameTree({
                      limits: false
                    });
                  }
                  this._root.data.Names.data.EmbeddedFiles.add(name, ref);
                }
                addNamedJavaScript(name, js) {
                  if (!this._root.data.Names.data.JavaScript) {
                    this._root.data.Names.data.JavaScript = new PDFNameTree();
                  }
                  let data = {
                    JS: new String(js),
                    S: "JavaScript"
                  };
                  this._root.data.Names.data.JavaScript.add(name, data);
                }
                ref(data) {
                  const ref = new PDFReference(this, this._offsets.length + 1, data);
                  this._offsets.push(null);
                  this._waiting++;
                  return ref;
                }
                _read() {
                }
                _write(data) {
                  if (!Buffer.isBuffer(data)) {
                    data = Buffer.from(data + "\n", "binary");
                  }
                  this.push(data);
                  this._offset += data.length;
                }
                addContent(data) {
                  this.page.write(data);
                  return this;
                }
                _refEnd(ref) {
                  this._offsets[ref.id - 1] = ref.offset;
                  if (--this._waiting === 0 && this._ended) {
                    this._finalize();
                    this._ended = false;
                  }
                }
                end() {
                  this.flushPages();
                  this._info = this.ref();
                  for (let key in this.info) {
                    let val = this.info[key];
                    if (typeof val === "string") {
                      val = new String(val);
                    }
                    let entry = this.ref(val);
                    entry.end();
                    this._info.data[key] = entry;
                  }
                  this._info.end();
                  for (let name in this._fontFamilies) {
                    const font = this._fontFamilies[name];
                    font.finalize();
                  }
                  this.endOutline();
                  this.endMarkings();
                  if (this.subset) {
                    this.endSubset();
                  }
                  this.endMetadata();
                  this._root.end();
                  this._root.data.Pages.end();
                  this._root.data.Names.end();
                  this.endAcroForm();
                  if (this._root.data.ViewerPreferences) {
                    this._root.data.ViewerPreferences.end();
                  }
                  if (this._security) {
                    this._security.end();
                  }
                  if (this._waiting === 0) {
                    this._finalize();
                  } else {
                    this._ended = true;
                  }
                }
                _finalize() {
                  const xRefOffset = this._offset;
                  this._write("xref");
                  this._write(`0 ${this._offsets.length + 1}`);
                  this._write("0000000000 65535 f ");
                  for (let offset of this._offsets) {
                    offset = `0000000000${offset}`.slice(-10);
                    this._write(offset + " 00000 n ");
                  }
                  const trailer = {
                    Size: this._offsets.length + 1,
                    Root: this._root,
                    Info: this._info,
                    ID: [this._id, this._id]
                  };
                  if (this._security) {
                    trailer.Encrypt = this._security.dictionary;
                  }
                  this._write("trailer");
                  this._write(PDFObject.convert(trailer));
                  this._write("startxref");
                  this._write(`${xRefOffset}`);
                  this._write("%%EOF");
                  this.push(null);
                }
                toString() {
                  return "[object PDFDocument]";
                }
              }
              exports2.A = PDFDocument;
              const mixin = (methods) => {
                Object.assign(PDFDocument.prototype, methods);
              };
              mixin(MetadataMixin);
              mixin(ColorMixin);
              mixin(VectorMixin);
              mixin(FontsMixin);
              mixin(TextMixin);
              mixin(ImagesMixin);
              mixin(AnnotationsMixin);
              mixin(OutlineMixin);
              mixin(MarkingsMixin);
              mixin(AcroFormMixin);
              mixin(AttachmentsMixin);
              mixin(SubsetMixin);
              mixin(TableMixin);
              PDFDocument.LineWrapper = LineWrapper;
            },
            /***/
            3249(module2) {
              "use strict";
              var numberIsNaN = function(value) {
                return value !== value;
              };
              module2.exports = function is(a, b) {
                if (a === 0 && b === 0) {
                  return 1 / a === 1 / b;
                }
                if (a === b) {
                  return true;
                }
                if (numberIsNaN(a) && numberIsNaN(b)) {
                  return true;
                }
                return false;
              };
            },
            /***/
            3257(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var origSymbol = typeof Symbol !== "undefined" && Symbol;
              var hasSymbolSham = __webpack_require__2(2843);
              module2.exports = function hasNativeSymbols() {
                if (typeof origSymbol !== "function") {
                  return false;
                }
                if (typeof Symbol !== "function") {
                  return false;
                }
                if (typeof origSymbol("foo") !== "symbol") {
                  return false;
                }
                if (typeof Symbol("bar") !== "symbol") {
                  return false;
                }
                return hasSymbolSham();
              };
            },
            /***/
            3282(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(2858));
                } else {
                }
              })(void 0, function(CryptoJS) {
                CryptoJS.pad.Iso97971 = {
                  pad: function(data, blockSize) {
                    data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
                    CryptoJS.pad.ZeroPadding.pad(data, blockSize);
                  },
                  unpad: function(data) {
                    CryptoJS.pad.ZeroPadding.unpad(data);
                    data.sigBytes--;
                  }
                };
                return CryptoJS.pad.Iso97971;
              });
            },
            /***/
            3297(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var requireObjectCoercible = __webpack_require__2(5034);
              var $Object = Object;
              module2.exports = function(argument) {
                return $Object(requireObjectCoercible(argument));
              };
            },
            /***/
            3301(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var call = __webpack_require__2(8993);
              var isObject = __webpack_require__2(3598);
              var isSymbol = __webpack_require__2(5985);
              var getMethod = __webpack_require__2(9738);
              var ordinaryToPrimitive = __webpack_require__2(290);
              var wellKnownSymbol = __webpack_require__2(8663);
              var $TypeError = TypeError;
              var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
              module2.exports = function(input, pref) {
                if (!isObject(input) || isSymbol(input)) return input;
                var exoticToPrim = getMethod(input, TO_PRIMITIVE);
                var result;
                if (exoticToPrim) {
                  if (pref === void 0) pref = "default";
                  result = call(exoticToPrim, input, pref);
                  if (!isObject(result) || isSymbol(result)) return result;
                  throw new $TypeError("Can't convert object to primitive value");
                }
                if (pref === void 0) pref = "number";
                return ordinaryToPrimitive(input, pref);
              };
            },
            /***/
            3324(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(4866), __webpack_require__2(3532), __webpack_require__2(6818), __webpack_require__2(2858));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function() {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var WordArray = C_lib.WordArray;
                  var BlockCipher = C_lib.BlockCipher;
                  var C_algo = C.algo;
                  var PC1 = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4];
                  var PC2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32];
                  var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
                  var SBOX_P = [{
                    0: 8421888,
                    268435456: 32768,
                    536870912: 8421378,
                    805306368: 2,
                    1073741824: 512,
                    1342177280: 8421890,
                    1610612736: 8389122,
                    1879048192: 8388608,
                    2147483648: 514,
                    2415919104: 8389120,
                    2684354560: 33280,
                    2952790016: 8421376,
                    3221225472: 32770,
                    3489660928: 8388610,
                    3758096384: 0,
                    4026531840: 33282,
                    134217728: 0,
                    402653184: 8421890,
                    671088640: 33282,
                    939524096: 32768,
                    1207959552: 8421888,
                    1476395008: 512,
                    1744830464: 8421378,
                    2013265920: 2,
                    2281701376: 8389120,
                    2550136832: 33280,
                    2818572288: 8421376,
                    3087007744: 8389122,
                    3355443200: 8388610,
                    3623878656: 32770,
                    3892314112: 514,
                    4160749568: 8388608,
                    1: 32768,
                    268435457: 2,
                    536870913: 8421888,
                    805306369: 8388608,
                    1073741825: 8421378,
                    1342177281: 33280,
                    1610612737: 512,
                    1879048193: 8389122,
                    2147483649: 8421890,
                    2415919105: 8421376,
                    2684354561: 8388610,
                    2952790017: 33282,
                    3221225473: 514,
                    3489660929: 8389120,
                    3758096385: 32770,
                    4026531841: 0,
                    134217729: 8421890,
                    402653185: 8421376,
                    671088641: 8388608,
                    939524097: 512,
                    1207959553: 32768,
                    1476395009: 8388610,
                    1744830465: 2,
                    2013265921: 33282,
                    2281701377: 32770,
                    2550136833: 8389122,
                    2818572289: 514,
                    3087007745: 8421888,
                    3355443201: 8389120,
                    3623878657: 0,
                    3892314113: 33280,
                    4160749569: 8421378
                  }, {
                    0: 1074282512,
                    16777216: 16384,
                    33554432: 524288,
                    50331648: 1074266128,
                    67108864: 1073741840,
                    83886080: 1074282496,
                    100663296: 1073758208,
                    117440512: 16,
                    134217728: 540672,
                    150994944: 1073758224,
                    167772160: 1073741824,
                    184549376: 540688,
                    201326592: 524304,
                    218103808: 0,
                    234881024: 16400,
                    251658240: 1074266112,
                    8388608: 1073758208,
                    25165824: 540688,
                    41943040: 16,
                    58720256: 1073758224,
                    75497472: 1074282512,
                    92274688: 1073741824,
                    109051904: 524288,
                    125829120: 1074266128,
                    142606336: 524304,
                    159383552: 0,
                    176160768: 16384,
                    192937984: 1074266112,
                    209715200: 1073741840,
                    226492416: 540672,
                    243269632: 1074282496,
                    260046848: 16400,
                    268435456: 0,
                    285212672: 1074266128,
                    301989888: 1073758224,
                    318767104: 1074282496,
                    335544320: 1074266112,
                    352321536: 16,
                    369098752: 540688,
                    385875968: 16384,
                    402653184: 16400,
                    419430400: 524288,
                    436207616: 524304,
                    452984832: 1073741840,
                    469762048: 540672,
                    486539264: 1073758208,
                    503316480: 1073741824,
                    520093696: 1074282512,
                    276824064: 540688,
                    293601280: 524288,
                    310378496: 1074266112,
                    327155712: 16384,
                    343932928: 1073758208,
                    360710144: 1074282512,
                    377487360: 16,
                    394264576: 1073741824,
                    411041792: 1074282496,
                    427819008: 1073741840,
                    444596224: 1073758224,
                    461373440: 524304,
                    478150656: 0,
                    494927872: 16400,
                    511705088: 1074266128,
                    528482304: 540672
                  }, {
                    0: 260,
                    1048576: 0,
                    2097152: 67109120,
                    3145728: 65796,
                    4194304: 65540,
                    5242880: 67108868,
                    6291456: 67174660,
                    7340032: 67174400,
                    8388608: 67108864,
                    9437184: 67174656,
                    10485760: 65792,
                    11534336: 67174404,
                    12582912: 67109124,
                    13631488: 65536,
                    14680064: 4,
                    15728640: 256,
                    524288: 67174656,
                    1572864: 67174404,
                    2621440: 0,
                    3670016: 67109120,
                    4718592: 67108868,
                    5767168: 65536,
                    6815744: 65540,
                    7864320: 260,
                    8912896: 4,
                    9961472: 256,
                    11010048: 67174400,
                    12058624: 65796,
                    13107200: 65792,
                    14155776: 67109124,
                    15204352: 67174660,
                    16252928: 67108864,
                    16777216: 67174656,
                    17825792: 65540,
                    18874368: 65536,
                    19922944: 67109120,
                    20971520: 256,
                    22020096: 67174660,
                    23068672: 67108868,
                    24117248: 0,
                    25165824: 67109124,
                    26214400: 67108864,
                    27262976: 4,
                    28311552: 65792,
                    29360128: 67174400,
                    30408704: 260,
                    31457280: 65796,
                    32505856: 67174404,
                    17301504: 67108864,
                    18350080: 260,
                    19398656: 67174656,
                    20447232: 0,
                    21495808: 65540,
                    22544384: 67109120,
                    23592960: 256,
                    24641536: 67174404,
                    25690112: 65536,
                    26738688: 67174660,
                    27787264: 65796,
                    28835840: 67108868,
                    29884416: 67109124,
                    30932992: 67174400,
                    31981568: 4,
                    33030144: 65792
                  }, {
                    0: 2151682048,
                    65536: 2147487808,
                    131072: 4198464,
                    196608: 2151677952,
                    262144: 0,
                    327680: 4198400,
                    393216: 2147483712,
                    458752: 4194368,
                    524288: 2147483648,
                    589824: 4194304,
                    655360: 64,
                    720896: 2147487744,
                    786432: 2151678016,
                    851968: 4160,
                    917504: 4096,
                    983040: 2151682112,
                    32768: 2147487808,
                    98304: 64,
                    163840: 2151678016,
                    229376: 2147487744,
                    294912: 4198400,
                    360448: 2151682112,
                    425984: 0,
                    491520: 2151677952,
                    557056: 4096,
                    622592: 2151682048,
                    688128: 4194304,
                    753664: 4160,
                    819200: 2147483648,
                    884736: 4194368,
                    950272: 4198464,
                    1015808: 2147483712,
                    1048576: 4194368,
                    1114112: 4198400,
                    1179648: 2147483712,
                    1245184: 0,
                    1310720: 4160,
                    1376256: 2151678016,
                    1441792: 2151682048,
                    1507328: 2147487808,
                    1572864: 2151682112,
                    1638400: 2147483648,
                    1703936: 2151677952,
                    1769472: 4198464,
                    1835008: 2147487744,
                    1900544: 4194304,
                    1966080: 64,
                    2031616: 4096,
                    1081344: 2151677952,
                    1146880: 2151682112,
                    1212416: 0,
                    1277952: 4198400,
                    1343488: 4194368,
                    1409024: 2147483648,
                    1474560: 2147487808,
                    1540096: 64,
                    1605632: 2147483712,
                    1671168: 4096,
                    1736704: 2147487744,
                    1802240: 2151678016,
                    1867776: 4160,
                    1933312: 2151682048,
                    1998848: 4194304,
                    2064384: 4198464
                  }, {
                    0: 128,
                    4096: 17039360,
                    8192: 262144,
                    12288: 536870912,
                    16384: 537133184,
                    20480: 16777344,
                    24576: 553648256,
                    28672: 262272,
                    32768: 16777216,
                    36864: 537133056,
                    40960: 536871040,
                    45056: 553910400,
                    49152: 553910272,
                    53248: 0,
                    57344: 17039488,
                    61440: 553648128,
                    2048: 17039488,
                    6144: 553648256,
                    10240: 128,
                    14336: 17039360,
                    18432: 262144,
                    22528: 537133184,
                    26624: 553910272,
                    30720: 536870912,
                    34816: 537133056,
                    38912: 0,
                    43008: 553910400,
                    47104: 16777344,
                    51200: 536871040,
                    55296: 553648128,
                    59392: 16777216,
                    63488: 262272,
                    65536: 262144,
                    69632: 128,
                    73728: 536870912,
                    77824: 553648256,
                    81920: 16777344,
                    86016: 553910272,
                    90112: 537133184,
                    94208: 16777216,
                    98304: 553910400,
                    102400: 553648128,
                    106496: 17039360,
                    110592: 537133056,
                    114688: 262272,
                    118784: 536871040,
                    122880: 0,
                    126976: 17039488,
                    67584: 553648256,
                    71680: 16777216,
                    75776: 17039360,
                    79872: 537133184,
                    83968: 536870912,
                    88064: 17039488,
                    92160: 128,
                    96256: 553910272,
                    100352: 262272,
                    104448: 553910400,
                    108544: 0,
                    112640: 553648128,
                    116736: 16777344,
                    120832: 262144,
                    124928: 537133056,
                    129024: 536871040
                  }, {
                    0: 268435464,
                    256: 8192,
                    512: 270532608,
                    768: 270540808,
                    1024: 268443648,
                    1280: 2097152,
                    1536: 2097160,
                    1792: 268435456,
                    2048: 0,
                    2304: 268443656,
                    2560: 2105344,
                    2816: 8,
                    3072: 270532616,
                    3328: 2105352,
                    3584: 8200,
                    3840: 270540800,
                    128: 270532608,
                    384: 270540808,
                    640: 8,
                    896: 2097152,
                    1152: 2105352,
                    1408: 268435464,
                    1664: 268443648,
                    1920: 8200,
                    2176: 2097160,
                    2432: 8192,
                    2688: 268443656,
                    2944: 270532616,
                    3200: 0,
                    3456: 270540800,
                    3712: 2105344,
                    3968: 268435456,
                    4096: 268443648,
                    4352: 270532616,
                    4608: 270540808,
                    4864: 8200,
                    5120: 2097152,
                    5376: 268435456,
                    5632: 268435464,
                    5888: 2105344,
                    6144: 2105352,
                    6400: 0,
                    6656: 8,
                    6912: 270532608,
                    7168: 8192,
                    7424: 268443656,
                    7680: 270540800,
                    7936: 2097160,
                    4224: 8,
                    4480: 2105344,
                    4736: 2097152,
                    4992: 268435464,
                    5248: 268443648,
                    5504: 8200,
                    5760: 270540808,
                    6016: 270532608,
                    6272: 270540800,
                    6528: 270532616,
                    6784: 8192,
                    7040: 2105352,
                    7296: 2097160,
                    7552: 0,
                    7808: 268435456,
                    8064: 268443656
                  }, {
                    0: 1048576,
                    16: 33555457,
                    32: 1024,
                    48: 1049601,
                    64: 34604033,
                    80: 0,
                    96: 1,
                    112: 34603009,
                    128: 33555456,
                    144: 1048577,
                    160: 33554433,
                    176: 34604032,
                    192: 34603008,
                    208: 1025,
                    224: 1049600,
                    240: 33554432,
                    8: 34603009,
                    24: 0,
                    40: 33555457,
                    56: 34604032,
                    72: 1048576,
                    88: 33554433,
                    104: 33554432,
                    120: 1025,
                    136: 1049601,
                    152: 33555456,
                    168: 34603008,
                    184: 1048577,
                    200: 1024,
                    216: 34604033,
                    232: 1,
                    248: 1049600,
                    256: 33554432,
                    272: 1048576,
                    288: 33555457,
                    304: 34603009,
                    320: 1048577,
                    336: 33555456,
                    352: 34604032,
                    368: 1049601,
                    384: 1025,
                    400: 34604033,
                    416: 1049600,
                    432: 1,
                    448: 0,
                    464: 34603008,
                    480: 33554433,
                    496: 1024,
                    264: 1049600,
                    280: 33555457,
                    296: 34603009,
                    312: 1,
                    328: 33554432,
                    344: 1048576,
                    360: 1025,
                    376: 34604032,
                    392: 33554433,
                    408: 34603008,
                    424: 0,
                    440: 34604033,
                    456: 1049601,
                    472: 1024,
                    488: 33555456,
                    504: 1048577
                  }, {
                    0: 134219808,
                    1: 131072,
                    2: 134217728,
                    3: 32,
                    4: 131104,
                    5: 134350880,
                    6: 134350848,
                    7: 2048,
                    8: 134348800,
                    9: 134219776,
                    10: 133120,
                    11: 134348832,
                    12: 2080,
                    13: 0,
                    14: 134217760,
                    15: 133152,
                    2147483648: 2048,
                    2147483649: 134350880,
                    2147483650: 134219808,
                    2147483651: 134217728,
                    2147483652: 134348800,
                    2147483653: 133120,
                    2147483654: 133152,
                    2147483655: 32,
                    2147483656: 134217760,
                    2147483657: 2080,
                    2147483658: 131104,
                    2147483659: 134350848,
                    2147483660: 0,
                    2147483661: 134348832,
                    2147483662: 134219776,
                    2147483663: 131072,
                    16: 133152,
                    17: 134350848,
                    18: 32,
                    19: 2048,
                    20: 134219776,
                    21: 134217760,
                    22: 134348832,
                    23: 131072,
                    24: 0,
                    25: 131104,
                    26: 134348800,
                    27: 134219808,
                    28: 134350880,
                    29: 133120,
                    30: 2080,
                    31: 134217728,
                    2147483664: 131072,
                    2147483665: 2048,
                    2147483666: 134348832,
                    2147483667: 133152,
                    2147483668: 32,
                    2147483669: 134348800,
                    2147483670: 134217728,
                    2147483671: 134219808,
                    2147483672: 134350880,
                    2147483673: 134217760,
                    2147483674: 134219776,
                    2147483675: 0,
                    2147483676: 133120,
                    2147483677: 2080,
                    2147483678: 131104,
                    2147483679: 134350848
                  }];
                  var SBOX_MASK = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679];
                  var DES = C_algo.DES = BlockCipher.extend({
                    _doReset: function() {
                      var key = this._key;
                      var keyWords = key.words;
                      var keyBits = [];
                      for (var i = 0; i < 56; i++) {
                        var keyBitPos = PC1[i] - 1;
                        keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
                      }
                      var subKeys = this._subKeys = [];
                      for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
                        var subKey = subKeys[nSubKey] = [];
                        var bitShift = BIT_SHIFTS[nSubKey];
                        for (var i = 0; i < 24; i++) {
                          subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                          subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
                        }
                        subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
                        for (var i = 1; i < 7; i++) {
                          subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
                        }
                        subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
                      }
                      var invSubKeys = this._invSubKeys = [];
                      for (var i = 0; i < 16; i++) {
                        invSubKeys[i] = subKeys[15 - i];
                      }
                    },
                    encryptBlock: function(M, offset) {
                      this._doCryptBlock(M, offset, this._subKeys);
                    },
                    decryptBlock: function(M, offset) {
                      this._doCryptBlock(M, offset, this._invSubKeys);
                    },
                    _doCryptBlock: function(M, offset, subKeys) {
                      this._lBlock = M[offset];
                      this._rBlock = M[offset + 1];
                      exchangeLR.call(this, 4, 252645135);
                      exchangeLR.call(this, 16, 65535);
                      exchangeRL.call(this, 2, 858993459);
                      exchangeRL.call(this, 8, 16711935);
                      exchangeLR.call(this, 1, 1431655765);
                      for (var round = 0; round < 16; round++) {
                        var subKey = subKeys[round];
                        var lBlock = this._lBlock;
                        var rBlock = this._rBlock;
                        var f = 0;
                        for (var i = 0; i < 8; i++) {
                          f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
                        }
                        this._lBlock = rBlock;
                        this._rBlock = lBlock ^ f;
                      }
                      var t = this._lBlock;
                      this._lBlock = this._rBlock;
                      this._rBlock = t;
                      exchangeLR.call(this, 1, 1431655765);
                      exchangeRL.call(this, 8, 16711935);
                      exchangeRL.call(this, 2, 858993459);
                      exchangeLR.call(this, 16, 65535);
                      exchangeLR.call(this, 4, 252645135);
                      M[offset] = this._lBlock;
                      M[offset + 1] = this._rBlock;
                    },
                    keySize: 64 / 32,
                    ivSize: 64 / 32,
                    blockSize: 64 / 32
                  });
                  function exchangeLR(offset, mask) {
                    var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
                    this._rBlock ^= t;
                    this._lBlock ^= t << offset;
                  }
                  function exchangeRL(offset, mask) {
                    var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
                    this._lBlock ^= t;
                    this._rBlock ^= t << offset;
                  }
                  C.DES = BlockCipher._createHelper(DES);
                  var TripleDES = C_algo.TripleDES = BlockCipher.extend({
                    _doReset: function() {
                      var key = this._key;
                      var keyWords = key.words;
                      if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
                        throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
                      }
                      var key1 = keyWords.slice(0, 2);
                      var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
                      var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
                      this._des1 = DES.createEncryptor(WordArray.create(key1));
                      this._des2 = DES.createEncryptor(WordArray.create(key2));
                      this._des3 = DES.createEncryptor(WordArray.create(key3));
                    },
                    encryptBlock: function(M, offset) {
                      this._des1.encryptBlock(M, offset);
                      this._des2.decryptBlock(M, offset);
                      this._des3.encryptBlock(M, offset);
                    },
                    decryptBlock: function(M, offset) {
                      this._des3.decryptBlock(M, offset);
                      this._des2.encryptBlock(M, offset);
                      this._des1.decryptBlock(M, offset);
                    },
                    keySize: 192 / 32,
                    ivSize: 64 / 32,
                    blockSize: 64 / 32
                  });
                  C.TripleDES = BlockCipher._createHelper(TripleDES);
                })();
                return CryptoJS.TripleDES;
              });
            },
            /***/
            3381(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var forEach = __webpack_require__2(8404);
              var availableTypedArrays = __webpack_require__2(821);
              var callBind = __webpack_require__2(6601);
              var callBound = __webpack_require__2(2774);
              var gOPD = __webpack_require__2(8109);
              var getProto = __webpack_require__2(7106);
              var $toString = callBound("Object.prototype.toString");
              var hasToStringTag = __webpack_require__2(6626)();
              var g = typeof globalThis === "undefined" ? __webpack_require__2.g : globalThis;
              var typedArrays = availableTypedArrays();
              var $slice = callBound("String.prototype.slice");
              var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
                for (var i = 0; i < array.length; i += 1) {
                  if (array[i] === value) {
                    return i;
                  }
                }
                return -1;
              };
              var cache = { __proto__: null };
              if (hasToStringTag && gOPD && getProto) {
                forEach(typedArrays, function(typedArray) {
                  var arr = new g[typedArray]();
                  if (Symbol.toStringTag in arr && getProto) {
                    var proto = getProto(arr);
                    var descriptor = gOPD(proto, Symbol.toStringTag);
                    if (!descriptor && proto) {
                      var superProto = getProto(proto);
                      descriptor = gOPD(superProto, Symbol.toStringTag);
                    }
                    if (descriptor && descriptor.get) {
                      var bound = callBind(descriptor.get);
                      cache[
                        /** @type {`$${import('.').TypedArrayName}`} */
                        "$" + typedArray
                      ] = bound;
                    }
                  }
                });
              } else {
                forEach(typedArrays, function(typedArray) {
                  var arr = new g[typedArray]();
                  var fn = arr.slice || arr.set;
                  if (fn) {
                    var bound = (
                      /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
                      // @ts-expect-error TODO FIXME
                      callBind(fn)
                    );
                    cache[
                      /** @type {`$${import('.').TypedArrayName}`} */
                      "$" + typedArray
                    ] = bound;
                  }
                });
              }
              var tryTypedArrays = function tryAllTypedArrays(value) {
                var found = false;
                forEach(
                  /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
                  cache,
                  /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
                  function(getter, typedArray) {
                    if (!found) {
                      try {
                        if ("$" + getter(value) === typedArray) {
                          found = /** @type {import('.').TypedArrayName} */
                          $slice(typedArray, 1);
                        }
                      } catch (e) {
                      }
                    }
                  }
                );
                return found;
              };
              var trySlices = function tryAllSlices(value) {
                var found = false;
                forEach(
                  /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
                  cache,
                  /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
                  function(getter, name) {
                    if (!found) {
                      try {
                        getter(value);
                        found = /** @type {import('.').TypedArrayName} */
                        $slice(name, 1);
                      } catch (e) {
                      }
                    }
                  }
                );
                return found;
              };
              module2.exports = function whichTypedArray(value) {
                if (!value || typeof value !== "object") {
                  return false;
                }
                if (!hasToStringTag) {
                  var tag = $slice($toString(value), 8, -1);
                  if ($indexOf(typedArrays, tag) > -1) {
                    return tag;
                  }
                  if (tag !== "Object") {
                    return false;
                  }
                  return trySlices(value);
                }
                if (!gOPD) {
                  return null;
                }
                return tryTypedArrays(value);
              };
            },
            /***/
            3383(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var uncurryThis = __webpack_require__2(1212);
              var fails = __webpack_require__2(299);
              var isCallable = __webpack_require__2(8681);
              var hasOwn = __webpack_require__2(6341);
              var DESCRIPTORS = __webpack_require__2(5144);
              var CONFIGURABLE_FUNCTION_NAME = __webpack_require__2(4378).CONFIGURABLE;
              var inspectSource = __webpack_require__2(4550);
              var InternalStateModule = __webpack_require__2(6921);
              var enforceInternalState = InternalStateModule.enforce;
              var getInternalState = InternalStateModule.get;
              var $String = String;
              var defineProperty = Object.defineProperty;
              var stringSlice = uncurryThis("".slice);
              var replace = uncurryThis("".replace);
              var join = uncurryThis([].join);
              var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
                return defineProperty(function() {
                }, "length", { value: 8 }).length !== 8;
              });
              var TEMPLATE = String(String).split("String");
              var makeBuiltIn = module2.exports = function(value, name, options) {
                if (stringSlice($String(name), 0, 7) === "Symbol(") {
                  name = "[" + replace($String(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
                }
                if (options && options.getter) name = "get " + name;
                if (options && options.setter) name = "set " + name;
                if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
                  if (DESCRIPTORS) defineProperty(value, "name", { value: name, configurable: true });
                  else value.name = name;
                }
                if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
                  defineProperty(value, "length", { value: options.arity });
                }
                try {
                  if (options && hasOwn(options, "constructor") && options.constructor) {
                    if (DESCRIPTORS) defineProperty(value, "prototype", { writable: false });
                  } else if (value.prototype) value.prototype = void 0;
                } catch (error) {
                }
                var state = enforceInternalState(value);
                if (!hasOwn(state, "source")) {
                  state.source = join(TEMPLATE, typeof name == "string" ? name : "");
                }
                return value;
              };
              Function.prototype.toString = makeBuiltIn(function toString() {
                return isCallable(this) && getInternalState(this).source || inspectSource(this);
              }, "toString");
            },
            /***/
            3483(module2) {
              var TINF_OK = 0;
              var TINF_DATA_ERROR = -3;
              function Tree() {
                this.table = new Uint16Array(16);
                this.trans = new Uint16Array(288);
              }
              function Data(source, dest) {
                this.source = source;
                this.sourceIndex = 0;
                this.tag = 0;
                this.bitcount = 0;
                this.dest = dest;
                this.destLen = 0;
                this.ltree = new Tree();
                this.dtree = new Tree();
              }
              var sltree = new Tree();
              var sdtree = new Tree();
              var length_bits = new Uint8Array(30);
              var length_base = new Uint16Array(30);
              var dist_bits = new Uint8Array(30);
              var dist_base = new Uint16Array(30);
              var clcidx = new Uint8Array([
                16,
                17,
                18,
                0,
                8,
                7,
                9,
                6,
                10,
                5,
                11,
                4,
                12,
                3,
                13,
                2,
                14,
                1,
                15
              ]);
              var code_tree = new Tree();
              var lengths = new Uint8Array(288 + 32);
              function tinf_build_bits_base(bits, base, delta, first) {
                var i, sum;
                for (i = 0; i < delta; ++i) bits[i] = 0;
                for (i = 0; i < 30 - delta; ++i) bits[i + delta] = i / delta | 0;
                for (sum = first, i = 0; i < 30; ++i) {
                  base[i] = sum;
                  sum += 1 << bits[i];
                }
              }
              function tinf_build_fixed_trees(lt, dt) {
                var i;
                for (i = 0; i < 7; ++i) lt.table[i] = 0;
                lt.table[7] = 24;
                lt.table[8] = 152;
                lt.table[9] = 112;
                for (i = 0; i < 24; ++i) lt.trans[i] = 256 + i;
                for (i = 0; i < 144; ++i) lt.trans[24 + i] = i;
                for (i = 0; i < 8; ++i) lt.trans[24 + 144 + i] = 280 + i;
                for (i = 0; i < 112; ++i) lt.trans[24 + 144 + 8 + i] = 144 + i;
                for (i = 0; i < 5; ++i) dt.table[i] = 0;
                dt.table[5] = 32;
                for (i = 0; i < 32; ++i) dt.trans[i] = i;
              }
              var offs = new Uint16Array(16);
              function tinf_build_tree(t, lengths2, off, num) {
                var i, sum;
                for (i = 0; i < 16; ++i) t.table[i] = 0;
                for (i = 0; i < num; ++i) t.table[lengths2[off + i]]++;
                t.table[0] = 0;
                for (sum = 0, i = 0; i < 16; ++i) {
                  offs[i] = sum;
                  sum += t.table[i];
                }
                for (i = 0; i < num; ++i) {
                  if (lengths2[off + i]) t.trans[offs[lengths2[off + i]]++] = i;
                }
              }
              function tinf_getbit(d) {
                if (!d.bitcount--) {
                  d.tag = d.source[d.sourceIndex++];
                  d.bitcount = 7;
                }
                var bit = d.tag & 1;
                d.tag >>>= 1;
                return bit;
              }
              function tinf_read_bits(d, num, base) {
                if (!num)
                  return base;
                while (d.bitcount < 24) {
                  d.tag |= d.source[d.sourceIndex++] << d.bitcount;
                  d.bitcount += 8;
                }
                var val = d.tag & 65535 >>> 16 - num;
                d.tag >>>= num;
                d.bitcount -= num;
                return val + base;
              }
              function tinf_decode_symbol(d, t) {
                while (d.bitcount < 24) {
                  d.tag |= d.source[d.sourceIndex++] << d.bitcount;
                  d.bitcount += 8;
                }
                var sum = 0, cur = 0, len = 0;
                var tag = d.tag;
                do {
                  cur = 2 * cur + (tag & 1);
                  tag >>>= 1;
                  ++len;
                  sum += t.table[len];
                  cur -= t.table[len];
                } while (cur >= 0);
                d.tag = tag;
                d.bitcount -= len;
                return t.trans[sum + cur];
              }
              function tinf_decode_trees(d, lt, dt) {
                var hlit, hdist, hclen;
                var i, num, length;
                hlit = tinf_read_bits(d, 5, 257);
                hdist = tinf_read_bits(d, 5, 1);
                hclen = tinf_read_bits(d, 4, 4);
                for (i = 0; i < 19; ++i) lengths[i] = 0;
                for (i = 0; i < hclen; ++i) {
                  var clen = tinf_read_bits(d, 3, 0);
                  lengths[clcidx[i]] = clen;
                }
                tinf_build_tree(code_tree, lengths, 0, 19);
                for (num = 0; num < hlit + hdist; ) {
                  var sym = tinf_decode_symbol(d, code_tree);
                  switch (sym) {
                    case 16:
                      var prev = lengths[num - 1];
                      for (length = tinf_read_bits(d, 2, 3); length; --length) {
                        lengths[num++] = prev;
                      }
                      break;
                    case 17:
                      for (length = tinf_read_bits(d, 3, 3); length; --length) {
                        lengths[num++] = 0;
                      }
                      break;
                    case 18:
                      for (length = tinf_read_bits(d, 7, 11); length; --length) {
                        lengths[num++] = 0;
                      }
                      break;
                    default:
                      lengths[num++] = sym;
                      break;
                  }
                }
                tinf_build_tree(lt, lengths, 0, hlit);
                tinf_build_tree(dt, lengths, hlit, hdist);
              }
              function tinf_inflate_block_data(d, lt, dt) {
                while (1) {
                  var sym = tinf_decode_symbol(d, lt);
                  if (sym === 256) {
                    return TINF_OK;
                  }
                  if (sym < 256) {
                    d.dest[d.destLen++] = sym;
                  } else {
                    var length, dist, offs2;
                    var i;
                    sym -= 257;
                    length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
                    dist = tinf_decode_symbol(d, dt);
                    offs2 = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
                    for (i = offs2; i < offs2 + length; ++i) {
                      d.dest[d.destLen++] = d.dest[i];
                    }
                  }
                }
              }
              function tinf_inflate_uncompressed_block(d) {
                var length, invlength;
                var i;
                while (d.bitcount > 8) {
                  d.sourceIndex--;
                  d.bitcount -= 8;
                }
                length = d.source[d.sourceIndex + 1];
                length = 256 * length + d.source[d.sourceIndex];
                invlength = d.source[d.sourceIndex + 3];
                invlength = 256 * invlength + d.source[d.sourceIndex + 2];
                if (length !== (~invlength & 65535))
                  return TINF_DATA_ERROR;
                d.sourceIndex += 4;
                for (i = length; i; --i)
                  d.dest[d.destLen++] = d.source[d.sourceIndex++];
                d.bitcount = 0;
                return TINF_OK;
              }
              function tinf_uncompress(source, dest) {
                var d = new Data(source, dest);
                var bfinal, btype, res;
                do {
                  bfinal = tinf_getbit(d);
                  btype = tinf_read_bits(d, 2, 0);
                  switch (btype) {
                    case 0:
                      res = tinf_inflate_uncompressed_block(d);
                      break;
                    case 1:
                      res = tinf_inflate_block_data(d, sltree, sdtree);
                      break;
                    case 2:
                      tinf_decode_trees(d, d.ltree, d.dtree);
                      res = tinf_inflate_block_data(d, d.ltree, d.dtree);
                      break;
                    default:
                      res = TINF_DATA_ERROR;
                  }
                  if (res !== TINF_OK)
                    throw new Error("Data error");
                } while (!bfinal);
                if (d.destLen < d.dest.length) {
                  if (typeof d.dest.slice === "function")
                    return d.dest.slice(0, d.destLen);
                  else
                    return d.dest.subarray(0, d.destLen);
                }
                return d.dest;
              }
              tinf_build_fixed_trees(sltree, sdtree);
              tinf_build_bits_base(length_bits, length_base, 4, 3);
              tinf_build_bits_base(dist_bits, dist_base, 2, 1);
              length_bits[28] = 0;
              length_base[28] = 258;
              module2.exports = tinf_uncompress;
            },
            /***/
            3501(module2) {
              module2.exports = "W5/fcQLn5gKf2XUbAiQ1XULX+TZz6ADToDsgqk6qVfeC0e4m6OO2wcQ1J76ZBVRV1fRkEsdu//62zQsFEZWSTCnMhcsQKlS2qOhuVYYMGCkV0fXWEoMFbESXrKEZ9wdUEsyw9g4bJlEt1Y6oVMxMRTEVbCIwZzJzboK5j8m4YH02qgXYhv1V+PM435sLVxyHJihaJREEhZGqL03txGFQLm76caGO/ovxKvzCby/3vMTtX/459f0igi7WutnKiMQ6wODSoRh/8Lx1V3Q99MvKtwB6bHdERYRY0hStJoMjNeTsNX7bn+Y7e4EQ3bf8xBc7L0BsyfFPK43dGSXpL6clYC/I328h54/VYrQ5i0648FgbGtl837svJ35L3Mot/+nPlNpWgKx1gGXQYqX6n+bbZ7wuyCHKcUok12Xjqub7NXZGzqBx0SD+uziNf87t7ve42jxSKQoW3nyxVrWIGlFShhCKxjpZZ5MeGna0+lBkk+kaN8F9qFBAFgEogyMBdcX/T1W/WnMOi/7ycWUQloEBKGeC48MkiwqJkJO+12eQiOFHMmck6q/IjWW3RZlany23TBm+cNr/84/oi5GGmGBZWrZ6j+zykVozz5fT/QH/Da6WTbZYYPynVNO7kxzuNN2kxKKWche5WveitPKAecB8YcAHz/+zXLjcLzkdDSktNIDwZE9J9X+tto43oJy65wApM3mDzYtCwX9lM+N5VR3kXYo0Z3t0TtXfgBFg7gU8oN0Dgl7fZlUbhNll+0uuohRVKjrEd8egrSndy5/Tgd2gqjA4CAVuC7ESUmL3DZoGnfhQV8uwnpi8EGvAVVsowNRxPudck7+oqAUDkwZopWqFnW1riss0t1z6iCISVKreYGNvQcXv+1L9+jbP8cd/dPUiqBso2q+7ZyFBvENCkkVr44iyPbtOoOoCecWsiuqMSML5lv+vN5MzUr+Dnh73G7Q1YnRYJVYXHRJaNAOByiaK6CusgFdBPE40r0rvqXV7tksKO2DrHYXBTv8P5ysqxEx8VDXUDDqkPH6NNOV/a2WH8zlkXRELSa8P+heNyJBBP7PgsG1EtWtNef6/i+lcayzQwQCsduidpbKfhWUDgAEmyhGu/zVTacI6RS0zTABrOYueemnVa19u9fT23N/Ta6RvTpof5DWygqreCqrDAgM4LID1+1T/taU6yTFVLqXOv+/MuQOFnaF8vLMKD7tKWDoBdALgxF33zQccCcdHx8fKIVdW69O7qHtXpeGr9jbbpFA+qRMWr5hp0s67FPc7HAiLV0g0/peZlW7hJPYEhZyhpSwahnf93/tZgfqZWXFdmdXBzqxGHLrQKxoAY6fRoBhgCRPmmGueYZ5JexTVDKUIXzkG/fqp/0U3hAgQdJ9zumutK6nqWbaqvm1pgu03IYR+G+8s0jDBBz8cApZFSBeuWasyqo2OMDKAZCozS+GWSvL/HsE9rHxooe17U3s/lTE+VZAk4j3dp6uIGaC0JMiqR5CUsabPyM0dOYDR7Ea7ip4USZlya38YfPtvrX/tBlhHilj55nZ1nfN24AOAi9BVtz/Mbn8AEDJCqJgsVUa6nQnSxv2Fs7l/NlCzpfYEjmPrNyib/+t0ei2eEMjvNhLkHCZlci4WhBe7ePZTmzYqlY9+1pxtS4GB+5lM1BHT9tS270EWUDYFq1I0yY/fNiAk4bk9yBgmef/f2k6AlYQZHsNFnW8wBQxCd68iWv7/35bXfz3JZmfGligWAKRjIs3IpzxQ27vAglHSiOzCYzJ9L9A1CdiyFvyR66ucA4jKifu5ehwER26yV7HjKqn5Mfozo7Coxxt8LWWPT47BeMxX8p0Pjb7hZn+6bw7z3Lw+7653j5sI8CLu5kThpMlj1m4c2ch3jGcP1FsT13vuK3qjecKTZk2kHcOZY40UX+qdaxstZqsqQqgXz+QGF99ZJLqr3VYu4aecl1Ab5GmqS8k/GV5b95zxQ5d4EfXUJ6kTS/CXF/aiqKDOT1T7Jz5z0PwDUcwr9clLN1OJGCiKfqvah+h3XzrBOiLOW8wvn8gW6qE8vPxi+Efv+UH55T7PQFVMh6cZ1pZQlzJpKZ7P7uWvwPGJ6DTlR6wbyj3Iv2HyefnRo/dv7dNx+qaa0N38iBsR++Uil7Wd4afwDNsrzDAK4fXZwvEY/jdKuIKXlfrQd2C39dW7ntnRbIp9OtGy9pPBn/V2ASoi/2UJZfS+xuGLH8bnLuPlzdTNS6zdyk8Dt/h6sfOW5myxh1f+zf3zZ3MX/mO9cQPp5pOx967ZA6/pqHvclNfnUFF+rq+Vd7alKr6KWPcIDhpn6v2K6NlUu6LrKo8b/pYpU/Gazfvtwhn7tEOUuXht5rUJdSf6sLjYf0VTYDgwJ81yaqKTUYej/tbHckSRb/HZicwGJqh1mAHB/IuNs9dc9yuvF3D5Xocm3elWFdq5oEy70dYFit79yaLiNjPj5UUcVmZUVhQEhW5V2Z6Cm4HVH/R8qlamRYwBileuh07CbEce3TXa2JmXWBf+ozt319psboobeZhVnwhMZzOeQJzhpTDbP71Tv8HuZxxUI/+ma3XW6DFDDs4+qmpERwHGBd2edxwUKlODRdUWZ/g0GOezrbzOZauFMai4QU6GVHV6aPNBiBndHSsV4IzpvUiiYyg6OyyrL4Dj5q/Lw3N5kAwftEVl9rNd7Jk5PDij2hTH6wIXnsyXkKePxbmHYgC8A6an5Fob/KH5GtC0l4eFso+VpxedtJHdHpNm+Bvy4C79yVOkrZsLrQ3OHCeB0Ra+kBIRldUGlDCEmq2RwXnfyh6Dz+alk6eftI2n6sastRrGwbwszBeDRS/Fa/KwRJkCzTsLr/JCs5hOPE/MPLYdZ1F1fv7D+VmysX6NpOC8aU9F4Qs6HvDyUy9PvFGDKZ/P5101TYHFl8pjj6wm/qyS75etZhhfg0UEL4OYmHk6m6dO192AzoIyPSV9QedDA4Ml23rRbqxMPMxf7FJnDc5FTElVS/PyqgePzmwVZ26NWhRDQ+oaT7ly7ell4s3DypS1s0g+tOr7XHrrkZj9+x/mJBttrLx98lFIaRZzHz4aC7r52/JQ4VjHahY2/YVXZn/QC2ztQb/sY3uRlyc5vQS8nLPGT/n27495i8HPA152z7Fh5aFpyn1GPJKHuPL8Iw94DuW3KjkURAWZXn4EQy89xiKEHN1mk/tkM4gYDBxwNoYvRfE6LFqsxWJtPrDGbsnLMap3Ka3MUoytW0cvieozOmdERmhcqzG+3HmZv2yZeiIeQTKGdRT4HHNxekm1tY+/n06rGmFleqLscSERzctTKM6G9P0Pc1RmVvrascIxaO1CQCiYPE15bD7c3xSeW7gXxYjgxcrUlcbIvO0r+Yplhx0kTt3qafDOmFyMjgGxXu73rddMHpV1wMubyAGcf/v5dLr5P72Ta9lBF+fzMJrMycwv+9vnU3ANIl1cH9tfW7af8u0/HG0vV47jNFXzFTtaha1xvze/s8KMtCYucXc1nzfd/MQydUXn/b72RBt5wO/3jRcMH9BdhC/yctKBIveRYPrNpDWqBsO8VMmP+WvRaOcA4zRMR1PvSoO92rS7pYEv+fZfEfTMzEdM+6X5tLlyxExhqLRkms5EuLovLfx66de5fL2/yX02H52FPVwahrPqmN/E0oVXnsCKhbi/yRxX83nRbUKWhzYceXOntfuXn51NszJ6MO73pQf5Pl4in3ec4JU8hF7ppV34+mm9r1LY0ee/i1O1wpd8+zfLztE0cqBxggiBi5Bu95v9l3r9r/U5hweLn+TbfxowrWDqdJauKd8+q/dH8sbPkc9ttuyO94f7/XK/nHX46MPFLEb5qQlNPvhJ50/59t9ft3LXu7uVaWaO2bDrDCnRSzZyWvFKxO1+vT8MwwunR3bX0CkfPjqb4K9O19tn5X50PvmYpEwHtiW9WtzuV/s76B1zvLLNkViNd8ySxIl/3orfqP90TyTGaf7/rx8jQzeHJXdmh/N6YDvbvmTBwCdxfEQ1NcL6wNMdSIXNq7b1EUzRy1/Axsyk5p22GMG1b+GxFgbHErZh92wuvco0AuOLXct9hvw2nw/LqIcDRRmJmmZzcgUa7JpM/WV/S9IUfbF56TL2orzqwebdRD8nIYNJ41D/hz37Fo11p2Y21wzPcn713qVGhqtevStYfGH4n69OEJtPvbbLYWvscDqc3Hgnu166+tAyLnxrX0Y5zoYjV++1sI7t5kMr02KT/+uwtkc+rZLOf/qn/s3nYCf13Dg8/sB2diJgjGqjQ+TLhxbzyue2Ob7X6/9lUwW7a+lbznHzOYy8LKW1C/uRPbQY3KW/0gO9LXunHLvPL97afba9bFtc9hmz7GAttjVYlCvQAiOwAk/gC5+hkLEs6tr3AZKxLJtOEwk2dLxTYWsIB/j/ToWtIWzo906FrSG8iaqqqqqqiIiIiAgzMzMzNz+AyK+01/zi8n8S+Y1MjoRaQ80WU/G8MBlO+53VPXANrWm4wzGUVZUjjBJZVdhpcfkjsmcWaO+UEldXi1e+zq+HOsCpknYshuh8pOLISJun7TN0EIGW2xTnlOImeecnoGW4raxe2G1T3HEvfYUYMhG+gAFOAwh5nK8mZhwJMmN7r224QVsNFvZ87Z0qatvknklyPDK3Hy45PgVKXji52Wen4d4PlFVVYGnNap+fSpFbK90rYnhUc6n91Q3AY9E0tJOFrcfZtm/491XbcG/jsViUPPX76qmeuiz+qY1Hk7/1VPM405zWVuoheLUimpWYdVzCmUdKHebMdzgrYrb8mL2eeLSnRWHdonfZa8RsOU9F37w+591l5FLYHiOqWeHtE/lWrBHcRKp3uhtr8yXm8LU/5ms+NM6ZKsqu90cFZ4o58+k4rdrtB97NADFbwmEG7lXqvirhOTOqU14xuUF2myIjURcPHrPOQ4lmM3PeMg7bUuk0nnZi67bXsU6H8lhqIo8TaOrEafCO1ARK9PjC0QOoq2BxmMdgYB9G/lIb9++fqNJ2s7BHGFyBNmZAR8J3KCo012ikaSP8BCrf6VI0X5xdnbhHIO+B5rbOyB54zXkzfObyJ4ecwxfqBJMLFc7m59rNcw7hoHnFZ0b00zee+gTqvjm61Pb4xn0kcDX4jvHM0rBXZypG3DCKnD/Waa/ZtHmtFPgO5eETx+k7RrVg3aSwm2YoNXnCs3XPQDhNn+Fia6IlOOuIG6VJH7TP6ava26ehKHQa2T4N0tcZ9dPCGo3ZdnNltsHQbeYt5vPnJezV/cAeNypdml1vCHI8M81nSRP5Qi2+mI8v/sxiZru9187nRtp3f/42NemcONa+4eVC3PCZzc88aZh851CqSsshe70uPxeN/dmYwlwb3trwMrN1Gq8jbnApcVDx/yDPeYs5/7r62tsQ6lLg+DiFXTEhzR9dHqv0iT4tgj825W+H3XiRUNUZT2kR9Ri0+lp+UM3iQtS8uOE23Ly4KYtvqH13jghUntJRAewuzNLDXp8RxdcaA3cMY6TO2IeSFRXezeWIjCqyhsUdMYuCgYTZSKpBype1zRfq8FshvfBPc6BAQWl7/QxIDp3VGo1J3vn42OEs3qznws+YLRXbymyB19a9XBx6n/owcyxlEYyFWCi+kG9F+EyD/4yn80+agaZ9P7ay2Dny99aK2o91FkfEOY8hBwyfi5uwx2y5SaHmG+oq/zl1FX/8irOf8Y3vAcX/6uLP6A6nvMO24edSGPjQc827Rw2atX+z2bKq0CmW9mOtYnr5/AfDa1ZfPaXnKtlWborup7QYx+Or2uWb+N3N//2+yDcXMqIJdf55xl7/vsj4WoPPlxLxtVrkJ4w/tTe3mLdATOOYwxcq52w5Wxz5MbPdVs5O8/lhfE7dPj0bIiPQ3QV0iqm4m3YX8hRfc6jQ3fWepevMqUDJd86Z4vwM40CWHnn+WphsGHfieF02D3tmZvpWD+kBpNCFcLnZhcmmrhpGzzbdA+sQ1ar18OJD87IOKOFoRNznaHPNHUfUNhvY1iU+uhvEvpKHaUn3qK3exVVyX4joipp3um7FmYJWmA+WbIDshRpbVRx5/nqstCgy87FGbfVB8yDGCqS+2qCsnRwnSAN6zgzxfdB2nBT/vZ4/6uxb6oH8b4VBRxiIB93wLa47hG3w2SL/2Z27yOXJFwZpSJaBYyvajA7vRRYNKqljXKpt/CFD/tSMr18DKKbwB0xggBePatl1nki0yvqW5zchlyZmJ0OTxJ3D+fsYJs/mxYN5+Le5oagtcl+YsVvy8kSjI2YGvGjvmpkRS9W2dtXqWnVuxUhURm1lKtou/hdEq19VBp9OjGvHEQSmrpuf2R24mXGheil8KeiANY8fW1VERUfBImb64j12caBZmRViZHbeVMjCrPDg9A90IXrtnsYCuZtRQ0PyrKDjBNOsPfKsg1pA02gHlVr0OXiFhtp6nJqXVzcbfM0KnzC3ggOENPE9VBdmHKN6LYaijb4wXxJn5A0FSDF5j+h1ooZx885Jt3ZKzO5n7Z5WfNEOtyyPqQEnn7WLv5Fis3PdgMshjF1FRydbNyeBbyKI1oN1TRVrVK7kgsb/zjX4NDPIRMctVeaxVB38Vh1x5KbeJbU138AM5KzmZu3uny0ErygxiJF7GVXUrPzFxrlx1uFdAaZFDN9cvIb74qD9tzBMo7L7WIEYK+sla1DVMHpF0F7b3+Y6S+zjvLeDMCpapmJo1weBWuxKF3rOocih1gun4BoJh1kWnV/Jmiq6uOhK3VfKxEHEkafjLgK3oujaPzY6SXg8phhL4TNR1xvJd1Wa0aYFfPUMLrNBDCh4AuGRTbtKMc6Z1Udj8evY/ZpCuMAUefdo69DZUngoqE1P9A3PJfOf7WixCEj+Y6t7fYeHbbxUAoFV3M89cCKfma3fc1+jKRe7MFWEbQqEfyzO2x/wrO2VYH7iYdQ9BkPyI8/3kXBpLaCpU7eC0Yv/am/tEDu7HZpqg0EvHo0nf/R/gRzUWy33/HXMJQeu1GylKmOkXzlCfGFruAcPPhaGqZOtu19zsJ1SO2Jz4Ztth5cBX6mRQwWmDwryG9FUMlZzNckMdK+IoMJv1rOWnBamS2w2KHiaPMPLC15hCZm4KTpoZyj4E2TqC/P6r7/EhnDMhKicZZ1ZwxuC7DPzDGs53q8gXaI9kFTK+2LTq7bhwsTbrMV8Rsfua5lMS0FwbTitUVnVa1yTb5IX51mmYnUcP9wPr8Ji1tiYJeJV9GZTrQhF7vvdU2OTU42ogJ9FDwhmycI2LIg++03C6scYhUyUuMV5tkw6kGUoL+mjNC38+wMdWNljn6tGPpRES7veqrSn5TRuv+dh6JVL/iDHU1db4c9WK3++OrH3PqziF916UMUKn8G67nN60GfWiHrXYhUG3yVWmyYak59NHj8t1smG4UDiWz2rPHNrKnN4Zo1LBbr2/eF9YZ0n0blx2nG4X+EKFxvS3W28JESD+FWk61VCD3z/URGHiJl++7TdBwkCj6tGOH3qDb0QqcOF9Kzpj0HUb/KyFW3Yhj2VMKJqGZleFBH7vqvf7WqLC3XMuHV8q8a4sTFuxUtkD/6JIBvKaVjv96ndgruKZ1k/BHzqf2K9fLk7HGXANyLDd1vxkK/i055pnzl+zw6zLnwXlVYVtfmacJgEpRP1hbGgrYPVN6v2lG+idQNGmwcKXu/8xEj/P6qe/sB2WmwNp6pp8jaISMkwdleFXYK55NHWLTTbutSUqjBfDGWo/Yg918qQ+8BRZSAHZbfuNZz2O0sov1Ue4CWlVg3rFhM3Kljj9ksGd/NUhk4nH+a5UN2+1i8+NM3vRNp7uQ6sqexSCukEVlVZriHNqFi5rLm9TMWa4qm3idJqppQACol2l4VSuvWLfta4JcXy3bROPNbXOgdOhG47LC0CwW/dMlSx4Jf17aEU3yA1x9p+Yc0jupXgcMuYNku64iYOkGToVDuJvlbEKlJqsmiHbvNrIVZEH+yFdF8DbleZ6iNiWwMqvtMp/mSpwx5KxRrT9p3MAPTHGtMbfvdFhyj9vhaKcn3At8Lc16Ai+vBcSp1ztXi7rCJZx/ql7TXcclq6Q76UeKWDy9boS0WHIjUuWhPG8LBmW5y2rhuTpM5vsLt+HOLh1Yf0DqXa9tsfC+kaKt2htA0ai/L2i7RKoNjEwztkmRU0GfgW1TxUvPFhg0V7DdfWJk5gfrccpYv+MA9M0dkGTLECeYwUixRzjRFdmjG7zdZIl3XKB9YliNKI31lfa7i2JG5C8Ss+rHe0D7Z696/V3DEAOWHnQ9yNahMUl5kENWS6pHKKp2D1BaSrrHdE1w2qNxIztpXgUIrF0bm15YML4b6V1k+GpNysTahKMVrrS85lTVo9OGJ96I47eAy5rYWpRf/mIzeoYU1DKaQCTUVwrhHeyNoDqHel+lLxr9WKzhSYw7vrR6+V5q0pfi2k3L1zqkubY6rrd9ZLvSuWNf0uqnkY+FpTvFzSW9Fp0b9l8JA7THV9eCi/PY/SCZIUYx3BU2alj7Cm3VV6eYpios4b6WuNOJdYXUK3zTqj5CVG2FqYM4Z7CuIU0qO05XR0d71FHM0YhZmJmTRfLlXEumN82BGtzdX0S19t1e+bUieK8zRmqpa4Qc5TSjifmaQsY2ETLjhI36gMR1+7qpjdXXHiceUekfBaucHShAOiFXmv3sNmGQyU5iVgnoocuonQXEPTFwslHtS8R+A47StI9wj0iSrtbi5rMysczFiImsQ+bdFClnFjjpXXwMy6O7qfjOr8Fb0a7ODItisjnn3EQO16+ypd1cwyaAW5Yzxz5QknfMO7643fXW/I9y3U2xH27Oapqr56Z/tEzglj6IbT6HEHjopiXqeRbe5mQQvxtcbDOVverN0ZgMdzqRYRjaXtMRd56Q4cZSmdPvZJdSrhJ1D9zNXPqAEqPIavPdfubt5oke2kmv0dztIszSv2VYuoyf1UuopbsYb+uX9h6WpwjpgtZ6fNNawNJ4q8O3CFoSbioAaOSZMx2GYaPYB+rEb6qjQiNRFQ76TvwNFVKD+BhH9VhcKGsXzmMI7BptU/CNWolM7YzROvpFAntsiWJp6eR2d3GarcYShVYSUqhmYOWj5E96NK2WvmYNTeY7Zs4RUEdv9h9QT4EseKt6LzLrqEOs3hxAY1MaNWpSa6zZx8F3YOVeCYMS88W+CYHDuWe4yoc6YK+djDuEOrBR5lvh0r+Q9uM88lrjx9x9AtgpQVNE8r+3O6Gvw59D+kBF/UMXyhliYUtPjmvXGY6Dk3x+kEOW+GtdMVC4EZTqoS/jmR0P0LS75DOc/w2vnri97M4SdbZ8qeU7gg8DVbERkU5geaMQO3mYrSYyAngeUQqrN0C0/vsFmcgWNXNeidsTAj7/4MncJR0caaBUpbLK1yBCBNRjEv6KvuVSdpPnEMJdsRRtqJ+U8tN1gXA4ePHc6ZT0eviI73UOJF0fEZ8YaneAQqQdGphNvwM4nIqPnXxV0xA0fnCT+oAhJuyw/q8jO0y8CjSteZExwBpIN6SvNp6A5G/abi6egeND/1GTguhuNjaUbbnSbGd4L8937Ezm34Eyi6n1maeOBxh3PI0jzJDf5mh/BsLD7F2GOKvlA/5gtvxI3/eV4sLfKW5Wy+oio+es/u6T8UU+nsofy57Icb/JlZHPFtCgd/x+bwt3ZT+xXTtTtTrGAb4QehC6X9G+8YT+ozcLxDsdCjsuOqwPFnrdLYaFc92Ui0m4fr39lYmlCaqTit7G6O/3kWDkgtXjNH4BiEm/+jegQnihOtfffn33WxsFjhfMd48HT+f6o6X65j7XR8WLSHMFkxbvOYsrRsF1bowDuSQ18Mkxk4qz2zoGPL5fu9h2Hqmt1asl3Q3Yu3szOc+spiCmX4AETBM3pLoTYSp3sVxahyhL8eC4mPN9k2x3o0xkiixIzM3CZFzf5oR4mecQ5+ax2wCah3/crmnHoqR0+KMaOPxRif1oEFRFOO/kTPPmtww+NfMXxEK6gn6iU32U6fFruIz8Q4WgljtnaCVTBgWx7diUdshC9ZEa5yKpRBBeW12r/iNc/+EgNqmhswNB8SBoihHXeDF7rrWDLcmt3V8GYYN7pXRy4DZjj4DJuUBL5iC3DQAaoo4vkftqVTYRGLS3mHZ7gdmdTTqbgNN/PTdTCOTgXolc88MhXAEUMdX0iy1JMuk5wLsgeu0QUYlz2S4skTWwJz6pOm/8ihrmgGfFgri+ZWUK2gAPHgbWa8jaocdSuM4FJYoKicYX/ZSENkg9Q1ZzJfwScfVnR2DegOGwCvmogaWJCLQepv9WNlU6QgsmOwICquU28Mlk3d9W5E81lU/5Ez0LcX6lwKMWDNluNKfBDUy/phJgBcMnfkh9iRxrdOzgs08JdPB85Lwo+GUSb4t3nC+0byqMZtO2fQJ4U2zGIr49t/28qmmGv2RanDD7a3FEcdtutkW8twwwlUSpb8QalodddbBfNHKDQ828BdE7OBgFdiKYohLawFYqpybQoxATZrheLhdI7+0Zlu9Q1myRcd15r9UIm8K2LGJxqTegntqNVMKnf1a8zQiyUR1rxoqjiFxeHxqFcYUTHfDu7rhbWng6qOxOsI+5A1p9mRyEPdVkTlE24vY54W7bWc6jMgZvNXdfC9/9q7408KDsbdL7Utz7QFSDetz2picArzrdpL8OaCHC9V26RroemtDZ5yNM/KGkWMyTmfnInEvwtSD23UcFcjhaE3VKzkoaEMKGBft4XbIO6forTY1lmGQwVmKicBCiArDzE+1oIxE08fWeviIOD5TznqH+OoHadvoOP20drMPe5Irg3XBQziW2XDuHYzjqQQ4wySssjXUs5H+t3FWYMHppUnBHMx/nYIT5d7OmjDbgD9F6na3m4l7KdkeSO3kTEPXafiWinogag7b52taiZhL1TSvBFmEZafFq2H8khQaZXuitCewT5FBgVtPK0j4xUHPfUz3Q28eac1Z139DAP23dgki94EC8vbDPTQC97HPPSWjUNG5tWKMsaxAEMKC0665Xvo1Ntd07wCLNf8Q56mrEPVpCxlIMVlQlWRxM3oAfpgIc+8KC3rEXUog5g06vt7zgXY8grH7hhwVSaeuvC06YYRAwpbyk/Unzj9hLEZNs2oxPQB9yc+GnL6zTgq7rI++KDJwX2SP8Sd6YzTuw5lV/kU6eQxRD12omfQAW6caTR4LikYkBB1CMOrvgRr/VY75+NSB40Cni6bADAtaK+vyxVWpf9NeKJxN2KYQ8Q2xPB3K1s7fuhvWbr2XpgW044VD6DRs0qXoqKf1NFsaGvKJc47leUV3pppP/5VTKFhaGuol4Esfjf5zyCyUHmHthChcYh4hYLQF+AFWsuq4t0wJyWgdwQVOZiV0efRHPoK5+E1vjz9wTJmVkITC9oEstAsyZSgE/dbicwKr89YUxKZI+owD205Tm5lnnmDRuP/JnzxX3gMtlrcX0UesZdxyQqYQuEW4R51vmQ5xOZteUd8SJruMlTUzhtVw/Nq7eUBcqN2/HVotgfngif60yKEtoUx3WYOZlVJuJOh8u59fzSDPFYtQgqDUAGyGhQOAvKroXMcOYY0qjnStJR/G3aP+Jt1sLVlGV8POwr/6OGsqetnyF3TmTqZjENfnXh51oxe9qVUw2M78EzAJ+IM8lZ1MBPQ9ZWSVc4J3mWSrLKrMHReA5qdGoz0ODRsaA+vwxXA2cAM4qlfzBJA6581m4hzxItQw5dxrrBL3Y6kCbUcFxo1S8jyV44q//+7ASNNudZ6xeaNOSIUffqMn4A9lIjFctYn2gpEPAb3f7p3iIBN8H14FUGQ9ct2hPsL+cEsTgUrR47uJVN4n4wt/wgfwwHuOnLd4yobkofy8JvxSQTA7rMpDIc608SlZFJfZYcmbT0tAHpPE8MrtQ42siTUNWxqvWZOmvu9f0JPoQmg+6l7sZWwyfi6PXkxJnwBraUG0MYG4zYHQz3igy/XsFkx5tNQxw43qvI9dU3f0DdhOUlHKjmi1VAr2Kiy0HZwD8VeEbhh0OiDdMYspolQsYdSwjCcjeowIXNZVUPmL2wwIkYhmXKhGozdCJ4lRKbsf4NBh/XnQoS92NJEWOVOFs2YhN8c5QZFeK0pRdAG40hqvLbmoSA8xQmzOOEc7wLcme9JOsjPCEgpCwUs9E2DohMHRhUeyGIN6TFvrbny8nDuilsDpzrH5mS76APoIEJmItS67sQJ+nfwddzmjPxcBEBBCw0kWDwd0EZCkNeOD7NNQhtBm7KHL9mRxj6U1yWU2puzlIDtpYxdH4ZPeXBJkTGAJfUr/oTCz/iypY6uXaR2V1doPxJYlrw2ghH0D5gbrhFcIxzYwi4a/4hqVdf2DdxBp6vGYDjavxMAAoy+1+3aiO6S3W/QAKNVXagDtvsNtx7Ks+HKgo6U21B+QSZgIogV5Bt+BnXisdVfy9VyXV+2P5fMuvdpAjM1o/K9Z+XnE4EOCrue+kcdYHqAQ0/Y/OmNlQ6OI33jH/uD1RalPaHpJAm2av0/xtpqdXVKNDrc9F2izo23Wu7firgbURFDNX9eGGeYBhiypyXZft2j3hTvzE6PMWKsod//rEILDkzBXfi7xh0eFkfb3/1zzPK/PI5Nk3FbZyTl4mq5BfBoVoqiPHO4Q4QKZAlrQ3MdNfi3oxIjvsM3kAFv3fdufurqYR3PSwX/mpGy/GFI/B2MNPiNdOppWVbs/gjF3YH+QA9jMhlAbhvasAHstB0IJew09iAkmXHl1/TEj+jvHOpOGrPRQXbPADM+Ig2/OEcUcpgPTItMtW4DdqgfYVI/+4hAFWYjUGpOP/UwNuB7+BbKOcALbjobdgzeBQfjgNSp2GOpxzGLj70Vvq5cw2AoYENwKLUtJUX8sGRox4dVa/TN4xKwaKcl9XawQR/uNus700Hf17pyNnezrUgaY9e4MADhEDBpsJT6y1gDJs1q6wlwGhuUzGR7C8kgpjPyHWwsvrf3yn1zJEIRa5eSxoLAZOCR9xbuztxFRJW9ZmMYfCFJ0evm9F2fVnuje92Rc4Pl6A8bluN8MZyyJGZ0+sNSb//DvAFxC2BqlEsFwccWeAl6CyBcQV1bx4mQMBP1Jxqk1EUADNLeieS2dUFbQ/c/kvwItbZ7tx0st16viqd53WsRmPTKv2AD8CUnhtPWg5aUegNpsYgasaw2+EVooeNKmrW3MFtj76bYHJm5K9gpAXZXsE5U8DM8XmVOSJ1F1WnLy6nQup+jx52bAb+rCq6y9WXl2B2oZDhfDkW7H3oYfT/4xx5VncBuxMXP2lNfhUVQjSSzSRbuZFE4vFawlzveXxaYKVs8LpvAb8IRYF3ZHiRnm0ADeNPWocwxSzNseG7NrSEVZoHdKWqaGEBz1N8Pt7kFbqh3LYmAbm9i1IChIpLpM5AS6mr6OAPHMwwznVy61YpBYX8xZDN/a+lt7n+x5j4bNOVteZ8lj3hpAHSx1VR8vZHec4AHO9XFCdjZ9eRkSV65ljMmZVzaej2qFn/qt1lvWzNZEfHxK3qOJrHL6crr0CRzMox5f2e8ALBB4UGFZKA3tN6F6IXd32GTJXGQ7DTi9j/dNcLF9jCbDcWGKxoKTYblIwbLDReL00LRcDPMcQuXLMh5YzgtfjkFK1DP1iDzzYYVZz5M/kWYRlRpig1htVRjVCknm+h1M5LiEDXOyHREhvzCGpFZjHS0RsK27o2avgdilrJkalWqPW3D9gmwV37HKmfM3F8YZj2ar+vHFvf3B8CRoH4kDHIK9mrAg+owiEwNjjd9V+FsQKYR8czJrUkf7Qoi2YaW6EVDZp5zYlqiYtuXOTHk4fAcZ7qBbdLDiJq0WNV1l2+Hntk1mMWvxrYmc8kIx8G3rW36J6Ra4lLrTOCgiOihmow+YnzUT19jbV2B3RWqSHyxkhmgsBqMYWvOcUom1jDQ436+fcbu3xf2bbeqU/ca+C4DOKE+e3qvmeMqW3AxejfzBRFVcwVYPq4L0APSWWoJu+5UYX4qg5U6YTioqQGPG9XrnuZ/BkxuYpe6Li87+18EskyQW/uA+uk2rpHpr6hut2TlVbKgWkFpx+AZffweiw2+VittkEyf/ifinS/0ItRL2Jq3tQOcxPaWO2xrG68GdFoUpZgFXaP2wYVtRc6xYCfI1CaBqyWpg4bx8OHBQwsV4XWMibZZ0LYjWEy2IxQ1mZrf1/UNbYCJplWu3nZ4WpodIGVA05d+RWSS+ET9tH3RfGGmNI1cIY7evZZq7o+a0bjjygpmR3mVfalkT/SZGT27Q8QGalwGlDOS9VHCyFAIL0a1Q7JiW3saz9gqY8lqKynFrPCzxkU4SIfLc9VfCI5edgRhDXs0edO992nhTKHriREP1NJC6SROMgQ0xO5kNNZOhMOIT99AUElbxqeZF8A3xrfDJsWtDnUenAHdYWSwAbYjFqQZ+D5gi3hNK8CSxU9i6f6ClL9IGlj1OPMQAsr84YG6ijsJpCaGWj75c3yOZKBB9mNpQNPUKkK0D6wgLH8MGoyRxTX6Y05Q4AnYNXMZwXM4eij/9WpsM/9CoRnFQXGR6MEaY+FXvXEO3RO0JaStk6OXuHVATHJE+1W+TU3bSZ2ksMtqjO0zfSJCdBv7y2d8DMx6TfVme3q0ZpTKMMu4YL/t7ciTNtdDkwPogh3Cnjx7qk08SHwf+dksZ7M2vCOlfsF0hQ6J4ehPCaHTNrM/zBSOqD83dBEBCW/F/LEmeh0nOHd7oVl3/Qo/9GUDkkbj7yz+9cvvu+dDAtx8NzCDTP4iKdZvk9MWiizvtILLepysflSvTLFBZ37RLwiriqyRxYv/zrgFd/9XVHh/OmzBvDX4mitMR/lUavs2Vx6cR94lzAkplm3IRNy4TFfu47tuYs9EQPIPVta4P64tV+sZ7n3ued3cgEx2YK+QL5+xms6osk8qQbTyuKVGdaX9FQqk6qfDnT5ykxk0VK7KZ62b6DNDUfQlqGHxSMKv1P0XN5BqMeKG1P4Wp5QfZDUCEldppoX0U6ss2jIko2XpURKCIhfaOqLPfShdtS37ZrT+jFRSH2xYVV1rmT/MBtRQhxiO4MQ3iAGlaZi+9PWBEIXOVnu9jN1f921lWLZky9bqbM3J2MAAI9jmuAx3gyoEUa6P2ivs0EeNv/OR+AX6q5SW6l5HaoFuS6jr6yg9limu+P0KYKzfMXWcQSfTXzpOzKEKpwI3YGXZpSSy2LTlMgfmFA3CF6R5c9xWEtRuCg2ZPUQ2Nb6dRFTNd4TfGHrnEWSKHPuRyiJSDAZ+KX0VxmSHjGPbQTLVpqixia2uyhQ394gBMt7C3ZAmxn/DJS+l1fBsAo2Eir/C0jG9csd4+/tp12pPc/BVJGaK9mfvr7M/CeztrmCO5qY06Edi4xAGtiEhnWAbzLy2VEyazE1J5nPmgU4RpW4Sa0TnOT6w5lgt3/tMpROigHHmexBGAMY0mdcDbDxWIz41NgdD6oxgHsJRgr5RnT6wZAkTOcStU4NMOQNemSO7gxGahdEsC+NRVGxMUhQmmM0llWRbbmFGHzEqLM4Iw0H7577Kyo+Zf+2cUFIOw93gEY171vQaM0HLwpjpdRR6Jz7V0ckE7XzYJ0TmY9znLdzkva0vNrAGGT5SUZ5uaHDkcGvI0ySpwkasEgZPMseYcu85w8HPdSNi+4T6A83iAwDbxgeFcB1ZM2iGXzFcEOUlYVrEckaOyodfvaYSQ7GuB4ISE0nYJc15X/1ciDTPbPCgYJK55VkEor4LvzL9S2WDy4xj+6FOqVyTAC2ZNowheeeSI5hA/02l8UYkv4nk9iaVn+kCVEUstgk5Hyq+gJm6R9vG3rhuM904he/hFmNQaUIATB1y3vw+OmxP4X5Yi6A5I5jJufHCjF9+AGNwnEllZjUco6XhsO5T5+R3yxz5yLVOnAn0zuS+6zdj0nTJbEZCbXJdtpfYZfCeCOqJHoE2vPPFS6eRLjIJlG69X93nfR0mxSFXzp1Zc0lt/VafDaImhUMtbnqWVb9M4nGNQLN68BHP7AR8Il9dkcxzmBv8PCZlw9guY0lurbBsmNYlwJZsA/B15/HfkbjbwPddaVecls/elmDHNW2r4crAx43feNkfRwsaNq/yyJ0d/p5hZ6AZajz7DBfUok0ZU62gCzz7x8eVfJTKA8IWn45vINLSM1q+HF9CV9qF3zP6Ml21kPPL3CXzkuYUlnSqT+Ij4tI/od5KwIs+tDajDs64owN7tOAd6eucGz+KfO26iNcBFpbWA5732bBNWO4kHNpr9D955L61bvHCF/mwSrz6eQaDjfDEANqGMkFc+NGxpKZzCD2sj/JrHd+zlPQ8Iz7Q+2JVIiVCuCKoK/hlAEHzvk/Piq3mRL1rT/fEh9hoT5GJmeYswg1otiKydizJ/fS2SeKHVu6Z3JEHjiW8NaTQgP5xdBli8nC57XiN9hrquBu99hn9zqwo92+PM2JXtpeVZS0PdqR5mDyDreMMtEws+CpwaRyyzoYtfcvt9PJIW0fJVNNi/FFyRsea7peLvJrL+5b4GOXJ8tAr+ATk9f8KmiIsRhqRy0vFzwRV3Z5dZ3QqIU8JQ/uQpkJbjMUMFj2F9sCFeaBjI4+fL/oN3+LQgjI4zuAfQ+3IPIPFQBccf0clJpsfpnBxD84atwtupkGqKvrH7cGNl/QcWcSi6wcVDML6ljOgYbo+2BOAWNNjlUBPiyitUAwbnhFvLbnqw42kR3Yp2kv2dMeDdcGOX5kT4S6M44KHEB/SpCfl7xgsUvs+JNY9G3O2X/6FEt9FyAn57lrbiu+tl83sCymSvq9eZbe9mchL7MTf/Ta78e80zSf0hYY5eUU7+ff14jv7Xy8qjzfzzzvaJnrIdvFb5BLWKcWGy5/w7+vV2cvIfwHqdTB+RuJK5oj9mbt0Hy94AmjMjjwYNZlNS6uiyxNnwNyt3gdreLb64p/3+08nXkb92LTkkRgFOwk1oGEVllcOj5lv1hfAZywDows0944U8vUFw+A/nuVq/UCygsrmWIBnHyU01d0XJPwriEOvx/ISK6Pk4y2w0gmojZs7lU8TtakBAdne4v/aNxmMpK4VcGMp7si0yqsiolXRuOi1Z1P7SqD3Zmp0CWcyK4Ubmp2SXiXuI5nGLCieFHKHNRIlcY3Pys2dwMTYCaqlyWSITwr2oGXvyU3h1Pf8eQ3w1bnD7ilocVjYDkcXR3Oo1BXgMLTUjNw2xMVwjtp99NhSVc5aIWrDQT5DHPKtCtheBP4zHcw4dz2eRdTMamhlHhtfgqJJHI7NGDUw1XL8vsSeSHyKqDtqoAmrQqsYwvwi7HW3ojWyhIa5oz5xJTaq14NAzFLjVLR12rRNUQ6xohDnrWFb5bG9yf8aCD8d5phoackcNJp+Dw3Due3RM+5Rid7EuIgsnwgpX0rUWh/nqPtByMhMZZ69NpgvRTKZ62ViZ+Q7Dp5r4K0d7EfJuiy06KuIYauRh5Ecrhdt2QpTS1k1AscEHvapNbU3HL1F2TFyR33Wxb5MvH5iZsrn3SDcsxlnnshO8PLwmdGN+paWnQuORtZGX37uhFT64SeuPsx8UOokY6ON85WdQ1dki5zErsJGazcBOddWJEKqNPiJpsMD1GrVLrVY+AOdPWQneTyyP1hRX/lMM4ZogGGOhYuAdr7F/DOiAoc++cn5vlf0zkMUJ40Z1rlgv9BelPqVOpxKeOpzKdF8maK+1Vv23MO9k/8+qpLoxrIGH2EDQlnGmH8CD31G8QqlyQIcpmR5bwmSVw9/Ns6IHgulCRehvZ/+VrM60Cu/r3AontFfrljew74skYe2uyn7JKQtFQBQRJ9ryGic/zQOsbS4scUBctA8cPToQ3x6ZBQu6DPu5m1bnCtP8TllLYA0UTQNVqza5nfew3Mopy1GPUwG5jsl0OVXniPmAcmLqO5HG8Hv3nSLecE9oOjPDXcsTxoCBxYyzBdj4wmnyEV4kvFDunipS8SSkvdaMnTBN9brHUR8xdmmEAp/Pdqk9uextp1t+JrtXwpN/MG2w/qhRMpSNxQ1uhg/kKO30eQ/FyHUDkWHT8V6gGRU4DhDMxZu7xXij9Ui6jlpWmQCqJg3FkOTq3WKneCRYZxBXMNAVLQgHXSCGSqNdjebY94oyIpVjMYehAiFx/tqzBXFHZaL5PeeD74rW5OysFoUXY8sebUZleFTUa/+zBKVTFDopTReXNuZq47QjkWnxjirCommO4L/GrFtVV21EpMyw8wyThL5Y59d88xtlx1g1ttSICDwnof6lt/6zliPzgVUL8jWBjC0o2D6Kg+jNuThkAlaDJsq/AG2aKA//A76avw2KNqtv223P+Wq3StRDDNKFFgtsFukYt1GFDWooFVXitaNhb3RCyJi4cMeNjROiPEDb4k+G3+hD8tsg+5hhmSc/8t2JTSwYoCzAI75doq8QTHe+E/Tw0RQSUDlU+6uBeNN3h6jJGX/mH8oj0i3caCNsjvTnoh73BtyZpsflHLq6AfwJNCDX4S98h4+pCOhGKDhV3rtkKHMa3EG4J9y8zFWI4UsfNzC/Rl5midNn7gwoN9j23HGCQQ+OAZpTTPMdiVow740gIyuEtd0qVxMyNXhHcnuXRKdw5wDUSL358ktjMXmAkvIB73BLa1vfF9BAUZInPYJiwxqFWQQBVk7gQH4ojfUQ/KEjn+A/WR6EEe4CtbpoLe1mzHkajgTIoE0SLDHVauKhrq12zrAXBGbPPWKCt4DGedq3JyGRbmPFW32bE7T20+73BatV/qQhhBWfWBFHfhYWXjALts38FemnoT+9bn1jDBMcUMmYgSc0e7GQjv2MUBwLU8ionCpgV+Qrhg7iUIfUY6JFxR0Y+ZTCPM+rVuq0GNLyJXX6nrUTt8HzFBRY1E/FIm2EeVA9NcXrj7S6YYIChVQCWr/m2fYUjC4j0XLkzZ8GCSLfmkW3PB/xq+nlXsKVBOj7vTvqKCOMq7Ztqr3cQ+N8gBnPaAps+oGwWOkbuxnRYj/x/WjiDclVrs22xMK4qArE1Ztk1456kiJriw6abkNeRHogaPRBgbgF9Z8i/tbzWELN4CvbqtrqV9TtGSnmPS2F9kqOIBaazHYaJ9bi3AoDBvlZasMluxt0BDXfhp02Jn411aVt6S4TUB8ZgFDkI6TP6gwPY85w+oUQSsjIeXVminrwIdK2ZAawb8Se6XOJbOaliQxHSrnAeONDLuCnFejIbp4YDtBcQCwMsYiRZfHefuEJqJcwKTTJ8sx5hjHmJI1sPFHOr6W9AhZ2NAod38mnLQk1gOz2LCAohoQbgMbUK9RMEA3LkiF7Sr9tLZp6lkciIGhE2V546w3Mam53VtVkGbB9w0Yk2XiRnCmbpxmHr2k4eSC0RuNbjNsUfDIfc8DZvRvgUDe1IlKdZTzcT4ZGEb53dp8VtsoZlyXzLHOdAbsp1LPTVaHvLA0GYDFMbAW/WUBfUAdHwqLFAV+3uHvYWrCfhUOR2i89qvCBoOb48usAGdcF2M4aKn79k/43WzBZ+xR1L0uZfia70XP9soQReeuhZiUnXFDG1T8/OXNmssTSnYO+3kVLAgeiY719uDwL9FQycgLPessNihMZbAKG7qwPZyG11G1+ZA3jAX2yddpYfmaKBlmfcK/V0mwIRUDC0nJSOPUl2KB8h13F4dlVZiRhdGY5farwN+f9hEb1cRi41ZcGDn6Xe9MMSTOY81ULJyXIHSWFIQHstVYLiJEiUjktlHiGjntN5/btB8Fu+vp28zl2fZXN+dJDyN6EXhS+0yzqpl/LSJNEUVxmu7BsNdjAY0jVsAhkNuuY0E1G48ej25mSt+00yPbQ4SRCVkIwb6ISvYtmJRPz9Zt5dk76blf+lJwAPH5KDF+vHAmACLoCdG2Adii6dOHnNJnTmZtoOGO8Q1jy1veMw6gbLFToQmfJa7nT7Al89mRbRkZZQxJTKgK5Kc9INzmTJFp0tpAPzNmyL/F08bX3nhCumM/cR/2RPn9emZ3VljokttZD1zVWXlUIqEU7SLk5I0lFRU0AcENXBYazNaVzsVHA/sD3o9hm42wbHIRb/BBQTKzAi8s3+bMtpOOZgLdQzCYPfX3UUxKd1WYVkGH7lh/RBBgMZZwXzU9+GYxdBqlGs0LP+DZ5g2BWNh6FAcR944B+K/JTWI3t9YyVyRhlP4CCoUk/mmF7+r2pilVBjxXBHFaBfBtr9hbVn2zDuI0kEOG3kBx8CGdPOjX1ph1POOZJUO1JEGG0jzUy2tK4X0CgVNYhmkqqQysRNtKuPdCJqK3WW57kaV17vXgiyPrl4KEEWgiGF1euI4QkSFHFf0TDroQiLNKJiLbdhH0YBhriRNCHPxSqJmNNoketaioohqMglh6wLtEGWSM1EZbQg72h0UJAIPVFCAJOThpQGGdKfFovcwEeiBuZHN2Ob4uVM7+gwZLz1D9E7ta4RmMZ24OBBAg7Eh6dLXGofZ4U2TFOCQMKjwhVckjrydRS+YaqCw1kYt6UexuzbNEDyYLTZnrY1PzsHZJT4U+awO2xlqTSYu6n/U29O2wPXgGOEKDMSq+zTUtyc8+6iLp0ivav4FKx+xxVy4FxhIF/pucVDqpsVe2jFOfdZhTzLz2QjtzvsTCvDPU7bzDH2eXVKUV9TZ+qFtaSSxnYgYdXKwVreIgvWhT9eGDB2OvnWyPLfIIIfNnfIxU8nW7MbcH05nhlsYtaW9EZRsxWcKdEqInq1DiZPKCz7iGmAU9/ccnnQud2pNgIGFYOTAWjhIrd63aPDgfj8/sdlD4l+UTlcxTI9jbaMqqN0gQxSHs60IAcW3cH4p3V1aSciTKB29L1tz2eUQhRiTgTvmqc+sGtBNh4ky0mQJGsdycBREP+fAaSs1EREDVo5gvgi5+aCN7NECw30owbCc1mSpjiahyNVwJd1jiGgzSwfTpzf2c5XJvG/g1n0fH88KHNnf+u7ZiRMlXueSIsloJBUtW9ezvsx9grfsX/FNxnbxU1Lvg0hLxixypHKGFAaPu0xCD8oDTeFSyfRT6s8109GMUZL8m2xXp8X2dpPCWWdX84iga4BrTlOfqox4shqEgh/Ht4qRst52cA1xOIUuOxgfUivp6v5f8IVyaryEdpVk72ERAwdT4aoY1usBgmP+0m06Q216H/nubtNYxHaOIYjcach3A8Ez/zc0KcShhel0HCYjFsA0FjYqyJ5ZUH1aZw3+zWC0hLpM6GDfcAdn9fq2orPmZbW6XXrf+Krc9RtvII5jeD3dFoT1KwZJwxfUMvc5KLfn8rROW23Jw89sJ2a5dpB3qWDUBWF2iX8OCuKprHosJ2mflBR+Wqs86VvgI/XMnsqb97+VlKdPVysczPj8Jhzf+WCvGBHijAqYlavbF60soMWlHbvKT+ScvhprgeTln51xX0sF+Eadc/l2s2a5BgkVbHYyz0E85p0LstqH+gEGiR84nBRRFIn8hLSZrGwqjZ3E29cuGi+5Z5bp7EM8MWFa9ssS/vy4VrDfECSv7DSU84DaP0sXI3Ap4lWznQ65nQoTKRWU30gd7Nn8ZowUvGIx4aqyXGwmA/PB4qN8msJUODezUHEl0VP9uo+cZ8vPFodSIB4C7lQYjEFj8yu49C2KIV3qxMFYTevG8KqAr0TPlkbzHHnTpDpvpzziAiNFh8xiT7C/TiyH0EguUw4vxAgpnE27WIypV+uFN2zW7xniF/n75trs9IJ5amB1zXXZ1LFkJ6GbS/dFokzl4cc2mamVwhL4XU0Av5gDWAl+aEWhAP7t2VIwU+EpvfOPDcLASX7H7lZpXA2XQfbSlD4qU18NffNPoAKMNSccBfO9YVVgmlW4RydBqfHAV7+hrZ84WJGho6bNT0YMhxxLdOx/dwGj0oyak9aAkNJ8lRJzUuA8sR+fPyiyTgUHio5+Pp+YaKlHrhR41jY5NESPS3x+zTMe0S2HnLOKCOQPpdxKyviBvdHrCDRqO+l96HhhNBLXWv4yEMuEUYo8kXnYJM8oIgVM4XJ+xXOev4YbWeqsvgq0lmw4/PiYr9sYLt+W5EAuYSFnJEan8CwJwbtASBfLBBpJZiRPor/aCJBZsM+MhvS7ZepyHvU8m5WSmaZnxuLts8ojl6KkS8oSAHkq5GWlCB/NgJ5W3rO2Cj1MK7ahxsCrbTT3a0V/QQH+sErxV4XUWDHx0kkFy25bPmBMBQ6BU3HoHhhYcJB9JhP6NXUWKxnE0raXHB6U9KHpWdQCQI72qevp5fMzcm+AvC85rsynVQhruDA9fp9COe7N56cg1UKGSas89vrN+WlGLYTwi5W+0xYdKEGtGCeNJwXKDU0XqU5uQYnWsMwTENLGtbQMvoGjIFIEMzCRal4rnBAg7D/CSn8MsCvS+FDJJAzoiioJEhZJgAp9n2+1Yznr7H+6eT4YkJ9Mpj60ImcW4i4iHDLn9RydB8dx3QYm3rsX6n4VRrZDsYK6DCGwkwd5n3/INFEpk16fYpP6JtMQpqEMzcOfQGAHXBTEGzuLJ03GYQL9bmV2/7ExDlRf+Uvf1sM2frRtCWmal12pMgtonvSCtR4n1CLUZRdTHDHP1Otwqd+rcdlavnKjUB/OYXQHUJzpNyFoKpQK+2OgrEKpGyIgIBgn2y9QHnTJihZOpEvOKIoHAMGAXHmj21Lym39Mbiow4IF+77xNuewziNVBxr6KD5e+9HzZSBIlUa/AmsDFJFXeyrQakR3FwowTGcADJHcEfhGkXYNGSYo4dh4bxwLM+28xjiqkdn0/3R4UEkvcBrBfn/SzBc1XhKM2VPlJgKSorjDac96V2UnQYXl1/yZPT4DVelgO+soMjexXwYO58VLl5xInQUZI8jc3H2CPnCNb9X05nOxIy4MlecasTqGK6s2az4RjpF2cQP2G28R+7wDPsZDZC/kWtjdoHC7SpdPmqQrUAhMwKVuxCmYTiD9q/O7GHtZvPSN0CAUQN/rymXZNniYLlJDE70bsk6Xxsh4kDOdxe7A2wo7P9F5YvqqRDI6brf79yPCSp4I0jVoO4YnLYtX5nzspR5WB4AKOYtR1ujXbOQpPyYDvfRE3FN5zw0i7reehdi7yV0YDRKRllGCGRk5Yz+Uv1fYl2ZwrnGsqsjgAVo0xEUba8ohjaNMJNwTwZA/wBDWFSCpg1eUH8MYL2zdioxRTqgGQrDZxQyNzyBJPXZF0+oxITJAbj7oNC5JwgDMUJaM5GqlGCWc//KCIrI+aclEe4IA0uzv7cuj6GCdaJONpi13O544vbtIHBF+A+JeDFUQNy61Gki3rtyQ4aUywn6ru314/dkGiP8Iwjo0J/2Txs49ZkwEl4mx+iYUUO55I6pJzU4P+7RRs+DXZkyKUYZqVWrPF4I94m4Wx1tXeE74o9GuX977yvJ/jkdak8+AmoHVjI15V+WwBdARFV2IPirJgVMdsg1Pez2VNHqa7EHWdTkl3XTcyjG9BiueWFvQfXI8aWSkuuRmqi/HUuzqyvLJfNfs0txMqldYYflWB1BS31WkuPJGGwXUCpjiQSktkuBMWwHjSkQxeehqw1Kgz0Trzm7QbtgxiEPDVmWCNCAeCfROTphd1ZNOhzLy6XfJyG6Xgd5MCAZw4xie0Sj5AnY1/akDgNS9YFl3Y06vd6FAsg2gVQJtzG7LVq1OH2frbXNHWH/NY89NNZ4QUSJqL2yEcGADbT38X0bGdukqYlSoliKOcsSTuqhcaemUeYLLoI8+MZor2RxXTRThF1LrHfqf/5LcLAjdl4EERgUysYS2geE+yFdasU91UgUDsc2cSQ1ZoT9+uLOwdgAmifwQqF028INc2IQEDfTmUw3eZxvz7Ud1z3xc1PQfeCvfKsB9jOhRj7rFyb9XcDWLcYj0bByosychMezMLVkFiYcdBBQtvI6K0KRuOZQH2kBsYHJaXTkup8F0eIhO1/GcIwWKpr2mouB7g5TUDJNvORXPXa/mU8bh27TAZYBe2sKx4NSv5OjnHIWD2RuysCzBlUfeNXhDd2jxnHoUlheJ3jBApzURy0fwm2FwwsSU0caQGl0Kv8hopRQE211NnvtLRsmCNrhhpEDoNiZEzD2QdJWKbRRWnaFedXHAELSN0t0bfsCsMf0ktfBoXBoNA+nZN9+pSlmuzspFevmsqqcMllzzvkyXrzoA+Ryo1ePXpdGOoJvhyru+EBRsmOp7MXZ0vNUMUqHLUoKglg1p73sWeZmPc+KAw0pE2zIsFFE5H4192KwDvDxdxEYoDBDNZjbg2bmADTeUKK57IPD4fTYF4c6EnXx/teYMORBDtIhPJneiZny7Nv/zG+YmekIKCoxr6kauE2bZtBLufetNG0BtBY7f+/ImUypMBvdWu/Q7vTMRzw5aQGZWuc1V0HEsItFYMIBnoKGZ0xcarba/TYZq50kCaflFysYjA4EDKHqGdpYWdKYmm+a7TADmW35yfnOYpZYrkpVEtiqF0EujI00aeplNs2k+qyFZNeE3CDPL9P6b4PQ/kataHkVpLSEVGK7EX6rAa7IVNrvZtFvOA6okKvBgMtFDAGZOx88MeBcJ8AR3AgUUeIznAN6tjCUipGDZONm1FjWJp4A3QIzSaIOmZ7DvF/ysYYbM/fFDOV0jntAjRdapxJxL0eThpEhKOjCDDq2ks+3GrwxqIFKLe1WdOzII8XIOPGnwy6LKXVfpSDOTEfaRsGujhpS4hBIsMOqHbl16PJxc4EkaVu9wpEYlF/84NSv5Zum4drMfp9yXbzzAOJqqS4YkI4cBrFrC7bMPiCfgI3nNZAqkk3QOZqR+yyqx+nDQKBBBZ7QKrfGMCL+XpqFaBJU0wpkBdAhbR4hJsmT5aynlvkouoxm/NjD5oe6BzVIO9uktM+/5dEC5P7vZvarmuO/lKXz4sBabVPIATuKTrwbJP8XUkdM6uEctHKXICUJGjaZIWRbZp8czquQYfY6ynBUCfIU+gG6wqSIBmYIm9pZpXdaL121V7q0VjDjmQnXvMe7ysoEZnZL15B0SpxS1jjd83uNIOKZwu5MPzg2NhOx3xMOPYwEn2CUzbSrwAs5OAtrz3GAaUkJOU74XwjaYUmGJdZBS1NJVkGYrToINLKDjxcuIlyfVsKQSG/G4DyiO2SlQvJ0d0Ot1uOG5IFSAkq+PRVMgVMDvOIJMdqjeCFKUGRWBW9wigYvcbU7CQL/7meF2KZAaWl+4y9uhowAX7elogAvItAAxo2+SFxGRsHGEW9BnhlTuWigYxRcnVUBRQHV41LV+Fr5CJYV7sHfeywswx4XMtUx6EkBhR+q8AXXUA8uPJ73Pb49i9KG9fOljvXeyFj9ixgbo6CcbAJ7WHWqKHy/h+YjBwp6VcN7M89FGzQ04qbrQtgrOFybg3gQRTYG5xn73ArkfQWjCJROwy3J38Dx/D7jOa6BBNsitEw1wGq780EEioOeD+ZGp2J66ADiVGMayiHYucMk8nTK2zzT9CnEraAk95kQjy4k0GRElLL5YAKLQErJ5rp1eay9O4Fb6yJGm9U4FaMwPGxtKD6odIIHKoWnhKo1U8KIpFC+MVn59ZXmc7ZTBZfsg6FQ8W10YfTr4u0nYrpHZbZ1jXiLmooF0cOm0+mPnJBXQtepc7n0BqOipNCqI6yyloTeRShNKH04FIo0gcMk0H/xThyN4pPAWjDDkEp3lNNPRNVfpMI44CWRlRgViP64eK0JSRp0WUvCWYumlW/c58Vcz/yMwVcW5oYb9+26TEhwvbxiNg48hl1VI1UXTU//Eta+BMKnGUivctfL5wINDD0giQL1ipt6U7C9cd4+lgqY2lMUZ02Uv6Prs+ZEZer7ZfWBXVghlfOOrClwsoOFKzWEfz6RZu1eCs+K8fLvkts5+BX0gyrFYve0C3qHrn5U/Oh6D/CihmWIrY7HUZRhJaxde+tldu6adYJ+LeXupQw0XExC36RETdNFxcq9glMu4cNQSX9cqR/GQYp+IxUkIcNGWVU7ZtGa6P3XAyodRt0XeS3Tp01AnCh0ZbUh4VrSZeV9RWfSoWyxnY3hzcZ30G/InDq4wxRrEejreBxnhIQbkxenxkaxl+k7eLUQkUR6vKJ2iDFNGX3WmVA1yaOH+mvhBd+sE6vacQzFobwY5BqEAFmejwW5ne7HtVNolOUgJc8CsUxmc/LBi8N5mu9VsIA5HyErnS6zeCz7VLI9+n/hbT6hTokMXTVyXJRKSG2hd2labXTbtmK4fNH3IZBPreSA4FMeVouVN3zG5x9CiGpLw/3pceo4qGqp+rVp+z+7yQ98oEf+nyH4F3+J9IheDBa94Wi63zJbLBCIZm7P0asHGpIJt3PzE3m0S4YIWyXBCVXGikj8MudDPB/6Nm2v4IxJ5gU0ii0guy5SUHqGUYzTP0jIJU5E82RHUXtX4lDdrihBLdP1YaG1AGUC12rQKuIaGvCpMjZC9bWSCYnjDlvpWbkdXMTNeBHLKiuoozMGIvkczmP0aRJSJ8PYnLCVNhKHXBNckH79e8Z8Kc2wUej4sQZoH8qDRGkg86maW/ZQWGNnLcXmq3FlXM6ssR/3P6E/bHMvm6HLrv1yRixit25JsH3/IOr2UV4BWJhxXW5BJ6Xdr07n9kF3ZNAk6/Xpc5MSFmYJ2R7bdL8Kk7q1OU9Elg/tCxJ8giT27wSTySF0GOxg4PbYJdi/Nyia9Nn89CGDulfJemm1aiEr/eleGSN+5MRrVJ4K6lgyTTIW3i9cQ0dAi6FHt0YMbH3wDSAtGLSAccezzxHitt1QdhW36CQgPcA8vIIBh3/JNjf/Obmc2yzpk8edSlS4lVdwgW5vzbYEyFoF4GCBBby1keVNueHAH+evi+H7oOVfS3XuPQSNTXOONAbzJeSb5stwdQHl1ZjrGoE49I8+A9j3t+ahhQj74FCSWpZrj7wRSFJJnnwi1T9HL5qrCFW/JZq6P62XkMWTb+u4lGpKfmmwiJWx178GOG7KbrZGqyWwmuyKWPkNswkZ1q8uptUlviIi+AXh2bOOTOLsrtNkfqbQJeh24reebkINLkjut5r4d9GR/r8CBa9SU0UQhsnZp5cP+RqWCixRm7i4YRFbtZ4EAkhtNa6jHb6gPYQv7MKqkPLRmX3dFsK8XsRLVZ6IEVrCbmNDc8o5mqsogjAQfoC9Bc7R6gfw03m+lQpv6kTfhxscDIX6s0w+fBxtkhjXAXr10UouWCx3C/p/FYwJRS/AXRKkjOb5CLmK4XRe0+xeDDwVkJPZau52bzLEDHCqV0f44pPgKOkYKgTZJ33fmk3Tu8SdxJ02SHM8Fem5SMsWqRyi2F1ynfRJszcFKykdWlNqgDA/L9lKYBmc7Zu/q9ii1FPF47VJkqhirUob53zoiJtVVRVwMR34gV9iqcBaHbRu9kkvqk3yMpfRFG49pKKjIiq7h/VpRwPGTHoY4cg05X5028iHsLvUW/uz+kjPyIEhhcKUwCkJAwbR9pIEGOn8z6svAO8i89sJ3dL5qDWFYbS+HGPRMxYwJItFQN86YESeJQhn2urGiLRffQeLptDl8dAgb+Tp47UQPxWOw17OeChLN1WnzlkPL1T5O+O3Menpn4C3IY5LEepHpnPeZHbvuWfeVtPlkH4LZjPbBrkJT3NoRJzBt86CO0Xq59oQ+8dsm0ymRcmQyn8w71mhmcuEI5byuF+C88VPYly2sEzjlzAQ3vdn/1+Hzguw6qFNNbqenhZGbdiG6RwZaTG7jTA2X9RdXjDN9yj1uQpyO4Lx8KRAcZcbZMafp4wPOd5MdXoFY52V1A8M9hi3sso93+uprE0qYNMjkE22CvK4HuUxqN7oIz5pWuETq1lQAjqlSlqdD2Rnr/ggp/TVkQYjn9lMfYelk2sH5HPdopYo7MHwlV1or9Bxf+QCyLzm92vzG2wjiIjC/ZHEJzeroJl6bdFPTpZho5MV2U86fLQqxNlGIMqCGy+9WYhJ8ob1r0+Whxde9L2PdysETv97O+xVw+VNN1TZSQN5I6l9m5Ip6pLIqLm4a1B1ffH6gHyqT9p82NOjntRWGIofO3bJz5GhkvSWbsXueTAMaJDou99kGLqDlhwBZNEQ4mKPuDvVwSK4WmLluHyhA97pZiVe8g+JxmnJF8IkV/tCs4Jq/HgOoAEGR9tCDsDbDmi3OviUQpG5D8XmKcSAUaFLRXb2lmJTNYdhtYyfjBYZQmN5qT5CNuaD3BVnlkCk7bsMW3AtXkNMMTuW4HjUERSJnVQ0vsBGa1wo3Qh7115XGeTF3NTz8w0440AgU7c3bSXO/KMINaIWXd0oLpoq/0/QJxCQSJ9XnYy1W7TYLBJpHsVWD1ahsA7FjNvRd6mxCiHsm8g6Z0pnzqIpF1dHUtP2ITU5Z1hZHbu+L3BEEStBbL9XYvGfEakv1bmf+bOZGnoiuHEdlBnaChxYKNzB23b8sw8YyT7Ajxfk49eJIAvdbVkdFCe2J0gMefhQ0bIZxhx3fzMIysQNiN8PgOUKxOMur10LduigREDRMZyP4oGWrP1GFY4t6groASsZ421os48wAdnrbovNhLt7ScNULkwZ5AIZJTrbaKYTLjA1oJ3sIuN/aYocm/9uoQHEIlacF1s/TM1fLcPTL38O9fOsjMEIwoPKfvt7opuI9G2Hf/PR4aCLDQ7wNmIdEuXJ/QNL72k5q4NejAldPfe3UVVqzkys8YZ/jYOGOp6c+YzRCrCuq0M11y7TiN6qk7YXRMn/gukxrEimbMQjr3jwRM6dKVZ4RUfWQr8noPXLJq6yh5R3EH1IVOHESst/LItbG2D2vRsZRkAObzvQAAD3mb3/G4NzopI0FAiHfbpq0X72adg6SRj+8OHMShtFxxLZlf/nLgRLbClwl5WmaYSs+yEjkq48tY7Z2bE0N91mJwt+ua0NlRJIDh0HikF4UvSVorFj2YVu9YeS5tfvlVjPSoNu/Zu6dEUfBOT555hahBdN3Sa5Xuj2Rvau1lQNIaC944y0RWj9UiNDskAK1WoL+EfXcC6IbBXFRyVfX/WKXxPAwUyIAGW8ggZ08hcijKTt1YKnUO6QPvcrmDVAb0FCLIXn5id4fD/Jx4tw/gbXs7WF9b2RgXtPhLBG9vF5FEkdHAKrQHZAJC/HWvk7nvzzDzIXZlfFTJoC3JpGgLPBY7SQTjGlUvG577yNutZ1hTfs9/1nkSXK9zzKLRZ3VODeKUovJe0WCq1zVMYxCJMenmNzPIU2S8TA4E7wWmbNkxq9rI2dd6v0VpcAPVMxnDsvWTWFayyqvKZO7Z08a62i/oH2/jxf8rpmfO64in3FLiL1GX8IGtVE9M23yGsIqJbxDTy+LtaMWDaPqkymb5VrQdzOvqldeU0SUi6IirG8UZ3jcpRbwHa1C0Dww9G/SFX3gPvTJQE+kyz+g1BeMILKKO+olcHzctOWgzxYHnOD7dpCRtuZEXACjgqesZMasoPgnuDC4nUviAAxDc5pngjoAITIkvhKwg5d608pdrZcA+qn5TMT6Uo/QzBaOxBCLTJX3Mgk85rMfsnWx86oLxf7p2PX5ONqieTa/qM3tPw4ZXvlAp83NSD8F7+ZgctK1TpoYwtiU2h02HCGioH5tkVCqNVTMH5p00sRy2JU1qyDBP2CII/Dg4WDsIl+zgeX7589srx6YORRQMBfKbodbB743Tl4WLKOEnwWUVBsm94SOlCracU72MSyj068wdpYjyz1FwC2bjQnxnB6Mp/pZ+yyZXtguEaYB+kqhjQ6UUmwSFazOb+rhYjLaoiM+aN9/8KKn0zaCTFpN9eKwWy7/u4EHzO46TdFSNjMfn2iPSJwDPCFHc0I1+vjdAZw5ZjqR/uzi9Zn20oAa5JnLEk/EA3VRWE7J/XrupfFJPtCUuqHPpnlL7ISJtRpSVcB8qsZCm2QEkWoROtCKKxUh3yEcMbWYJwk6DlEBG0bZP6eg06FL3v6RPb7odGuwm7FN8fG4woqtB8e7M5klPpo97GoObNwt+ludTAmxyC5hmcFx+dIvEZKI6igFKHqLH01iY1o7903VzG9QGetyVx5RNmBYUU+zIuSva/yIcECUi4pRmE3VkF2avqulQEUY4yZ/wmNboBzPmAPey3+dSYtBZUjeWWT0pPwCz4Vozxp9xeClIU60qvEFMQCaPvPaA70WlOP9f/ey39macvpGCVa+zfa8gO44wbxpJUlC8GN/pRMTQtzY8Z8/hiNrU+Zq64ZfFGIkdj7m7abcK1EBtws1X4J/hnqvasPvvDSDYWN+QcQVGMqXalkDtTad5rYY0TIR1Eqox3czwPMjKPvF5sFv17Thujr1IZ1Ytl4VX1J0vjXKmLY4lmXipRAro0qVGEcXxEVMMEl54jQMd4J7RjgomU0j1ptjyxY+cLiSyXPfiEcIS2lWDK3ISAy6UZ3Hb5vnPncA94411jcy75ay6B6DSTzK6UTCZR9uDANtPBrvIDgjsfarMiwoax2OlLxaSoYn4iRgkpEGqEkwox5tyI8aKkLlfZ12lO11TxsqRMY89j5JaO55XfPJPDL1LGSnC88Re9Ai+Nu5bZjtwRrvFITUFHPR4ZmxGslQMecgbZO7nHk32qHxYkdvWpup07ojcMCaVrpFAyFZJJbNvBpZfdf39Hdo2kPtT7v0/f8R/B5Nz4f1t9/3zNM/7n6SUHfcWk5dfQFJvcJMgPolGCpOFb/WC0FGWU2asuQyT+rm88ZKZ78Cei/CAh939CH0JYbpZIPtxc2ufXqjS3pHH9lnWK4iJ7OjR/EESpCo2R3MYKyE7rHfhTvWho4cL1QdN4jFTyR6syMwFm124TVDDRXMNveI1Dp/ntwdz8k8kxw7iFSx6+Yx6O+1LzMVrN0BBzziZi9kneZSzgollBnVwBh6oSOPHXrglrOj+QmR/AESrhDpKrWT+8/AiMDxS/5wwRNuGQPLlJ9ovomhJWn8sMLVItQ8N/7IXvtD8kdOoHaw+vBSbFImQsv/OCAIui99E+YSIOMlMvBXkAt+NAZK8wB9Jf8CPtB+TOUOR+z71d/AFXpPBT6+A5FLjxMjLIEoJzrQfquvxEIi+WoUzGR1IzQFNvbYOnxb2PyQ0kGdyXKzW2axQL8lNAXPk6NEjqrRD1oZtKLlFoofrXw0dCNWASHzy+7PSzOUJ3XtaPZsxLDjr+o41fKuKWNmjiZtfkOzItvlV2MDGSheGF0ma04qE3TUEfqJMrXFm7DpK+27DSvCUVf7rbNoljPhha5W7KBqVq0ShUSTbRmuqPtQreVWH4JET5yMhuqMoSd4r/N8sDmeQiQQvi1tcZv7Moc7dT5X5AtCD6kNEGZOzVcNYlpX4AbTsLgSYYliiPyVoniuYYySxsBy5cgb3pD+EK0Gpb0wJg031dPgaL8JZt6sIvzNPEHfVPOjXmaXj4bd4voXzpZ5GApMhILgMbCEWZ2zwgdeQgjNHLbPIt+KqxRwWPLTN6HwZ0Ouijj4UF+Sg0Au8XuIKW0WxlexdrFrDcZJ8Shauat3X0XmHygqgL1nAu2hrJFb4wZXkcS+i36KMyU1yFvYv23bQUJi/3yQpqr/naUOoiEWOxckyq/gq43dFou1DVDaYMZK9tho7+IXXokBCs5GRfOcBK7g3A+jXQ39K4YA8PBRW4m5+yR0ZAxWJncjRVbITvIAPHYRt1EJ3YLiUbqIvoKHtzHKtUy1ddRUQ0AUO41vonZDUOW+mrszw+SW/6Q/IUgNpcXFjkM7F4CSSQ2ExZg85otsMs7kqsQD4OxYeBNDcSpifjMoLb7GEbGWTwasVObmB/bfPcUlq0wYhXCYEDWRW02TP5bBrYsKTGWjnWDDJ1F7zWai0zW/2XsCuvBQjPFcTYaQX3tSXRSm8hsAoDdjArK/OFp6vcWYOE7lizP0Yc+8p16i7/NiXIiiQTp7c7Xus925VEtlKAjUdFhyaiLT7VxDagprMFwix4wZ05u0qj7cDWFd0W9OYHIu3JbJKMXRJ1aYNovugg+QqRN7fNHSi26VSgBpn+JfMuPo3aeqPWik/wI5Rz3BWarPQX4i5+dM0npwVOsX+KsOhC7vDg+OJsz4Q5zlnIeflUWL6QYMbf9WDfLmosLF4Qev3mJiOuHjoor/dMeBpA9iKDkMjYBNbRo414HCxjsHrB4EXNbHzNMDHCLuNBG6Sf+J4MZ/ElVsDSLxjIiGsTPhw8BPjxbfQtskj+dyNMKOOcUYIRBEIqbazz3lmjlRQhplxq673VklMMY6597vu+d89ec/zq7Mi4gQvh87ehYbpOuZEXj5g/Q7S7BFDAAB9DzG35SC853xtWVcnZQoH54jeOqYLR9NDuwxsVthTV7V99n/B7HSbAytbEyVTz/5NhJ8gGIjG0E5j3griULUd5Rg7tQR+90hJgNQKQH2btbSfPcaTOfIexc1db1BxUOhM1vWCpLaYuKr3FdNTt/T3PWCpEUWDKEtzYrjpzlL/wri3MITKsFvtF8QVV/NhVo97aKIBgdliNc10dWdXVDpVtsNn+2UIolrgqdWA4EY8so0YvB4a+aLzMXiMAuOHQrXY0tr+CL10JbvZzgjJJuB1cRkdT7DUqTvnswVUp5kkUSFVtIIFYK05+tQxT6992HHNWVhWxUsD1PkceIrlXuUVRogwmfdhyrf6zzaL8+c0L7GXMZOteAhAVQVwdJh+7nrX7x4LaIIfz2F2v7Dg/uDfz2Fa+4gFm2zHAor8UqimJG3VTJtZEoFXhnDYXvxMJFc6ku2bhbCxzij2z5UNuK0jmp1mnvkVNUfR+SEmj1Lr94Lym75PO7Fs0MIr3GdsWXRXSfgLTVY0FLqba97u1In8NAcY7IC6TjWLigwKEIm43NxTdaVTv9mcKkzuzBkKd8x/xt1p/9BbP7Wyb4bpo1K1gnOpbLvKz58pWl3B55RJ/Z5mRDLPtNQg14jdOEs9+h/V5UVpwrAI8kGbX8KPVPDIMfIqKDjJD9UyDOPhjZ3vFAyecwyq4akUE9mDOtJEK1hpDyi6Ae87sWAClXGTiwPwN7PXWwjxaR79ArHRIPeYKTunVW24sPr/3HPz2IwH8oKH4OlWEmt4BLM6W5g4kMcYbLwj2usodD1088stZA7VOsUSpEVl4w7NMb1EUHMRxAxLF0CIV+0L3iZb+ekB1vSDSFjAZ3hfLJf7gFaXrOKn+mhR+rWw/eTXIcAgl4HvFuBg1LOmOAwJH3eoVEjjwheKA4icbrQCmvAtpQ0mXG0agYp5mj4Rb6mdQ+RV4QBPbxMqh9C7o8nP0Wko2ocnCHeRGhN1XVyT2b9ACsL+6ylUy+yC3QEnaKRIJK91YtaoSrcWZMMwxuM0E9J68Z+YyjA0g8p1PfHAAIROy6Sa04VXOuT6A351FOWhKfTGsFJ3RTJGWYPoLk5FVK4OaYR9hkJvezwF9vQN1126r6isMGXWTqFW+3HL3I/jurlIdDWIVvYY+s6yq7lrFSPAGRdnU7PVwY/SvWbZGpXzy3BQ2LmAJlrONUsZs4oGkly0V267xbD5KMY8woNNsmWG1VVgLCra8aQBBcI4DP2BlNwxhiCtHlaz6OWFoCW0vMR3ErrG7JyMjTSCnvRcsEHgmPnwA6iNpJ2DrFb4gLlhKJyZGaWkA97H6FFdwEcLT6DRQQL++fOkVC4cYGW1TG/3iK5dShRSuiBulmihqgjR45Vi03o2RbQbP3sxt90VxQ6vzdlGfkXmmKmjOi080JSHkLntjvsBJnv7gKscOaTOkEaRQqAnCA4HWtB4XnMtOhpRmH2FH8tTXrIjAGNWEmudQLCkcVlGTQ965Kh0H6ixXbgImQP6b42B49sO5C8pc7iRlgyvSYvcnH9FgQ3azLbQG2cUW96SDojTQStxkOJyOuDGTHAnnWkz29aEwN9FT8EJ4yhXOg+jLTrCPKeEoJ9a7lDXOjEr8AgX4BmnMQ668oW0zYPyQiVMPxKRHtpfnEEyaKhdzNVThlxxDQNdrHeZiUFb6NoY2KwvSb7BnRcpJy+/g/zAYx3fYSN5QEaVD2Y1VsNWxB0BSO12MRsRY8JLfAezRMz5lURuLUnG1ToKk6Q30FughqWN6gBNcFxP/nY/iv+iaUQOa+2Nuym46wtI/DvSfzSp1jEi4SdYBE7YhTiVV5cX9gwboVDMVgZp5YBQlHOQvaDNfcCoCJuYhf5kz5kwiIKPjzgpcRJHPbOhJajeoeRL53cuMahhV8Z7IRr6M4hW0JzT7mzaMUzQpm866zwM7Cs07fJYXuWvjAMkbe5O6V4bu71sOG6JQ4oL8zIeXHheFVavzxmlIyBkgc9IZlEDplMPr8xlcyss4pVUdwK1e7CK2kTsSdq7g5SHRAl3pYUB9Ko4fsh4qleOyJv1z3KFSTSvwEcRO/Ew8ozEDYZSqpfoVW9uhJfYrNAXR0Z3VmeoAD+rVWtwP/13sE/3ICX3HhDG3CMc476dEEC0K3umSAD4j+ZQLVdFOsWL2C1TH5+4KiSWH+lMibo+B55hR3Gq40G1n25sGcN0mEcoU2wN9FCVyQLBhYOu9aHVLWjEKx2JIUZi5ySoHUAI9b8hGzaLMxCZDMLhv8MkcpTqEwz9KFDpCpqQhVmsGQN8m24wyB82FAKNmjgfKRsXRmsSESovAwXjBIoMKSG51p6Um8b3i7GISs7kjTq/PZoioCfJzfKdJTN0Q45kQEQuh9H88M3yEs3DbtRTKALraM0YC8laiMiOOe6ADmTcCiREeAWZelBaEXRaSuj2lx0xHaRYqF65O0Lo5OCFU18A8cMDE4MLYm9w2QSr9NgQAIcRxZsNpA7UJR0e71JL+VU+ISWFk5I97lra8uGg7GlQYhGd4Gc6rxsLFRiIeGO4abP4S4ekQ1fiqDCy87GZHd52fn5aaDGuvOmIofrzpVwMvtbreZ/855OaXTRcNiNE0wzGZSxbjg26v8ko8L537v/XCCWP2MFaArJpvnkep0pA+O86MWjRAZPQRfznZiSIaTppy6m3p6HrNSsY7fDtz7Cl4V/DJAjQDoyiL2uwf1UHVd2AIrzBUSlJaTj4k6NL97a/GqhWKU9RUmjnYKpm2r+JYUcrkCuZKvcYvrg8pDoUKQywY9GDWg03DUFSirlUXBS5SWn/KAntnf0IdHGL/7mwXqDG+LZYjbEdQmqUqq4y54TNmWUP7IgcAw5816YBzwiNIJiE9M4lPCzeI/FGBeYy3p6IAmH4AjXXmvQ4Iy0Y82NTobcAggT2Cdqz6Mx4TdGoq9fn2etrWKUNFyatAHydQTVUQ2S5OWVUlugcNvoUrlA8cJJz9MqOa/W3iVno4zDHfE7zhoY5f5lRTVZDhrQbR8LS4eRLz8iPMyBL6o4PiLlp89FjdokQLaSBmKHUwWp0na5fE3v9zny2YcDXG/jfI9sctulHRbdkI5a4GOPJx4oAJQzVZ/yYAado8KNZUdEFs9ZPiBsausotXMNebEgr0dyopuqfScFJ3ODNPHgclACPdccwv0YJGQdsN2lhoV4HVGBxcEUeUX/alr4nqpcc1CCR3vR7g40zteQg/JvWmFlUE4mAiTpHlYGrB7w+U2KdSwQz2QJKBe/5eiixWipmfP15AFWrK8Sh1GBBYLgzki1wTMhGQmagXqJ2+FuqJ8f0XzXCVJFHQdMAw8xco11HhM347alrAu+wmX3pDFABOvkC+WPX0Uhg1Z5MVHKNROxaR84YV3s12UcM+70cJ460SzEaKLyh472vOMD3XnaK7zxZcXlWqenEvcjmgGNR2OKbI1s8U+iwiW+HotHalp3e1MGDy6BMVIvajnAzkFHbeVsgjmJUkrP9OAwnEHYXVBqYx3q7LvXjoVR0mY8h+ZaOnh053pdsGkmbqhyryN01eVHySr+CkDYkSMeZ1xjPNVM+gVLTDKu2VGsMUJqWO4TwPDP0VOg2/8ITbAUaMGb4LjL7L+Pi11lEVMXTYIlAZ/QHmTENjyx3kDkBdfcvvQt6tKk6jYFM4EG5UXDTaF5+1ZjRz6W7MdJPC+wTkbDUim4p5QQH3b9kGk2Bkilyeur8Bc20wm5uJSBO95GfYDI1EZipoRaH7uVveneqz43tlTZGRQ4a7CNmMHgXyOQQOL6WQkgMUTQDT8vh21aSdz7ERiZT1jK9F+v6wgFvuEmGngSvIUR2CJkc5tx1QygfZnAruONobB1idCLB1FCfO7N1ZdRocT8/Wye+EnDiO9pzqIpnLDl4bkaRKW+ekBVwHn46Shw1X0tclt/0ROijuUB4kIInrVJU4buWf4YITJtjOJ6iKdr1u+flgQeFH70GxKjhdgt/MrwfB4K/sXczQ+9zYcrD4dhY6qZhZ010rrxggWA8JaZyg2pYij8ieYEg1aZJkZK9O1Re7sB0iouf60rK0Gd+AYlp7soqCBCDGwfKeUQhCBn0E0o0GS6PdmjLi0TtCYZeqazqwN+yNINIA8Lk3iPDnWUiIPLGNcHmZDxfeK0iAdxm/T7LnN+gemRL61hHIc0NCAZaiYJR+OHnLWSe8sLrK905B5eEJHNlWq4RmEXIaFTmo49f8w61+NwfEUyuJAwVqZCLFcyHBKAcIVj3sNzfEOXzVKIndxHw+AR93owhbCxUZf6Gs8cz6/1VdrFEPrv330+9s6BtMVPJ3zl/Uf9rUi0Z/opexfdL3ykF76e999GPfVv8fJv/Y/+/5hEMon1tqNFyVRevV9y9/uIvsG3dbB8GRRrgaEXfhx+2xeOFt+cEn3RZanNxdEe2+B6MHpNbrRE53PlDifPvFcp4kO78ILR0T4xyW/WGPyBsqGdoA7zJJCu1TKbGfhnqgnRbxbB2B3UZoeQ2bz2sTVnUwokTcTU21RxN1PYPS3Sar7T0eRIsyCNowr9amwoMU/od9s2APtiKNL6ENOlyKADstAEWKA+sdKDhrJ6BOhRJmZ+QJbAaZ3/5Fq0/lumCgEzGEbu3yi0Y4I4EgVAjqxh4HbuQn0GrRhOWyAfsglQJAVL1y/6yezS2k8RE2MstJLh92NOB3GCYgFXznF4d25qiP4ZCyI4RYGesut6FXK6GwPpKK8WHEkhYui0AyEmr5Ml3uBFtPFdnioI8RiCooa7Z1G1WuyIi3nSNglutc+xY8BkeW3JJXPK6jd2VIMpaSxpVtFq+R+ySK9J6WG5Qvt+C+QH1hyYUOVK7857nFmyDBYgZ/o+AnibzNVqyYCJQvyDXDTK+iXdkA71bY7TL3bvuLxLBQ8kbTvTEY9aqkQ3+MiLWbEgjLzOH+lXgco1ERgzd80rDCymlpaRQbOYnKG/ODoFl46lzT0cjM5FYVvv0qLUbD5lyJtMUaC1pFlTkNONx6lliaX9o0i/1vws5bNKn5OuENQEKmLlcP4o2ZmJjD4zzd3Fk32uQ4uRWkPSUqb4LBe3EXHdORNB2BWsws5daRnMfNVX7isPSb1hMQdAJi1/qmDMfRUlCU74pmnzjbXfL8PVG8NsW6IQM2Ne23iCPIpryJjYbVnm5hCvKpMa7HLViNiNc+xTfDIaKm3jctViD8A1M9YPJNk003VVr4Zo2MuGW8vil8SLaGpPXqG7I4DLdtl8a4Rbx1Lt4w5Huqaa1XzZBtj208EJVGcmKYEuaeN27zT9EE6a09JerXdEbpaNgNqYJdhP1NdqiPKsbDRUi86XvvNC7rME5mrSQtrzAZVndtSjCMqd8BmaeGR4l4YFULGRBeXIV9Y4yxLFdyoUNpiy2IhePSWzBofYPP0eIa2q5JP4j9G8at/AqoSsLAUuRXtvgsqX/zYwsE+of6oSDbUOo4RMJw+DOUTJq+hnqwKim9Yy/napyZNTc2rCq6V9jHtJbxGPDwlzWj/Sk3zF/BHOlT/fSjSq7FqlPI1q6J+ru8Aku008SFINXZfOfnZNOvGPMtEmn2gLPt+H4QLA+/SYe4j398auzhKIp2Pok3mPC5q1IN1HgR+mnEfc4NeeHYwd2/kpszR3cBn7ni9NbIqhtSWFW8xbUJuUPVOeeXu3j0IGZmFNiwaNZ6rH4/zQ2ODz6tFxRLsUYZu1bfd1uIvfQDt4YD/efKYv8VF8bHGDgK22w2Wqwpi43vNCOXFJZCGMqWiPbL8mil6tsmOTXAWCyMCw73e2rADZj2IK6rqksM3EXF2cbLb4vjB14wa/yXK5vwU+05MzERJ5nXsXsW21o7M+gO0js2OyKciP5uF2iXyb2DiptwQeHeqygkrNsqVCSlldxBMpwHi1vfc8RKpP/4L3Lmpq6DZcvhDDfxTCE3splacTcOtXdK2g303dIWBVe2wD/Gvja1cClFQ67gw0t1ZUttsUgQ1Veky8oOpS6ksYEc4bqseCbZy766SvL3FodmnahlWJRgVCNjPxhL/fk2wyvlKhITH/VQCipOI0dNcRa5B1M5HmOBjTLeZQJy237e2mobwmDyJNHePhdDmiknvLKaDbShL+Is1XTCJuLQd2wmdJL7+mKvs294whXQD+vtd88KKk0DXP8B1Xu9J+xo69VOuFgexgTrcvI6SyltuLix9OPuE6/iRJYoBMEXxU4shQMf4Fjqwf1PtnJ/wWSZd29rhZjRmTGgiGTAUQqRz+nCdjeMfYhsBD5Lv60KILWEvNEHfmsDs2L0A252351eUoYxAysVaCJVLdH9QFWAmqJDCODUcdoo12+gd6bW2boY0pBVHWL6LQDK5bYWh1V8vFvi0cRpfwv7cJiMX3AZNJuTddHehTIdU0YQ/sQ1dLoF2xQPcCuHKiuCWOY30DHe1OwcClLAhqAKyqlnIbH/8u9ScJpcS4kgp6HKDUdiOgRaRGSiUCRBjzI5gSksMZKqy7Sd51aeg0tgJ+x0TH9YH2Mgsap9N7ENZdEB0bey2DMTrBA1hn56SErNHf3tKtqyL9b6yXEP97/rc+jgD2N1LNUH6RM9AzP3kSipr06RkKOolR7HO768jjWiH1X92jA7dkg7gcNcjqsZCgfqWw0tPXdLg20cF6vnQypg7gLtkazrHAodyYfENPQZsdfnjMZiNu4nJO97D1/sQE+3vNFzrSDOKw+keLECYf7RJwVHeP/j79833oZ0egonYB2FlFE5qj02B/LVOMJQlsB8uNg3Leg4qtZwntsOSNidR0abbZmAK4sCzvt8Yiuz2yrNCJoH5O8XvX/vLeR/BBYTWj0sOPYM/jyxRd5+/JziKAABaPcw/34UA3aj/gLZxZgRCWN6m4m3demanNgsx0P237/Q+Ew5VYnJPkyCY0cIVHoFn2Ay/e7U4P19APbPFXEHX94N6KhEMPG7iwB3+I+O1jd5n6VSgHegxgaSawO6iQCYFgDsPSMsNOcUj4q3sF6KzGaH/0u5PQoAj/8zq6Uc9MoNrGqhYeb2jQo0WlGlXjxtanZLS24/OIN5Gx/2g684BPDQpwlqnkFcxpmP/osnOXrFuu4PqifouQH0eF5qCkvITQbJw/Zvy5mAHWC9oU+cTiYhJmSfKsCyt1cGVxisKu+NymEQIAyaCgud/V09qT3nk/9s/SWsYtha7yNpzBIMM40rCSGaJ9u6lEkl00vXBiEt7p9P5IBCiavynEOv7FgLqPdeqxRiCwuFVMolSIUBcoyfUC2e2FJSAUgYdVGFf0b0Kn2EZlK97yyxrT2MVgvtRikfdaAW8RwEEfN+B7/eK8bBdp7URpbqn1xcrC6d2UjdsKbzCjBFqkKkoZt7Mrhg6YagE7spkqj0jOrWM+UGQ0MUlG2evP1uE1p2xSv4dMK0dna6ENcNUF+xkaJ7B764NdxLCpuvhblltVRAf7vK5qPttJ/9RYFUUSGcLdibnz6mf7WkPO3MkUUhR2mAOuGv8IWw5XG1ZvoVMnjSAZe6T7WYA99GENxoHkMiKxHlCuK5Gd0INrISImHQrQmv6F4mqU/TTQ8nHMDzCRivKySQ8dqkpQgnUMnwIkaAuc6/FGq1hw3b2Sba398BhUwUZSAIO8XZvnuLdY2n6hOXws+gq9BHUKcKFA6kz6FDnpxLPICa3qGhnc97bo1FT/XJk48LrkHJ2CAtBv0RtN97N21plfpXHvZ8gMJb7Zc4cfI6MbPwsW7AilCSXMFIEUEmir8XLEklA0ztYbGpTTGqttp5hpFTTIqUyaAIqvMT9A/x+Ji5ejA4Bhxb/cl1pUdOD6epd3yilIdO6j297xInoiBPuEDW2/UfslDyhGkQs7Wy253bVnlT+SWg89zYIK/9KXFl5fe+jow2rd5FXv8zDPrmfMXiUPt9QBO/iK4QGbX5j/7Rx1c1vzsY8ONbP3lVIaPrhL4+1QrECTN3nyKavGG0gBBtHvTKhGoBHgMXHStFowN+HKrPriYu+OZ05Frn8okQrPaaxoKP1ULCS/cmKFN3gcH7HQlVjraCeQmtjg1pSQxeuqXiSKgLpxc/1OiZsU4+n4lz4hpahGyWBURLi4642n1gn9qz9bIsaCeEPJ0uJmenMWp2tJmIwLQ6VSgDYErOeBCfSj9P4G/vI7oIF+l/n5fp956QgxGvur77ynawAu3G9MdFbJbu49NZnWnnFcQHjxRuhUYvg1U/e84N4JTecciDAKb/KYIFXzloyuE1eYXf54MmhjTq7B/yBToDzzpx3tJCTo3HCmVPYfmtBRe3mPYEE/6RlTIxbf4fSOcaKFGk4gbaUWe44hVk9SZzhW80yfW5QWBHxmtUzvMhfVQli4gZTktIOZd9mjJ5hsbmzttaHQB29Am3dZkmx3g/qvYocyhZ2PXAWsNQiIaf+Q8W/MWPIK7/TjvCx5q2XRp4lVWydMc2wIQkhadDB0xsnw/kSEyGjLKjI4coVIwtubTF3E7MJ6LS6UOsJKj82XVAVPJJcepfewbzE91ivXZvOvYfsmMevwtPpfMzGmC7WJlyW2j0jh7AF1JLmwEJSKYwIvu6DHc3YnyLH9ZdIBnQ+nOVDRiP+REpqv++typYHIvoJyICGA40d8bR7HR2k7do6UQTHF4oriYeIQbxKe4Th6+/l1BjUtS9hqORh3MbgvYrStXTfSwaBOmAVQZzpYNqsAmQyjY56MUqty3c/xH6GuhNvNaG9vGbG6cPtBM8UA3e8r51D0AR9kozKuGGSMgLz3nAHxDNnc7GTwpLj7/6HeWp1iksDeTjwCLpxejuMtpMnGJgsiku1sOACwQ9ukzESiDRN77YNESxR5LphOlcASXA5uIts1LnBIcn1J7BLWs49DMALSnuz95gdOrTZr0u1SeYHinno/pE58xYoXbVO/S+FEMMs5qyWkMnp8Q3ClyTlZP52Y9nq7b8fITPuVXUk9ohG5EFHw4gAEcjFxfKb3xuAsEjx2z1wxNbSZMcgS9GKyW3R6KwJONgtA64LTyxWm8Bvudp0M1FdJPEGopM4Fvg7G/hsptkhCfHFegv4ENwxPeXmYhxwZy7js+BeM27t9ODBMynVCLJ7RWcBMteZJtvjOYHb5lOnCLYWNEMKC59BA7covu1cANa2PXL05iGdufOzkgFqqHBOrgQVUmLEc+Mkz4Rq8O6WkNr7atNkH4M8d+SD1t/tSzt3oFql+neVs+AwEI5JaBJaxARtY2Z4mKoUqxds4UpZ0sv3zIbNoo0J4fihldQTX3XNcuNcZmcrB5LTWMdzeRuAtBk3cZHYQF6gTi3PNuDJ0nmR+4LPLoHvxQIxRgJ9iNNXqf2SYJhcvCtJiVWo85TsyFOuq7EyBPJrAdhEgE0cTq16FQXhYPJFqSfiVn0IQnPOy0LbU4BeG94QjdYNB0CiQ3QaxQqD2ebSMiNjaVaw8WaM4Z5WnzcVDsr4eGweSLa2DE3BWViaxhZFIcSTjgxNCAfelg+hznVOYoe5VqTYs1g7WtfTm3e4/WduC6p+qqAM8H4ZyrJCGpewThTDPe6H7CzX/zQ8Tm+r65HeZn+MsmxUciEWPlAVaK/VBaQBWfoG/aRL/jSZIQfep/89GjasWmbaWzeEZ2R1FOjvyJT37O9B8046SRSKVEnXWlBqbkb5XCS3qFeuE9xb9+frEknxWB5h1D/hruz2iVDEAS7+qkEz5Ot5agHJc7WCdY94Ws61sURcX5nG8UELGBAHZ3i+3VulAyT0nKNNz4K2LBHBWJcTBX1wzf+//u/j/9+//v87+9/l9Lbh/L/uyNYiTsWV2LwsjaA6MxTuzFMqmxW8Jw/+IppdX8t/Clgi1rI1SN0UC/r6tX/4lUc2VV1OQReSeCsjUpKZchw4XUcjHfw6ryCV3R8s6VXm67vp4n+lcPV9gJwmbKQEsmrJi9c2vkwrm8HFbVYNTaRGq8D91t9n5+U+aD/hNtN3HjC/nC/vUoGFSCkXP+NlRcmLUqLbiUBl4LYf1U/CCvwtd3ryCH8gUmGITAxiH1O5rnGTz7y1LuFjmnFGQ1UWuM7HwfXtWl2fPFKklYwNUpF2IL/TmaRETjQiM5SJacI+3Gv5MBU8lP5Io6gWkawpyzNEVGqOdx4YlO1dCvjbWFZWbCmeiFKPSlMKtKcMFLs/KQxtgAHi7NZNCQ32bBAW2mbHflVZ8wXKi1JKVHkW20bnYnl3dKWJeWJOiX3oKPBD6Zbi0ZvSIuWktUHB8qDR8DMMh1ZfkBL9FS9x5r0hBGLJ8pUCJv3NYH+Ae8p40mZWd5m5fhobFjQeQvqTT4VKWIYfRL0tfaXKiVl75hHReuTJEcqVlug+eOIIc4bdIydtn2K0iNZPsYWQvQio2qbO3OqAlPHDDOB7DfjGEfVF51FqqNacd6QmgFKJpMfLp5DHTv4wXlONKVXF9zTJpDV4m1sYZqJPhotcsliZM8yksKkCkzpiXt+EcRQvSQqmBS9WdWkxMTJXPSw94jqI3varCjQxTazjlMH8jTS8ilaW8014/vwA/LNa+YiFoyyx3s/KswP3O8QW1jtq45yTM/DX9a8M4voTVaO2ebvw1EooDw/yg6Y1faY+WwrdVs5Yt0hQ5EwRfYXSFxray1YvSM+kYmlpLG2/9mm1MfmbKHXr44Ih8nVKb1M537ZANUkCtdsPZ80JVKVKabVHCadaLXg+IV8i5GSwpZti0h6diTaKs9sdpUKEpd7jDUpYmHtiX33SKiO3tuydkaxA7pEc9XIQEOfWJlszj5YpL5bKeQyT7aZSBOamvSHl8xsWvgo26IP/bqk+0EJUz+gkkcvlUlyPp2kdKFtt7y5aCdks9ZJJcFp5ZWeaWKgtnXMN3ORwGLBE0PtkEIek5FY2aVssUZHtsWIvnljMVJtuVIjpZup/5VL1yPOHWWHkOMc6YySWMckczD5jUj2mlLVquFaMU8leGVaqeXis+aRRL8zm4WuBk6cyWfGMxgtr8useQEx7k/PvRoZyd9nde1GUCV84gMX8Ogu/BWezYPSR27llzQnA97oo0pYyxobYUJfsj+ysTm9zJ+S4pk0TGo9VTG0KjqYhTmALfoDZVKla2b5yhv241PxFaLJs3i05K0AAIdcGxCJZmT3ZdT7CliR7q+kur7WdQjygYtOWRL9B8E4s4LI8KpAj7bE0dg7DLOaX+MGeAi0hMMSSWZEz+RudXbZCsGYS0QqiXjH9XQbd8sCB+nIVTq7/T/FDS+zWY9q7Z2fdq1tdLb6v3hKKVDAw5gjj6o9r1wHFROdHc18MJp4SJ2Ucvu+iQ9EgkekW8VCM+psM6y+/2SBy8tNN4a3L1MzP+OLsyvESo5gS7IQOnIqMmviJBVc6zbVG1n8eXiA3j46kmvvtJlewwNDrxk4SbJOtP/TV/lIVK9ueShNbbMHfwnLTLLhbZuO79ec5XvfgRwLFK+w1r5ZWW15rVFZrE+wKqNRv5KqsLNfpGgnoUU6Y71NxEmN7MyqwqAQqoIULOw/LbuUB2+uE75gJt+kq1qY4LoxV+qR/zalupea3D5+WMeaRIn0sAI6DDWDh158fqUb4YhAxhREbUN0qyyJYkBU4V2KARXDT65gW3gRsiv7xSPYEKLwzgriWcWgPr0sbZnv7m1XHNFW6xPdGNZUdxFiUYlmXNjDVWuu7LCkX/nVkrXaJhiYktBISC2xgBXQnNEP+cptWl1eG62a7CPXrnrkTQ5BQASbEqUZWMDiZUisKyHDeLFOaJILUo5f6iDt4ZO8MlqaKLto0AmTHVVbkGuyPa1R/ywZsWRoRDoRdNMMHwYTsklMVnlAd2S0282bgMI8fiJpDh69OSL6K3qbo20KfpNMurnYGQSr/stFqZ7hYsxKlLnKAKhsmB8AIpEQ4bd/NrTLTXefsE6ChRmKWjXKVgpGoPs8GAicgKVw4K0qgDgy1A6hFq1WRat3fHF+FkU+b6H4NWpOU3KXTxrIb2qSHAb+qhm8hiSROi/9ofapjxhyKxxntPpge6KL5Z4+WBMYkAcE6+0Hd3Yh2zBsK2MV3iW0Y6cvOCroXlRb2MMJtdWx+3dkFzGh2Pe3DZ9QpSqpaR/rE1ImOrHqYYyccpiLC22amJIjRWVAherTfpQLmo6/K2pna85GrDuQPlH1Tsar8isAJbXLafSwOof4gg9RkAGm/oYpBQQiPUoyDk2BCQ1k+KILq48ErFo4WSRhHLq/y7mgw3+L85PpP6xWr6cgp9sOjYjKagOrxF148uhuaWtjet953fh1IQiEzgC+d2IgBCcUZqgTAICm2bR8oCjDLBsmg+ThyhfD+zBalsKBY1Ce54Y/t9cwfbLu9SFwEgphfopNA3yNxgyDafUM3mYTovZNgPGdd4ZFFOj1vtfFW3u7N+iHEN1HkeesDMXKPyoCDCGVMo4GCCD6PBhQ3dRZIHy0Y/3MaE5zU9mTCrwwnZojtE+qNpMSkJSpmGe0EzLyFelMJqhfFQ7a50uXxZ8pCc2wxtAKWgHoeamR2O7R+bq7IbPYItO0esdRgoTaY38hZLJ5y02oIVwoPokGIzxAMDuanQ1vn2WDQ00Rh6o5QOaCRu99fwDbQcN0XAuqkFpxT/cfz3slGRVokrNU0iqiMAJFEbKScZdmSkTUznC0U+MfwFOGdLgsewRyPKwBZYSmy6U325iUhBQNxbAC3FLKDV9VSOuQpOOukJ/GAmu/tyEbX9DgEp6dv1zoU0IqzpG6gssSjIYRVPGgU1QAQYRgIT8gEV0EXr1sqeh2I6rXjtmoCYyEDCe/PkFEi/Q48FuT29p557iN+LCwk5CK/CZ2WdAdfQZh2Z9QGrzPLSNRj5igUWzl9Vi0rCqH8G1Kp4QMLkuwMCAypdviDXyOIk0AHTM8HBYKh3b0/F+DxoNj4ZdoZfCpQVdnZarqoMaHWnMLNVcyevytGsrXQEoIbubqWYNo7NRHzdc0zvT21fWVirj7g36iy6pxogfvgHp1xH1Turbz8QyyHnXeBJicpYUctbzApwzZ1HT+FPEXMAgUZetgeGMwt4G+DHiDT2Lu+PT21fjJCAfV16a/Wu1PqOkUHSTKYhWW6PhhHUlNtWzFnA7MbY+r64vkwdpfNB2JfWgWXAvkzd42K4lN9x7Wrg4kIKgXCb4mcW595MCPJ/cTfPAMQMFWwnqwde4w8HZYJFpQwcSMhjVz4B8p6ncSCN1X4klxoIH4BN2J6taBMj6lHkAOs8JJAmXq5xsQtrPIPIIp/HG6i21xMGcFgqDXSRF0xQg14d2uy6HgKE13LSvQe52oShF5Jx1R6avyL4thhXQZHfC94oZzuPUBKFYf1VvDaxIrtV6dNGSx7DO0i1p6CzBkuAmEqyWceQY7F9+U0ObYDzoa1iKao/cOD/v6Q9gHrrr1uCeOk8fST9MG23Ul0KmM3r+Wn6Hi6WAcL7gEeaykicvgjzkjSwFsAXIR81Zx4QJ6oosVyJkCcT+4xAldCcihqvTf94HHUPXYp3REIaR4dhpQF6+FK1H0i9i7Pvh8owu3lO4PT1iuqu+DkL2Bj9+kdfGAg2TXw03iNHyobxofLE2ibjsYDPgeEQlRMR7afXbSGQcnPjI2D+sdtmuQ771dbASUsDndU7t58jrrNGRzISvwioAlHs5FA+cBE5Ccznkd8NMV6BR6ksnKLPZnMUawRDU1MZ/ib3xCdkTblHKu4blNiylH5n213yM0zubEie0o4JhzcfAy3H5qh2l17uLooBNLaO+gzonTH2uF8PQu9EyH+pjGsACTMy4cHzsPdymUSXYJOMP3yTkXqvO/lpvt0cX5ekDEu9PUfBeZODkFuAjXCaGdi6ew4qxJ8PmFfwmPpkgQjQlWqomFY6UkjmcnAtJG75EVR+NpzGpP1Ef5qUUbfowrC3zcSLX3BxgWEgEx/v9cP8H8u1Mvt9/rMDYf6sjwU1xSOPBgzFEeJLMRVFtKo5QHsUYT8ZRLCah27599EuqoC9PYjYO6aoAMHB8X1OHwEAYouHfHB3nyb2B+SnZxM/vw/bCtORjLMSy5aZoEpvgdGvlJfNPFUu/p7Z4VVK1hiI0/UTuB3ZPq4ohEbm7Mntgc1evEtknaosgZSwnDC2BdMmibpeg48X8Ixl+/8+xXdbshQXUPPvx8jT3fkELivHSmqbhblfNFShWAyQnJ3WBU6SMYSIpTDmHjdLVAdlADdz9gCplZw6mTiHqDwIsxbm9ErGusiVpg2w8Q3khKV/R9Oj8PFeF43hmW/nSd99nZzhyjCX3QOZkkB6BsH4H866WGyv9E0hVAzPYah2tkRfQZMmP2rinfOeQalge0ovhduBjJs9a1GBwReerceify49ctOh5/65ATYuMsAkVltmvTLBk4oHpdl6i+p8DoNj4Fb2vhdFYer2JSEilEwPd5n5zNoGBXEjreg/wh2NFnNRaIUHSOXa4eJRwygZoX6vnWnqVdCRT1ARxeFrNBJ+tsdooMwqnYhE7zIxnD8pZH+P0Nu1wWxCPTADfNWmqx626IBJJq6NeapcGeOmbtXvl0TeWG0Y7OGGV4+EHTtNBIT5Wd0Bujl7inXgZgfXTM5efD3qDTJ54O9v3Bkv+tdIRlq1kXcVD0BEMirmFxglNPt5pedb1AnxuCYMChUykwsTIWqT23XDpvTiKEru1cTcEMeniB+HQDehxPXNmkotFdwUPnilB/u4Nx5Xc6l8J9jH1EgKZUUt8t8cyoZleDBEt8oibDmJRAoMKJ5Oe9CSWS5ZMEJvacsGVdXDWjp/Ype5x0p9PXB2PAwt2LRD3d+ftNgpuyvxlP8pB84oB1i73vAVpwyrmXW72hfW6Dzn9Jkj4++0VQ4d0KSx1AsDA4OtXXDo63/w+GD+zC7w5SJaxsmnlYRQ4dgdjA7tTl2KNLnpJ+mvkoDxtt1a4oPaX3EVqj96o9sRKBQqU7ZOiupeAIyLMD+Y3YwHx30XWHB5CQiw7q3mj1EDlP2eBsZbz79ayUMbyHQ7s8gu4Lgip1LiGJj7NQj905/+rgUYKAA5qdrlHKIknWmqfuR+PB8RdBkDg/NgnlT89G72h2NvySnj7UyBwD+mi/IWs1xWbxuVwUIVXun5cMqBtFbrccI+DILjsVQg6eeq0itiRfedn89CvyFtpkxaauEvSANuZmB1p8FGPbU94J9medwsZ9HkUYjmI7OH5HuxendLbxTaYrPuIfE2ffXFKhoNBUp33HsFAXmCV/Vxpq5AYgFoRr5Ay93ZLRlgaIPjhZjXZZChT+aE5iWAXMX0oSFQEtwjiuhQQItTQX5IYrKfKB+queTNplR1Hoflo5/I6aPPmACwQCE2jTOYo5Dz1cs7Sod0KTG/3kEDGk3kUaUCON19xSJCab3kNpWZhSWkO8l+SpW70Wn3g0ciOIJO5JXma6dbos6jyisuxXwUUhj2+1uGhcvuliKtWwsUTw4gi1c/diEEpZHoKoxTBeMDmhPhKTx7TXWRakV8imJR355DcIHkR9IREHxohP4TbyR5LtFU24umRPRmEYHbpe1LghyxPx7YgUHjNbbQFRQhh4KeU1EabXx8FS3JAxp2rwRDoeWkJgWRUSKw6gGP5U2PuO9V4ZuiKXGGzFQuRuf+tkSSsbBtRJKhCi3ENuLlXhPbjTKD4djXVnfXFds6Zb+1XiUrRfyayGxJq1+SYBEfbKlgjiSmk0orgTqzSS+DZ5rTqsJbttiNtp+KMqGE2AHGFw6jQqM5vD6vMptmXV9OAjq49Uf/Lx9Opam+Hn5O9p8qoBBAQixzQZ4eNVkO9sPzJAMyR1y4/RCQQ1s0pV5KAU5sKLw3tkcFbI/JqrjCsK4Mw+W8aod4lioYuawUiCyVWBE/qPaFi5bnkgpfu/ae47174rI1fqQoTbW0HrU6FAejq7ByM0V4zkZTg02/YJK2N7hUQRCeZ4BIgSEqgD8XsjzG6LIsSbuHoIdz/LhFzbNn1clci1NHWJ0/6/O8HJMdIpEZbqi1RrrFfoo/rI/7ufm2MPG5lUI0IYJ4MAiHRTSOFJ2oTverFHYXThkYFIoyFx6rMYFgaOKM4xNWdlOnIcKb/suptptgTOTdVIf4YgdaAjJnIAm4qNNHNQqqAzvi53GkyRCEoseUBrHohZsjUbkR8gfKtc/+Oa72lwxJ8Mq6HDfDATbfbJhzeIuFQJSiw1uZprHlzUf90WgqG76zO0eCB1WdPv1IT6sNxxh91GEL2YpgC97ikFHyoaH92ndwduqZ6IYjkg20DX33MWdoZk7QkcKUCgisIYslOaaLyvIIqRKWQj16jE1DlQWJJaPopWTJjXfixEjRJJo8g4++wuQjbq+WVYjsqCuNIQW3YjnxKe2M5ZKEqq+cX7ZVgnkbsU3RWIyXA1rxv4kGersYJjD//auldXGmcEbcfTeF16Y1708FB1HIfmWv6dSFi6oD4E+RIjCsEZ+kY7dKnwReJJw3xCjKvi3kGN42rvyhUlIz0Bp+fNSV5xwFiuBzG296e5s/oHoFtUyUplmPulIPl+e1CQIQVtjlzLzzzbV+D/OVQtYzo5ixtMi5BmHuG4N/uKfJk5UIREp7+12oZlKtPBomXSzAY0KgtbPzzZoHQxujnREUgBU+O/jKKhgxVhRPtbqyHiUaRwRpHv7pgRPyUrnE7fYkVblGmfTY28tFCvlILC04Tz3ivkNWVazA+OsYrxvRM/hiNn8Fc4bQBeUZABGx5S/xFf9Lbbmk298X7iFg2yeimvsQqqJ+hYbt6uq+Zf9jC+Jcwiccd61NKQtFvGWrgJiHB5lwi6fR8KzYS7EaEHf/ka9EC7H8D+WEa3TEACHBkNSj/cXxFeq4RllC+fUFm2xtstYLL2nos1DfzsC9vqDDdRVcPA3Ho95aEQHvExVThXPqym65llkKlfRXbPTRiDepdylHjmV9YTWAEjlD9DdQnCem7Aj/ml58On366392214B5zrmQz/9ySG2mFqEwjq5sFl5tYJPw5hNz8lyZPUTsr5E0F2C9VMPnZckWP7+mbwp/BiN7f4kf7vtGnZF2JGvjK/sDX1RtcFY5oPQnE4lIAYV49U3C9SP0LCY/9i/WIFK9ORjzM9kG/KGrAuwFmgdEpdLaiqQNpCTGZVuAO65afkY1h33hrqyLjZy92JK3/twdj9pafFcwfXONmPQWldPlMe7jlP24Js0v9m8bIJ9TgS2IuRvE9ZVRaCwSJYOtAfL5H/YS4FfzKWKbek+GFulheyKtDNlBtrdmr+KU+ibHTdalzFUmMfxw3f36x+3cQbJLItSilW9cuvZEMjKw987jykZRlsH/UI+HlKfo2tLwemBEeBFtmxF2xmItA/dAIfQ+rXnm88dqvXa+GapOYVt/2waFimXFx3TC2MUiOi5/Ml+3rj/YU6Ihx2hXgiDXFsUeQkRAD6wF3SCPi2flk7XwKAA4zboqynuELD312EJ88lmDEVOMa1W/K/a8tGylZRMrMoILyoMQzzbDJHNZrhH77L9qSC42HVmKiZ5S0016UTp83gOhCwz9XItK9fgXfK3F5d7nZCBUekoLxrutQaPHa16Rjsa0gTrzyjqTnmcIcrxg6X6dkKiucudc0DD5W4pJPf0vuDW8r5/uw24YfMuxFRpD2ovT2mFX79xH6Jf+MVdv2TYqR6/955QgVPe3JCD/WjAYcLA9tpXgFiEjge2J5ljeI/iUzg91KQuHkII4mmHZxC3XQORLAC6G7uFn5LOmlnXkjFdoO976moNTxElS8HdxWoPAkjjocDR136m2l+f5t6xaaNgdodOvTu0rievnhNAB79WNrVs6EsPgkgfahF9gSFzzAd+rJSraw5Mllit7vUP5YxA843lUpu6/5jAR0RvH4rRXkSg3nE+O5GFyfe+L0s5r3k05FyghSFnKo4TTgs07qj4nTLqOYj6qaW9knJTDkF5OFMYbmCP+8H16Ty482OjvERV6OFyw043L9w3hoJi408sR+SGo1WviXUu8d7qS+ehKjpKwxeCthsm2LBFSFeetx0x4AaKPxtp3CxdWqCsLrB1s/j5TAhc1jNZsXWl6tjo/WDoewxzg8T8NnhZ1niUwL/nhfygLanCnRwaFGDyLw+sfZhyZ1UtYTp8TYB6dE7R3VsKKH95CUxJ8u8N+9u2/9HUNKHW3x3w5GQrfOPafk2w5qZq8MaHT0ebeY3wIsp3rN9lrpIsW9c1ws3VNV+JwNz0Lo9+V7zZr6GD56We6gWVIvtmam5GPPkVAbr74r6SwhuL+TRXtW/0pgyX16VNl4/EAD50TnUPuwrW6OcUO2VlWXS0inq872kk7GUlW6o/ozFKq+Sip6LcTtSDfDrPTcCHhx75H8BeRon+KG2wRwzfDgWhALmiWOMO6h3pm1UCZEPEjScyk7tdLx6WrdA2N1QTPENvNnhCQjW6kl057/qv7IwRryHrZBCwVSbLLnFRiHdTwk8mlYixFt1slEcPD7FVht13HyqVeyD55HOXrh2ElAxJyinGeoFzwKA91zfrdLvDxJSjzmImfvTisreI25EDcVfGsmxLVbfU8PGe/7NmWWKjXcdTJ11jAlVIY/Bv/mcxg/Q10vCHwKG1GW/XbJq5nxDhyLqiorn7Wd7VEVL8UgVzpHMjQ+Z8DUgSukiVwWAKkeTlVVeZ7t1DGnCgJVIdBPZAEK5f8CDyDNo7tK4/5DBjdD5MPV86TaEhGsLVFPQSI68KlBYy84FievdU9gWh6XZrugvtCZmi9vfd6db6V7FmoEcRHnG36VZH8N4aZaldq9zZawt1uBFgxYYx+Gs/qW1jwANeFy+LCoymyM6zgG7j8bGzUyLhvrbJkTYAEdICEb4kMKusKT9V3eIwMLsjdUdgijMc+7iKrr+TxrVWG0U+W95SGrxnxGrE4eaJFfgvAjUM4SAy8UaRwE9j6ZQH5qYAWGtXByvDiLSDfOD0yFA3UCMKSyQ30fyy1mIRg4ZcgZHLNHWl+c9SeijOvbOJxoQy7lTN2r3Y8p6ovxvUY74aOYbuVezryqXA6U+fcp6wSV9X5/OZKP18tB56Ua0gMyxJI7XyNT7IrqN8GsB9rL/kP5KMrjXxgqKLDa+V5OCH6a5hmOWemMUsea9vQl9t5Oce76PrTyTv50ExOqngE3PHPfSL//AItPdB7kGnyTRhVUUFNdJJ2z7RtktZwgmQzhBG/G7QsjZmJfCE7k75EmdIKH7xlnmDrNM/XbTT6FzldcH/rcRGxlPrv4qDScqE7JSmQABJWqRT/TUcJSwoQM+1jvDigvrjjH8oeK2in1S+/yO1j8xAws/T5u0VnIvAPqaE1atNuN0cuRliLcH2j0nTL4JpcR7w9Qya0JoaHgsOiALLCCzRkl1UUESz+ze/gIXHGtDwgYrK6pCFKJ1webSDog4zTlPkgXZqxlQDiYMjhDpwTtBW2WxthWbov9dt2X9XFLFmcF+eEc1UaQ74gqZiZsdj63pH1qcv3Vy8JYciogIVKsJ8Yy3J9w/GhjWVSQAmrS0BPOWK+RKV+0lWqXgYMnIFwpcZVD7zPSp547i9HlflB8gVnSTGmmq1ClO081OW/UH11pEQMfkEdDFzjLC1Cdo/BdL3s7cXb8J++Hzz1rhOUVZFIPehRiZ8VYu6+7Er7j5PSZu9g/GBdmNzJmyCD9wiswj9BZw+T3iBrg81re36ihMLjoVLoWc+62a1U/7qVX5CpvTVF7rocSAKwv4cBVqZm7lLDS/qoXs4fMs/VQi6BtVbNA3uSzKpQfjH1o3x4LrvkOn40zhm6hjduDglzJUwA0POabgdXIndp9fzhOo23Pe+Rk9GSLX0d71Poqry8NQDTzNlsa+JTNG9+UrEf+ngxCjGEsDCc0bz+udVRyHQI1jmEO3S+IOQycEq7XwB6z3wfMfa73m8PVRp+iOgtZfeSBl01xn03vMaQJkyj7vnhGCklsCWVRUl4y+5oNUzQ63B2dbjDF3vikd/3RUMifPYnX5Glfuk2FsV/7RqjI9yKTbE8wJY+74p7qXO8+dIYgjtLD/N8TJtRh04N9tXJA4H59IkMmLElgvr0Q5OCeVfdAt+5hkh4pQgfRMHpL74XatLQpPiOyHRs/OdmHtBf8nOZcxVKzdGclIN16lE7kJ+pVMjspOI+5+TqLRO6m0ZpNXJoZRv9MPDRcAfJUtNZHyig/s2wwReakFgPPJwCQmu1I30/tcBbji+Na53i1W1N+BqoY7Zxo+U/M9XyJ4Ok2SSkBtoOrwuhAY3a03Eu6l8wFdIG1cN+e8hopTkiKF093KuH/BcB39rMiGDLn6XVhGKEaaT/vqb/lufuAdpGExevF1+J9itkFhCfymWr9vGb3BTK4j598zRH7+e+MU9maruZqb0pkGxRDRE1CD4Z8LV4vhgPidk5w2Bq816g3nHw1//j3JStz7NR9HIWELO8TMn3QrP/zZp//+Dv9p429/ogv+GATR+n/UdF+ns9xNkXZQJXY4t9jMkJNUFygAtzndXwjss+yWH9HAnLQQfhAskdZS2l01HLWv7L7us5uTH409pqitvfSOQg/c+Zt7k879P3K9+WV68n7+3cZfuRd/dDPP/03rn+d+/nBvWfgDlt8+LzjqJ/vx3CnNOwiXhho778C96iD+1TBvRZYeP+EH81LE0vVwOOrmCLB3iKzI1x+vJEsrPH4uF0UB4TJ4X3uDfOCo3PYpYe0MF4bouh0DQ/l43fxUF7Y+dpWuvTSffB0yO2UQUETI/LwCZE3BvnevJ7c9zUlY3H58xzke6DNFDQG8n0WtDN4LAYN4nogKav1ezOfK/z+t6tsCTp+dhx4ymjWuCJk1dEUifDP+HyS4iP/Vg9B2jTo9L4NbiBuDS4nuuHW6H+JDQn2JtqRKGkEQPEYE7uzazXIkcxIAqUq1esasZBETlEZY7y7Jo+RoV/IsjY9eIMkUvr42Hc0xqtsavZvhz1OLwSxMOTuqzlhb0WbdOwBH9EYiyBjatz40bUxTHbiWxqJ0uma19qhPruvcWJlbiSSH48OLDDpaHPszvyct41ZfTu10+vjox6kOqK6v0K/gEPphEvMl/vwSv+A4Hhm36JSP9IXTyCZDm4kKsqD5ay8b1Sad/vaiyO5N/sDfEV6Z4q95E+yfjxpqBoBETW2C7xl4pIO2bDODDFurUPwE7EWC2Uplq+AHmBHvir2PSgkR12/Ry65O0aZtQPeXi9mTlF/Wj5GQ+vFkYyhXsLTjrBSP9hwk4GPqDP5rBn5/l8b0mLRAvRSzXHc293bs3s8EsdE3m2exxidWVB4joHR+S+dz5/W+v00K3TqN14CDBth8eWcsTbiwXPsygHdGid0PEdy6HHm2v/IUuV5RVapYmzGsX90mpnIdNGcOOq64Dbc5GUbYpD9M7S+6cLY//QmjxFLP5cuTFRm3vA5rkFZroFnO3bjHF35uU3s8mvL7Tp9nyTc4mymTJ5sLIp7umSnGkO23faehtz3mmTS7fbVx5rP7x3HXIjRNeq/A3xCs9JNB08c9S9BF2O3bOur0ItslFxXgRPdaapBIi4dRpKGxVz7ir69t/bc9qTxjvtOyGOfiLGDhR4fYywHv1WdOplxIV87TpLBy3Wc0QP0P9s4G7FBNOdITS/tep3o3h1TEa5XDDii7fWtqRzUEReP2fbxz7bHWWJdbIOxOUJZtItNZpTFRfj6vm9sYjRxQVO+WTdiOhdPeTJ+8YirPvoeL88l5iLYOHd3b/Imkq+1ZN1El3UikhftuteEYxf1Wujof8Pr4ICTu5ezZyZ4tHQMxlzUHLYO2VMOoNMGL/20S5i2o2obfk+8qqdR7xzbRDbgU0lnuIgz4LelQ5XS7xbLuSQtNS95v3ZUOdaUx/Qd8qxCt6xf2E62yb/HukLO6RyorV8KgYl5YNc75y+KvefrxY+lc/64y9kvWP0a0bDz/rojq+RWjO06WeruWqNFU7r3HPIcLWRql8ICZsz2Ls/qOm/CLn6++X+Qf7mGspYCrZod/lpl6Rw4xN/yuq8gqV4B6aHk1hVE1SfILxWu5gvXqbfARYQpspcxKp1F/c8XOPzkZvmoSw+vEqBLdrq1fr3wAPv5NnM9i8F+jdAuxkP5Z71c6uhK3enlnGymr7UsWZKC12qgUiG8XXGQ9mxnqz4GSIlybF9eXmbqj2sHX+a1jf0gRoONHRdRSrIq03Ty89eQ1GbV/Bk+du4+V15zls+vvERvZ4E7ZbnxWTVjDjb4o/k8jlw44pTIrUGxxuJvBeO+heuhOjpFsO6lVJ/aXnJDa/bM0Ql1cLbXE/Pbv3EZ3vj3iVrB5irjupZTzlnv677NrI9UNYNqbPgp/HZXS+lJmk87wec+7YOxTDo2aw2l3NfDr34VNlvqWJBknuK7oSlZ6/T10zuOoPZOeoIk81N+sL843WJ2Q4Z0fZ3scsqC/JV2fuhWi1jGURSKZV637lf53Xnnx16/vKEXY89aVJ0fv91jGdfG+G4+sniwHes4hS+udOr4RfhFhG/F5gUG35QaU+McuLmclb5ZWmR+sG5V6nf+PxYzlrnFGxpZaK8eqqVo0NfmAWoGfXDiT/FnUbWvzGDOTr8aktOZWg4BYvz5YH12ZbfCcGtNk+dDAZNGWvHov+PIOnY9Prjg8h/wLRrT69suaMVZ5bNuK00lSVpnqSX1NON/81FoP92rYndionwgOiA8WMf4vc8l15KqEEG4yAm2+WAN5Brfu1sq9suWYqgoajgOYt/JCk1gC8wPkK+XKCtRX6TAtgvrnuBgNRmn6I8lVDipOVB9kX6Oxkp4ZKyd1M6Gj8/v2U7k+YQBL95Kb9PQENucJb0JlW3b5tObN7m/Z1j1ev388d7o15zgXsI9CikAGAViR6lkJv7nb4Ak40M2G8TJ447kN+pvfHiOFjSUSP6PM+QfbAywKJCBaxSVxpizHseZUyUBhq59vFwrkyGoRiHbo0apweEZeSLuNiQ+HAekOnarFg00dZNXaPeoHPTRR0FmEyqYExOVaaaO8c0uFUh7U4e/UxdBmthlBDgg257Q33j1hA7HTxSeTTSuVnPZbgW1nodwmG16aKBDKxEetv7D9OjO0JhrbJTnoe+kcGoDJazFSO8/fUN9Jy/g4XK5PUkw2dgPDGpJqBfhe7GA+cjzfE/EGsMM+FV9nj9IAhrSfT/J3QE5TEIYyk5UjsI6ZZcCPr6A8FZUF4g9nnpVmjX90MLSQysIPD0nFzqwCcSJmIb5mYv2Cmk+C1MDFkZQyCBq4c/Yai9LJ6xYkGS/x2s5/frIW2vmG2Wrv0APpCdgCA9snFvfpe8uc0OwdRs4G9973PGEBnQB5qKrCQ6m6X/H7NInZ7y/1674/ZXOVp7OeuCRk8JFS516VHrnH1HkIUIlTIljjHaQtEtkJtosYul77cVwjk3gW1Ajaa6zWeyHGLlpk3VHE2VFzT2yI/EvlGUSz2H9zYE1s4nsKMtMqNyKNtL/59CpFJki5Fou6VXGm8vWATEPwrUVOLvoA8jLuwOzVBCgHB2Cr5V6OwEWtJEKokJkfc87h+sNHTvMb0KVTp5284QTPupoWvQVUwUeogZR3kBMESYo0mfukewRVPKh5+rzLQb7HKjFFIgWhj1w3yN/qCNoPI8XFiUgBNT1hCHBsAz8L7Oyt8wQWUFj92ONn/APyJFg8hzueqoJdNj57ROrFbffuS/XxrSXLTRgj5uxZjpgQYceeMc2wJrahReSKpm3QjHfqExTLAB2ipVumE8pqcZv8LYXQiPHHsgb5BMW8zM5pvQit+mQx8XGaVDcfVbLyMTlY8xcfmm/RSAT/H09UQol5gIz7rESDmnrQ4bURIB4iRXMDQwxgex1GgtDxKp2HayIkR+E/aDmCttNm2C6lytWdfOVzD6X2SpDWjQDlMRvAp1symWv4my1bPCD+E1EmGnMGWhNwmycJnDV2WrQNxO45ukEb08AAffizYKVULp15I4vbNK5DzWwCSUADfmKhfGSUqii1L2UsE8rB7mLuHuUJZOx4+WiizHBJ/hwboaBzhpNOVvgFTf5cJsHef7L1HCI9dOUUbb+YxUJWn6dYOLz+THi91kzY5dtO5c+grX7v0jEbsuoOGnoIreDIg/sFMyG+TyCLIcAWd1IZ1UNFxE8Uie13ucm40U2fcxC0u3WLvLOxwu+F7MWUsHsdtFQZ7W+nlfCASiAKyh8rnP3EyDByvtJb6Kax6/HkLzT9SyEyTMVM1zPtM0MJY14DmsWh4MgD15Ea9Hd00AdkTZ0EiG5NAGuIBzQJJ0JR0na+OB7lQA6UKxMfihIQ7GCCnVz694QvykWXTxpS2soDu+smru1UdIxSvAszBFD1c8c6ZOobA8bJiJIvuycgIXBQIXWwhyTgZDQxJTRXgEwRNAawGSXO0a1DKjdihLVNp/taE/xYhsgwe+VpKEEB4LlraQyE84gEihxCnbfoyOuJIEXy2FIYw+JjRusybKlU2g/vhTSGTydvCvXhYBdtAXtS2v7LkHtmXh/8fly1do8FI/D0f8UbzVb5h+KRhMGSAmR2mhi0YG/uj7wgxcfzCrMvdjitUIpXDX8ae2JcF/36qUWIMwN6JsjaRGNj+jEteGDcFyTUb8X/NHSucKMJp7pduxtD6KuxVlyxxwaeiC1FbGBESO84lbyrAugYxdl+2N8/6AgWpo/IeoAOcsG35IA/b3AuSyoa55L7llBLlaWlEWvuCFd8f8NfcTUgzJv6CbB+6ohWwodlk9nGWFpBAOaz5uEW5xBvmjnHFeDsb0mXwayj3mdYq5gxxNf3H3/tnCgHwjSrpSgVxLmiTtuszdRUFIsn6LiMPjL808vL1uQhDbM7aA43mISXReqjSskynIRcHCJ9qeFopJfx9tqyUoGbSwJex/0aDE3plBPGtNBYgWbdLom3+Q/bjdizR2/AS/c/dH/d3G7pyl1qDXgtOFtEqidwLqxPYtrNEveasWq3vPUUtqTeu8gpov4bdOQRI2kneFvRNMrShyVeEupK1PoLDPMSfWMIJcs267mGB8X9CehQCF0gIyhpP10mbyM7lwW1e6TGvHBV1sg/UyTghHPGRqMyaebC6pbB1WKNCQtlai1GGvmq9zUKaUzLaXsXEBYtHxmFbEZ2kJhR164LhWW2Tlp1dhsGE7ZgIWRBOx3Zcu2DxgH+G83WTPceKG0TgQKKiiNNOlWgvqNEbnrk6fVD+AqRam2OguZb0YWSTX88N+i/ELSxbaUUpPx4vJUzYg/WonSeA8xUK6u7DPHgpqWpEe6D4cXg5uK9FIYVba47V/nb+wyOtk+zG8RrS4EA0ouwa04iByRLSvoJA2FzaobbZtXnq8GdbfqEp5I2dpfpj59TCVif6+E75p665faiX8gS213RqBxTZqfHP46nF6NSenOneuT+vgbLUbdTH2/t0REFXZJOEB6DHvx6N6g9956CYrY/AYcm9gELJXYkrSi+0F0geKDZgOCIYkLU/+GOW5aGj8mvLFgtFH5+XC8hvAE3CvHRfl4ofM/Qwk4x2A+R+nyc9gNu/9Tem7XW4XRnyRymf52z09cTOdr+PG6+P/Vb4QiXlwauc5WB1z3o+IJjlbxI8MyWtSzT+k4sKVbhF3xa+vDts3NxXa87iiu+xRH9cAprnOL2h6vV54iQRXuOAj1s8nLFK8gZ70ThIQcWdF19/2xaJmT0efrkNDkWbpAQPdo92Z8+Hn/aLjbOzB9AI/k12fPs9HhUNDJ1u6ax2VxD3R6PywN7BrLJ26z6s3QoMp76qzzwetrDABKSGkfW5PwS1GvYNUbK6uRqxfyVGNyFB0E+OugMM8kKwmJmupuRWO8XkXXXQECyRVw9UyIrtCtcc4oNqXqr7AURBmKn6Khz3eBN96LwIJrAGP9mr/59uTOSx631suyT+QujDd4beUFpZ0kJEEnjlP+X/Kr2kCKhnENTg4BsMTOmMqlj2WMFLRUlVG0fzdCBgUta9odrJfpVdFomTi6ak0tFjXTcdqqvWBAzjY6hVrH9sbt3Z9gn+AVDpTcQImefbB4edirjzrsNievve4ZT4EUZWV3TxEsIW+9MT/RJoKfZZYSRGfC1CwPG/9rdMOM8qR/LUYvw5f/emUSoD7YSFuOoqchdUg2UePd1eCtFSKgxLSZ764oy4lvRCIH6bowPxZWwxNFctksLeil47pfevcBipkkBIc4ngZG+kxGZ71a72KQ7VaZ6MZOZkQJZXM6kb/Ac0/XkJx8dvyfJcWbI3zONEaEPIW8GbkYjsZcwy+eMoKrYjDmvEEixHzkCSCRPRzhOfJZuLdcbx19EL23MA8rnjTZZ787FGMnkqnpuzB5/90w1gtUSRaWcb0eta8198VEeZMUSfIhyuc4/nywFQ9uqn7jdqXh+5wwv+RK9XouNPbYdoEelNGo34KyySwigsrfCe0v/PlWPvQvQg8R0KgHO18mTVThhQrlbEQ0Kp/JxPdjHyR7E1QPw/ut0r+HDDG7BwZFm9IqEUZRpv2WpzlMkOemeLcAt5CsrzskLGaVOAxyySzZV/D2EY7ydNZMf8e8VhHcKGHAWNszf1EOq8fNstijMY4JXyATwTdncFFqcNDfDo+mWFvxJJpc4sEZtjXyBdoFcxbUmniCoKq5jydUHNjYJxMqN1KzYV62MugcELVhS3Bnd+TLLOh7dws/zSXWzxEb4Nj4aFun5x4kDWLK5TUF/yCXB/cZYvI9kPgVsG2jShtXkxfgT+xzjJofXqPEnIXIQ1lnIdmVzBOM90EXvJUW6a0nZ/7XjJGl8ToO3H/fdxnxmTNKBZxnkpXLVgLXCZywGT3YyS75w/PAH5I/jMuRspej8xZObU9kREbRA+kqjmKRFaKGWAmFQspC+QLbKPf0RaK3OXvBSWqo46p70ws/eZpu6jCtZUgQy6r4tHMPUdAgWGGUYNbuv/1a6K+MVFsd3T183+T8capSo6m0+Sh57fEeG/95dykGJBQMj09DSW2bY0mUonDy9a8trLnnL5B5LW3Nl8rJZNysO8Zb+80zXxqUGFpud3Qzwb7bf+8mq6x0TAnJU9pDQR9YQmZhlna2xuxJt0aCO/f1SU8gblOrbIyMsxTlVUW69VJPzYU2HlRXcqE2lLLxnObZuz2tT9CivfTAUYfmzJlt/lOPgsR6VN64/xQd4Jlk/RV7UKVv2Gx/AWsmTAuCWKhdwC+4HmKEKYZh2Xis4KsUR1BeObs1c13wqFRnocdmuheaTV30gvVXZcouzHKK5zwrN52jXJEuX6dGx3BCpV/++4f3hyaW/cQJLFKqasjsMuO3B3WlMq2gyYfdK1e7L2pO/tRye2mwzwZPfdUMrl5wdLqdd2Kv/wVtnpyWYhd49L6rsOV+8HXPrWH2Kup89l2tz6bf80iYSd+V4LROSOHeamvexR524q4r43rTmtFzQvArpvWfLYFZrbFspBsXNUqqenjxNNsFXatZvlIhk7teUPfK+YL32F8McTnjv0BZNppb+vshoCrtLXjIWq3EJXpVXIlG6ZNL0dh6qEm2WMwDjD3LfOfkGh1/czYc/0qhiD2ozNnH4882MVVt3JbVFkbwowNCO3KL5IoYW5wlVeGCViOuv1svZx7FbzxKzA4zGqBlRRaRWCobXaVq4yYCWbZf8eiJwt3OY+MFiSJengcFP2t0JMfzOiJ7cECvpx7neg1Rc5x+7myPJOXt2FohVRyXtD+/rDoTOyGYInJelZMjolecVHUhUNqvdZWg2J2t0jPmiLFeRD/8fOT4o+NGILb+TufCo9ceBBm3JLVn+MO2675n7qiEX/6W+188cYg3Zn5NSTjgOKfWFSAANa6raCxSoVU851oJLY11WIoYK0du0ec5E4tCnAPoKh71riTsjVIp3gKvBbEYQiNYrmH22oLQWA2AdwMnID6PX9b58dR2QKo4qag1D1Z+L/FwEKTR7osOZPWECPJIHQqPUsM5i/CH5YupVPfFA5pHUBcsesh8eO5YhyWnaVRPZn/BmdXVumZWPxMP5e28zm2uqHgFoT9CymHYNNrzrrjlXZM06HnzDxYNlI5b/QosxLmmrqDFqmogQdqk0WLkUceoAvQxHgkIyvWU69BPFr24VB6+lx75Rna6dGtrmOxDnvBojvi1/4dHjVeg8owofPe1cOnxU1ioh016s/Vudv9mhV9f35At+Sh28h1bpp8xhr09+vf47Elx3Ms6hyp6QvB3t0vnLbOhwo660cp7K0vvepabK7YJfxEWWfrC2YzJfYOjygPwfwd/1amTqa0hZ5ueebhWYVMubRTwIjj+0Oq0ohU3zfRfuL8gt59XsHdwKtxTQQ4Y2qz6gisxnm2UdlmpEkgOsZz7iEk6QOt8BuPwr+NR01LTqXmJo1C76o1N274twJvl+I069TiLpenK/miRxhyY8jvYV6W1WuSwhH9q7kuwnJMtm7IWcqs7HsnyHSqWXLSpYtZGaR1V3t0gauninFPZGtWskF65rtti48UV9uV9KM8kfDYs0pgB00S+TlzTXV6P8mxq15b9En8sz3jWSszcifZa/NuufPNnNTb031pptt0+sRSH/7UG8pzbsgtt3OG3ut7B9JzDMt2mTZuyRNIV8D54TuTrpNcHtgmMlYJeiY9XS83NYJicjRjtJSf9BZLsQv629QdDsKQhTK5CnXhpk7vMNkHzPhm0ExW/VCGApHfPyBagtZQTQmPHx7g5IXXsrQDPzIVhv2LB6Ih138iSDww1JNHrDvzUxvp73MsQBVhW8EbrReaVUcLB1R3PUXyaYG4HpJUcLVxMgDxcPkVRQpL7VTAGabDzbKcvg12t5P8TSGQkrj/gOrpnbiDHwluA73xbXts/L7u468cRWSWRtgTwlQnA47EKg0OiZDgFxAKQQUcsbGomITgeXUAAyKe03eA7Mp4gnyKQmm0LXJtEk6ddksMJCuxDmmHzmVhO+XaN2A54MIh3niw5CF7PwiXFZrnA8wOdeHLvvhdoqIDG9PDI7UnWWHq526T8y6ixJPhkuVKZnoUruOpUgOOp3iIKBjk+yi1vHo5cItHXb1PIKzGaZlRS0g5d3MV2pD8FQdGYLZ73aae/eEIUePMc4NFz8pIUfLCrrF4jVWH5gQneN3S8vANBmUXrEcKGn6hIUN95y1vpsvLwbGpzV9L0ZKTan6TDXM05236uLJcIEMKVAxKNT0K8WljuwNny3BNQRfzovA85beI9zr1AGNYnYCVkR1aGngWURUrgqR+gRrQhxW81l3CHevjvGEPzPMTxdsIfB9dfGRbZU0cg/1mcubtECX4tvaedmNAvTxCJtc2QaoUalGfENCGK7IS/O8CRpdOVca8EWCRwv2sSWE8CJPW5PCugjCXPd3h6U60cPD+bdhtXZuYB6stcoveE7Sm5MM2yvfUHXFSW7KzLmi7/EeEWL0wqcOH9MOSKjhCHHmw+JGLcYE/7SBZQCRggox0ZZTAxrlzNNXYXL5fNIjkdT4YMqVUz6p8YDt049v4OXGdg3qTrtLBUXOZf7ahPlZAY/O+7Sp0bvGSHdyQ8B1LOsplqMb9Se8VAE7gIdSZvxbRSrfl+Lk5Qaqi5QJceqjitdErcHXg/3MryljPSIAMaaloFm1cVwBJ8DNmkDqoGROSHFetrgjQ5CahuKkdH5pRPigMrgTtlFI8ufJPJSUlGgTjbBSvpRc0zypiUn6U5KZqcRoyrtzhmJ7/caeZkmVRwJQeLOG8LY6vP5ChpKhc8Js0El+n6FXqbx9ItdtLtYP92kKfaTLtCi8StLZdENJa9Ex1nOoz1kQ7qxoiZFKRyLf4O4CHRT0T/0W9F8epNKVoeyxUXhy3sQMMsJjQJEyMOjmOhMFgOmmlscV4eFi1CldU92yjwleirEKPW3bPAuEhRZV7JsKV3Lr5cETAiFuX5Nw5UlF7d2HZ96Bh0sgFIL5KGaKSoVYVlvdKpZJVP5+NZ7xDEkQhmDgsDKciazJCXJ6ZN2B3FY2f6VZyGl/t4aunGIAk/BHaS+i+SpdRfnB/OktOvyjinWNfM9Ksr6WwtCa1hCmeRI6icpFM4o8quCLsikU0tMoZI/9EqXRMpKGaWzofl4nQuVQm17d5fU5qXCQeCDqVaL9XJ9qJ08n3G3EFZS28SHEb3cdRBdtO0YcTzil3QknNKEe/smQ1fTb0XbpyNB5xAeuIlf+5KWlEY0DqJbsnzJlQxJPOVyHiKMx5Xu9FcEv1Fbg6Fhm4t+Jyy5JC1W3YO8dYLsO0PXPbxodBgttTbH3rt9Cp1lJIk2r3O1Zqu94eRbnIz2f50lWolYzuKsj4PMok4abHLO8NAC884hiXx5Fy5pWKO0bWL7uEGXaJCtznhP67SlQ4xjWIfgq6EpZ28QMtuZK7JC0RGbl9nA4XtFLug/NLMoH1pGt9IonAJqcEDLyH6TDROcbsmGPaGIxMo41IUAnQVPMPGByp4mOmh9ZQMkBAcksUK55LsZj7E5z5XuZoyWCKu6nHmDq22xI/9Z8YdxJy4kWpD16jLVrpwGLWfyOD0Wd+cBzFBxVaGv7S5k9qwh/5t/LQEXsRqI3Q9Rm3QIoaZW9GlsDaKOUyykyWuhNOprSEi0s1G4rgoiX1V743EELti+pJu5og6X0g6oTynUqlhH9k6ezyRi05NGZHz0nvp3HOJr7ebrAUFrDjbkFBObEvdQWkkUbL0pEvMU46X58vF9j9F3j6kpyetNUBItrEubW9ZvMPM4qNqLlsSBJqOH3XbNwv/cXDXNxN8iFLzUhteisYY+RlHYOuP29/Cb+L+xv+35Rv7xudnZ6ohK4cMPfCG8KI7dNmjNk/H4e84pOxn/sZHK9psfvj8ncA8qJz7O8xqbxESDivGJOZzF7o5PJLQ7g34qAWoyuA+x3btU98LT6ZyGyceIXjrqob2CAVql4VOTQPUQYvHV/g4zAuCZGvYQBtf0wmd5lilrvuEn1BXLny01B4h4SMDlYsnNpm9d7m9h578ufpef9Z4WplqWQvqo52fyUA7J24eZD5av6SyGIV9kpmHNqyvdfzcpEMw97BvknV2fq+MFHun9BT3Lsf8pbzvisWiIQvYkng+8Vxk1V+dli1u56kY50LRjaPdotvT5BwqtwyF+emo/z9J3yVUVGfKrxQtJMOAQWoQii/4dp9wgybSa5mkucmRLtEQZ/pz0tL/NVcgWAd95nEQ3Tg6tNbuyn3Iepz65L3huMUUBntllWuu4DbtOFSMSbpILV4fy6wlM0SOvi6CpLh81c1LreIvKd61uEWBcDw1lUBUW1I0Z+m/PaRlX+PQ/oxg0Ye6KUiIiTF4ADNk59Ydpt5/rkxmq9tV5Kcp/eQLUVVmBzQNVuytQCP6Ezd0G8eLxWyHpmZWJ3bAzkWTtg4lZlw42SQezEmiUPaJUuR/qklVA/87S4ArFCpALdY3QRdUw3G3XbWUp6aq9z0zUizcPa7351p9JXOZyfdZBFnqt90VzQndXB/mwf8LC9STj5kenVpNuqOQQP3mIRJj7eV21FxG8VAxKrEn3c+XfmZ800EPb9/5lIlijscUbB6da0RQaMook0zug1G0tKi/JBC4rw7/D3m4ARzAkzMcVrDcT2SyFtUdWAsFlsPDFqV3N+EjyXaoEePwroaZCiLqEzb8MW+PNE9TmTC01EzWli51PzZvUqkmyuROU+V6ik+Le/9qT6nwzUzf9tP68tYei0YaDGx6kAd7jn1cKqOCuYbiELH9zYqcc4MnRJjkeGiqaGwLImhyeKs+xKJMBlOJ05ow9gGCKZ1VpnMKoSCTbMS+X+23y042zOb5MtcY/6oBeAo1Vy89OTyhpavFP78jXCcFH0t7Gx24hMEOm2gsEfGabVpQgvFqbQKMsknFRRmuPHcZu0Su/WMFphZvB2r/EGbG72rpGGho3h+Msz0uGzJ7hNK2uqQiE1qmn0zgacKYYZBCqsxV+sjbpoVdSilW/b94n2xNb648VmNIoizqEWhBnsen+d0kbCPmRItfWqSBeOd9Wne3c6bcd6uvXOJ6WdiSsuXq0ndhqrQ4QoWUjCjYtZ0EAhnSOP1m44xkf0O7jXghrzSJWxP4a/t72jU29Vu2rvu4n7HfHkkmQOMGSS+NPeLGO5I73mC2B7+lMiBQQZRM9/9liLIfowupUFAbPBbR+lxDM6M8Ptgh1paJq5Rvs7yEuLQv/7d1oU2woFSb3FMPWQOKMuCuJ7pDDjpIclus5TeEoMBy2YdVB4fxmesaCeMNsEgTHKS5WDSGyNUOoEpcC2OFWtIRf0w27ck34/DjxRTVIcc9+kqZE6iMSiVDsiKdP/Xz5XfEhm/sBhO50p1rvJDlkyyxuJ9SPgs7YeUJBjXdeAkE+P9OQJm6SZnn1svcduI78dYmbkE2mtziPrcjVisXG78spLvbZaSFx/Rks9zP4LKn0Cdz/3JsetkT06A8f/yCgMO6Mb1Hme0JJ7b2wZz1qleqTuKBGokhPVUZ0dVu+tnQYNEY1fmkZSz6+EGZ5EzL7657mreZGR3jUfaEk458PDniBzsSmBKhDRzfXameryJv9/D5m6HIqZ0R+ouCE54Dzp4IJuuD1e4Dc5i+PpSORJfG23uVgqixAMDvchMR0nZdH5brclYwRoJRWv/rlxGRI5ffD5NPGmIDt7vDE1434pYdVZIFh89Bs94HGGJbTwrN8T6lh1HZFTOB4lWzWj6EVqxSMvC0/ljWBQ3F2kc/mO2b6tWonT2JEqEwFts8rz2h+oWNds9ceR2cb7zZvJTDppHaEhK5avWqsseWa2Dt5BBhabdWSktS80oMQrL4TvAM9b5HMmyDnO+OkkbMXfUJG7eXqTIG6lqSOEbqVR+qYdP7uWb57WEJqzyh411GAVsDinPs7KvUeXItlcMdOUWzXBH6zscymV1LLVCtc8IePojzXHF9m5b5zGwBRdzcyUJkiu938ApmAayRdJrX1PmVguWUvt2ThQ62czItTyWJMW2An/hdDfMK7SiFQlGIdAbltHz3ycoh7j9V7GxNWBpbtcSdqm4XxRwTawc3cbZ+xfSv9qQfEkDKfZTwCkqWGI/ur250ItXlMlh6vUNWEYIg9A3GzbgmbqvTN8js2YMo87CU5y6nZ4dbJLDQJj9fc7yM7tZzJDZFtqOcU8+mZjYlq4VmifI23iHb1ZoT9E+kT2dolnP1AfiOkt7PQCSykBiXy5mv637IegWSKj9IKrYZf4Lu9+I7ub+mkRdlvYzehh/jaJ9n7HUH5b2IbgeNdkY7wx1yVzxS7pbvky6+nmVUtRllEFfweUQ0/nG017WoUYSxs+j2B4FV/F62EtHlMWZXYrjGHpthnNb1x66LKZ0Qe92INWHdfR/vqp02wMS8r1G4dJqHok8KmQ7947G13a4YXbsGgHcBvRuVu1eAi4/A5+ZixmdSXM73LupB/LH7O9yxLTVXJTyBbI1S49TIROrfVCOb/czZ9pM4JsZx8kUz8dQGv7gUWKxXvTH7QM/3J2OuXXgciUhqY+cgtaOliQQVOYthBLV3xpESZT3rmfEYNZxmpBbb24CRao86prn+i9TNOh8VxRJGXJfXHATJHs1T5txgc/opYrY8XjlGQQbRcoxIBcnVsMjmU1ymmIUL4dviJXndMAJ0Yet+c7O52/p98ytlmAsGBaTAmMhimAnvp1TWNGM9BpuitGj+t810CU2UhorrjPKGtThVC8WaXw04WFnT5fTjqmPyrQ0tN3CkLsctVy2xr0ZWgiWVZ1OrlFjjxJYsOiZv2cAoOvE+7sY0I/TwWcZqMoyIKNOftwP7w++Rfg67ljfovKYa50if3fzE/8aPYVey/Nq35+nH2sLPh/fP5TsylSKGOZ4k69d2PnH43+kq++sRXHQqGArWdwhx+hpwQC6JgT2uxehYU4Zbw7oNb6/HLikPyJROGK2ouyr+vzseESp9G50T4AyFrSqOQ0rroCYP4sMDFBrHn342EyZTMlSyk47rHSq89Y9/nI3zG5lX16Z5lxphguLOcZUndL8wNcrkyjH82jqg8Bo8OYkynrxZvbFno5lUS3OPr8Ko3mX9NoRPdYOKKjD07bvgFgpZ/RF+YzkWvJ/Hs/tUbfeGzGWLxNAjfDzHHMVSDwB5SabQLsIZHiBp43FjGkaienYoDd18hu2BGwOK7U3o70K/WY/kuuKdmdrykIBUdG2mvE91L1JtTbh20mOLbk1vCAamu7utlXeGU2ooVikbU/actcgmsC1FKk2qmj3GWeIWbj4tGIxE7BLcBWUvvcnd/lYxsMV4F917fWeFB/XbINN3qGvIyTpCalz1lVewdIGqeAS/gB8Mi+sA+BqDiX3VGD2eUunTRbSY+AuDy4E3Qx3hAhwnSXX+B0zuj3eQ1miS8Vux2z/l6/BkWtjKGU72aJkOCWhGcSf3+kFkkB15vGOsQrSdFr6qTj0gBYiOlnBO41170gOWHSUoBVRU2JjwppYdhIFDfu7tIRHccSNM5KZOFDPz0TGMAjzzEpeLwTWp+kn201kU6NjbiMQJx83+LX1e1tZ10kuChJZ/XBUQ1dwaBHjTDJDqOympEk8X2M3VtVw21JksChA8w1tTefO3RJ1FMbqZ01bHHkudDB/OhLfe7P5GOHaI28ZXKTMuqo0hLWQ4HabBsGG7NbP1RiXtETz074er6w/OerJWEqjmkq2y51q1BVI+JUudnVa3ogBpzdhFE7fC7kybrAt2Z6RqDjATAUEYeYK45WMupBKQRtQlU+uNsjnzj6ZmGrezA+ASrWxQ6LMkHRXqXwNq7ftv28dUx/ZSJciDXP2SWJsWaN0FjPX9Yko6LobZ7aYW/IdUktI9apTLyHS8DyWPyuoZyxN1TK/vtfxk3HwWh6JczZC8Ftn0bIJay2g+n5wd7lm9rEsKO+svqVmi+c1j88hSCxbzrg4+HEP0Nt1/B6YW1XVm09T1CpAKjc9n18hjqsaFGdfyva1ZG0Xu3ip6N6JGpyTSqY5h4BOlpLPaOnyw45PdXTN+DtAKg7DLrLFTnWusoSBHk3s0d7YouJHq85/R09Tfc37ENXZF48eAYLnq9GLioNcwDZrC6FW6godB8JnqYUPvn0pWLfQz0lM0Yy8Mybgn84Ds3Q9bDP10bLyOV+qzxa4Rd9Dhu7cju8mMaONXK3UqmBQ9qIg7etIwEqM/kECk/Dzja4Bs1xR+Q/tCbc8IKrSGsTdJJ0vge7IG20W687uVmK6icWQ6cD3lwFzgNMGtFvO5qyJeKflGLAAcQZOrkxVwy3cWvqlGpvjmf9Qe6Ap20MPbV92DPV0OhFM4kz8Yr0ffC2zLWSQ1kqY6QdQrttR3kh1YLtQd1kCEv5hVoPIRWl5ERcUTttBIrWp6Xs5Ehh5OUUwI5aEBvuiDmUoENmnVw1FohCrbRp1A1E+XSlWVOTi7ADW+5Ohb9z1vK4qx5R5lPdGCPBJZ00mC+Ssp8VUbgpGAvXWMuWQQRbCqI6Rr2jtxZxtfP7W/8onz+yz0Gs76LaT5HX9ecyiZCB/ZR/gFtMxPsDwohoeCRtiuLxE1GM1vUEUgBv86+eehL58/P56QFGQ/MqOe/vC76L63jzmeax4exd/OKTUvkXg+fOJUHych9xt/9goJMrapSgvXrj8+8vk/N80f22Sewj6cyGqt1B6mztoeklVHHraouhvHJaG/OuBz6DHKMpFmQULU1bRWlyYE0RPXYYkUycIemN7TLtgNCJX6BqdyxDKkegO7nJK5xQ7OVYDZTMf9bVHidtk6DQX9Et+V9M7esgbsYBdEeUpsB0Xvw2kd9+rI7V+m47u+O/tq7mw7262HU1WlS9uFzsV6JxIHNmUCy0QS9e077JGRFbG65z3/dOKB/Zk+yDdKpUmdXjn/aS3N5nv4fK7bMHHmPlHd4E2+iTbV5rpzScRnxk6KARuDTJ8Q1LpK2mP8gj1EbuJ9RIyY+EWK4hCiIDBAS1Tm2IEXAFfgKPgdL9O6mAa06wjCcUAL6EsxPQWO9VNegBPm/0GgkZbDxCynxujX/92vmGcjZRMAY45puak2sFLCLSwXpEsyy5fnF0jGJBhm+fNSHKKUUfy+276A7/feLOFxxUuHRNJI2Osenxyvf8DAGObT60pfTTlhEg9u/KKkhJqm5U1/+BEcSkpFDA5XeCqxwXmPac1jcuZ3JWQ+p0NdWzb/5v1ZvF8GtMTFFEdQjpLO0bwPb0BHNWnip3liDXI2fXf05jjvfJ0NpjLCUgfTh9CMFYVFKEd4Z/OG/2C+N435mnK+9t1gvCiVcaaH7rK4+PjCvpVNiz+t2QyqH1O8x3JKZVl6Q+Lp/XK8wMjVMslOq9FdSw5FtUs/CptXH9PW+wbWHgrV17R5jTVOtGtKFu3nb80T+E0tv9QkzW3J2dbaw/8ddAKZ0pxIaEqLjlPrji3VgJ3GvdFvlqD8075woxh4fVt0JZE0KVFsAvqhe0dqN9b35jtSpnYMXkU+vZq+IAHad3IHc2s/LYrnD1anfG46IFiMIr9oNbZDWvwthqYNqOigaKd/XlLU4XHfk/PXIjPsLy/9/kAtQ+/wKH+hI/IROWj5FPvTZAT9f7j4ZXQyG4M0TujMAFXYkKvEHv1xhySekgXGGqNxWeWKlf8dDAlLuB1cb/qOD+rk7cmwt+1yKpk9cudqBanTi6zTbXRtV8qylNtjyOVKy1HTz0GW9rjt6sSjAZcT5R+KdtyYb0zyqG9pSLuCw5WBwAn7fjBjKLLoxLXMI+52L9cLwIR2B6OllJZLHJ8vDxmWdtF+QJnmt1rsHPIWY20lftk8fYePkAIg6Hgn532QoIpegMxiWgAOfe5/U44APR8Ac0NeZrVh3gEhs12W+tVSiWiUQekf/YBECUy5fdYbA08dd7VzPAP9aiVcIB9k6tY7WdJ1wNV+bHeydNtmC6G5ICtFC1ZwmJU/j8hf0I8TRVKSiz5oYIa93EpUI78X8GYIAZabx47/n8LDAAJ0nNtP1rpROprqKMBRecShca6qXuTSI3jZBLOB3Vp381B5rCGhjSvh/NSVkYp2qIdP/Bg=";
            },
            /***/
            3532(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function(Math2) {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var WordArray = C_lib.WordArray;
                  var Hasher = C_lib.Hasher;
                  var C_algo = C.algo;
                  var T = [];
                  (function() {
                    for (var i = 0; i < 64; i++) {
                      T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
                    }
                  })();
                  var MD5 = C_algo.MD5 = Hasher.extend({
                    _doReset: function() {
                      this._hash = new WordArray.init([1732584193, 4023233417, 2562383102, 271733878]);
                    },
                    _doProcessBlock: function(M, offset) {
                      for (var i = 0; i < 16; i++) {
                        var offset_i = offset + i;
                        var M_offset_i = M[offset_i];
                        M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
                      }
                      var H = this._hash.words;
                      var M_offset_0 = M[offset + 0];
                      var M_offset_1 = M[offset + 1];
                      var M_offset_2 = M[offset + 2];
                      var M_offset_3 = M[offset + 3];
                      var M_offset_4 = M[offset + 4];
                      var M_offset_5 = M[offset + 5];
                      var M_offset_6 = M[offset + 6];
                      var M_offset_7 = M[offset + 7];
                      var M_offset_8 = M[offset + 8];
                      var M_offset_9 = M[offset + 9];
                      var M_offset_10 = M[offset + 10];
                      var M_offset_11 = M[offset + 11];
                      var M_offset_12 = M[offset + 12];
                      var M_offset_13 = M[offset + 13];
                      var M_offset_14 = M[offset + 14];
                      var M_offset_15 = M[offset + 15];
                      var a = H[0];
                      var b = H[1];
                      var c = H[2];
                      var d = H[3];
                      a = FF(a, b, c, d, M_offset_0, 7, T[0]);
                      d = FF(d, a, b, c, M_offset_1, 12, T[1]);
                      c = FF(c, d, a, b, M_offset_2, 17, T[2]);
                      b = FF(b, c, d, a, M_offset_3, 22, T[3]);
                      a = FF(a, b, c, d, M_offset_4, 7, T[4]);
                      d = FF(d, a, b, c, M_offset_5, 12, T[5]);
                      c = FF(c, d, a, b, M_offset_6, 17, T[6]);
                      b = FF(b, c, d, a, M_offset_7, 22, T[7]);
                      a = FF(a, b, c, d, M_offset_8, 7, T[8]);
                      d = FF(d, a, b, c, M_offset_9, 12, T[9]);
                      c = FF(c, d, a, b, M_offset_10, 17, T[10]);
                      b = FF(b, c, d, a, M_offset_11, 22, T[11]);
                      a = FF(a, b, c, d, M_offset_12, 7, T[12]);
                      d = FF(d, a, b, c, M_offset_13, 12, T[13]);
                      c = FF(c, d, a, b, M_offset_14, 17, T[14]);
                      b = FF(b, c, d, a, M_offset_15, 22, T[15]);
                      a = GG(a, b, c, d, M_offset_1, 5, T[16]);
                      d = GG(d, a, b, c, M_offset_6, 9, T[17]);
                      c = GG(c, d, a, b, M_offset_11, 14, T[18]);
                      b = GG(b, c, d, a, M_offset_0, 20, T[19]);
                      a = GG(a, b, c, d, M_offset_5, 5, T[20]);
                      d = GG(d, a, b, c, M_offset_10, 9, T[21]);
                      c = GG(c, d, a, b, M_offset_15, 14, T[22]);
                      b = GG(b, c, d, a, M_offset_4, 20, T[23]);
                      a = GG(a, b, c, d, M_offset_9, 5, T[24]);
                      d = GG(d, a, b, c, M_offset_14, 9, T[25]);
                      c = GG(c, d, a, b, M_offset_3, 14, T[26]);
                      b = GG(b, c, d, a, M_offset_8, 20, T[27]);
                      a = GG(a, b, c, d, M_offset_13, 5, T[28]);
                      d = GG(d, a, b, c, M_offset_2, 9, T[29]);
                      c = GG(c, d, a, b, M_offset_7, 14, T[30]);
                      b = GG(b, c, d, a, M_offset_12, 20, T[31]);
                      a = HH(a, b, c, d, M_offset_5, 4, T[32]);
                      d = HH(d, a, b, c, M_offset_8, 11, T[33]);
                      c = HH(c, d, a, b, M_offset_11, 16, T[34]);
                      b = HH(b, c, d, a, M_offset_14, 23, T[35]);
                      a = HH(a, b, c, d, M_offset_1, 4, T[36]);
                      d = HH(d, a, b, c, M_offset_4, 11, T[37]);
                      c = HH(c, d, a, b, M_offset_7, 16, T[38]);
                      b = HH(b, c, d, a, M_offset_10, 23, T[39]);
                      a = HH(a, b, c, d, M_offset_13, 4, T[40]);
                      d = HH(d, a, b, c, M_offset_0, 11, T[41]);
                      c = HH(c, d, a, b, M_offset_3, 16, T[42]);
                      b = HH(b, c, d, a, M_offset_6, 23, T[43]);
                      a = HH(a, b, c, d, M_offset_9, 4, T[44]);
                      d = HH(d, a, b, c, M_offset_12, 11, T[45]);
                      c = HH(c, d, a, b, M_offset_15, 16, T[46]);
                      b = HH(b, c, d, a, M_offset_2, 23, T[47]);
                      a = II(a, b, c, d, M_offset_0, 6, T[48]);
                      d = II(d, a, b, c, M_offset_7, 10, T[49]);
                      c = II(c, d, a, b, M_offset_14, 15, T[50]);
                      b = II(b, c, d, a, M_offset_5, 21, T[51]);
                      a = II(a, b, c, d, M_offset_12, 6, T[52]);
                      d = II(d, a, b, c, M_offset_3, 10, T[53]);
                      c = II(c, d, a, b, M_offset_10, 15, T[54]);
                      b = II(b, c, d, a, M_offset_1, 21, T[55]);
                      a = II(a, b, c, d, M_offset_8, 6, T[56]);
                      d = II(d, a, b, c, M_offset_15, 10, T[57]);
                      c = II(c, d, a, b, M_offset_6, 15, T[58]);
                      b = II(b, c, d, a, M_offset_13, 21, T[59]);
                      a = II(a, b, c, d, M_offset_4, 6, T[60]);
                      d = II(d, a, b, c, M_offset_11, 10, T[61]);
                      c = II(c, d, a, b, M_offset_2, 15, T[62]);
                      b = II(b, c, d, a, M_offset_9, 21, T[63]);
                      H[0] = H[0] + a | 0;
                      H[1] = H[1] + b | 0;
                      H[2] = H[2] + c | 0;
                      H[3] = H[3] + d | 0;
                    },
                    _doFinalize: function() {
                      var data = this._data;
                      var dataWords = data.words;
                      var nBitsTotal = this._nDataBytes * 8;
                      var nBitsLeft = data.sigBytes * 8;
                      dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                      var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
                      var nBitsTotalL = nBitsTotal;
                      dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
                      dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
                      data.sigBytes = (dataWords.length + 1) * 4;
                      this._process();
                      var hash = this._hash;
                      var H = hash.words;
                      for (var i = 0; i < 4; i++) {
                        var H_i = H[i];
                        H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
                      }
                      return hash;
                    },
                    clone: function() {
                      var clone = Hasher.clone.call(this);
                      clone._hash = this._hash.clone();
                      return clone;
                    }
                  });
                  function FF(a, b, c, d, x, s, t) {
                    var n = a + (b & c | ~b & d) + x + t;
                    return (n << s | n >>> 32 - s) + b;
                  }
                  function GG(a, b, c, d, x, s, t) {
                    var n = a + (b & d | c & ~d) + x + t;
                    return (n << s | n >>> 32 - s) + b;
                  }
                  function HH(a, b, c, d, x, s, t) {
                    var n = a + (b ^ c ^ d) + x + t;
                    return (n << s | n >>> 32 - s) + b;
                  }
                  function II(a, b, c, d, x, s, t) {
                    var n = a + (c ^ (b | ~d)) + x + t;
                    return (n << s | n >>> 32 - s) + b;
                  }
                  C.MD5 = Hasher._createHelper(MD5);
                  C.HmacMD5 = Hasher._createHmacHelper(MD5);
                })(Math);
                return CryptoJS.MD5;
              });
            },
            /***/
            3534(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var getPolyfill = __webpack_require__2(9636);
              var define2 = __webpack_require__2(5421);
              module2.exports = function shimObjectIs() {
                var polyfill = getPolyfill();
                define2(Object, { is: polyfill }, {
                  is: function testObjectIs() {
                    return Object.is !== polyfill;
                  }
                });
                return polyfill;
              };
            },
            /***/
            3598(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var isCallable = __webpack_require__2(8681);
              module2.exports = function(it) {
                return typeof it == "object" ? it !== null : isCallable(it);
              };
            },
            /***/
            3610(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(4866), __webpack_require__2(3532), __webpack_require__2(6818), __webpack_require__2(2858));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function() {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var StreamCipher = C_lib.StreamCipher;
                  var C_algo = C.algo;
                  var S = [];
                  var C_ = [];
                  var G = [];
                  var Rabbit = C_algo.Rabbit = StreamCipher.extend({
                    _doReset: function() {
                      var K = this._key.words;
                      var iv = this.cfg.iv;
                      for (var i = 0; i < 4; i++) {
                        K[i] = (K[i] << 8 | K[i] >>> 24) & 16711935 | (K[i] << 24 | K[i] >>> 8) & 4278255360;
                      }
                      var X = this._X = [K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16];
                      var C2 = this._C = [K[2] << 16 | K[2] >>> 16, K[0] & 4294901760 | K[1] & 65535, K[3] << 16 | K[3] >>> 16, K[1] & 4294901760 | K[2] & 65535, K[0] << 16 | K[0] >>> 16, K[2] & 4294901760 | K[3] & 65535, K[1] << 16 | K[1] >>> 16, K[3] & 4294901760 | K[0] & 65535];
                      this._b = 0;
                      for (var i = 0; i < 4; i++) {
                        nextState.call(this);
                      }
                      for (var i = 0; i < 8; i++) {
                        C2[i] ^= X[i + 4 & 7];
                      }
                      if (iv) {
                        var IV = iv.words;
                        var IV_0 = IV[0];
                        var IV_1 = IV[1];
                        var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                        var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                        var i1 = i0 >>> 16 | i2 & 4294901760;
                        var i3 = i2 << 16 | i0 & 65535;
                        C2[0] ^= i0;
                        C2[1] ^= i1;
                        C2[2] ^= i2;
                        C2[3] ^= i3;
                        C2[4] ^= i0;
                        C2[5] ^= i1;
                        C2[6] ^= i2;
                        C2[7] ^= i3;
                        for (var i = 0; i < 4; i++) {
                          nextState.call(this);
                        }
                      }
                    },
                    _doProcessBlock: function(M, offset) {
                      var X = this._X;
                      nextState.call(this);
                      S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
                      S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
                      S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
                      S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
                      for (var i = 0; i < 4; i++) {
                        S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
                        M[offset + i] ^= S[i];
                      }
                    },
                    blockSize: 128 / 32,
                    ivSize: 64 / 32
                  });
                  function nextState() {
                    var X = this._X;
                    var C2 = this._C;
                    for (var i = 0; i < 8; i++) {
                      C_[i] = C2[i];
                    }
                    C2[0] = C2[0] + 1295307597 + this._b | 0;
                    C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
                    C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
                    C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
                    C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
                    C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
                    C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
                    C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
                    this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
                    for (var i = 0; i < 8; i++) {
                      var gx = X[i] + C2[i];
                      var ga = gx & 65535;
                      var gb = gx >>> 16;
                      var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
                      var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
                      G[i] = gh ^ gl;
                    }
                    X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
                    X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
                    X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
                    X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
                    X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
                    X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
                    X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
                    X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
                  }
                  C.Rabbit = StreamCipher._createHelper(Rabbit);
                })();
                return CryptoJS.Rabbit;
              });
            },
            /***/
            3620(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(321));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function() {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var WordArray = C_lib.WordArray;
                  var C_algo = C.algo;
                  var SHA256 = C_algo.SHA256;
                  var SHA224 = C_algo.SHA224 = SHA256.extend({
                    _doReset: function() {
                      this._hash = new WordArray.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]);
                    },
                    _doFinalize: function() {
                      var hash = SHA256._doFinalize.call(this);
                      hash.sigBytes -= 4;
                      return hash;
                    }
                  });
                  C.SHA224 = SHA256._createHelper(SHA224);
                  C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
                })();
                return CryptoJS.SHA224;
              });
            },
            /***/
            3701(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(2858));
                } else {
                }
              })(void 0, function(CryptoJS) {
                CryptoJS.mode.OFB = function() {
                  var OFB = CryptoJS.lib.BlockCipherMode.extend();
                  var Encryptor = OFB.Encryptor = OFB.extend({
                    processBlock: function(words, offset) {
                      var cipher = this._cipher;
                      var blockSize = cipher.blockSize;
                      var iv = this._iv;
                      var keystream = this._keystream;
                      if (iv) {
                        keystream = this._keystream = iv.slice(0);
                        this._iv = void 0;
                      }
                      cipher.encryptBlock(keystream, 0);
                      for (var i = 0; i < blockSize; i++) {
                        words[offset + i] ^= keystream[i];
                      }
                    }
                  });
                  OFB.Decryptor = Encryptor;
                  return OFB;
                }();
                return CryptoJS.mode.OFB;
              });
            },
            /***/
            3746(module2) {
              "use strict";
              var fnToStr = Function.prototype.toString;
              var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
              var badArrayLike;
              var isCallableMarker;
              if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
                try {
                  badArrayLike = Object.defineProperty({}, "length", {
                    get: function() {
                      throw isCallableMarker;
                    }
                  });
                  isCallableMarker = {};
                  reflectApply(function() {
                    throw 42;
                  }, null, badArrayLike);
                } catch (_) {
                  if (_ !== isCallableMarker) {
                    reflectApply = null;
                  }
                }
              } else {
                reflectApply = null;
              }
              var constructorRegex = /^\s*class\b/;
              var isES6ClassFn = function isES6ClassFunction(value) {
                try {
                  var fnStr = fnToStr.call(value);
                  return constructorRegex.test(fnStr);
                } catch (e) {
                  return false;
                }
              };
              var tryFunctionObject = function tryFunctionToStr(value) {
                try {
                  if (isES6ClassFn(value)) {
                    return false;
                  }
                  fnToStr.call(value);
                  return true;
                } catch (e) {
                  return false;
                }
              };
              var toStr = Object.prototype.toString;
              var objectClass = "[object Object]";
              var fnClass = "[object Function]";
              var genClass = "[object GeneratorFunction]";
              var ddaClass = "[object HTMLAllCollection]";
              var ddaClass2 = "[object HTML document.all class]";
              var ddaClass3 = "[object HTMLCollection]";
              var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
              var isIE68 = !(0 in [,]);
              var isDDA = function isDocumentDotAll() {
                return false;
              };
              if (typeof document === "object") {
                var all = document.all;
                if (toStr.call(all) === toStr.call(document.all)) {
                  isDDA = function isDocumentDotAll(value) {
                    if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
                      try {
                        var str = toStr.call(value);
                        return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
                      } catch (e) {
                      }
                    }
                    return false;
                  };
                }
              }
              module2.exports = reflectApply ? function isCallable(value) {
                if (isDDA(value)) {
                  return true;
                }
                if (!value) {
                  return false;
                }
                if (typeof value !== "function" && typeof value !== "object") {
                  return false;
                }
                try {
                  reflectApply(value, null, badArrayLike);
                } catch (e) {
                  if (e !== isCallableMarker) {
                    return false;
                  }
                }
                return !isES6ClassFn(value) && tryFunctionObject(value);
              } : function isCallable(value) {
                if (isDDA(value)) {
                  return true;
                }
                if (!value) {
                  return false;
                }
                if (typeof value !== "function" && typeof value !== "object") {
                  return false;
                }
                if (hasToStringTag) {
                  return tryFunctionObject(value);
                }
                if (isES6ClassFn(value)) {
                  return false;
                }
                var strClass = toStr.call(value);
                if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
                  return false;
                }
                return tryFunctionObject(value);
              };
            },
            /***/
            3752(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function(Math2) {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var WordArray = C_lib.WordArray;
                  var Hasher = C_lib.Hasher;
                  var C_algo = C.algo;
                  var _zl = WordArray.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]);
                  var _zr = WordArray.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]);
                  var _sl = WordArray.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]);
                  var _sr = WordArray.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]);
                  var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
                  var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
                  var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
                    _doReset: function() {
                      this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
                    },
                    _doProcessBlock: function(M, offset) {
                      for (var i = 0; i < 16; i++) {
                        var offset_i = offset + i;
                        var M_offset_i = M[offset_i];
                        M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
                      }
                      var H = this._hash.words;
                      var hl = _hl.words;
                      var hr = _hr.words;
                      var zl = _zl.words;
                      var zr = _zr.words;
                      var sl = _sl.words;
                      var sr = _sr.words;
                      var al, bl, cl, dl, el;
                      var ar, br, cr, dr, er;
                      ar = al = H[0];
                      br = bl = H[1];
                      cr = cl = H[2];
                      dr = dl = H[3];
                      er = el = H[4];
                      var t;
                      for (var i = 0; i < 80; i += 1) {
                        t = al + M[offset + zl[i]] | 0;
                        if (i < 16) {
                          t += f1(bl, cl, dl) + hl[0];
                        } else if (i < 32) {
                          t += f2(bl, cl, dl) + hl[1];
                        } else if (i < 48) {
                          t += f3(bl, cl, dl) + hl[2];
                        } else if (i < 64) {
                          t += f4(bl, cl, dl) + hl[3];
                        } else {
                          t += f5(bl, cl, dl) + hl[4];
                        }
                        t = t | 0;
                        t = rotl(t, sl[i]);
                        t = t + el | 0;
                        al = el;
                        el = dl;
                        dl = rotl(cl, 10);
                        cl = bl;
                        bl = t;
                        t = ar + M[offset + zr[i]] | 0;
                        if (i < 16) {
                          t += f5(br, cr, dr) + hr[0];
                        } else if (i < 32) {
                          t += f4(br, cr, dr) + hr[1];
                        } else if (i < 48) {
                          t += f3(br, cr, dr) + hr[2];
                        } else if (i < 64) {
                          t += f2(br, cr, dr) + hr[3];
                        } else {
                          t += f1(br, cr, dr) + hr[4];
                        }
                        t = t | 0;
                        t = rotl(t, sr[i]);
                        t = t + er | 0;
                        ar = er;
                        er = dr;
                        dr = rotl(cr, 10);
                        cr = br;
                        br = t;
                      }
                      t = H[1] + cl + dr | 0;
                      H[1] = H[2] + dl + er | 0;
                      H[2] = H[3] + el + ar | 0;
                      H[3] = H[4] + al + br | 0;
                      H[4] = H[0] + bl + cr | 0;
                      H[0] = t;
                    },
                    _doFinalize: function() {
                      var data = this._data;
                      var dataWords = data.words;
                      var nBitsTotal = this._nDataBytes * 8;
                      var nBitsLeft = data.sigBytes * 8;
                      dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                      dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
                      data.sigBytes = (dataWords.length + 1) * 4;
                      this._process();
                      var hash = this._hash;
                      var H = hash.words;
                      for (var i = 0; i < 5; i++) {
                        var H_i = H[i];
                        H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
                      }
                      return hash;
                    },
                    clone: function() {
                      var clone = Hasher.clone.call(this);
                      clone._hash = this._hash.clone();
                      return clone;
                    }
                  });
                  function f1(x, y, z) {
                    return x ^ y ^ z;
                  }
                  function f2(x, y, z) {
                    return x & y | ~x & z;
                  }
                  function f3(x, y, z) {
                    return (x | ~y) ^ z;
                  }
                  function f4(x, y, z) {
                    return x & z | y & ~z;
                  }
                  function f5(x, y, z) {
                    return x ^ (y | ~z);
                  }
                  function rotl(x, n) {
                    return x << n | x >>> 32 - n;
                  }
                  C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
                  C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
                })(Math);
                return CryptoJS.RIPEMD160;
              });
            },
            /***/
            3765(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var eos;
              function once(callback) {
                var called = false;
                return function() {
                  if (called) return;
                  called = true;
                  callback.apply(void 0, arguments);
                };
              }
              var _require$codes = __webpack_require__2(3797).F, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
              function noop(err) {
                if (err) throw err;
              }
              function isRequest(stream) {
                return stream.setHeader && typeof stream.abort === "function";
              }
              function destroyer(stream, reading, writing, callback) {
                callback = once(callback);
                var closed = false;
                stream.on("close", function() {
                  closed = true;
                });
                if (eos === void 0) eos = __webpack_require__2(2167);
                eos(stream, {
                  readable: reading,
                  writable: writing
                }, function(err) {
                  if (err) return callback(err);
                  closed = true;
                  callback();
                });
                var destroyed = false;
                return function(err) {
                  if (closed) return;
                  if (destroyed) return;
                  destroyed = true;
                  if (isRequest(stream)) return stream.abort();
                  if (typeof stream.destroy === "function") return stream.destroy();
                  callback(err || new ERR_STREAM_DESTROYED("pipe"));
                };
              }
              function call(fn) {
                fn();
              }
              function pipe(from, to) {
                return from.pipe(to);
              }
              function popCallback(streams) {
                if (!streams.length) return noop;
                if (typeof streams[streams.length - 1] !== "function") return noop;
                return streams.pop();
              }
              function pipeline() {
                for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
                  streams[_key] = arguments[_key];
                }
                var callback = popCallback(streams);
                if (Array.isArray(streams[0])) streams = streams[0];
                if (streams.length < 2) {
                  throw new ERR_MISSING_ARGS("streams");
                }
                var error;
                var destroys = streams.map(function(stream, i) {
                  var reading = i < streams.length - 1;
                  var writing = i > 0;
                  return destroyer(stream, reading, writing, function(err) {
                    if (!error) error = err;
                    if (err) destroys.forEach(call);
                    if (reading) return;
                    destroys.forEach(call);
                    callback(error);
                  });
                });
                return streams.reduce(pipe);
              }
              module2.exports = pipeline;
            },
            /***/
            3766(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var $Object = __webpack_require__2(5846);
              module2.exports = $Object.getPrototypeOf || null;
            },
            /***/
            3774(module2) {
              "use strict";
              module2.exports = Math.max;
            },
            /***/
            3779() {
            },
            /***/
            3793(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var IS_PURE = __webpack_require__2(7695);
              var globalThis2 = __webpack_require__2(7756);
              var defineGlobalProperty = __webpack_require__2(7309);
              var SHARED = "__core-js_shared__";
              var store = module2.exports = globalThis2[SHARED] || defineGlobalProperty(SHARED, {});
              (store.versions || (store.versions = [])).push({
                version: "3.47.0",
                mode: IS_PURE ? "pure" : "global",
                copyright: " 2014-2025 Denis Pushkarev (zloirock.ru), 2025 CoreJS Company (core-js.io)",
                license: "https://github.com/zloirock/core-js/blob/v3.47.0/LICENSE",
                source: "https://github.com/zloirock/core-js"
              });
            },
            /***/
            3797(module2) {
              "use strict";
              function _inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var codes = {};
              function createErrorType(code, message, Base) {
                if (!Base) {
                  Base = Error;
                }
                function getMessage(arg1, arg2, arg3) {
                  if (typeof message === "string") {
                    return message;
                  } else {
                    return message(arg1, arg2, arg3);
                  }
                }
                var NodeError = function(_Base) {
                  _inheritsLoose(NodeError2, _Base);
                  function NodeError2(arg1, arg2, arg3) {
                    return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
                  }
                  return NodeError2;
                }(Base);
                NodeError.prototype.name = Base.name;
                NodeError.prototype.code = code;
                codes[code] = NodeError;
              }
              function oneOf(expected, thing) {
                if (Array.isArray(expected)) {
                  var len = expected.length;
                  expected = expected.map(function(i) {
                    return String(i);
                  });
                  if (len > 2) {
                    return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
                  } else if (len === 2) {
                    return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
                  } else {
                    return "of ".concat(thing, " ").concat(expected[0]);
                  }
                } else {
                  return "of ".concat(thing, " ").concat(String(expected));
                }
              }
              function startsWith(str, search, pos) {
                return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
              }
              function endsWith(str, search, this_len) {
                if (this_len === void 0 || this_len > str.length) {
                  this_len = str.length;
                }
                return str.substring(this_len - search.length, this_len) === search;
              }
              function includes(str, search, start) {
                if (typeof start !== "number") {
                  start = 0;
                }
                if (start + search.length > str.length) {
                  return false;
                } else {
                  return str.indexOf(search, start) !== -1;
                }
              }
              createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
                return 'The value "' + value + '" is invalid for option "' + name + '"';
              }, TypeError);
              createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
                var determiner;
                if (typeof expected === "string" && startsWith(expected, "not ")) {
                  determiner = "must not be";
                  expected = expected.replace(/^not /, "");
                } else {
                  determiner = "must be";
                }
                var msg;
                if (endsWith(name, " argument")) {
                  msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
                } else {
                  var type = includes(name, ".") ? "property" : "argument";
                  msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
                }
                msg += ". Received type ".concat(typeof actual);
                return msg;
              }, TypeError);
              createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
              createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
                return "The " + name + " method is not implemented";
              });
              createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
              createErrorType("ERR_STREAM_DESTROYED", function(name) {
                return "Cannot call " + name + " after a stream was destroyed";
              });
              createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
              createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
              createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
              createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
              createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
                return "Unknown encoding: " + arg;
              }, TypeError);
              createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
              module2.exports.F = codes;
            },
            /***/
            3915(__unused_webpack_module, exports2, __webpack_require__2) {
              "use strict";
              __webpack_require__2(8376);
              __webpack_require__2(6401);
              __webpack_require__2(2017);
              var lookup = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
              ;
              (function(exports3) {
                "use strict";
                var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
                var PLUS = "+".charCodeAt(0);
                var SLASH = "/".charCodeAt(0);
                var NUMBER = "0".charCodeAt(0);
                var LOWER = "a".charCodeAt(0);
                var UPPER = "A".charCodeAt(0);
                var PLUS_URL_SAFE = "-".charCodeAt(0);
                var SLASH_URL_SAFE = "_".charCodeAt(0);
                function decode(elt) {
                  var code = elt.charCodeAt(0);
                  if (code === PLUS || code === PLUS_URL_SAFE) return 62;
                  if (code === SLASH || code === SLASH_URL_SAFE) return 63;
                  if (code < NUMBER) return -1;
                  if (code < NUMBER + 10) return code - NUMBER + 26 + 26;
                  if (code < UPPER + 26) return code - UPPER;
                  if (code < LOWER + 26) return code - LOWER + 26;
                }
                function b64ToByteArray(b64) {
                  var i, j, l, tmp, placeHolders, arr;
                  if (b64.length % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4");
                  }
                  var len = b64.length;
                  placeHolders = "=" === b64.charAt(len - 2) ? 2 : "=" === b64.charAt(len - 1) ? 1 : 0;
                  arr = new Arr(b64.length * 3 / 4 - placeHolders);
                  l = placeHolders > 0 ? b64.length - 4 : b64.length;
                  var L = 0;
                  function push(v) {
                    arr[L++] = v;
                  }
                  for (i = 0, j = 0; i < l; i += 4, j += 3) {
                    tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
                    push((tmp & 16711680) >> 16);
                    push((tmp & 65280) >> 8);
                    push(tmp & 255);
                  }
                  if (placeHolders === 2) {
                    tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
                    push(tmp & 255);
                  } else if (placeHolders === 1) {
                    tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
                    push(tmp >> 8 & 255);
                    push(tmp & 255);
                  }
                  return arr;
                }
                function uint8ToBase64(uint8) {
                  var i, extraBytes = uint8.length % 3, output = "", temp, length;
                  function encode(num) {
                    return lookup.charAt(num);
                  }
                  function tripletToBase64(num) {
                    return encode(num >> 18 & 63) + encode(num >> 12 & 63) + encode(num >> 6 & 63) + encode(num & 63);
                  }
                  for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
                    temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
                    output += tripletToBase64(temp);
                  }
                  switch (extraBytes) {
                    case 1:
                      temp = uint8[uint8.length - 1];
                      output += encode(temp >> 2);
                      output += encode(temp << 4 & 63);
                      output += "==";
                      break;
                    case 2:
                      temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
                      output += encode(temp >> 10);
                      output += encode(temp >> 4 & 63);
                      output += encode(temp << 2 & 63);
                      output += "=";
                      break;
                  }
                  return output;
                }
                exports3.toByteArray = b64ToByteArray;
                exports3.fromByteArray = uint8ToBase64;
              })(false ? 0 : exports2);
            },
            /***/
            4001(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var toPositiveInteger = __webpack_require__2(7866);
              var $RangeError = RangeError;
              module2.exports = function(it, BYTES) {
                var offset = toPositiveInteger(it);
                if (offset % BYTES) throw new $RangeError("Wrong offset");
                return offset;
              };
            },
            /***/
            4055(module2) {
              "use strict";
              module2.exports = URIError;
            },
            /***/
            4074(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var NATIVE_ARRAY_BUFFER = __webpack_require__2(5117);
              var DESCRIPTORS = __webpack_require__2(5144);
              var globalThis2 = __webpack_require__2(7756);
              var isCallable = __webpack_require__2(8681);
              var isObject = __webpack_require__2(3598);
              var hasOwn = __webpack_require__2(6341);
              var classof = __webpack_require__2(9391);
              var tryToString = __webpack_require__2(8819);
              var createNonEnumerableProperty = __webpack_require__2(5719);
              var defineBuiltIn = __webpack_require__2(4092);
              var defineBuiltInAccessor = __webpack_require__2(1182);
              var isPrototypeOf = __webpack_require__2(9877);
              var getPrototypeOf = __webpack_require__2(8607);
              var setPrototypeOf = __webpack_require__2(443);
              var wellKnownSymbol = __webpack_require__2(8663);
              var uid = __webpack_require__2(6044);
              var InternalStateModule = __webpack_require__2(6921);
              var enforceInternalState = InternalStateModule.enforce;
              var getInternalState = InternalStateModule.get;
              var Int8Array2 = globalThis2.Int8Array;
              var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
              var Uint8ClampedArray2 = globalThis2.Uint8ClampedArray;
              var Uint8ClampedArrayPrototype = Uint8ClampedArray2 && Uint8ClampedArray2.prototype;
              var TypedArray = Int8Array2 && getPrototypeOf(Int8Array2);
              var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
              var ObjectPrototype = Object.prototype;
              var TypeError2 = globalThis2.TypeError;
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              var TYPED_ARRAY_TAG = uid("TYPED_ARRAY_TAG");
              var TYPED_ARRAY_CONSTRUCTOR = "TypedArrayConstructor";
              var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(globalThis2.opera) !== "Opera";
              var TYPED_ARRAY_TAG_REQUIRED = false;
              var NAME, Constructor, Prototype;
              var TypedArrayConstructorsList = {
                Int8Array: 1,
                Uint8Array: 1,
                Uint8ClampedArray: 1,
                Int16Array: 2,
                Uint16Array: 2,
                Int32Array: 4,
                Uint32Array: 4,
                Float32Array: 4,
                Float64Array: 8
              };
              var BigIntArrayConstructorsList = {
                BigInt64Array: 8,
                BigUint64Array: 8
              };
              var isView = function isView2(it) {
                if (!isObject(it)) return false;
                var klass = classof(it);
                return klass === "DataView" || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
              };
              var getTypedArrayConstructor = function(it) {
                var proto = getPrototypeOf(it);
                if (!isObject(proto)) return;
                var state = getInternalState(proto);
                return state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
              };
              var isTypedArray = function(it) {
                if (!isObject(it)) return false;
                var klass = classof(it);
                return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
              };
              var aTypedArray = function(it) {
                if (isTypedArray(it)) return it;
                throw new TypeError2("Target is not a typed array");
              };
              var aTypedArrayConstructor = function(C) {
                if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
                throw new TypeError2(tryToString(C) + " is not a typed array constructor");
              };
              var exportTypedArrayMethod = function(KEY, property, forced, options) {
                if (!DESCRIPTORS) return;
                if (forced) for (var ARRAY in TypedArrayConstructorsList) {
                  var TypedArrayConstructor = globalThis2[ARRAY];
                  if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
                    delete TypedArrayConstructor.prototype[KEY];
                  } catch (error) {
                    try {
                      TypedArrayConstructor.prototype[KEY] = property;
                    } catch (error2) {
                    }
                  }
                }
                if (!TypedArrayPrototype[KEY] || forced) {
                  defineBuiltIn(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
                }
              };
              var exportTypedArrayStaticMethod = function(KEY, property, forced) {
                var ARRAY, TypedArrayConstructor;
                if (!DESCRIPTORS) return;
                if (setPrototypeOf) {
                  if (forced) for (ARRAY in TypedArrayConstructorsList) {
                    TypedArrayConstructor = globalThis2[ARRAY];
                    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
                      delete TypedArrayConstructor[KEY];
                    } catch (error) {
                    }
                  }
                  if (!TypedArray[KEY] || forced) {
                    try {
                      return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
                    } catch (error) {
                    }
                  } else return;
                }
                for (ARRAY in TypedArrayConstructorsList) {
                  TypedArrayConstructor = globalThis2[ARRAY];
                  if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
                    defineBuiltIn(TypedArrayConstructor, KEY, property);
                  }
                }
              };
              for (NAME in TypedArrayConstructorsList) {
                Constructor = globalThis2[NAME];
                Prototype = Constructor && Constructor.prototype;
                if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
                else NATIVE_ARRAY_BUFFER_VIEWS = false;
              }
              for (NAME in BigIntArrayConstructorsList) {
                Constructor = globalThis2[NAME];
                Prototype = Constructor && Constructor.prototype;
                if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
              }
              if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
                TypedArray = function TypedArray2() {
                  throw new TypeError2("Incorrect invocation");
                };
                if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
                  if (globalThis2[NAME]) setPrototypeOf(globalThis2[NAME], TypedArray);
                }
              }
              if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
                TypedArrayPrototype = TypedArray.prototype;
                if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
                  if (globalThis2[NAME]) setPrototypeOf(globalThis2[NAME].prototype, TypedArrayPrototype);
                }
              }
              if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
                setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
              }
              if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
                TYPED_ARRAY_TAG_REQUIRED = true;
                defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {
                  configurable: true,
                  get: function() {
                    return isObject(this) ? this[TYPED_ARRAY_TAG] : void 0;
                  }
                });
                for (NAME in TypedArrayConstructorsList) if (globalThis2[NAME]) {
                  createNonEnumerableProperty(globalThis2[NAME], TYPED_ARRAY_TAG, NAME);
                }
              }
              module2.exports = {
                NATIVE_ARRAY_BUFFER_VIEWS,
                TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
                aTypedArray,
                aTypedArrayConstructor,
                exportTypedArrayMethod,
                exportTypedArrayStaticMethod,
                getTypedArrayConstructor,
                isView,
                isTypedArray,
                TypedArray,
                TypedArrayPrototype
              };
            },
            /***/
            4092(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var isCallable = __webpack_require__2(8681);
              var definePropertyModule = __webpack_require__2(2333);
              var makeBuiltIn = __webpack_require__2(3383);
              var defineGlobalProperty = __webpack_require__2(7309);
              module2.exports = function(O, key, value, options) {
                if (!options) options = {};
                var simple = options.enumerable;
                var name = options.name !== void 0 ? options.name : key;
                if (isCallable(value)) makeBuiltIn(value, name, options);
                if (options.global) {
                  if (simple) O[key] = value;
                  else defineGlobalProperty(key, value);
                } else {
                  try {
                    if (!options.unsafe) delete O[key];
                    else if (O[key]) simple = true;
                  } catch (error) {
                  }
                  if (simple) O[key] = value;
                  else definePropertyModule.f(O, key, {
                    value,
                    enumerable: false,
                    configurable: !options.nonConfigurable,
                    writable: !options.nonWritable
                  });
                }
                return O;
              };
            },
            /***/
            4097(module2) {
              var BROTLI_READ_SIZE = 4096;
              var BROTLI_IBUF_SIZE = 2 * BROTLI_READ_SIZE + 32;
              var BROTLI_IBUF_MASK = 2 * BROTLI_READ_SIZE - 1;
              var kBitMask = new Uint32Array([
                0,
                1,
                3,
                7,
                15,
                31,
                63,
                127,
                255,
                511,
                1023,
                2047,
                4095,
                8191,
                16383,
                32767,
                65535,
                131071,
                262143,
                524287,
                1048575,
                2097151,
                4194303,
                8388607,
                16777215
              ]);
              function BrotliBitReader(input) {
                this.buf_ = new Uint8Array(BROTLI_IBUF_SIZE);
                this.input_ = input;
                this.reset();
              }
              BrotliBitReader.READ_SIZE = BROTLI_READ_SIZE;
              BrotliBitReader.IBUF_MASK = BROTLI_IBUF_MASK;
              BrotliBitReader.prototype.reset = function() {
                this.buf_ptr_ = 0;
                this.val_ = 0;
                this.pos_ = 0;
                this.bit_pos_ = 0;
                this.bit_end_pos_ = 0;
                this.eos_ = 0;
                this.readMoreInput();
                for (var i = 0; i < 4; i++) {
                  this.val_ |= this.buf_[this.pos_] << 8 * i;
                  ++this.pos_;
                }
                return this.bit_end_pos_ > 0;
              };
              BrotliBitReader.prototype.readMoreInput = function() {
                if (this.bit_end_pos_ > 256) {
                  return;
                } else if (this.eos_) {
                  if (this.bit_pos_ > this.bit_end_pos_)
                    throw new Error("Unexpected end of input " + this.bit_pos_ + " " + this.bit_end_pos_);
                } else {
                  var dst = this.buf_ptr_;
                  var bytes_read = this.input_.read(this.buf_, dst, BROTLI_READ_SIZE);
                  if (bytes_read < 0) {
                    throw new Error("Unexpected end of input");
                  }
                  if (bytes_read < BROTLI_READ_SIZE) {
                    this.eos_ = 1;
                    for (var p = 0; p < 32; p++)
                      this.buf_[dst + bytes_read + p] = 0;
                  }
                  if (dst === 0) {
                    for (var p = 0; p < 32; p++)
                      this.buf_[(BROTLI_READ_SIZE << 1) + p] = this.buf_[p];
                    this.buf_ptr_ = BROTLI_READ_SIZE;
                  } else {
                    this.buf_ptr_ = 0;
                  }
                  this.bit_end_pos_ += bytes_read << 3;
                }
              };
              BrotliBitReader.prototype.fillBitWindow = function() {
                while (this.bit_pos_ >= 8) {
                  this.val_ >>>= 8;
                  this.val_ |= this.buf_[this.pos_ & BROTLI_IBUF_MASK] << 24;
                  ++this.pos_;
                  this.bit_pos_ = this.bit_pos_ - 8 >>> 0;
                  this.bit_end_pos_ = this.bit_end_pos_ - 8 >>> 0;
                }
              };
              BrotliBitReader.prototype.readBits = function(n_bits) {
                if (32 - this.bit_pos_ < n_bits) {
                  this.fillBitWindow();
                }
                var val = this.val_ >>> this.bit_pos_ & kBitMask[n_bits];
                this.bit_pos_ += n_bits;
                return val;
              };
              module2.exports = BrotliBitReader;
            },
            /***/
            4137(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(2858));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function(undefined2) {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var CipherParams = C_lib.CipherParams;
                  var C_enc = C.enc;
                  var Hex = C_enc.Hex;
                  var C_format = C.format;
                  var HexFormatter = C_format.Hex = {
                    /**
                     * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
                     *
                     * @param {CipherParams} cipherParams The cipher params object.
                     *
                     * @return {string} The hexadecimally encoded string.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
                     */
                    stringify: function(cipherParams) {
                      return cipherParams.ciphertext.toString(Hex);
                    },
                    /**
                     * Converts a hexadecimally encoded ciphertext string to a cipher params object.
                     *
                     * @param {string} input The hexadecimally encoded string.
                     *
                     * @return {CipherParams} The cipher params object.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
                     */
                    parse: function(input) {
                      var ciphertext = Hex.parse(input);
                      return CipherParams.create({
                        ciphertext
                      });
                    }
                  };
                })();
                return CryptoJS.format.Hex;
              });
            },
            /***/
            4378(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var DESCRIPTORS = __webpack_require__2(5144);
              var hasOwn = __webpack_require__2(6341);
              var FunctionPrototype = Function.prototype;
              var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
              var EXISTS = hasOwn(FunctionPrototype, "name");
              var PROPER = EXISTS && (function something() {
              }).name === "something";
              var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
              module2.exports = {
                EXISTS,
                PROPER,
                CONFIGURABLE
              };
            },
            /***/
            4406(module2) {
              "use strict";
              var INITIAL_STATE = 1;
              var FAIL_STATE = 0;
              class StateMachine {
                constructor(dfa) {
                  this.stateTable = dfa.stateTable;
                  this.accepting = dfa.accepting;
                  this.tags = dfa.tags;
                }
                /**
                 * Returns an iterable object that yields pattern matches over the input sequence.
                 * Matches are of the form [startIndex, endIndex, tags].
                 */
                match(str) {
                  var self2 = this;
                  return {
                    *[Symbol.iterator]() {
                      var state = INITIAL_STATE;
                      var startRun = null;
                      var lastAccepting = null;
                      var lastState = null;
                      for (var p = 0; p < str.length; p++) {
                        var c = str[p];
                        lastState = state;
                        state = self2.stateTable[state][c];
                        if (state === FAIL_STATE) {
                          if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
                            yield [startRun, lastAccepting, self2.tags[lastState]];
                          }
                          state = self2.stateTable[INITIAL_STATE][c];
                          startRun = null;
                        }
                        if (state !== FAIL_STATE && startRun == null) {
                          startRun = p;
                        }
                        if (self2.accepting[state]) {
                          lastAccepting = p;
                        }
                        if (state === FAIL_STATE) {
                          state = INITIAL_STATE;
                        }
                      }
                      if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
                        yield [startRun, lastAccepting, self2.tags[state]];
                      }
                    }
                  };
                }
                /**
                 * For each match over the input sequence, action functions matching
                 * the tag definitions in the input pattern are called with the startIndex,
                 * endIndex, and sub-match sequence.
                 */
                apply(str, actions) {
                  for (var [start, end, tags] of this.match(str)) {
                    for (var tag of tags) {
                      if (typeof actions[tag] === "function") {
                        actions[tag](start, end, str.slice(start, end + 1));
                      }
                    }
                  }
                }
              }
              module2.exports = StateMachine;
            },
            /***/
            4415(__unused_webpack_module, exports2) {
              "use strict";
              function _define_property(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                } else obj[key] = value;
                return obj;
              }
              exports2._ = _define_property;
            },
            /***/
            4460(module2, __unused_webpack_exports, __webpack_require__2) {
              module2.exports = __webpack_require__2(980).BrotliDecompressBuffer;
            },
            /***/
            4483(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var V8_VERSION = __webpack_require__2(2227);
              var fails = __webpack_require__2(299);
              var globalThis2 = __webpack_require__2(7756);
              var $String = globalThis2.String;
              module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
                var symbol = Symbol("symbol detection");
                return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
                !Symbol.sham && V8_VERSION && V8_VERSION < 41;
              });
            },
            /***/
            4494(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var uncurryThis = __webpack_require__2(1212);
              var aCallable = __webpack_require__2(1078);
              module2.exports = function(object, key, method) {
                try {
                  return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
                } catch (error) {
                }
              };
            },
            /***/
            4507(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var userAgent = __webpack_require__2(8115);
              var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
              module2.exports = !!webkit && +webkit[1];
            },
            /***/
            4540(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(2858));
                } else {
                }
              })(void 0, function(CryptoJS) {
                CryptoJS.pad.NoPadding = {
                  pad: function() {
                  },
                  unpad: function() {
                  }
                };
                return CryptoJS.pad.NoPadding;
              });
            },
            /***/
            4543(__unused_webpack_module, exports2, __webpack_require__2) {
              var base64 = __webpack_require__2(2504);
              exports2.init = function() {
                var BrotliDecompressBuffer = __webpack_require__2(980).BrotliDecompressBuffer;
                var compressed = base64.toByteArray(__webpack_require__2(3501));
                return BrotliDecompressBuffer(compressed);
              };
            },
            /***/
            4550(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var uncurryThis = __webpack_require__2(1212);
              var isCallable = __webpack_require__2(8681);
              var store = __webpack_require__2(3793);
              var functionToString = uncurryThis(Function.toString);
              if (!isCallable(store.inspectSource)) {
                store.inspectSource = function(it) {
                  return functionToString(it);
                };
              }
              module2.exports = store.inspectSource;
            },
            /***/
            4610(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var callBound = __webpack_require__2(2774);
              var safeRegexTest = __webpack_require__2(8843);
              var isFnRegex = safeRegexTest(/^\s*(?:function)?\*/);
              var hasToStringTag = __webpack_require__2(6626)();
              var getProto = __webpack_require__2(7106);
              var toStr = callBound("Object.prototype.toString");
              var fnToStr = callBound("Function.prototype.toString");
              var getGeneratorFunction = __webpack_require__2(3011);
              module2.exports = function isGeneratorFunction(fn) {
                if (typeof fn !== "function") {
                  return false;
                }
                if (isFnRegex(fnToStr(fn))) {
                  return true;
                }
                if (!hasToStringTag) {
                  var str = toStr(fn);
                  return str === "[object GeneratorFunction]";
                }
                if (!getProto) {
                  return false;
                }
                var GeneratorFunction = getGeneratorFunction();
                return GeneratorFunction && getProto(fn) === GeneratorFunction.prototype;
              };
            },
            /***/
            4730(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var toLength = __webpack_require__2(8266);
              module2.exports = function(obj) {
                return toLength(obj.length);
              };
            },
            /***/
            4766(module2, __unused_webpack_exports, __webpack_require__2) {
              var $c5L0i$base64js = __webpack_require__2(2504);
              var $c5L0i$unicodetrie = __webpack_require__2(7571);
              function $parcel$interopDefault(a) {
                return a && a.__esModule ? a.default : a;
              }
              function $parcel$defineInteropFlag(a) {
                Object.defineProperty(a, "__esModule", { value: true, configurable: true });
              }
              function $parcel$export(e, n, v, s) {
                Object.defineProperty(e, n, { get: v, set: s, enumerable: true, configurable: true });
              }
              $parcel$defineInteropFlag(module2.exports);
              $parcel$export(module2.exports, "getCategory", () => $43d7963e56408b24$export$410364bbb673ddbc);
              $parcel$export(module2.exports, "getCombiningClass", () => $43d7963e56408b24$export$c03b919c6651ed55);
              $parcel$export(module2.exports, "getScript", () => $43d7963e56408b24$export$941569448d136665);
              $parcel$export(module2.exports, "getEastAsianWidth", () => $43d7963e56408b24$export$92f6187db8ca6d26);
              $parcel$export(module2.exports, "getNumericValue", () => $43d7963e56408b24$export$7d1258ebb7625a0d);
              $parcel$export(module2.exports, "isAlphabetic", () => $43d7963e56408b24$export$52c8ea63abd07594);
              $parcel$export(module2.exports, "isDigit", () => $43d7963e56408b24$export$727d9dbc4fbb948f);
              $parcel$export(module2.exports, "isPunctuation", () => $43d7963e56408b24$export$a5b49f4dc6a07d2c);
              $parcel$export(module2.exports, "isLowerCase", () => $43d7963e56408b24$export$7b6804e8df61fcf5);
              $parcel$export(module2.exports, "isUpperCase", () => $43d7963e56408b24$export$aebd617640818cda);
              $parcel$export(module2.exports, "isTitleCase", () => $43d7963e56408b24$export$de8b4ee23b2cf823);
              $parcel$export(module2.exports, "isWhiteSpace", () => $43d7963e56408b24$export$3c52dd84024ae72c);
              $parcel$export(module2.exports, "isBaseForm", () => $43d7963e56408b24$export$a11bdcffe109e74b);
              $parcel$export(module2.exports, "isMark", () => $43d7963e56408b24$export$e33ad6871e762338);
              $parcel$export(module2.exports, "default", () => $43d7963e56408b24$export$2e2bcd8739ae039);
              var $29668e65f2091c2c$exports = {};
              $29668e65f2091c2c$exports = JSON.parse('{"categories":["Cc","Zs","Po","Sc","Ps","Pe","Sm","Pd","Nd","Lu","Sk","Pc","Ll","So","Lo","Pi","Cf","No","Pf","Lt","Lm","Mn","Me","Mc","Nl","Zl","Zp","Cs","Co"],"combiningClasses":["Not_Reordered","Above","Above_Right","Below","Attached_Above_Right","Attached_Below","Overlay","Iota_Subscript","Double_Below","Double_Above","Below_Right","Above_Left","CCC10","CCC11","CCC12","CCC13","CCC14","CCC15","CCC16","CCC17","CCC18","CCC19","CCC20","CCC21","CCC22","CCC23","CCC24","CCC25","CCC30","CCC31","CCC32","CCC27","CCC28","CCC29","CCC33","CCC34","CCC35","CCC36","Nukta","Virama","CCC84","CCC91","CCC103","CCC107","CCC118","CCC122","CCC129","CCC130","CCC132","Attached_Above","Below_Left","Left","Kana_Voicing","CCC26","Right"],"scripts":["Common","Latin","Bopomofo","Inherited","Greek","Coptic","Cyrillic","Armenian","Hebrew","Arabic","Syriac","Thaana","Nko","Samaritan","Mandaic","Devanagari","Bengali","Gurmukhi","Gujarati","Oriya","Tamil","Telugu","Kannada","Malayalam","Sinhala","Thai","Lao","Tibetan","Myanmar","Georgian","Hangul","Ethiopic","Cherokee","Canadian_Aboriginal","Ogham","Runic","Tagalog","Hanunoo","Buhid","Tagbanwa","Khmer","Mongolian","Limbu","Tai_Le","New_Tai_Lue","Buginese","Tai_Tham","Balinese","Sundanese","Batak","Lepcha","Ol_Chiki","Braille","Glagolitic","Tifinagh","Han","Hiragana","Katakana","Yi","Lisu","Vai","Bamum","Syloti_Nagri","Phags_Pa","Saurashtra","Kayah_Li","Rejang","Javanese","Cham","Tai_Viet","Meetei_Mayek","null","Linear_B","Lycian","Carian","Old_Italic","Gothic","Old_Permic","Ugaritic","Old_Persian","Deseret","Shavian","Osmanya","Osage","Elbasan","Caucasian_Albanian","Linear_A","Cypriot","Imperial_Aramaic","Palmyrene","Nabataean","Hatran","Phoenician","Lydian","Meroitic_Hieroglyphs","Meroitic_Cursive","Kharoshthi","Old_South_Arabian","Old_North_Arabian","Manichaean","Avestan","Inscriptional_Parthian","Inscriptional_Pahlavi","Psalter_Pahlavi","Old_Turkic","Old_Hungarian","Hanifi_Rohingya","Old_Sogdian","Sogdian","Elymaic","Brahmi","Kaithi","Sora_Sompeng","Chakma","Mahajani","Sharada","Khojki","Multani","Khudawadi","Grantha","Newa","Tirhuta","Siddham","Modi","Takri","Ahom","Dogra","Warang_Citi","Nandinagari","Zanabazar_Square","Soyombo","Pau_Cin_Hau","Bhaiksuki","Marchen","Masaram_Gondi","Gunjala_Gondi","Makasar","Cuneiform","Egyptian_Hieroglyphs","Anatolian_Hieroglyphs","Mro","Bassa_Vah","Pahawh_Hmong","Medefaidrin","Miao","Tangut","Nushu","Duployan","SignWriting","Nyiakeng_Puachue_Hmong","Wancho","Mende_Kikakui","Adlam"],"eaw":["N","Na","A","W","H","F"]}');
              const $43d7963e56408b24$var$trie = new (0, $parcel$interopDefault($c5L0i$unicodetrie))((0, $parcel$interopDefault($c5L0i$base64js)).toByteArray("AAARAAAAAADwfAEAZXl5ONRt+/5bPVFZimRfKoTQJNm37CGE7Iw0j3UsTWKsoyI7kwyyTiEUzSD7NiEzhWYijH0wMVkHE4Mx49fzfo+3nuP4/fdZjvv+XNd5n/d9nef1WZvmKhTxiZndzDQBSEYQqxqKwnsKvGQucFh+6t6cJ792ePQBZv5S9yXSwkyjf/P4T7mTNnIAv1dOVhMlR9lflbUL9JeJguqsjvG9NTj/wLb566VAURnLo2vvRi89S3gW/33ihh2eXpDn40BIW7REl/7coRKIhAFlAiOtbLDTt6mMb4GzMF1gNnvX/sBxtbsAIjfztCNcQjcNDtLThRvuXu5M5g/CBjaLBE4lJm4qy/oZD97+IJryApcXfgWYlkvWbhfXgujOJKVu8B+ozqTLbxyJ5kNiR75CxDqfBM9eOlDMmGeoZ0iQbbS5VUplIwI+ZNXEKQVJxlwqjhOY7w3XwPesbLK5JZE+Tt4X8q8km0dzInsPPzbscrjBMVjF5mOHSeRdJVgKUjLTHiHqXSPkep8N/zFk8167KLp75f6RndkvzdfB6Uz3MmqvRArzdCbs1/iRZjYPLLF3U8Qs+H+Rb8iK51a6NIV2V9+07uJsTGFWpPz8J++7iRu2B6eAKlK/kujrLthwaD/7a6J5w90TusnH1JMAc+gNrql4aspOUG/RrsxUKmPzhHgP4Bleru+6Vfc/MBjgXVx7who94nPn7MPFrnwQP7g0k0Dq0h2GSKO6fTZ8nLodN1SiOUj/5EL/Xo1DBvRm0wmrh3x6phcJ20/9CuMr5h8WPqXMSasLoLHoufTmE7mzYrs6B0dY7KjuCogKqsvxnxAwXWvd9Puc9PnE8DOHT2INHxRlIyVHrqZahtfV2E/A2PDdtA3ewlRHMtFIBKO/T4IozWTQZ+mb+gdKuk/ZHrqloucKdsOSJmlWTSntWjcxVMjUmroXLM10I6TwDLnBq4LP69TxgVeyGsd8yHvhF8ydPlrNRSNs9EP7WmeuSE7Lu10JbOuQcJw/63sDp68wB9iwP5AO+mBpV0R5VDDeyQUFCel1G+4KHBgEVFS0YK+m2sXLWLuGTlkVAd97WwKKdacjWElRCuDRauf33l/yVcDF6sVPKeTes99FC1NpNWcpieGSV/IbO8PCTy5pbUR1U8lxzf4T+y6fZMxOz3LshkQLeeDSd0WmUrQgajmbktrxsb2AZ0ACw2Vgni+gV/m+KvCRWLg08Clx7uhql+v9XySGcjjOHlsp8vBw/e8HS7dtiqF6T/XcSXuaMW66GF1g4q9YyBadHqy3Y5jin1c7yZos6BBr6dsomSHxiUHanYtcYQwnMMZhRhOnaYJeyJzaRuukyCUh48+e/BUvk/aEfDp8ag+jD64BHxNnQ5v/E7WRk7eLjGV13I3oqy45YNONi/1op1oDr7rPjkhPsTXgUpQtGDPlIs55KhQaic9kSGs/UrZ2QKQOflB8MTEQxRF9pullToWO7Eplan6mcMRFnUu2441yxi23x+KqKlr7RWWsi9ZXMWlr8vfP3llk1m2PRj0yudccxBuoa7VfIgRmnFPGX6Pm1WIfMm/Rm4n/xTn8IGqA0GWuqgu48pEUO0U9nN+ZdIvFpPb7VDPphIfRZxznlHeVFebkd9l+raXy9BpTMcIUIvBfgHEb6ndGo8VUkxpief14KjzFOcaANfgvFpvyY8lE8lE4raHizLpluPzMks1hx/e1Hok5yV0p7qQH7GaYeMzzZTFvRpv6k6iaJ4yNqzBvN8J7B430h2wFm1IBPcqbou33G7/NWPgopl4Mllla6e24L3TOTVNkza2zv3QKuDWTeDpClCEYgTQ+5vEBSQZs/rMF50+sm4jofTgWLqgX1x3TkrDEVaRqfY/xZizFZ3Y8/DFEFD31VSfBQ5raEB6nHnZh6ddehtclQJ8fBrldyIh99LNnV32HzKEej04hk6SYjdauCa4aYW0ru/QxvQRGzLKOAQszf3ixJypTW3WWL6BLSF2EMCMIw7OUvWBC6A/gDc2D1jvBapMCc7ztx6jYczwTKsRLL6dMNXb83HS8kdD0pTMMj161zbVHkU0mhSHo9SlBDDXdN6hDvRGizmohtIyR3ot8tF5iUG4GLNcXeGvBudSFrHu+bVZb9jirNVG+rQPI51A7Hu8/b0UeaIaZ4UgDO68PkYx3PE2HWpKapJ764Kxt5TFYpywMy4DLQqVRy11I7SOLhxUFmqiEK52NaijWArIfCg6qG8q5eSiwRCJb1R7GDJG74TrYgx/lVq7w9++Kh929xSJEaoSse5fUOQg9nMAnIZv+7fwVRcNv3gOHI46Vb5jYUC66PYHO6lS+TOmvEQjuYmx4RkffYGxqZIp/DPWNHAixbRBc+XKE3JEOgs4jIwu/dSAwhydruOGF39co91aTs85JJ3Z/LpXoF43hUwJsb/M1Chzdn8HX8vLXnqWUKvRhNLpfAF4PTFqva1sBQG0J+59HyYfmQ3oa4/sxZdapVLlo/fooxSXi/dOEQWIWq8E0FkttEyTFXR2aNMPINMIzZwCNEheYTVltsdaLkMyKoEUluPNAYCM2IG3br0DLy0fVNWKHtbSKbBjfiw7Lu06gQFalC7RC9BwRMSpLYDUo9pDtDfzwUiPJKLJ2LGcSphWBadOI/iJjNqUHV7ucG8yC6+iNM9QYElqBR7ECFXrcTgWQ3eG/tCWacT9bxIkfmxPmi3vOd36KxihAJA73vWNJ+Y9oapXNscVSVqS5g15xOWND/WuUCcA9YAAg6WFbjHamrblZ5c0L6Zx1X58ZittGcfDKU697QRSqW/g+RofNRyvrWMrBn44cPvkRe2HdTu/Cq01C5/riWPHZyXPKHuSDDdW8c1XPgd6ogvLh20qEIu8c19sqr4ufyHrwh37ZN5MkvY1dsGmEz9pUBTxWrvvhNyODyX2Q1k/fbX/T/vbHNcBrmjgDtvBdtZrVtiIg5iXQuzO/DEMvRX8Mi1zymSlt92BGILeKItjoShJXE/H7xwnf0Iewb8BFieJ9MflEBCQYEDm8eZniiEPfGoaYiiEdhQxHQNr2AuRdmbL9mcl18Kumh+HEZLp6z+j35ML9zTbUwahUZCyQQOgQrGfdfQtaR/OYJ/9dYXb2TWZFMijfCA8Nov4sa5FFDUe1T68h4q08WDE7JbbDiej4utRMR9ontevxlXv6LuJTXt1YEv8bDzEt683PuSsIN0afvu0rcBu9AbXZbkOG3K3AhtqQ28N23lXm7S3Yn6KXmAhBhz+GeorJJ4XxO/b3vZk2LXp42+QvsVxGSNVpfSctIFMTR1bD9t70i6sfNF3WKz/uKDEDCpzzztwhL45lsw89H2IpWN10sXHRlhDse9KCdpP5qNNpU84cTY+aiqswqR8XZ9ea0KbVRwRuOGQU3csAtV2fSbnq47U6es6rKlWLWhg3s/B9C9g+oTyp6RtIldR51OOkP5/6nSy6itUVPcMNOp4M/hDdKOz3uK6srbdxOrc2cJgr1Sg02oBxxSky6V7JaG+ziNwlfqnjnvh2/uq1lKfbp+qpwq/D/5OI5gkFl5CejKGxfc2YVJfGqc4E0x5e9PHK2ukbHNI7/RZV6LNe65apbTGjoCaQls0txPPbmQbCQn+/upCoXRZy9yzorWJvZ0KWcbXlBxU/d5I4ERUTxMuVWhSMmF677LNN7NnLwsmKawXkCgbrpcluOl0WChR1qhtSrxGXHu251dEItYhYX3snvn1gS2uXuzdTxCJjZtjsip0iT2sDC0qMS7Bk9su2NyXjFK5/f5ZoWwofg3DtTyjaFqspnOOTSh8xK/CKUFS57guVEkw9xoQuRCwwEO9Lu9z2vYxSa9NFV8DvSxv2C4WYLYF8Nrc4DzWkzNsk81JJOlZ/LYJrGCoj4MmZpnf3AXmzxT4rtl9jsqljEyedz468SGKdBiQzyz/qWKEhFg45ZczlZZ3KGL3l6sn+3TTa3zMVMhPa1obGp/z+fvY0QXTrJTf1XAT3EtQdUfYYlmWZyvPZ/6rWwU7UOQei7pVE0osgN94Iy+T1+omE6z4Rh2O20FjgBeK2y1mcoFiMDOJvuZPn5Moy9fmFH3wyfKvn4+TwfLvt/lHTTVnvrtoUWRBiQXhiNM8nE6ZoWeux/Z0b2unRcdUzdDpmL7CAgd1ToRXwgmHTZOgiGtVT+xr1QH9ObebRTT4NzL+XSpLuuWp62GqQvJVTPoZOeJCb6gIwd9XHMftQ+Kc08IKKdKQANSJ1a2gve3JdRhO0+tNiYzWAZfd7isoeBu67W7xuK8WX7nhJURld98Inb0t/dWOSau/kDvV4DJo/cImw9AO2Gvq0F2n0M7yIZKL8amMbjYld+qFls7hq8Acvq97K2PrCaomuUiesu7qNanGupEl6J/iem8lyr/NMnsTr6o41PO0yhQh3hPFN0wJP7S830je9iTBLzUNgYH+gUZpROo3rN2qgCI+6GewpX8w8CH+ro6QrWiStqmcMzVa3vEel+3/dDxMp0rDv1Q6wTMS3K64zTT6RWzK1y643im25Ja7X2ePCV2mTswd/4jshZPo4bLnerqIosq/hy2bKUAmVn9n4oun1+a0DIZ56UhVwmZHdUNpLa8gmPvxS1eNvCF1T0wo1wKPdCJi0qOrWz7oYRTzgTtkzEzZn308XSLwUog4OWGKJzCn/3FfF9iA32dZHSv30pRCM3KBY9WZoRhtdK/ChHk6DEQBsfV6tN2o1Cn0mLtPBfnkS+qy1L2xfFe9TQPtDE1Be44RTl82E9hPT2rS2+93LFbzhQQO3C/hD2jRFH3BWWbasAfuMhRJFcTri73eE835y016s22DjoFJ862WvLj69fu2TgSF3RHia9D5DSitlQAXYCnbdqjPkR287Lh6dCHDapos+eFDvcZPP2edPmTFxznJE/EBLoQQ0Qmn9EkZOyJmHxMbvKYb8o21ZHmv5YLqgsEPk9gWZwYQY9wLqGXuax/8QlV5qDaPbq9pLPT1yp+zOWKmraEy1OUJI7zdEcEmvBpbdwLrDCgEb2xX8S/nxZgjK4bRi+pbOmbh8bEeoPvU/L9ndx9kntlDALbdAvp0O8ZC3zSUnFg4cePsw7jxewWvL7HRSBLUn6J7vTH9uld5N76JFPgBCdXGF221oEJk++XfRwXplLSyrVO7HFWBEs99nTazKveW3HpbD4dH/YmdAl+lwbSt8BQWyTG7jAsACI7bPPUU9hI9XUHWqQOuezHzUjnx5Qqs6T1qNHfTTHleDtmqK7flA9a0gz2nycIpz1FHBuWxKNtUeTdqP29Fb3tv+tl5JyBqXoR+vCsdzZwZUhf6Lu8bvkB9yQP4x7GGegB0ym0Lpl03Q7e+C0cDsm9GSDepCDji7nUslLyYyluPfvLyKaDSX4xpR+nVYQjQQn5F8KbY1gbIVLiK1J3mW90zTyR1bqApX2BlWh7KG8LAY9/S9nWC0XXh9pZZo6xuir12T43rkaGfQssbQyIslA7uJnSHOV22NhlNtUo0czxPAsXhh8tIQYaTM4l/yAlZlydTcXhlG22Gs/n3BxKBd/3ZjYwg3NaUurVXhNB+afVnFfNr9TbC9ksNdvwpNfeHanyJ8M6GrIVfLlYAPv0ILe4dn0Z+BJSbJkN7eZY/c6+6ttDYcIDeUKIDXqUSE42Xdh5nRbuaObozjht0HJ5H1e+em+NJi/+8kQlyjCbJpPckwThZeIF9/u7lrVIKNeJLCN/TpPAeXxvd31/CUDWHK9MuP1V1TJgngzi4V0qzS3SW3Qy5UiGHqg02wQa5tsEl9s/X9nNMosgLlUgZSfCBj1DiypLfhr9/r0nR0XY2tmhDOcUS4E7cqa4EJBhzqvpbZa35Q5Iz5EqmhYiOGDAYk606Tv74+KGfPjKVuP15rIzgW0I7/niOu9el/sn2bRye0gV+GrePDRDMHjwO1lEdeXH8N+UTO3IoN18kpI3tPxz+fY+n2MGMSGFHAx/83tKeJOl+2i+f1O9v6FfEDBbqrw+lpM8Anav7zHNr7hE78nXUtPNodMbCnITWA7Ma/IHlZ50F9hWge/wzOvSbtqFVFtkS8Of2nssjZwbSFdU+VO8z6tCEc9UA9ACxT5zIUeSrkBB/v1krOpm7bVMrGxEKfI6LcnpB4D8bvn2hDKGqKrJaVAJuDaBEY3F7eXyqnFWlOoFV/8ZLspZiZd7orXLhd4mhHQgbuKbHjJWUzrnm0Dxw/LJLzXCkh7slMxKo8uxZIWZfdKHlfI7uj3LP6ARAuWdF7ZmZ7daOKqKGbz5LxOggTgS39oEioYmrqkCeUDvbxkBYKeHhcLmMN8dMF01ZMb32IpL/cH8R7VHQSI5I0YfL14g9d7P/6cjB1JXXxbozEDbsrPdmL8ph7QW10jio+v7YsqHKQ6xrBbOVtxU0/nFfzUGZwIBLwyUvg49ii+54nv9FyECBpURnQK4Ox6N7lw5fsjdd5l/2SwBcAHMJoyjO1Pifye2dagaOwCVMqdJWAo77pvBe0zdJcTWu5fdzPNfV2p1pc7/JKQ8zhKkwsOELUDhXygPJ5oR8Vpk2lsCen3D3QOQp2zdrSZHjVBstDF/wWO98rrkQ6/7zt/Drip7OHIug1lomNdmRaHRrjmqeodn22sesQQPgzimPOMqC60a5+i/UYh51uZm+ijWkkaI2xjrBO2558DZNZMiuDQlaVAvBy2wLn/bR3FrNzfnO/9oDztYqxZrr7JMIhqmrochbqmQnKowxW29bpqTaJu7kW1VotC72QkYX8OoDDdMDwV1kJRk3mufgJBzf+iwFRJ7XWQwO5ujVglgFgHtycWiMLx5N+6XU+TulLabWjOzoao03fniUW0xvIJNPbk7CQlFZd/RCOPvgQbLjh5ITE8NVJeKt3HGr6JTnFdIzcVOlEtwqbIIX0IM7saC+4N5047MTJ9+Wn11EhyEPIlwsHE5utCeXRjQzlrR+R1Cf/qDzcNbqLXdk3J7gQ39VUrrEkS/VMWjjg+t2oYrqB0tUZClcUF6+LBC3EQ7KnGIwm/qjZX4GKPtjTX1zQKV6nPAb2t/Rza5IqKRf8i2DFEhV/YSifX0YwsiF6TQnp48Gr65TFq0zUe6LGjiY7fq0LSGKL1VnC6ESI2yxvt3XqBx53B3gSlGFeJcPbUbonW1E9E9m4NfuwPh+t5QjRxX34lvBPVxwQd7aeTd+r9dw5CiP1pt8wMZoMdni7GapYdo6KPgeQKcmlFfq4UYhvV0IBgeiR3RnTMBaqDqpZrTRyLdsp4l0IXZTdErfH0sN3dqBG5vRIx3VgCYcHmmkqJ8Hyu3s9K9uBD1d8cZUEx3qYcF5vsqeRpF1GOg8emeWM2OmBlWPdZ6qAXwm3nENFyh+kvXk132PfWAlN0kb7yh4fz2T7VWUY/hEXX5DvxGABC03XRpyOG8t/u3Gh5tZdpsSV9AWaxJN7zwhVglgII1gV28tUViyqn4UMdIh5t+Ea2zo7PO48oba0TwQbiSZOH4YhD578kPF3reuaP7LujPMsjHmaDuId9XEaZBCJhbXJbRg5VCk3KJpryH/+8S3wdhR47pdFcmpZG2p0Bpjp/VbvalgIZMllYX5L31aMPdt1J7r/7wbixt0Mnz2ZvNGTARHPVD+2O1D8SGpWXlVnP2ekgon55YiinADDynyaXtZDXueVqbuTi8z8cHHK325pgqM+mWZwzHeEreMvhZopAScXM14SJHpGwZyRljMlDvcMm9FZ/1e9+r/puOnpXOtc9Iu2fmgBfEP9cGW1Fzb1rGlfJ08pACtq1ZW18bf2cevebzVeHbaA50G9qoUp39JWdPHbYkPCRXjt4gzlq3Cxge28Mky8MoS/+On72kc+ZI2xBtgJytpAQHQ1zrEddMIVyR5urX6yBNu8v5lKC8eLdGKTJtbgIZ3ZyTzSfWmx9f+cvcJe8yM39K/djkp2aUTE/9m2Lj5jg7b8vdRAer7DO3SyLNHs1CAm5x5iAdh2yGJYivArZbCBNY88Tw+w+C1Tbt7wK3zl2rzTHo/D8/gb3c3mYrnEIEipYqPUcdWjnTsSw471O3EUN7Gtg4NOAs9PJrxm03VuZKa5xwXAYCjt7Gs01Km6T2DhOYUMoFcCSu7Hk1p3yP1eG+M3v3Q5luAze6WwBnZIYO0TCucPWK+UJ36KoJ8Y+vpavhLO8g5ed704IjlQdfemrMu//EvPYXTQSGIPPfiagJS9nMqP5IvkxN9pvuJz7h8carPXTKMq8jnTeL0STan6dnLTAqwIswcIwWDR2KwbGddAVN8SYWRB7kfBfBRkSXzvHlIF8D6jo64kUzYk5o/n8oLjKqat0rdXvQ86MkwQGMnnlcasqPPT2+mVtUGb32KuH6cyZQenrRG11TArcAl27+nvOMBDe++EKHf4YdyGf7mznzOz33cFFGEcv329p4qG2hoaQ8ULiMyVz6ENcxhoqGnFIdupcn7GICQWuw3yO3W8S33mzCcMYJ8ywc7U7rmaQf/W5K63Gr4bVTpXOyOp4tbaPyIaatBNpXqlmQUTSZXjxPr19+73PSaT+QnI35YsWn6WpfJjRtK8vlJZoTSgjaRU39AGCkWOZtifJrnefCrqwTKDFmuWUCukEsYcRrMzCoit28wYpP7kSVjMD8WJYQiNc2blMjuqYegmf6SsfC1jqz8XzghMlOX+gn/MKZmgljszrmehEa4V98VreJDxYvHr3j7IeJB9/sBZV41BWT/AZAjuC5XorlIPnZgBAniBEhanp0/0+qZmEWDpu8ige1hUPIyTo6T6gDEcFhWSoduNh8YSu65KgMOGBw7VlNYzNIgwHtq9KP2yyTVysqX5v12sf7D+vQUdR2dRDvCV40rIInXSLWT/yrC6ExOQxBJwIDbeZcl3z1yR5Rj3l8IGpxspapnvBL+fwupA3b6fkFceID9wgiM1ILB0cHVdvo/R4xg8yqKXT8efl0GnGX1/27FUYeUW2L/GNRGGWVGp3i91oaJkb4rybENHre9a2P5viz/yqk8ngWUUS+Kv+fu+9BLFnfLiLXOFcIeBJLhnayCiuDRSqcx0Qu68gVsGYc6EHD500Fkt+gpDj6gvr884n8wZ5o6q7xtL5wA0beXQnffWYkZrs2NGIRgQbsc5NB302SVx+R4ROvmgZaR8wBcji128BMfJ9kcvJ4DC+bQ57kRmv5yxgU4ngZfn0/JNZ8JBwxjTqS+s9kjJFG1unGUGLwMiIuXUD9EFhNIJuyCEAmVZSIGKH4G6v1gRR1LyzQKH2ZqiI1DnHMoDEZspbDjTeaFIAbSvjSq3A+n46y9hhVM8wIpnARSXyzmOD96d9UXvFroSPgGw1dq2vdEqDq9fJN1EbL2WulNmHkFDvxSO9ZT/RX/Bw2gA/BrF90XrJACereVfbV/YXaKfp77Nmx5NjEIUlxojsy7iN7nBHSZigfsbFyVOX1ZTeCCxvqnRSExP4lk5ZeYlRu9caaa743TWNdchRIhEWwadsBIe245C8clpaZ4zrPsk+OwXzxWCvRRumyNSLW5KWaSJyJU95cwheK76gr7228spZ3hmTtLyrfM2QRFqZFMR8/Q6yWfVgwTdfX2Ry4w3+eAO/5VT5nFb5NlzXPvBEAWrNZ6Q3jbH0RF4vcbp+fDngf/ywpoyNQtjrfvcq93AVb1RDWRghvyqgI2BkMr1rwYi8gizZ0G9GmPpMeqPerAQ0dJbzx+KAFM4IBq6iSLpZHUroeyfd9o5o+4fR2EtsZBoJORQEA4SW0CmeXSnblx2e9QkCHIodyqV6+g5ETEpZsLqnd/Na60EKPX/tQpPEcO+COIBPcQdszDzSiHGyQFPly/7KciUh1u+mFfxTCHGv9nn2WqndGgeGjQ/kr02qmTBX7Hc1qiEvgiSz1Tz/sy7Es29wvn6FrDGPP7asXlhOaiHxOctPvTptFA1kHFUk8bME7SsTSnGbFbUrssxrq70LhoSh5OwvQna+w84XdXhZb2sloJ4ZsCg3j+PrjJL08/JBi5zGd6ud/ZxhmcGKLOXPcNunQq5ESW92iJvfsuRrNYtawWwSmNhPYoFj2QqWNF0ffLpGt/ad24RJ8vkb5sXkpyKXmvFG5Vcdzf/44k3PBL/ojJ52+kWGzOArnyp5f969oV3J2c4Li27Nkova9VwRNVKqN0V+gV+mTHitgkXV30aWd3A1RSildEleiNPA+5cp+3+T7X+xfHiRZXQ1s4FA9TxIcnveQs9JSZ5r5qNmgqlW4zMtZ6rYNvgmyVcywKtu8ZxnSbS5vXlBV+NXdIfi3+xzrnJ0TkFL+Un8v1PWOC2PPFCjVPq7qTH7mOpzOYj/b4h0ceT+eHgr97Jqhb1ziVfeANzfN8bFUhPKBi7hJBCukQnB0aGjFTYLJPXL26lQ2b80xrOD5cFWgA8hz3St0e69kwNnD3+nX3gy12FjrjO+ddRvvvfyV3SWbXcxqNHfmsb9u1TV+wHTb9B07/L2sB8WUHJ9eeNomDyysEWZ0deqEhH/oWI2oiEh526gvAK1Nx2kIhNvkYR+tPYHEa9j+nd1VBpQP1uzSjIDO+fDDB7uy029rRjDC5Sk6aKczyz1D5uA9Lu+Rrrapl8JXNL3VRllNQH2K1ZFxOpX8LprttfqQ56MbPM0IttUheXWD/mROOeFqGUbL+kUOVlXLTFX/525g4faLEFO4qWWdmOXMNvVjpIVTWt650HfQjX9oT3Dg5Au6+v1/Ci78La6ZOngYCFPT1AUwxQuZ0yt5xKdNXLaDTISMTeCj16XTryhM36K2mfGRIgot71voWs8tTpL/f1rvcwv3LSDf+/G8THCT7NpfHWcW+lsF/ol8q9Bi6MezNTqp0rpp/kJRiVfNrX/w27cRRTu8RIIqtUblBMkxy4jwAVqCjUJkiPBj2cAoVloG8B2/N5deLdMhDb7xs5nhd3dubJhuj8WbaFRyu1L678DHhhA+rMimNo4C1kGpp0tD/qnCfCFHejpf0LJX43OTr578PY0tnIIrlWyNYyuR/ie6j2xNb1OV6u0dOX/1Dtcd7+ya9W+rY2LmnyQMtk8SMLTon8RAdwOaN2tNg5zVnDKlmVeOxPV2vhHIo9QEPV7jc3f+zVDquiNg1OaHX3cZXJDRY5MJpo+VanAcmqp4oasYLG+wrXUL5vJU0kqk2hGEskhP+Jjigrz1l6QnEwp6n8PMVeJp70Ii6ppeaK9GhF6fJE00ceLyxv08tKiPat4QdxZFgSbQknnEiCLD8Qc1rjazVKM3r3gXnnMeONgdz/yFV1q+haaN+wnF3Fn4uYCI9XsKOuVwDD0LsCO/f0gj5cmxCFcr7sclIcefWjvore+3aSU474cyqDVxH7w1RX3CHsaqsMRX17ZLgjsDXws3kLm2XJdM3Ku383UXqaHqsywzPhx7NFir0Fqjym/w6cxD2U9ypa3dx7Z12w/fi3Jps8sqJ8f8Ah8aZAvkHXvIRyrsxK7rrFaNNdNvjI8+3Emri195DCNa858anj2Qdny6Czshkn4N2+1m+k5S8sunX3Ja7I+JutRzg1mc2e9Yc0Zv9PZn1SwhxIdU9sXwZRTd/J5FoUm0e+PYREeHg3oc2YYzGf2xfJxXExt4pT3RfDRHvMXLUmoXOy63xv5pLuhOEax0dRgSywZ/GH+YBXFgCeTU0hZ8SPEFsn8punp1Kurd1KgXxUZ+la3R5+4ePGR4ZF5UQtOa83+Vj8zh80dfzbhxWCeoJnQ4dkZJM4drzknZOOKx2n3WrvJnzFIS8p0xeic+M3ZRVXIp10tV2DyYKwRxLzulPwzHcLlYTxl4PF7v8l106Azr+6wBFejbq/3P72C/0j78cepY9990/d4eAurn2lqdGKLU8FffnMw7cY7pVeXJRMU73Oxwi2g2vh/+4gX8dvbjfojn/eLVhhYl8GthwCQ50KcZq4z2JeW5eeOnJWFQEnVxDoG459TaC4zXybECEoJ0V5q1tXrQbDMtUxeTV6Pdt1/zJuc7TJoV/9YZFWxUtCf6Ou3Vd/vR/vG0138hJQrHkNeoep5dLe+6umcSquKvMaFpm3EZHDBOvCi0XYyIFHMgX7Cqp3JVXlxJFwQfHSaIUEbI2u1lBVUdlNw4Qa9UsLPEK94Qiln3pyKxQVCeNlx8yd7EegVNQBkFLabKvnietYVB4IPZ1fSor82arbgYec8aSdFMaIluYTYuNx32SxfrjKUdPGq+UNp5YpydoEG3xVLixtmHO9zXxKAnHnPuH2fPGrjx0GcuCDEU+yXUtXh6nfUL+cykws1gJ5vkfYFaFBr9PdCXvVf35OJQxzUMmWjv0W6uGJK11uAGDqSpOwCf6rouSIjPVgw57cJCOQ4b9tkI/Y5WNon9Swe72aZryKo8d+HyHBEdWJKrkary0LIGczA4Irq353Wc0Zga3om7UQiAGCvIl8GGyaqz5zH+1gMP5phWUCpKtttWIyicz09vXg76GxkmiGSMQ06Z9X8BUwqOtauDbPIf4rpK/yYoeAHxJ9soXS9VDe1Aw+awOOxaN8foLrif0TXBvQ55dtRtulRq9emFDBxlQcqKCaD8NeTSE7FOHvcjf/+oKbbtRqz9gbofoc2EzQ3pL6W5JdfJzAWmOk8oeoECe90lVMruwl/ltM015P/zIPazqvdvFmLNVHMIZrwiQ2tIKtGh6PDVH+85ew3caqVt2BsDv5rOcu3G9srQWd7NmgtzCRUXLYknYRSwtH9oUtkqyN3CfP20xQ1faXQl4MEmjQehWR6GmGnkdpYNQYeIG408yAX7uCZmYUic9juOfb+Re28+OVOB+scYK4DaPcBe+5wmji9gymtkMpKo4UKqCz7yxzuN8VIlx9yNozpRJpNaWHtaZVEqP45n2JemTlYBSmNIK1FuSYAUQ1yBLnKxevrjayd+h2i8PjdB3YY6b0nr3JuOXGpPMyh4V2dslpR3DFEvgpsBLqhqLDOWP4yEvIL6f21PpA7/8B"));
              const $43d7963e56408b24$var$log2 = Math.log2 || ((n) => Math.log(n) / Math.LN2);
              const $43d7963e56408b24$var$bits = (n) => $43d7963e56408b24$var$log2(n) + 1 | 0;
              const $43d7963e56408b24$var$CATEGORY_BITS = $43d7963e56408b24$var$bits((0, $parcel$interopDefault($29668e65f2091c2c$exports)).categories.length - 1);
              const $43d7963e56408b24$var$COMBINING_BITS = $43d7963e56408b24$var$bits((0, $parcel$interopDefault($29668e65f2091c2c$exports)).combiningClasses.length - 1);
              const $43d7963e56408b24$var$SCRIPT_BITS = $43d7963e56408b24$var$bits((0, $parcel$interopDefault($29668e65f2091c2c$exports)).scripts.length - 1);
              const $43d7963e56408b24$var$EAW_BITS = $43d7963e56408b24$var$bits((0, $parcel$interopDefault($29668e65f2091c2c$exports)).eaw.length - 1);
              const $43d7963e56408b24$var$NUMBER_BITS = 10;
              const $43d7963e56408b24$var$CATEGORY_SHIFT = $43d7963e56408b24$var$COMBINING_BITS + $43d7963e56408b24$var$SCRIPT_BITS + $43d7963e56408b24$var$EAW_BITS + $43d7963e56408b24$var$NUMBER_BITS;
              const $43d7963e56408b24$var$COMBINING_SHIFT = $43d7963e56408b24$var$SCRIPT_BITS + $43d7963e56408b24$var$EAW_BITS + $43d7963e56408b24$var$NUMBER_BITS;
              const $43d7963e56408b24$var$SCRIPT_SHIFT = $43d7963e56408b24$var$EAW_BITS + $43d7963e56408b24$var$NUMBER_BITS;
              const $43d7963e56408b24$var$EAW_SHIFT = $43d7963e56408b24$var$NUMBER_BITS;
              const $43d7963e56408b24$var$CATEGORY_MASK = (1 << $43d7963e56408b24$var$CATEGORY_BITS) - 1;
              const $43d7963e56408b24$var$COMBINING_MASK = (1 << $43d7963e56408b24$var$COMBINING_BITS) - 1;
              const $43d7963e56408b24$var$SCRIPT_MASK = (1 << $43d7963e56408b24$var$SCRIPT_BITS) - 1;
              const $43d7963e56408b24$var$EAW_MASK = (1 << $43d7963e56408b24$var$EAW_BITS) - 1;
              const $43d7963e56408b24$var$NUMBER_MASK = (1 << $43d7963e56408b24$var$NUMBER_BITS) - 1;
              function $43d7963e56408b24$export$410364bbb673ddbc(codePoint) {
                const val = $43d7963e56408b24$var$trie.get(codePoint);
                return (0, $parcel$interopDefault($29668e65f2091c2c$exports)).categories[val >> $43d7963e56408b24$var$CATEGORY_SHIFT & $43d7963e56408b24$var$CATEGORY_MASK];
              }
              function $43d7963e56408b24$export$c03b919c6651ed55(codePoint) {
                const val = $43d7963e56408b24$var$trie.get(codePoint);
                return (0, $parcel$interopDefault($29668e65f2091c2c$exports)).combiningClasses[val >> $43d7963e56408b24$var$COMBINING_SHIFT & $43d7963e56408b24$var$COMBINING_MASK];
              }
              function $43d7963e56408b24$export$941569448d136665(codePoint) {
                const val = $43d7963e56408b24$var$trie.get(codePoint);
                return (0, $parcel$interopDefault($29668e65f2091c2c$exports)).scripts[val >> $43d7963e56408b24$var$SCRIPT_SHIFT & $43d7963e56408b24$var$SCRIPT_MASK];
              }
              function $43d7963e56408b24$export$92f6187db8ca6d26(codePoint) {
                const val = $43d7963e56408b24$var$trie.get(codePoint);
                return (0, $parcel$interopDefault($29668e65f2091c2c$exports)).eaw[val >> $43d7963e56408b24$var$EAW_SHIFT & $43d7963e56408b24$var$EAW_MASK];
              }
              function $43d7963e56408b24$export$7d1258ebb7625a0d(codePoint) {
                let val = $43d7963e56408b24$var$trie.get(codePoint);
                let num = val & $43d7963e56408b24$var$NUMBER_MASK;
                if (num === 0) return null;
                else if (num <= 50) return num - 1;
                else if (num < 480) {
                  const numerator = (num >> 4) - 12;
                  const denominator = (num & 15) + 1;
                  return numerator / denominator;
                } else if (num < 768) {
                  val = (num >> 5) - 14;
                  let exp = (num & 31) + 2;
                  while (exp > 0) {
                    val *= 10;
                    exp--;
                  }
                  return val;
                } else {
                  val = (num >> 2) - 191;
                  let exp = (num & 3) + 1;
                  while (exp > 0) {
                    val *= 60;
                    exp--;
                  }
                  return val;
                }
              }
              function $43d7963e56408b24$export$52c8ea63abd07594(codePoint) {
                const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
                return category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Nl";
              }
              function $43d7963e56408b24$export$727d9dbc4fbb948f(codePoint) {
                return $43d7963e56408b24$export$410364bbb673ddbc(codePoint) === "Nd";
              }
              function $43d7963e56408b24$export$a5b49f4dc6a07d2c(codePoint) {
                const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
                return category === "Pc" || category === "Pd" || category === "Pe" || category === "Pf" || category === "Pi" || category === "Po" || category === "Ps";
              }
              function $43d7963e56408b24$export$7b6804e8df61fcf5(codePoint) {
                return $43d7963e56408b24$export$410364bbb673ddbc(codePoint) === "Ll";
              }
              function $43d7963e56408b24$export$aebd617640818cda(codePoint) {
                return $43d7963e56408b24$export$410364bbb673ddbc(codePoint) === "Lu";
              }
              function $43d7963e56408b24$export$de8b4ee23b2cf823(codePoint) {
                return $43d7963e56408b24$export$410364bbb673ddbc(codePoint) === "Lt";
              }
              function $43d7963e56408b24$export$3c52dd84024ae72c(codePoint) {
                const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
                return category === "Zs" || category === "Zl" || category === "Zp";
              }
              function $43d7963e56408b24$export$a11bdcffe109e74b(codePoint) {
                const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
                return category === "Nd" || category === "No" || category === "Nl" || category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Me" || category === "Mc";
              }
              function $43d7963e56408b24$export$e33ad6871e762338(codePoint) {
                const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
                return category === "Mn" || category === "Me" || category === "Mc";
              }
              var $43d7963e56408b24$export$2e2bcd8739ae039 = {
                getCategory: $43d7963e56408b24$export$410364bbb673ddbc,
                getCombiningClass: $43d7963e56408b24$export$c03b919c6651ed55,
                getScript: $43d7963e56408b24$export$941569448d136665,
                getEastAsianWidth: $43d7963e56408b24$export$92f6187db8ca6d26,
                getNumericValue: $43d7963e56408b24$export$7d1258ebb7625a0d,
                isAlphabetic: $43d7963e56408b24$export$52c8ea63abd07594,
                isDigit: $43d7963e56408b24$export$727d9dbc4fbb948f,
                isPunctuation: $43d7963e56408b24$export$a5b49f4dc6a07d2c,
                isLowerCase: $43d7963e56408b24$export$7b6804e8df61fcf5,
                isUpperCase: $43d7963e56408b24$export$aebd617640818cda,
                isTitleCase: $43d7963e56408b24$export$de8b4ee23b2cf823,
                isWhiteSpace: $43d7963e56408b24$export$3c52dd84024ae72c,
                isBaseForm: $43d7963e56408b24$export$a11bdcffe109e74b,
                isMark: $43d7963e56408b24$export$e33ad6871e762338
              };
            },
            /***/
            4779(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(2858));
                } else {
                }
              })(void 0, function(CryptoJS) {
                CryptoJS.pad.ZeroPadding = {
                  pad: function(data, blockSize) {
                    var blockSizeBytes = blockSize * 4;
                    data.clamp();
                    data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
                  },
                  unpad: function(data) {
                    var dataWords = data.words;
                    var i = data.sigBytes - 1;
                    for (var i = data.sigBytes - 1; i >= 0; i--) {
                      if (dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255) {
                        data.sigBytes = i + 1;
                        break;
                      }
                    }
                  }
                };
                return CryptoJS.pad.ZeroPadding;
              });
            },
            /***/
            4785(module2) {
              "use strict";
              var R = typeof Reflect === "object" ? Reflect : null;
              var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
                return Function.prototype.apply.call(target, receiver, args);
              };
              var ReflectOwnKeys;
              if (R && typeof R.ownKeys === "function") {
                ReflectOwnKeys = R.ownKeys;
              } else if (Object.getOwnPropertySymbols) {
                ReflectOwnKeys = function ReflectOwnKeys2(target) {
                  return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
                };
              } else {
                ReflectOwnKeys = function ReflectOwnKeys2(target) {
                  return Object.getOwnPropertyNames(target);
                };
              }
              function ProcessEmitWarning(warning) {
                if (console && console.warn) console.warn(warning);
              }
              var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
                return value !== value;
              };
              function EventEmitter() {
                EventEmitter.init.call(this);
              }
              module2.exports = EventEmitter;
              module2.exports.once = once;
              EventEmitter.EventEmitter = EventEmitter;
              EventEmitter.prototype._events = void 0;
              EventEmitter.prototype._eventsCount = 0;
              EventEmitter.prototype._maxListeners = void 0;
              var defaultMaxListeners = 10;
              function checkListener(listener) {
                if (typeof listener !== "function") {
                  throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
                }
              }
              Object.defineProperty(EventEmitter, "defaultMaxListeners", {
                enumerable: true,
                get: function() {
                  return defaultMaxListeners;
                },
                set: function(arg) {
                  if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
                  }
                  defaultMaxListeners = arg;
                }
              });
              EventEmitter.init = function() {
                if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
                  this._events = /* @__PURE__ */ Object.create(null);
                  this._eventsCount = 0;
                }
                this._maxListeners = this._maxListeners || void 0;
              };
              EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
                if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
                  throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
                }
                this._maxListeners = n;
                return this;
              };
              function _getMaxListeners(that) {
                if (that._maxListeners === void 0)
                  return EventEmitter.defaultMaxListeners;
                return that._maxListeners;
              }
              EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
                return _getMaxListeners(this);
              };
              EventEmitter.prototype.emit = function emit(type) {
                var args = [];
                for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
                var doError = type === "error";
                var events = this._events;
                if (events !== void 0)
                  doError = doError && events.error === void 0;
                else if (!doError)
                  return false;
                if (doError) {
                  var er;
                  if (args.length > 0)
                    er = args[0];
                  if (er instanceof Error) {
                    throw er;
                  }
                  var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
                  err.context = er;
                  throw err;
                }
                var handler = events[type];
                if (handler === void 0)
                  return false;
                if (typeof handler === "function") {
                  ReflectApply(handler, this, args);
                } else {
                  var len = handler.length;
                  var listeners = arrayClone(handler, len);
                  for (var i = 0; i < len; ++i)
                    ReflectApply(listeners[i], this, args);
                }
                return true;
              };
              function _addListener(target, type, listener, prepend) {
                var m;
                var events;
                var existing;
                checkListener(listener);
                events = target._events;
                if (events === void 0) {
                  events = target._events = /* @__PURE__ */ Object.create(null);
                  target._eventsCount = 0;
                } else {
                  if (events.newListener !== void 0) {
                    target.emit(
                      "newListener",
                      type,
                      listener.listener ? listener.listener : listener
                    );
                    events = target._events;
                  }
                  existing = events[type];
                }
                if (existing === void 0) {
                  existing = events[type] = listener;
                  ++target._eventsCount;
                } else {
                  if (typeof existing === "function") {
                    existing = events[type] = prepend ? [listener, existing] : [existing, listener];
                  } else if (prepend) {
                    existing.unshift(listener);
                  } else {
                    existing.push(listener);
                  }
                  m = _getMaxListeners(target);
                  if (m > 0 && existing.length > m && !existing.warned) {
                    existing.warned = true;
                    var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    w.name = "MaxListenersExceededWarning";
                    w.emitter = target;
                    w.type = type;
                    w.count = existing.length;
                    ProcessEmitWarning(w);
                  }
                }
                return target;
              }
              EventEmitter.prototype.addListener = function addListener(type, listener) {
                return _addListener(this, type, listener, false);
              };
              EventEmitter.prototype.on = EventEmitter.prototype.addListener;
              EventEmitter.prototype.prependListener = function prependListener(type, listener) {
                return _addListener(this, type, listener, true);
              };
              function onceWrapper() {
                if (!this.fired) {
                  this.target.removeListener(this.type, this.wrapFn);
                  this.fired = true;
                  if (arguments.length === 0)
                    return this.listener.call(this.target);
                  return this.listener.apply(this.target, arguments);
                }
              }
              function _onceWrap(target, type, listener) {
                var state = { fired: false, wrapFn: void 0, target, type, listener };
                var wrapped = onceWrapper.bind(state);
                wrapped.listener = listener;
                state.wrapFn = wrapped;
                return wrapped;
              }
              EventEmitter.prototype.once = function once2(type, listener) {
                checkListener(listener);
                this.on(type, _onceWrap(this, type, listener));
                return this;
              };
              EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
                checkListener(listener);
                this.prependListener(type, _onceWrap(this, type, listener));
                return this;
              };
              EventEmitter.prototype.removeListener = function removeListener(type, listener) {
                var list, events, position, i, originalListener;
                checkListener(listener);
                events = this._events;
                if (events === void 0)
                  return this;
                list = events[type];
                if (list === void 0)
                  return this;
                if (list === listener || list.listener === listener) {
                  if (--this._eventsCount === 0)
                    this._events = /* @__PURE__ */ Object.create(null);
                  else {
                    delete events[type];
                    if (events.removeListener)
                      this.emit("removeListener", type, list.listener || listener);
                  }
                } else if (typeof list !== "function") {
                  position = -1;
                  for (i = list.length - 1; i >= 0; i--) {
                    if (list[i] === listener || list[i].listener === listener) {
                      originalListener = list[i].listener;
                      position = i;
                      break;
                    }
                  }
                  if (position < 0)
                    return this;
                  if (position === 0)
                    list.shift();
                  else {
                    spliceOne(list, position);
                  }
                  if (list.length === 1)
                    events[type] = list[0];
                  if (events.removeListener !== void 0)
                    this.emit("removeListener", type, originalListener || listener);
                }
                return this;
              };
              EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
              EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
                var listeners, events, i;
                events = this._events;
                if (events === void 0)
                  return this;
                if (events.removeListener === void 0) {
                  if (arguments.length === 0) {
                    this._events = /* @__PURE__ */ Object.create(null);
                    this._eventsCount = 0;
                  } else if (events[type] !== void 0) {
                    if (--this._eventsCount === 0)
                      this._events = /* @__PURE__ */ Object.create(null);
                    else
                      delete events[type];
                  }
                  return this;
                }
                if (arguments.length === 0) {
                  var keys = Object.keys(events);
                  var key;
                  for (i = 0; i < keys.length; ++i) {
                    key = keys[i];
                    if (key === "removeListener") continue;
                    this.removeAllListeners(key);
                  }
                  this.removeAllListeners("removeListener");
                  this._events = /* @__PURE__ */ Object.create(null);
                  this._eventsCount = 0;
                  return this;
                }
                listeners = events[type];
                if (typeof listeners === "function") {
                  this.removeListener(type, listeners);
                } else if (listeners !== void 0) {
                  for (i = listeners.length - 1; i >= 0; i--) {
                    this.removeListener(type, listeners[i]);
                  }
                }
                return this;
              };
              function _listeners(target, type, unwrap) {
                var events = target._events;
                if (events === void 0)
                  return [];
                var evlistener = events[type];
                if (evlistener === void 0)
                  return [];
                if (typeof evlistener === "function")
                  return unwrap ? [evlistener.listener || evlistener] : [evlistener];
                return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
              }
              EventEmitter.prototype.listeners = function listeners(type) {
                return _listeners(this, type, true);
              };
              EventEmitter.prototype.rawListeners = function rawListeners(type) {
                return _listeners(this, type, false);
              };
              EventEmitter.listenerCount = function(emitter, type) {
                if (typeof emitter.listenerCount === "function") {
                  return emitter.listenerCount(type);
                } else {
                  return listenerCount.call(emitter, type);
                }
              };
              EventEmitter.prototype.listenerCount = listenerCount;
              function listenerCount(type) {
                var events = this._events;
                if (events !== void 0) {
                  var evlistener = events[type];
                  if (typeof evlistener === "function") {
                    return 1;
                  } else if (evlistener !== void 0) {
                    return evlistener.length;
                  }
                }
                return 0;
              }
              EventEmitter.prototype.eventNames = function eventNames() {
                return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
              };
              function arrayClone(arr, n) {
                var copy = new Array(n);
                for (var i = 0; i < n; ++i)
                  copy[i] = arr[i];
                return copy;
              }
              function spliceOne(list, index) {
                for (; index + 1 < list.length; index++)
                  list[index] = list[index + 1];
                list.pop();
              }
              function unwrapListeners(arr) {
                var ret = new Array(arr.length);
                for (var i = 0; i < ret.length; ++i) {
                  ret[i] = arr[i].listener || arr[i];
                }
                return ret;
              }
              function once(emitter, name) {
                return new Promise(function(resolve, reject) {
                  function errorListener(err) {
                    emitter.removeListener(name, resolver);
                    reject(err);
                  }
                  function resolver() {
                    if (typeof emitter.removeListener === "function") {
                      emitter.removeListener("error", errorListener);
                    }
                    resolve([].slice.call(arguments));
                  }
                  ;
                  eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
                  if (name !== "error") {
                    addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
                  }
                });
              }
              function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
                if (typeof emitter.on === "function") {
                  eventTargetAgnosticAddListener(emitter, "error", handler, flags);
                }
              }
              function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
                if (typeof emitter.on === "function") {
                  if (flags.once) {
                    emitter.once(name, listener);
                  } else {
                    emitter.on(name, listener);
                  }
                } else if (typeof emitter.addEventListener === "function") {
                  emitter.addEventListener(name, function wrapListener(arg) {
                    if (flags.once) {
                      emitter.removeEventListener(name, wrapListener);
                    }
                    listener(arg);
                  });
                } else {
                  throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
                }
              }
            },
            /***/
            4866(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function() {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var WordArray = C_lib.WordArray;
                  var C_enc = C.enc;
                  var Base64 = C_enc.Base64 = {
                    /**
                     * Converts a word array to a Base64 string.
                     *
                     * @param {WordArray} wordArray The word array.
                     *
                     * @return {string} The Base64 string.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
                     */
                    stringify: function(wordArray) {
                      var words = wordArray.words;
                      var sigBytes = wordArray.sigBytes;
                      var map = this._map;
                      wordArray.clamp();
                      var base64Chars = [];
                      for (var i = 0; i < sigBytes; i += 3) {
                        var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                        var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
                        var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
                        var triplet = byte1 << 16 | byte2 << 8 | byte3;
                        for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                          base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
                        }
                      }
                      var paddingChar = map.charAt(64);
                      if (paddingChar) {
                        while (base64Chars.length % 4) {
                          base64Chars.push(paddingChar);
                        }
                      }
                      return base64Chars.join("");
                    },
                    /**
                     * Converts a Base64 string to a word array.
                     *
                     * @param {string} base64Str The Base64 string.
                     *
                     * @return {WordArray} The word array.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
                     */
                    parse: function(base64Str) {
                      var base64StrLength = base64Str.length;
                      var map = this._map;
                      var reverseMap = this._reverseMap;
                      if (!reverseMap) {
                        reverseMap = this._reverseMap = [];
                        for (var j = 0; j < map.length; j++) {
                          reverseMap[map.charCodeAt(j)] = j;
                        }
                      }
                      var paddingChar = map.charAt(64);
                      if (paddingChar) {
                        var paddingIndex = base64Str.indexOf(paddingChar);
                        if (paddingIndex !== -1) {
                          base64StrLength = paddingIndex;
                        }
                      }
                      return parseLoop(base64Str, base64StrLength, reverseMap);
                    },
                    _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
                  };
                  function parseLoop(base64Str, base64StrLength, reverseMap) {
                    var words = [];
                    var nBytes = 0;
                    for (var i = 0; i < base64StrLength; i++) {
                      if (i % 4) {
                        var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
                        var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
                        var bitsCombined = bits1 | bits2;
                        words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                        nBytes++;
                      }
                    }
                    return WordArray.create(words, nBytes);
                  }
                })();
                return CryptoJS.enc.Base64;
              });
            },
            /***/
            4873(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(2858));
                } else {
                }
              })(void 0, function(CryptoJS) {
                CryptoJS.pad.AnsiX923 = {
                  pad: function(data, blockSize) {
                    var dataSigBytes = data.sigBytes;
                    var blockSizeBytes = blockSize * 4;
                    var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
                    var lastBytePos = dataSigBytes + nPaddingBytes - 1;
                    data.clamp();
                    data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
                    data.sigBytes += nPaddingBytes;
                  },
                  unpad: function(data) {
                    var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
                    data.sigBytes -= nPaddingBytes;
                  }
                };
                return CryptoJS.pad.Ansix923;
              });
            },
            /***/
            4903(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var process = __webpack_require__2(9964);
              var objectKeys = Object.keys || function(obj) {
                var keys2 = [];
                for (var key in obj) keys2.push(key);
                return keys2;
              };
              module2.exports = Duplex;
              var Readable = __webpack_require__2(8261);
              var Writable = __webpack_require__2(9781);
              __webpack_require__2(9784)(Duplex, Readable);
              {
                var keys = objectKeys(Writable.prototype);
                for (var v = 0; v < keys.length; v++) {
                  var method = keys[v];
                  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
                }
              }
              function Duplex(options) {
                if (!(this instanceof Duplex)) return new Duplex(options);
                Readable.call(this, options);
                Writable.call(this, options);
                this.allowHalfOpen = true;
                if (options) {
                  if (options.readable === false) this.readable = false;
                  if (options.writable === false) this.writable = false;
                  if (options.allowHalfOpen === false) {
                    this.allowHalfOpen = false;
                    this.once("end", onend);
                  }
                }
              }
              Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._writableState.highWaterMark;
                }
              });
              Object.defineProperty(Duplex.prototype, "writableBuffer", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._writableState && this._writableState.getBuffer();
                }
              });
              Object.defineProperty(Duplex.prototype, "writableLength", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._writableState.length;
                }
              });
              function onend() {
                if (this._writableState.ended) return;
                process.nextTick(onEndNT, this);
              }
              function onEndNT(self2) {
                self2.end();
              }
              Object.defineProperty(Duplex.prototype, "destroyed", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  if (this._readableState === void 0 || this._writableState === void 0) {
                    return false;
                  }
                  return this._readableState.destroyed && this._writableState.destroyed;
                },
                set: function set(value) {
                  if (this._readableState === void 0 || this._writableState === void 0) {
                    return;
                  }
                  this._readableState.destroyed = value;
                  this._writableState.destroyed = value;
                }
              });
            },
            /***/
            4918(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var toIntegerOrInfinity = __webpack_require__2(2119);
              var max = Math.max;
              var min = Math.min;
              module2.exports = function(index, length) {
                var integer = toIntegerOrInfinity(index);
                return integer < 0 ? max(integer + length, 0) : min(integer, length);
              };
            },
            /***/
            5034(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var isNullOrUndefined = __webpack_require__2(6297);
              var $TypeError = TypeError;
              module2.exports = function(it) {
                if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
                return it;
              };
            },
            /***/
            5049(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var implementation = __webpack_require__2(2719);
              module2.exports = Function.prototype.bind || implementation;
            },
            /***/
            5071(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var fails = __webpack_require__2(299);
              module2.exports = !fails(function() {
                function F() {
                }
                F.prototype.constructor = null;
                return Object.getPrototypeOf(new F()) !== F.prototype;
              });
            },
            /***/
            5074(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var define2 = __webpack_require__2(5421);
              var getPolyfill = __webpack_require__2(1320);
              module2.exports = function shimNumberIsNaN() {
                var polyfill = getPolyfill();
                define2(Number, { isNaN: polyfill }, {
                  isNaN: function testIsNaN() {
                    return Number.isNaN !== polyfill;
                  }
                });
                return polyfill;
              };
            },
            /***/
            5117(module2) {
              "use strict";
              module2.exports = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
            },
            /***/
            5144(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var fails = __webpack_require__2(299);
              module2.exports = !fails(function() {
                return Object.defineProperty({}, 1, { get: function() {
                  return 7;
                } })[1] !== 7;
              });
            },
            /***/
            5215(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var call = Function.prototype.call;
              var $hasOwn = Object.prototype.hasOwnProperty;
              var bind = __webpack_require__2(5049);
              module2.exports = bind.call(call, $hasOwn);
            },
            /***/
            5233(module2) {
              function $parcel$exportWildcard(dest, source) {
                Object.keys(source).forEach(function(key) {
                  if (key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(dest, key)) {
                    return;
                  }
                  Object.defineProperty(dest, key, {
                    enumerable: true,
                    get: function get() {
                      return source[key];
                    }
                  });
                });
                return dest;
              }
              function $parcel$export(e, n, v, s) {
                Object.defineProperty(e, n, { get: v, set: s, enumerable: true, configurable: true });
              }
              $parcel$export(module2.exports, "EncodeStream", () => $1ed46182c1410e1d$export$9b4f661deaa36c3e);
              $parcel$export(module2.exports, "DecodeStream", () => $8ae20583b93e4933$export$c18b354bac7948e9);
              $parcel$export(module2.exports, "Array", () => $8ea28a08eae2a116$export$c4be6576ca6fe4aa);
              $parcel$export(module2.exports, "LazyArray", () => $444f112d3cbc7e9f$export$5576c026028d4983);
              $parcel$export(module2.exports, "Bitfield", () => $3def237a34a226b5$export$96b43b8a49f688ea);
              $parcel$export(module2.exports, "Boolean", () => $8415e91bb83faf74$export$ff887cefee4d61ec);
              $parcel$export(module2.exports, "Buffer", () => $08d28604119af47e$export$7d22a0eea6656474);
              $parcel$export(module2.exports, "Enum", () => $070ce31ea947467f$export$deb82508dd66d288);
              $parcel$export(module2.exports, "Optional", () => $80703542fcfb6ff0$export$7acb7b24c478f9c6);
              $parcel$export(module2.exports, "Reserved", () => $f4fd49878232508a$export$da9b5fe187a9aa1);
              $parcel$export(module2.exports, "String", () => $d8705cd4022e7dcf$export$89b8e0fa65f6a914);
              $parcel$export(module2.exports, "Struct", () => $aa8b66bae6abe658$export$eabc71f011df675a);
              $parcel$export(module2.exports, "VersionedStruct", () => $fcb208a95f6d048b$export$95a8b60f4da7dec8);
              const $8ae20583b93e4933$var$ENCODING_MAPPING = {
                utf16le: "utf-16le",
                ucs2: "utf-16le",
                utf16be: "utf-16be"
              };
              class $8ae20583b93e4933$export$c18b354bac7948e9 {
                constructor(buffer) {
                  this.buffer = buffer;
                  this.view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
                  this.pos = 0;
                  this.length = this.buffer.length;
                }
                readString(length, encoding = "ascii") {
                  encoding = $8ae20583b93e4933$var$ENCODING_MAPPING[encoding] || encoding;
                  let buf = this.readBuffer(length);
                  try {
                    let decoder = new TextDecoder(encoding);
                    return decoder.decode(buf);
                  } catch (err) {
                    return buf;
                  }
                }
                readBuffer(length) {
                  return this.buffer.slice(this.pos, this.pos += length);
                }
                readUInt24BE() {
                  return (this.readUInt16BE() << 8) + this.readUInt8();
                }
                readUInt24LE() {
                  return this.readUInt16LE() + (this.readUInt8() << 16);
                }
                readInt24BE() {
                  return (this.readInt16BE() << 8) + this.readUInt8();
                }
                readInt24LE() {
                  return this.readUInt16LE() + (this.readInt8() << 16);
                }
              }
              $8ae20583b93e4933$export$c18b354bac7948e9.TYPES = {
                UInt8: 1,
                UInt16: 2,
                UInt24: 3,
                UInt32: 4,
                Int8: 1,
                Int16: 2,
                Int24: 3,
                Int32: 4,
                Float: 4,
                Double: 8
              };
              for (let key of Object.getOwnPropertyNames(DataView.prototype)) if (key.slice(0, 3) === "get") {
                let type = key.slice(3).replace("Ui", "UI");
                if (type === "Float32") type = "Float";
                else if (type === "Float64") type = "Double";
                let bytes = $8ae20583b93e4933$export$c18b354bac7948e9.TYPES[type];
                $8ae20583b93e4933$export$c18b354bac7948e9.prototype["read" + type + (bytes === 1 ? "" : "BE")] = function() {
                  const ret = this.view[key](this.pos, false);
                  this.pos += bytes;
                  return ret;
                };
                if (bytes !== 1) $8ae20583b93e4933$export$c18b354bac7948e9.prototype["read" + type + "LE"] = function() {
                  const ret = this.view[key](this.pos, true);
                  this.pos += bytes;
                  return ret;
                };
              }
              const $1ed46182c1410e1d$var$textEncoder = new TextEncoder();
              const $1ed46182c1410e1d$var$isBigEndian = new Uint8Array(new Uint16Array([
                4660
              ]).buffer)[0] == 18;
              class $1ed46182c1410e1d$export$9b4f661deaa36c3e {
                constructor(buffer) {
                  this.buffer = buffer;
                  this.view = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
                  this.pos = 0;
                }
                writeBuffer(buffer) {
                  this.buffer.set(buffer, this.pos);
                  this.pos += buffer.length;
                }
                writeString(string, encoding = "ascii") {
                  let buf;
                  switch (encoding) {
                    case "utf16le":
                    case "utf16-le":
                    case "ucs2":
                      buf = $1ed46182c1410e1d$var$stringToUtf16(string, $1ed46182c1410e1d$var$isBigEndian);
                      break;
                    case "utf16be":
                    case "utf16-be":
                      buf = $1ed46182c1410e1d$var$stringToUtf16(string, !$1ed46182c1410e1d$var$isBigEndian);
                      break;
                    case "utf8":
                      buf = $1ed46182c1410e1d$var$textEncoder.encode(string);
                      break;
                    case "ascii":
                      buf = $1ed46182c1410e1d$var$stringToAscii(string);
                      break;
                    default:
                      throw new Error(`Unsupported encoding: ${encoding}`);
                  }
                  this.writeBuffer(buf);
                }
                writeUInt24BE(val) {
                  this.buffer[this.pos++] = val >>> 16 & 255;
                  this.buffer[this.pos++] = val >>> 8 & 255;
                  this.buffer[this.pos++] = val & 255;
                }
                writeUInt24LE(val) {
                  this.buffer[this.pos++] = val & 255;
                  this.buffer[this.pos++] = val >>> 8 & 255;
                  this.buffer[this.pos++] = val >>> 16 & 255;
                }
                writeInt24BE(val) {
                  if (val >= 0) this.writeUInt24BE(val);
                  else this.writeUInt24BE(val + 16777215 + 1);
                }
                writeInt24LE(val) {
                  if (val >= 0) this.writeUInt24LE(val);
                  else this.writeUInt24LE(val + 16777215 + 1);
                }
                fill(val, length) {
                  if (length < this.buffer.length) {
                    this.buffer.fill(val, this.pos, this.pos + length);
                    this.pos += length;
                  } else {
                    const buf = new Uint8Array(length);
                    buf.fill(val);
                    this.writeBuffer(buf);
                  }
                }
              }
              function $1ed46182c1410e1d$var$stringToUtf16(string, swap) {
                let buf = new Uint16Array(string.length);
                for (let i = 0; i < string.length; i++) {
                  let code = string.charCodeAt(i);
                  if (swap) code = code >> 8 | (code & 255) << 8;
                  buf[i] = code;
                }
                return new Uint8Array(buf.buffer);
              }
              function $1ed46182c1410e1d$var$stringToAscii(string) {
                let buf = new Uint8Array(string.length);
                for (let i = 0; i < string.length; i++)
                  buf[i] = string.charCodeAt(i);
                return buf;
              }
              for (let key of Object.getOwnPropertyNames(DataView.prototype)) if (key.slice(0, 3) === "set") {
                let type = key.slice(3).replace("Ui", "UI");
                if (type === "Float32") type = "Float";
                else if (type === "Float64") type = "Double";
                let bytes = (0, $8ae20583b93e4933$export$c18b354bac7948e9).TYPES[type];
                $1ed46182c1410e1d$export$9b4f661deaa36c3e.prototype["write" + type + (bytes === 1 ? "" : "BE")] = function(value) {
                  this.view[key](this.pos, value, false);
                  this.pos += bytes;
                };
                if (bytes !== 1) $1ed46182c1410e1d$export$9b4f661deaa36c3e.prototype["write" + type + "LE"] = function(value) {
                  this.view[key](this.pos, value, true);
                  this.pos += bytes;
                };
              }
              class $8d21f7fa58802901$export$ef88aa0d34c34520 {
                fromBuffer(buffer) {
                  let stream = new (0, $8ae20583b93e4933$export$c18b354bac7948e9)(buffer);
                  return this.decode(stream);
                }
                toBuffer(value) {
                  let size = this.size(value);
                  let buffer = new Uint8Array(size);
                  let stream = new (0, $1ed46182c1410e1d$export$9b4f661deaa36c3e)(buffer);
                  this.encode(stream, value);
                  return buffer;
                }
              }
              var $af65abf7bf65ac42$exports = {};
              $parcel$export($af65abf7bf65ac42$exports, "Number", () => $af65abf7bf65ac42$export$fffa67e515d04022);
              $parcel$export($af65abf7bf65ac42$exports, "uint8", () => $af65abf7bf65ac42$export$52e103c63c4e68cf);
              $parcel$export($af65abf7bf65ac42$exports, "uint16be", () => $af65abf7bf65ac42$export$60dfe43c8297a8f8);
              $parcel$export($af65abf7bf65ac42$exports, "uint16", () => $af65abf7bf65ac42$export$56bd24b5a3ee8456);
              $parcel$export($af65abf7bf65ac42$exports, "uint16le", () => $af65abf7bf65ac42$export$b92d76f0ca6d1789);
              $parcel$export($af65abf7bf65ac42$exports, "uint24be", () => $af65abf7bf65ac42$export$255f45171f96b50c);
              $parcel$export($af65abf7bf65ac42$exports, "uint24", () => $af65abf7bf65ac42$export$1925298fbd719b21);
              $parcel$export($af65abf7bf65ac42$exports, "uint24le", () => $af65abf7bf65ac42$export$758e1dafc8dc7271);
              $parcel$export($af65abf7bf65ac42$exports, "uint32be", () => $af65abf7bf65ac42$export$74c16dba6c885532);
              $parcel$export($af65abf7bf65ac42$exports, "uint32", () => $af65abf7bf65ac42$export$de9ffb9418dd7d0d);
              $parcel$export($af65abf7bf65ac42$exports, "uint32le", () => $af65abf7bf65ac42$export$5f744bb30a534bc9);
              $parcel$export($af65abf7bf65ac42$exports, "int8", () => $af65abf7bf65ac42$export$5984f25eab09961f);
              $parcel$export($af65abf7bf65ac42$exports, "int16be", () => $af65abf7bf65ac42$export$198ae7d10d26a900);
              $parcel$export($af65abf7bf65ac42$exports, "int16", () => $af65abf7bf65ac42$export$c35c15c7caeff2b6);
              $parcel$export($af65abf7bf65ac42$exports, "int16le", () => $af65abf7bf65ac42$export$399cc4b7169e5aed);
              $parcel$export($af65abf7bf65ac42$exports, "int24be", () => $af65abf7bf65ac42$export$3676d1f71eca2ec0);
              $parcel$export($af65abf7bf65ac42$exports, "int24", () => $af65abf7bf65ac42$export$73f695d681ac61f9);
              $parcel$export($af65abf7bf65ac42$exports, "int24le", () => $af65abf7bf65ac42$export$671f8672dbd40a4);
              $parcel$export($af65abf7bf65ac42$exports, "int32be", () => $af65abf7bf65ac42$export$78a2ac3d09dd42d5);
              $parcel$export($af65abf7bf65ac42$exports, "int32", () => $af65abf7bf65ac42$export$1d95835383bb05a);
              $parcel$export($af65abf7bf65ac42$exports, "int32le", () => $af65abf7bf65ac42$export$5ec1f146e759329a);
              $parcel$export($af65abf7bf65ac42$exports, "floatbe", () => $af65abf7bf65ac42$export$92b5c14c6abb5c97);
              $parcel$export($af65abf7bf65ac42$exports, "float", () => $af65abf7bf65ac42$export$6b5cd3983e3ee5ab);
              $parcel$export($af65abf7bf65ac42$exports, "floatle", () => $af65abf7bf65ac42$export$6d20592bc4cb19d9);
              $parcel$export($af65abf7bf65ac42$exports, "doublebe", () => $af65abf7bf65ac42$export$e50b9e97e4d43631);
              $parcel$export($af65abf7bf65ac42$exports, "double", () => $af65abf7bf65ac42$export$7b3cbda67be88f5f);
              $parcel$export($af65abf7bf65ac42$exports, "doublele", () => $af65abf7bf65ac42$export$6f53315aa512b751);
              $parcel$export($af65abf7bf65ac42$exports, "Fixed", () => $af65abf7bf65ac42$export$13475bbd2a37a9b4);
              $parcel$export($af65abf7bf65ac42$exports, "fixed16be", () => $af65abf7bf65ac42$export$f87b441e6bd90278);
              $parcel$export($af65abf7bf65ac42$exports, "fixed16", () => $af65abf7bf65ac42$export$a3abada75ef55921);
              $parcel$export($af65abf7bf65ac42$exports, "fixed16le", () => $af65abf7bf65ac42$export$3752a2886837dc22);
              $parcel$export($af65abf7bf65ac42$exports, "fixed32be", () => $af65abf7bf65ac42$export$dd71d8d9bc792632);
              $parcel$export($af65abf7bf65ac42$exports, "fixed32", () => $af65abf7bf65ac42$export$e913265d48471f2d);
              $parcel$export($af65abf7bf65ac42$exports, "fixed32le", () => $af65abf7bf65ac42$export$7fc47db6a5fc8223);
              class $af65abf7bf65ac42$export$fffa67e515d04022 extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {
                constructor(type, endian = "BE") {
                  super();
                  this.type = type;
                  this.endian = endian;
                  this.fn = this.type;
                  if (this.type[this.type.length - 1] !== "8") this.fn += this.endian;
                }
                size() {
                  return (0, $8ae20583b93e4933$export$c18b354bac7948e9).TYPES[this.type];
                }
                decode(stream) {
                  return stream[`read${this.fn}`]();
                }
                encode(stream, val) {
                  return stream[`write${this.fn}`](val);
                }
              }
              const $af65abf7bf65ac42$export$52e103c63c4e68cf = new $af65abf7bf65ac42$export$fffa67e515d04022("UInt8");
              const $af65abf7bf65ac42$export$60dfe43c8297a8f8 = new $af65abf7bf65ac42$export$fffa67e515d04022("UInt16", "BE");
              const $af65abf7bf65ac42$export$56bd24b5a3ee8456 = $af65abf7bf65ac42$export$60dfe43c8297a8f8;
              const $af65abf7bf65ac42$export$b92d76f0ca6d1789 = new $af65abf7bf65ac42$export$fffa67e515d04022("UInt16", "LE");
              const $af65abf7bf65ac42$export$255f45171f96b50c = new $af65abf7bf65ac42$export$fffa67e515d04022("UInt24", "BE");
              const $af65abf7bf65ac42$export$1925298fbd719b21 = $af65abf7bf65ac42$export$255f45171f96b50c;
              const $af65abf7bf65ac42$export$758e1dafc8dc7271 = new $af65abf7bf65ac42$export$fffa67e515d04022("UInt24", "LE");
              const $af65abf7bf65ac42$export$74c16dba6c885532 = new $af65abf7bf65ac42$export$fffa67e515d04022("UInt32", "BE");
              const $af65abf7bf65ac42$export$de9ffb9418dd7d0d = $af65abf7bf65ac42$export$74c16dba6c885532;
              const $af65abf7bf65ac42$export$5f744bb30a534bc9 = new $af65abf7bf65ac42$export$fffa67e515d04022("UInt32", "LE");
              const $af65abf7bf65ac42$export$5984f25eab09961f = new $af65abf7bf65ac42$export$fffa67e515d04022("Int8");
              const $af65abf7bf65ac42$export$198ae7d10d26a900 = new $af65abf7bf65ac42$export$fffa67e515d04022("Int16", "BE");
              const $af65abf7bf65ac42$export$c35c15c7caeff2b6 = $af65abf7bf65ac42$export$198ae7d10d26a900;
              const $af65abf7bf65ac42$export$399cc4b7169e5aed = new $af65abf7bf65ac42$export$fffa67e515d04022("Int16", "LE");
              const $af65abf7bf65ac42$export$3676d1f71eca2ec0 = new $af65abf7bf65ac42$export$fffa67e515d04022("Int24", "BE");
              const $af65abf7bf65ac42$export$73f695d681ac61f9 = $af65abf7bf65ac42$export$3676d1f71eca2ec0;
              const $af65abf7bf65ac42$export$671f8672dbd40a4 = new $af65abf7bf65ac42$export$fffa67e515d04022("Int24", "LE");
              const $af65abf7bf65ac42$export$78a2ac3d09dd42d5 = new $af65abf7bf65ac42$export$fffa67e515d04022("Int32", "BE");
              const $af65abf7bf65ac42$export$1d95835383bb05a = $af65abf7bf65ac42$export$78a2ac3d09dd42d5;
              const $af65abf7bf65ac42$export$5ec1f146e759329a = new $af65abf7bf65ac42$export$fffa67e515d04022("Int32", "LE");
              const $af65abf7bf65ac42$export$92b5c14c6abb5c97 = new $af65abf7bf65ac42$export$fffa67e515d04022("Float", "BE");
              const $af65abf7bf65ac42$export$6b5cd3983e3ee5ab = $af65abf7bf65ac42$export$92b5c14c6abb5c97;
              const $af65abf7bf65ac42$export$6d20592bc4cb19d9 = new $af65abf7bf65ac42$export$fffa67e515d04022("Float", "LE");
              const $af65abf7bf65ac42$export$e50b9e97e4d43631 = new $af65abf7bf65ac42$export$fffa67e515d04022("Double", "BE");
              const $af65abf7bf65ac42$export$7b3cbda67be88f5f = $af65abf7bf65ac42$export$e50b9e97e4d43631;
              const $af65abf7bf65ac42$export$6f53315aa512b751 = new $af65abf7bf65ac42$export$fffa67e515d04022("Double", "LE");
              class $af65abf7bf65ac42$export$13475bbd2a37a9b4 extends $af65abf7bf65ac42$export$fffa67e515d04022 {
                constructor(size, endian, fracBits = size >> 1) {
                  super(`Int${size}`, endian);
                  this._point = 1 << fracBits;
                }
                decode(stream) {
                  return super.decode(stream) / this._point;
                }
                encode(stream, val) {
                  return super.encode(stream, val * this._point | 0);
                }
              }
              const $af65abf7bf65ac42$export$f87b441e6bd90278 = new $af65abf7bf65ac42$export$13475bbd2a37a9b4(16, "BE");
              const $af65abf7bf65ac42$export$a3abada75ef55921 = $af65abf7bf65ac42$export$f87b441e6bd90278;
              const $af65abf7bf65ac42$export$3752a2886837dc22 = new $af65abf7bf65ac42$export$13475bbd2a37a9b4(16, "LE");
              const $af65abf7bf65ac42$export$dd71d8d9bc792632 = new $af65abf7bf65ac42$export$13475bbd2a37a9b4(32, "BE");
              const $af65abf7bf65ac42$export$e913265d48471f2d = $af65abf7bf65ac42$export$dd71d8d9bc792632;
              const $af65abf7bf65ac42$export$7fc47db6a5fc8223 = new $af65abf7bf65ac42$export$13475bbd2a37a9b4(32, "LE");
              var $4559ecf940edc78d$exports = {};
              $parcel$export($4559ecf940edc78d$exports, "resolveLength", () => $4559ecf940edc78d$export$83b6dc3503c1fda6);
              $parcel$export($4559ecf940edc78d$exports, "PropertyDescriptor", () => $4559ecf940edc78d$export$41705b1d644e0f14);
              function $4559ecf940edc78d$export$83b6dc3503c1fda6(length, stream, parent) {
                let res;
                if (typeof length === "number") res = length;
                else if (typeof length === "function") res = length.call(parent, parent);
                else if (parent && typeof length === "string") res = parent[length];
                else if (stream && length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) res = length.decode(stream);
                if (isNaN(res)) throw new Error("Not a fixed size");
                return res;
              }
              class $4559ecf940edc78d$export$41705b1d644e0f14 {
                constructor(opts = {}) {
                  this.enumerable = true;
                  this.configurable = true;
                  for (let key in opts) {
                    const val = opts[key];
                    this[key] = val;
                  }
                }
              }
              class $8ea28a08eae2a116$export$c4be6576ca6fe4aa extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {
                constructor(type, length, lengthType = "count") {
                  super();
                  this.type = type;
                  this.length = length;
                  this.lengthType = lengthType;
                }
                decode(stream, parent) {
                  let length;
                  const { pos } = stream;
                  const res = [];
                  let ctx = parent;
                  if (this.length != null) length = $4559ecf940edc78d$export$83b6dc3503c1fda6(this.length, stream, parent);
                  if (this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) {
                    Object.defineProperties(res, {
                      parent: {
                        value: parent
                      },
                      _startOffset: {
                        value: pos
                      },
                      _currentOffset: {
                        value: 0,
                        writable: true
                      },
                      _length: {
                        value: length
                      }
                    });
                    ctx = res;
                  }
                  if (length == null || this.lengthType === "bytes") {
                    const target = length != null ? stream.pos + length : (parent != null ? parent._length : void 0) ? parent._startOffset + parent._length : stream.length;
                    while (stream.pos < target) res.push(this.type.decode(stream, ctx));
                  } else for (let i = 0, end = length; i < end; i++) res.push(this.type.decode(stream, ctx));
                  return res;
                }
                size(array, ctx, includePointers = true) {
                  if (!array) return this.type.size(null, ctx) * $4559ecf940edc78d$export$83b6dc3503c1fda6(this.length, null, ctx);
                  let size = 0;
                  if (this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) {
                    size += this.length.size();
                    ctx = {
                      parent: ctx,
                      pointerSize: 0
                    };
                  }
                  for (let item of array) size += this.type.size(item, ctx);
                  if (ctx && includePointers && this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) size += ctx.pointerSize;
                  return size;
                }
                encode(stream, array, parent) {
                  let ctx = parent;
                  if (this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) {
                    ctx = {
                      pointers: [],
                      startOffset: stream.pos,
                      parent
                    };
                    ctx.pointerOffset = stream.pos + this.size(array, ctx, false);
                    this.length.encode(stream, array.length);
                  }
                  for (let item of array) this.type.encode(stream, item, ctx);
                  if (this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) {
                    let i = 0;
                    while (i < ctx.pointers.length) {
                      const ptr = ctx.pointers[i++];
                      ptr.type.encode(stream, ptr.val, ptr.parent);
                    }
                  }
                }
              }
              class $444f112d3cbc7e9f$export$5576c026028d4983 extends (0, $8ea28a08eae2a116$export$c4be6576ca6fe4aa) {
                decode(stream, parent) {
                  const { pos } = stream;
                  const length = $4559ecf940edc78d$export$83b6dc3503c1fda6(this.length, stream, parent);
                  if (this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) parent = {
                    parent,
                    _startOffset: pos,
                    _currentOffset: 0,
                    _length: length
                  };
                  const res = new $444f112d3cbc7e9f$var$LazyArrayValue(this.type, length, stream, parent);
                  stream.pos += length * this.type.size(null, parent);
                  return res;
                }
                size(val, ctx) {
                  if (val instanceof $444f112d3cbc7e9f$var$LazyArrayValue) val = val.toArray();
                  return super.size(val, ctx);
                }
                encode(stream, val, ctx) {
                  if (val instanceof $444f112d3cbc7e9f$var$LazyArrayValue) val = val.toArray();
                  return super.encode(stream, val, ctx);
                }
              }
              class $444f112d3cbc7e9f$var$LazyArrayValue {
                constructor(type, length, stream, ctx) {
                  this.type = type;
                  this.length = length;
                  this.stream = stream;
                  this.ctx = ctx;
                  this.base = this.stream.pos;
                  this.items = [];
                }
                get(index) {
                  if (index < 0 || index >= this.length) return void 0;
                  if (this.items[index] == null) {
                    const { pos } = this.stream;
                    this.stream.pos = this.base + this.type.size(null, this.ctx) * index;
                    this.items[index] = this.type.decode(this.stream, this.ctx);
                    this.stream.pos = pos;
                  }
                  return this.items[index];
                }
                toArray() {
                  const result = [];
                  for (let i = 0, end = this.length; i < end; i++) result.push(this.get(i));
                  return result;
                }
              }
              class $3def237a34a226b5$export$96b43b8a49f688ea extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {
                constructor(type, flags = []) {
                  super();
                  this.type = type;
                  this.flags = flags;
                }
                decode(stream) {
                  const val = this.type.decode(stream);
                  const res = {};
                  for (let i = 0; i < this.flags.length; i++) {
                    const flag = this.flags[i];
                    if (flag != null) res[flag] = !!(val & 1 << i);
                  }
                  return res;
                }
                size() {
                  return this.type.size();
                }
                encode(stream, keys) {
                  let val = 0;
                  for (let i = 0; i < this.flags.length; i++) {
                    const flag = this.flags[i];
                    if (flag != null) {
                      if (keys[flag]) val |= 1 << i;
                    }
                  }
                  return this.type.encode(stream, val);
                }
              }
              class $8415e91bb83faf74$export$ff887cefee4d61ec extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {
                constructor(type) {
                  super();
                  this.type = type;
                }
                decode(stream, parent) {
                  return !!this.type.decode(stream, parent);
                }
                size(val, parent) {
                  return this.type.size(val, parent);
                }
                encode(stream, val, parent) {
                  return this.type.encode(stream, +val, parent);
                }
              }
              class $08d28604119af47e$export$7d22a0eea6656474 extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {
                constructor(length) {
                  super();
                  this.length = length;
                }
                decode(stream, parent) {
                  const length = $4559ecf940edc78d$export$83b6dc3503c1fda6(this.length, stream, parent);
                  return stream.readBuffer(length);
                }
                size(val, parent) {
                  if (!val) return $4559ecf940edc78d$export$83b6dc3503c1fda6(this.length, null, parent);
                  let len = val.length;
                  if (this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) len += this.length.size();
                  return len;
                }
                encode(stream, buf, parent) {
                  if (this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) this.length.encode(stream, buf.length);
                  return stream.writeBuffer(buf);
                }
              }
              class $070ce31ea947467f$export$deb82508dd66d288 extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {
                constructor(type, options = []) {
                  super();
                  this.type = type;
                  this.options = options;
                }
                decode(stream) {
                  const index = this.type.decode(stream);
                  return this.options[index] || index;
                }
                size() {
                  return this.type.size();
                }
                encode(stream, val) {
                  const index = this.options.indexOf(val);
                  if (index === -1) throw new Error(`Unknown option in enum: ${val}`);
                  return this.type.encode(stream, index);
                }
              }
              class $80703542fcfb6ff0$export$7acb7b24c478f9c6 extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {
                constructor(type, condition = true) {
                  super();
                  this.type = type;
                  this.condition = condition;
                }
                decode(stream, parent) {
                  let { condition } = this;
                  if (typeof condition === "function") condition = condition.call(parent, parent);
                  if (condition) return this.type.decode(stream, parent);
                }
                size(val, parent) {
                  let { condition } = this;
                  if (typeof condition === "function") condition = condition.call(parent, parent);
                  if (condition) return this.type.size(val, parent);
                  else return 0;
                }
                encode(stream, val, parent) {
                  let { condition } = this;
                  if (typeof condition === "function") condition = condition.call(parent, parent);
                  if (condition) return this.type.encode(stream, val, parent);
                }
              }
              class $f4fd49878232508a$export$da9b5fe187a9aa1 extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {
                constructor(type, count = 1) {
                  super();
                  this.type = type;
                  this.count = count;
                }
                decode(stream, parent) {
                  stream.pos += this.size(null, parent);
                  return void 0;
                }
                size(data, parent) {
                  const count = $4559ecf940edc78d$export$83b6dc3503c1fda6(this.count, null, parent);
                  return this.type.size() * count;
                }
                encode(stream, val, parent) {
                  return stream.fill(0, this.size(val, parent));
                }
              }
              class $d8705cd4022e7dcf$export$89b8e0fa65f6a914 extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {
                constructor(length, encoding = "ascii") {
                  super();
                  this.length = length;
                  this.encoding = encoding;
                }
                decode(stream, parent) {
                  let length, pos;
                  let { encoding } = this;
                  if (typeof encoding === "function") encoding = encoding.call(parent, parent) || "ascii";
                  let width = $d8705cd4022e7dcf$var$encodingWidth(encoding);
                  if (this.length != null) length = $4559ecf940edc78d$export$83b6dc3503c1fda6(this.length, stream, parent);
                  else {
                    let buffer;
                    ({ buffer, length, pos } = stream);
                    while (pos < length - width + 1 && (buffer[pos] !== 0 || width === 2 && buffer[pos + 1] !== 0)) pos += width;
                    length = pos - stream.pos;
                  }
                  const string = stream.readString(length, encoding);
                  if (this.length == null && stream.pos < stream.length) stream.pos += width;
                  return string;
                }
                size(val, parent) {
                  if (val === void 0 || val === null) return $4559ecf940edc78d$export$83b6dc3503c1fda6(this.length, null, parent);
                  let { encoding } = this;
                  if (typeof encoding === "function") encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
                  if (encoding === "utf16be") encoding = "utf16le";
                  let size = $d8705cd4022e7dcf$var$byteLength(val, encoding);
                  if (this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) size += this.length.size();
                  if (this.length == null) size += $d8705cd4022e7dcf$var$encodingWidth(encoding);
                  return size;
                }
                encode(stream, val, parent) {
                  let { encoding } = this;
                  if (typeof encoding === "function") encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
                  if (this.length instanceof (0, $af65abf7bf65ac42$export$fffa67e515d04022)) this.length.encode(stream, $d8705cd4022e7dcf$var$byteLength(val, encoding));
                  stream.writeString(val, encoding);
                  if (this.length == null) return $d8705cd4022e7dcf$var$encodingWidth(encoding) == 2 ? stream.writeUInt16LE(0) : stream.writeUInt8(0);
                }
              }
              function $d8705cd4022e7dcf$var$encodingWidth(encoding) {
                switch (encoding) {
                  case "ascii":
                  case "utf8":
                    return 1;
                  case "utf16le":
                  case "utf16-le":
                  case "utf-16be":
                  case "utf-16le":
                  case "utf16be":
                  case "utf16-be":
                  case "ucs2":
                    return 2;
                  default:
                    return 1;
                }
              }
              function $d8705cd4022e7dcf$var$byteLength(string, encoding) {
                switch (encoding) {
                  case "ascii":
                    return string.length;
                  case "utf8":
                    let len = 0;
                    for (let i = 0; i < string.length; i++) {
                      let c = string.charCodeAt(i);
                      if (c >= 55296 && c <= 56319 && i < string.length - 1) {
                        let c2 = string.charCodeAt(++i);
                        if ((c2 & 64512) === 56320) c = ((c & 1023) << 10) + (c2 & 1023) + 65536;
                        else
                          i--;
                      }
                      if ((c & 4294967168) === 0) len++;
                      else if ((c & 4294965248) === 0) len += 2;
                      else if ((c & 4294901760) === 0) len += 3;
                      else if ((c & 4292870144) === 0) len += 4;
                    }
                    return len;
                  case "utf16le":
                  case "utf16-le":
                  case "utf16be":
                  case "utf16-be":
                  case "ucs2":
                    return string.length * 2;
                  default:
                    throw new Error("Unknown encoding " + encoding);
                }
              }
              class $aa8b66bae6abe658$export$eabc71f011df675a extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {
                constructor(fields = {}) {
                  super();
                  this.fields = fields;
                }
                decode(stream, parent, length = 0) {
                  const res = this._setup(stream, parent, length);
                  this._parseFields(stream, res, this.fields);
                  if (this.process != null) this.process.call(res, stream);
                  return res;
                }
                _setup(stream, parent, length) {
                  const res = {};
                  Object.defineProperties(res, {
                    parent: {
                      value: parent
                    },
                    _startOffset: {
                      value: stream.pos
                    },
                    _currentOffset: {
                      value: 0,
                      writable: true
                    },
                    _length: {
                      value: length
                    }
                  });
                  return res;
                }
                _parseFields(stream, res, fields) {
                  for (let key in fields) {
                    var val;
                    const type = fields[key];
                    if (typeof type === "function") val = type.call(res, res);
                    else val = type.decode(stream, res);
                    if (val !== void 0) {
                      if (val instanceof $4559ecf940edc78d$export$41705b1d644e0f14) Object.defineProperty(res, key, val);
                      else res[key] = val;
                    }
                    res._currentOffset = stream.pos - res._startOffset;
                  }
                }
                size(val, parent, includePointers = true) {
                  if (val == null) val = {};
                  const ctx = {
                    parent,
                    val,
                    pointerSize: 0
                  };
                  if (this.preEncode != null) this.preEncode.call(val);
                  let size = 0;
                  for (let key in this.fields) {
                    const type = this.fields[key];
                    if (type.size != null) size += type.size(val[key], ctx);
                  }
                  if (includePointers) size += ctx.pointerSize;
                  return size;
                }
                encode(stream, val, parent) {
                  let type;
                  if (this.preEncode != null) this.preEncode.call(val, stream);
                  const ctx = {
                    pointers: [],
                    startOffset: stream.pos,
                    parent,
                    val,
                    pointerSize: 0
                  };
                  ctx.pointerOffset = stream.pos + this.size(val, ctx, false);
                  for (let key in this.fields) {
                    type = this.fields[key];
                    if (type.encode != null) type.encode(stream, val[key], ctx);
                  }
                  let i = 0;
                  while (i < ctx.pointers.length) {
                    const ptr = ctx.pointers[i++];
                    ptr.type.encode(stream, ptr.val, ptr.parent);
                  }
                }
              }
              const $fcb208a95f6d048b$var$getPath = (object, pathArray) => {
                return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);
              };
              class $fcb208a95f6d048b$export$95a8b60f4da7dec8 extends (0, $aa8b66bae6abe658$export$eabc71f011df675a) {
                constructor(type, versions = {}) {
                  super();
                  this.type = type;
                  this.versions = versions;
                  if (typeof type === "string") this.versionPath = type.split(".");
                }
                decode(stream, parent, length = 0) {
                  const res = this._setup(stream, parent, length);
                  if (typeof this.type === "string") res.version = $fcb208a95f6d048b$var$getPath(parent, this.versionPath);
                  else res.version = this.type.decode(stream);
                  if (this.versions.header) this._parseFields(stream, res, this.versions.header);
                  const fields = this.versions[res.version];
                  if (fields == null) throw new Error(`Unknown version ${res.version}`);
                  if (fields instanceof $fcb208a95f6d048b$export$95a8b60f4da7dec8) return fields.decode(stream, parent);
                  this._parseFields(stream, res, fields);
                  if (this.process != null) this.process.call(res, stream);
                  return res;
                }
                size(val, parent, includePointers = true) {
                  let key, type;
                  if (!val) throw new Error("Not a fixed size");
                  if (this.preEncode != null) this.preEncode.call(val);
                  const ctx = {
                    parent,
                    val,
                    pointerSize: 0
                  };
                  let size = 0;
                  if (typeof this.type !== "string") size += this.type.size(val.version, ctx);
                  if (this.versions.header) for (key in this.versions.header) {
                    type = this.versions.header[key];
                    if (type.size != null) size += type.size(val[key], ctx);
                  }
                  const fields = this.versions[val.version];
                  if (fields == null) throw new Error(`Unknown version ${val.version}`);
                  for (key in fields) {
                    type = fields[key];
                    if (type.size != null) size += type.size(val[key], ctx);
                  }
                  if (includePointers) size += ctx.pointerSize;
                  return size;
                }
                encode(stream, val, parent) {
                  let key, type;
                  if (this.preEncode != null) this.preEncode.call(val, stream);
                  const ctx = {
                    pointers: [],
                    startOffset: stream.pos,
                    parent,
                    val,
                    pointerSize: 0
                  };
                  ctx.pointerOffset = stream.pos + this.size(val, ctx, false);
                  if (typeof this.type !== "string") this.type.encode(stream, val.version);
                  if (this.versions.header) for (key in this.versions.header) {
                    type = this.versions.header[key];
                    if (type.encode != null) type.encode(stream, val[key], ctx);
                  }
                  const fields = this.versions[val.version];
                  for (key in fields) {
                    type = fields[key];
                    if (type.encode != null) type.encode(stream, val[key], ctx);
                  }
                  let i = 0;
                  while (i < ctx.pointers.length) {
                    const ptr = ctx.pointers[i++];
                    ptr.type.encode(stream, ptr.val, ptr.parent);
                  }
                }
              }
              var $92184962f8f0d5e2$exports = {};
              $parcel$export($92184962f8f0d5e2$exports, "Pointer", () => $92184962f8f0d5e2$export$b56007f12edf0c17);
              $parcel$export($92184962f8f0d5e2$exports, "VoidPointer", () => $92184962f8f0d5e2$export$df5cb1f3d04f5a0f);
              class $92184962f8f0d5e2$export$b56007f12edf0c17 extends (0, $8d21f7fa58802901$export$ef88aa0d34c34520) {
                constructor(offsetType, type, options = {}) {
                  super();
                  this.offsetType = offsetType;
                  this.type = type;
                  this.options = options;
                  if (this.type === "void") this.type = null;
                  if (this.options.type == null) this.options.type = "local";
                  if (this.options.allowNull == null) this.options.allowNull = true;
                  if (this.options.nullValue == null) this.options.nullValue = 0;
                  if (this.options.lazy == null) this.options.lazy = false;
                  if (this.options.relativeTo) {
                    if (typeof this.options.relativeTo !== "function") throw new Error("relativeTo option must be a function");
                    this.relativeToGetter = options.relativeTo;
                  }
                }
                decode(stream, ctx) {
                  const offset = this.offsetType.decode(stream, ctx);
                  if (offset === this.options.nullValue && this.options.allowNull) return null;
                  let relative;
                  switch (this.options.type) {
                    case "local":
                      relative = ctx._startOffset;
                      break;
                    case "immediate":
                      relative = stream.pos - this.offsetType.size();
                      break;
                    case "parent":
                      relative = ctx.parent._startOffset;
                      break;
                    default:
                      var c = ctx;
                      while (c.parent) c = c.parent;
                      relative = c._startOffset || 0;
                  }
                  if (this.options.relativeTo) relative += this.relativeToGetter(ctx);
                  const ptr = offset + relative;
                  if (this.type != null) {
                    let val = null;
                    const decodeValue = () => {
                      if (val != null) return val;
                      const { pos } = stream;
                      stream.pos = ptr;
                      val = this.type.decode(stream, ctx);
                      stream.pos = pos;
                      return val;
                    };
                    if (this.options.lazy) return new $4559ecf940edc78d$export$41705b1d644e0f14({
                      get: decodeValue
                    });
                    return decodeValue();
                  } else return ptr;
                }
                size(val, ctx) {
                  const parent = ctx;
                  switch (this.options.type) {
                    case "local":
                    case "immediate":
                      break;
                    case "parent":
                      ctx = ctx.parent;
                      break;
                    default:
                      while (ctx.parent) ctx = ctx.parent;
                  }
                  let { type } = this;
                  if (type == null) {
                    if (!(val instanceof $92184962f8f0d5e2$export$df5cb1f3d04f5a0f)) throw new Error("Must be a VoidPointer");
                    ({ type } = val);
                    val = val.value;
                  }
                  if (val && ctx) {
                    let size = type.size(val, parent);
                    ctx.pointerSize += size;
                  }
                  return this.offsetType.size();
                }
                encode(stream, val, ctx) {
                  let relative;
                  const parent = ctx;
                  if (val == null) {
                    this.offsetType.encode(stream, this.options.nullValue);
                    return;
                  }
                  switch (this.options.type) {
                    case "local":
                      relative = ctx.startOffset;
                      break;
                    case "immediate":
                      relative = stream.pos + this.offsetType.size(val, parent);
                      break;
                    case "parent":
                      ctx = ctx.parent;
                      relative = ctx.startOffset;
                      break;
                    default:
                      relative = 0;
                      while (ctx.parent) ctx = ctx.parent;
                  }
                  if (this.options.relativeTo) relative += this.relativeToGetter(parent.val);
                  this.offsetType.encode(stream, ctx.pointerOffset - relative);
                  let { type } = this;
                  if (type == null) {
                    if (!(val instanceof $92184962f8f0d5e2$export$df5cb1f3d04f5a0f)) throw new Error("Must be a VoidPointer");
                    ({ type } = val);
                    val = val.value;
                  }
                  ctx.pointers.push({
                    type,
                    val,
                    parent
                  });
                  return ctx.pointerOffset += type.size(val, parent);
                }
              }
              class $92184962f8f0d5e2$export$df5cb1f3d04f5a0f {
                constructor(type, value) {
                  this.type = type;
                  this.value = value;
                }
              }
              $parcel$exportWildcard(module2.exports, $4559ecf940edc78d$exports);
              $parcel$exportWildcard(module2.exports, $af65abf7bf65ac42$exports);
              $parcel$exportWildcard(module2.exports, $92184962f8f0d5e2$exports);
            },
            /***/
            5293(module2) {
              "use strict";
              module2.exports = Error;
            },
            /***/
            5336(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var classofRaw = __webpack_require__2(8420);
              var uncurryThis = __webpack_require__2(1212);
              module2.exports = function(fn) {
                if (classofRaw(fn) === "Function") return uncurryThis(fn);
              };
            },
            /***/
            5337(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var userAgent = __webpack_require__2(8115);
              var firefox = userAgent.match(/firefox\/(\d+)/i);
              module2.exports = !!firefox && +firefox[1];
            },
            /***/
            5348(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(3144), __webpack_require__2(9064), __webpack_require__2(1199), __webpack_require__2(4866), __webpack_require__2(7493), __webpack_require__2(3532), __webpack_require__2(9663), __webpack_require__2(321), __webpack_require__2(3620), __webpack_require__2(8692), __webpack_require__2(517), __webpack_require__2(6174), __webpack_require__2(3752), __webpack_require__2(8865), __webpack_require__2(7331), __webpack_require__2(6818), __webpack_require__2(2858), __webpack_require__2(2073), __webpack_require__2(6843), __webpack_require__2(1220), __webpack_require__2(3701), __webpack_require__2(8358), __webpack_require__2(4873), __webpack_require__2(7705), __webpack_require__2(3282), __webpack_require__2(4779), __webpack_require__2(4540), __webpack_require__2(4137), __webpack_require__2(9851), __webpack_require__2(3324), __webpack_require__2(6089), __webpack_require__2(3610), __webpack_require__2(5464), __webpack_require__2(3032));
                } else {
                }
              })(void 0, function(CryptoJS) {
                return CryptoJS;
              });
            },
            /***/
            5403(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              function _typeof(o) {
                "@babel/helpers - typeof";
                return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
                  return typeof o2;
                } : function(o2) {
                  return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
                }, _typeof(o);
              }
              function _defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                }
              }
              function _createClass(Constructor, protoProps, staticProps) {
                if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                if (staticProps) _defineProperties(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              function _toPropertyKey(arg) {
                var key = _toPrimitive(arg, "string");
                return _typeof(key) === "symbol" ? key : String(key);
              }
              function _toPrimitive(input, hint) {
                if (_typeof(input) !== "object" || input === null) return input;
                var prim = input[Symbol.toPrimitive];
                if (prim !== void 0) {
                  var res = prim.call(input, hint || "default");
                  if (_typeof(res) !== "object") return res;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return (hint === "string" ? String : Number)(input);
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function");
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                Object.defineProperty(subClass, "prototype", { writable: false });
                if (superClass) _setPrototypeOf(subClass, superClass);
              }
              function _setPrototypeOf(o, p) {
                _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                  o2.__proto__ = p2;
                  return o2;
                };
                return _setPrototypeOf(o, p);
              }
              function _createSuper(Derived) {
                var hasNativeReflectConstruct = _isNativeReflectConstruct();
                return function _createSuperInternal() {
                  var Super = _getPrototypeOf(Derived), result;
                  if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget);
                  } else {
                    result = Super.apply(this, arguments);
                  }
                  return _possibleConstructorReturn(this, result);
                };
              }
              function _possibleConstructorReturn(self2, call) {
                if (call && (_typeof(call) === "object" || typeof call === "function")) {
                  return call;
                } else if (call !== void 0) {
                  throw new TypeError("Derived constructors may only return object or undefined");
                }
                return _assertThisInitialized(self2);
              }
              function _assertThisInitialized(self2) {
                if (self2 === void 0) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self2;
              }
              function _isNativeReflectConstruct() {
                if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                if (Reflect.construct.sham) return false;
                if (typeof Proxy === "function") return true;
                try {
                  Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                  }));
                  return true;
                } catch (e) {
                  return false;
                }
              }
              function _getPrototypeOf(o) {
                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
                  return o2.__proto__ || Object.getPrototypeOf(o2);
                };
                return _getPrototypeOf(o);
              }
              var codes = {};
              var assert;
              var util;
              function createErrorType(code, message, Base) {
                if (!Base) {
                  Base = Error;
                }
                function getMessage(arg1, arg2, arg3) {
                  if (typeof message === "string") {
                    return message;
                  } else {
                    return message(arg1, arg2, arg3);
                  }
                }
                var NodeError = function(_Base) {
                  _inherits(NodeError2, _Base);
                  var _super = _createSuper(NodeError2);
                  function NodeError2(arg1, arg2, arg3) {
                    var _this;
                    _classCallCheck(this, NodeError2);
                    _this = _super.call(this, getMessage(arg1, arg2, arg3));
                    _this.code = code;
                    return _this;
                  }
                  return _createClass(NodeError2);
                }(Base);
                codes[code] = NodeError;
              }
              function oneOf(expected, thing) {
                if (Array.isArray(expected)) {
                  var len = expected.length;
                  expected = expected.map(function(i) {
                    return String(i);
                  });
                  if (len > 2) {
                    return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
                  } else if (len === 2) {
                    return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
                  } else {
                    return "of ".concat(thing, " ").concat(expected[0]);
                  }
                } else {
                  return "of ".concat(thing, " ").concat(String(expected));
                }
              }
              function startsWith(str, search, pos) {
                return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
              }
              function endsWith(str, search, this_len) {
                if (this_len === void 0 || this_len > str.length) {
                  this_len = str.length;
                }
                return str.substring(this_len - search.length, this_len) === search;
              }
              function includes(str, search, start) {
                if (typeof start !== "number") {
                  start = 0;
                }
                if (start + search.length > str.length) {
                  return false;
                } else {
                  return str.indexOf(search, start) !== -1;
                }
              }
              createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
              createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
                if (assert === void 0) assert = __webpack_require__2(7801);
                assert(typeof name === "string", "'name' must be a string");
                var determiner;
                if (typeof expected === "string" && startsWith(expected, "not ")) {
                  determiner = "must not be";
                  expected = expected.replace(/^not /, "");
                } else {
                  determiner = "must be";
                }
                var msg;
                if (endsWith(name, " argument")) {
                  msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
                } else {
                  var type = includes(name, ".") ? "property" : "argument";
                  msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
                }
                msg += ". Received type ".concat(_typeof(actual));
                return msg;
              }, TypeError);
              createErrorType("ERR_INVALID_ARG_VALUE", function(name, value) {
                var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
                if (util === void 0) util = __webpack_require__2(7187);
                var inspected = util.inspect(value);
                if (inspected.length > 128) {
                  inspected = "".concat(inspected.slice(0, 128), "...");
                }
                return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
              }, TypeError, RangeError);
              createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name, value) {
                var type;
                if (value && value.constructor && value.constructor.name) {
                  type = "instance of ".concat(value.constructor.name);
                } else {
                  type = "type ".concat(_typeof(value));
                }
                return "Expected ".concat(input, ' to be returned from the "').concat(name, '"') + " function but got ".concat(type, ".");
              }, TypeError);
              createErrorType("ERR_MISSING_ARGS", function() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                if (assert === void 0) assert = __webpack_require__2(7801);
                assert(args.length > 0, "At least one arg needs to be specified");
                var msg = "The ";
                var len = args.length;
                args = args.map(function(a) {
                  return '"'.concat(a, '"');
                });
                switch (len) {
                  case 1:
                    msg += "".concat(args[0], " argument");
                    break;
                  case 2:
                    msg += "".concat(args[0], " and ").concat(args[1], " arguments");
                    break;
                  default:
                    msg += args.slice(0, len - 1).join(", ");
                    msg += ", and ".concat(args[len - 1], " arguments");
                    break;
                }
                return "".concat(msg, " must be specified");
              }, TypeError);
              module2.exports.codes = codes;
            },
            /***/
            5416(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var process = __webpack_require__2(9964);
              function ownKeys(e, r) {
                var t = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                  var o = Object.getOwnPropertySymbols(e);
                  r && (o = o.filter(function(r2) {
                    return Object.getOwnPropertyDescriptor(e, r2).enumerable;
                  })), t.push.apply(t, o);
                }
                return t;
              }
              function _objectSpread(e) {
                for (var r = 1; r < arguments.length; r++) {
                  var t = null != arguments[r] ? arguments[r] : {};
                  r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
                    _defineProperty(e, r2, t[r2]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
                    Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
                  });
                }
                return e;
              }
              function _defineProperty(obj, key, value) {
                key = _toPropertyKey(key);
                if (key in obj) {
                  Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                }
              }
              function _createClass(Constructor, protoProps, staticProps) {
                if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                if (staticProps) _defineProperties(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              function _toPropertyKey(arg) {
                var key = _toPrimitive(arg, "string");
                return _typeof(key) === "symbol" ? key : String(key);
              }
              function _toPrimitive(input, hint) {
                if (_typeof(input) !== "object" || input === null) return input;
                var prim = input[Symbol.toPrimitive];
                if (prim !== void 0) {
                  var res = prim.call(input, hint || "default");
                  if (_typeof(res) !== "object") return res;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return (hint === "string" ? String : Number)(input);
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function");
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                Object.defineProperty(subClass, "prototype", { writable: false });
                if (superClass) _setPrototypeOf(subClass, superClass);
              }
              function _createSuper(Derived) {
                var hasNativeReflectConstruct = _isNativeReflectConstruct();
                return function _createSuperInternal() {
                  var Super = _getPrototypeOf(Derived), result;
                  if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget);
                  } else {
                    result = Super.apply(this, arguments);
                  }
                  return _possibleConstructorReturn(this, result);
                };
              }
              function _possibleConstructorReturn(self2, call) {
                if (call && (_typeof(call) === "object" || typeof call === "function")) {
                  return call;
                } else if (call !== void 0) {
                  throw new TypeError("Derived constructors may only return object or undefined");
                }
                return _assertThisInitialized(self2);
              }
              function _assertThisInitialized(self2) {
                if (self2 === void 0) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self2;
              }
              function _wrapNativeSuper(Class) {
                var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
                _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
                  if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
                  if (typeof Class2 !== "function") {
                    throw new TypeError("Super expression must either be null or a function");
                  }
                  if (typeof _cache !== "undefined") {
                    if (_cache.has(Class2)) return _cache.get(Class2);
                    _cache.set(Class2, Wrapper);
                  }
                  function Wrapper() {
                    return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
                  }
                  Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
                  return _setPrototypeOf(Wrapper, Class2);
                };
                return _wrapNativeSuper(Class);
              }
              function _construct(Parent, args, Class) {
                if (_isNativeReflectConstruct()) {
                  _construct = Reflect.construct.bind();
                } else {
                  _construct = function _construct2(Parent2, args2, Class2) {
                    var a = [null];
                    a.push.apply(a, args2);
                    var Constructor = Function.bind.apply(Parent2, a);
                    var instance = new Constructor();
                    if (Class2) _setPrototypeOf(instance, Class2.prototype);
                    return instance;
                  };
                }
                return _construct.apply(null, arguments);
              }
              function _isNativeReflectConstruct() {
                if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                if (Reflect.construct.sham) return false;
                if (typeof Proxy === "function") return true;
                try {
                  Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                  }));
                  return true;
                } catch (e) {
                  return false;
                }
              }
              function _isNativeFunction(fn) {
                return Function.toString.call(fn).indexOf("[native code]") !== -1;
              }
              function _setPrototypeOf(o, p) {
                _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                  o2.__proto__ = p2;
                  return o2;
                };
                return _setPrototypeOf(o, p);
              }
              function _getPrototypeOf(o) {
                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
                  return o2.__proto__ || Object.getPrototypeOf(o2);
                };
                return _getPrototypeOf(o);
              }
              function _typeof(o) {
                "@babel/helpers - typeof";
                return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
                  return typeof o2;
                } : function(o2) {
                  return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
                }, _typeof(o);
              }
              var _require = __webpack_require__2(7187), inspect = _require.inspect;
              var _require2 = __webpack_require__2(5403), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
              function endsWith(str, search, this_len) {
                if (this_len === void 0 || this_len > str.length) {
                  this_len = str.length;
                }
                return str.substring(this_len - search.length, this_len) === search;
              }
              function repeat(str, count) {
                count = Math.floor(count);
                if (str.length == 0 || count == 0) return "";
                var maxCount = str.length * count;
                count = Math.floor(Math.log(count) / Math.log(2));
                while (count) {
                  str += str;
                  count--;
                }
                str += str.substring(0, maxCount - str.length);
                return str;
              }
              var blue = "";
              var green = "";
              var red = "";
              var white = "";
              var kReadableOperator = {
                deepStrictEqual: "Expected values to be strictly deep-equal:",
                strictEqual: "Expected values to be strictly equal:",
                strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
                deepEqual: "Expected values to be loosely deep-equal:",
                equal: "Expected values to be loosely equal:",
                notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
                notStrictEqual: 'Expected "actual" to be strictly unequal to:',
                notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
                notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
                notEqual: 'Expected "actual" to be loosely unequal to:',
                notIdentical: "Values identical but not reference-equal:"
              };
              var kMaxShortLength = 10;
              function copyError(source) {
                var keys = Object.keys(source);
                var target = Object.create(Object.getPrototypeOf(source));
                keys.forEach(function(key) {
                  target[key] = source[key];
                });
                Object.defineProperty(target, "message", {
                  value: source.message
                });
                return target;
              }
              function inspectValue(val) {
                return inspect(val, {
                  compact: false,
                  customInspect: false,
                  depth: 1e3,
                  maxArrayLength: Infinity,
                  // Assert compares only enumerable properties (with a few exceptions).
                  showHidden: false,
                  // Having a long line as error is better than wrapping the line for
                  // comparison for now.
                  // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
                  // have meta information about the inspected properties (i.e., know where
                  // in what line the property starts and ends).
                  breakLength: Infinity,
                  // Assert does not detect proxies currently.
                  showProxy: false,
                  sorted: true,
                  // Inspect getters as we also check them when comparing entries.
                  getters: true
                });
              }
              function createErrDiff(actual, expected, operator) {
                var other = "";
                var res = "";
                var lastPos = 0;
                var end = "";
                var skipped = false;
                var actualInspected = inspectValue(actual);
                var actualLines = actualInspected.split("\n");
                var expectedLines = inspectValue(expected).split("\n");
                var i = 0;
                var indicator = "";
                if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null) {
                  operator = "strictEqualObject";
                }
                if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
                  var inputLength = actualLines[0].length + expectedLines[0].length;
                  if (inputLength <= kMaxShortLength) {
                    if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
                      return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
                    }
                  } else if (operator !== "strictEqualObject") {
                    var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
                    if (inputLength < maxLength) {
                      while (actualLines[0][i] === expectedLines[0][i]) {
                        i++;
                      }
                      if (i > 2) {
                        indicator = "\n  ".concat(repeat(" ", i), "^");
                        i = 0;
                      }
                    }
                  }
                }
                var a = actualLines[actualLines.length - 1];
                var b = expectedLines[expectedLines.length - 1];
                while (a === b) {
                  if (i++ < 2) {
                    end = "\n  ".concat(a).concat(end);
                  } else {
                    other = a;
                  }
                  actualLines.pop();
                  expectedLines.pop();
                  if (actualLines.length === 0 || expectedLines.length === 0) break;
                  a = actualLines[actualLines.length - 1];
                  b = expectedLines[expectedLines.length - 1];
                }
                var maxLines = Math.max(actualLines.length, expectedLines.length);
                if (maxLines === 0) {
                  var _actualLines = actualInspected.split("\n");
                  if (_actualLines.length > 30) {
                    _actualLines[26] = "".concat(blue, "...").concat(white);
                    while (_actualLines.length > 27) {
                      _actualLines.pop();
                    }
                  }
                  return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
                }
                if (i > 3) {
                  end = "\n".concat(blue, "...").concat(white).concat(end);
                  skipped = true;
                }
                if (other !== "") {
                  end = "\n  ".concat(other).concat(end);
                  other = "";
                }
                var printedLines = 0;
                var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
                var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
                for (i = 0; i < maxLines; i++) {
                  var cur = i - lastPos;
                  if (actualLines.length < i + 1) {
                    if (cur > 1 && i > 2) {
                      if (cur > 4) {
                        res += "\n".concat(blue, "...").concat(white);
                        skipped = true;
                      } else if (cur > 3) {
                        res += "\n  ".concat(expectedLines[i - 2]);
                        printedLines++;
                      }
                      res += "\n  ".concat(expectedLines[i - 1]);
                      printedLines++;
                    }
                    lastPos = i;
                    other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
                    printedLines++;
                  } else if (expectedLines.length < i + 1) {
                    if (cur > 1 && i > 2) {
                      if (cur > 4) {
                        res += "\n".concat(blue, "...").concat(white);
                        skipped = true;
                      } else if (cur > 3) {
                        res += "\n  ".concat(actualLines[i - 2]);
                        printedLines++;
                      }
                      res += "\n  ".concat(actualLines[i - 1]);
                      printedLines++;
                    }
                    lastPos = i;
                    res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
                    printedLines++;
                  } else {
                    var expectedLine = expectedLines[i];
                    var actualLine = actualLines[i];
                    var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
                    if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
                      divergingLines = false;
                      actualLine += ",";
                    }
                    if (divergingLines) {
                      if (cur > 1 && i > 2) {
                        if (cur > 4) {
                          res += "\n".concat(blue, "...").concat(white);
                          skipped = true;
                        } else if (cur > 3) {
                          res += "\n  ".concat(actualLines[i - 2]);
                          printedLines++;
                        }
                        res += "\n  ".concat(actualLines[i - 1]);
                        printedLines++;
                      }
                      lastPos = i;
                      res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
                      other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
                      printedLines += 2;
                    } else {
                      res += other;
                      other = "";
                      if (cur === 1 || i === 0) {
                        res += "\n  ".concat(actualLine);
                        printedLines++;
                      }
                    }
                  }
                  if (printedLines > 20 && i < maxLines - 2) {
                    return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
                  }
                }
                return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
              }
              var AssertionError = function(_Error, _inspect$custom) {
                _inherits(AssertionError2, _Error);
                var _super = _createSuper(AssertionError2);
                function AssertionError2(options) {
                  var _this;
                  _classCallCheck(this, AssertionError2);
                  if (_typeof(options) !== "object" || options === null) {
                    throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
                  }
                  var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
                  var actual = options.actual, expected = options.expected;
                  var limit = Error.stackTraceLimit;
                  Error.stackTraceLimit = 0;
                  if (message != null) {
                    _this = _super.call(this, String(message));
                  } else {
                    if (process.stderr && process.stderr.isTTY) {
                      if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                        blue = "\x1B[34m";
                        green = "\x1B[32m";
                        white = "\x1B[39m";
                        red = "\x1B[31m";
                      } else {
                        blue = "";
                        green = "";
                        white = "";
                        red = "";
                      }
                    }
                    if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
                      actual = copyError(actual);
                      expected = copyError(expected);
                    }
                    if (operator === "deepStrictEqual" || operator === "strictEqual") {
                      _this = _super.call(this, createErrDiff(actual, expected, operator));
                    } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
                      var base = kReadableOperator[operator];
                      var res = inspectValue(actual).split("\n");
                      if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null) {
                        base = kReadableOperator.notStrictEqualObject;
                      }
                      if (res.length > 30) {
                        res[26] = "".concat(blue, "...").concat(white);
                        while (res.length > 27) {
                          res.pop();
                        }
                      }
                      if (res.length === 1) {
                        _this = _super.call(this, "".concat(base, " ").concat(res[0]));
                      } else {
                        _this = _super.call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n"));
                      }
                    } else {
                      var _res = inspectValue(actual);
                      var other = "";
                      var knownOperators = kReadableOperator[operator];
                      if (operator === "notDeepEqual" || operator === "notEqual") {
                        _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                        if (_res.length > 1024) {
                          _res = "".concat(_res.slice(0, 1021), "...");
                        }
                      } else {
                        other = "".concat(inspectValue(expected));
                        if (_res.length > 512) {
                          _res = "".concat(_res.slice(0, 509), "...");
                        }
                        if (other.length > 512) {
                          other = "".concat(other.slice(0, 509), "...");
                        }
                        if (operator === "deepEqual" || operator === "equal") {
                          _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                        } else {
                          other = " ".concat(operator, " ").concat(other);
                        }
                      }
                      _this = _super.call(this, "".concat(_res).concat(other));
                    }
                  }
                  Error.stackTraceLimit = limit;
                  _this.generatedMessage = !message;
                  Object.defineProperty(_assertThisInitialized(_this), "name", {
                    value: "AssertionError [ERR_ASSERTION]",
                    enumerable: false,
                    writable: true,
                    configurable: true
                  });
                  _this.code = "ERR_ASSERTION";
                  _this.actual = actual;
                  _this.expected = expected;
                  _this.operator = operator;
                  if (Error.captureStackTrace) {
                    Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
                  }
                  _this.stack;
                  _this.name = "AssertionError";
                  return _possibleConstructorReturn(_this);
                }
                _createClass(AssertionError2, [{
                  key: "toString",
                  value: function toString() {
                    return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
                  }
                }, {
                  key: _inspect$custom,
                  value: function value(recurseTimes, ctx) {
                    return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {
                      customInspect: false,
                      depth: 0
                    }));
                  }
                }]);
                return AssertionError2;
              }(_wrapNativeSuper(Error), inspect.custom);
              module2.exports = AssertionError;
            },
            /***/
            5421(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var keys = __webpack_require__2(5643);
              var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
              var toStr = Object.prototype.toString;
              var concat = Array.prototype.concat;
              var defineDataProperty = __webpack_require__2(9295);
              var isFunction = function(fn) {
                return typeof fn === "function" && toStr.call(fn) === "[object Function]";
              };
              var supportsDescriptors = __webpack_require__2(8890)();
              var defineProperty = function(object, name, value, predicate) {
                if (name in object) {
                  if (predicate === true) {
                    if (object[name] === value) {
                      return;
                    }
                  } else if (!isFunction(predicate) || !predicate()) {
                    return;
                  }
                }
                if (supportsDescriptors) {
                  defineDataProperty(object, name, value, true);
                } else {
                  defineDataProperty(object, name, value);
                }
              };
              var defineProperties = function(object, map) {
                var predicates = arguments.length > 2 ? arguments[2] : {};
                var props = keys(map);
                if (hasSymbols) {
                  props = concat.call(props, Object.getOwnPropertySymbols(map));
                }
                for (var i = 0; i < props.length; i += 1) {
                  defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
                }
              };
              defineProperties.supportsDescriptors = !!supportsDescriptors;
              module2.exports = defineProperties;
            },
            /***/
            5464(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(4866), __webpack_require__2(3532), __webpack_require__2(6818), __webpack_require__2(2858));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function() {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var StreamCipher = C_lib.StreamCipher;
                  var C_algo = C.algo;
                  var S = [];
                  var C_ = [];
                  var G = [];
                  var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
                    _doReset: function() {
                      var K = this._key.words;
                      var iv = this.cfg.iv;
                      var X = this._X = [K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16];
                      var C2 = this._C = [K[2] << 16 | K[2] >>> 16, K[0] & 4294901760 | K[1] & 65535, K[3] << 16 | K[3] >>> 16, K[1] & 4294901760 | K[2] & 65535, K[0] << 16 | K[0] >>> 16, K[2] & 4294901760 | K[3] & 65535, K[1] << 16 | K[1] >>> 16, K[3] & 4294901760 | K[0] & 65535];
                      this._b = 0;
                      for (var i = 0; i < 4; i++) {
                        nextState.call(this);
                      }
                      for (var i = 0; i < 8; i++) {
                        C2[i] ^= X[i + 4 & 7];
                      }
                      if (iv) {
                        var IV = iv.words;
                        var IV_0 = IV[0];
                        var IV_1 = IV[1];
                        var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                        var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                        var i1 = i0 >>> 16 | i2 & 4294901760;
                        var i3 = i2 << 16 | i0 & 65535;
                        C2[0] ^= i0;
                        C2[1] ^= i1;
                        C2[2] ^= i2;
                        C2[3] ^= i3;
                        C2[4] ^= i0;
                        C2[5] ^= i1;
                        C2[6] ^= i2;
                        C2[7] ^= i3;
                        for (var i = 0; i < 4; i++) {
                          nextState.call(this);
                        }
                      }
                    },
                    _doProcessBlock: function(M, offset) {
                      var X = this._X;
                      nextState.call(this);
                      S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
                      S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
                      S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
                      S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
                      for (var i = 0; i < 4; i++) {
                        S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
                        M[offset + i] ^= S[i];
                      }
                    },
                    blockSize: 128 / 32,
                    ivSize: 64 / 32
                  });
                  function nextState() {
                    var X = this._X;
                    var C2 = this._C;
                    for (var i = 0; i < 8; i++) {
                      C_[i] = C2[i];
                    }
                    C2[0] = C2[0] + 1295307597 + this._b | 0;
                    C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
                    C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
                    C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
                    C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
                    C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
                    C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
                    C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
                    this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
                    for (var i = 0; i < 8; i++) {
                      var gx = X[i] + C2[i];
                      var ga = gx & 65535;
                      var gb = gx >>> 16;
                      var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
                      var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
                      G[i] = gh ^ gl;
                    }
                    X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
                    X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
                    X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
                    X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
                    X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
                    X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
                    X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
                    X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
                  }
                  C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
                })();
                return CryptoJS.RabbitLegacy;
              });
            },
            /***/
            5567(module2) {
              "use strict";
              module2.exports = Object.getOwnPropertyDescriptor;
            },
            /***/
            5643(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var slice = Array.prototype.slice;
              var isArgs = __webpack_require__2(6515);
              var origKeys = Object.keys;
              var keysShim = origKeys ? function keys(o) {
                return origKeys(o);
              } : __webpack_require__2(8461);
              var originalKeys = Object.keys;
              keysShim.shim = function shimObjectKeys() {
                if (Object.keys) {
                  var keysWorksWithArguments = function() {
                    var args = Object.keys(arguments);
                    return args && args.length === arguments.length;
                  }(1, 2);
                  if (!keysWorksWithArguments) {
                    Object.keys = function keys(object) {
                      if (isArgs(object)) {
                        return originalKeys(slice.call(object));
                      }
                      return originalKeys(object);
                    };
                  }
                } else {
                  Object.keys = keysShim;
                }
                return Object.keys || keysShim;
              };
              module2.exports = keysShim;
            },
            /***/
            5691(module2, exports2, __webpack_require__2) {
              "use strict";
              var buffer = __webpack_require__2(783);
              var Buffer = buffer.Buffer;
              function copyProps(src, dst) {
                for (var key in src) {
                  dst[key] = src[key];
                }
              }
              if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
                module2.exports = buffer;
              } else {
                copyProps(buffer, exports2);
                exports2.Buffer = SafeBuffer;
              }
              function SafeBuffer(arg, encodingOrOffset, length) {
                return Buffer(arg, encodingOrOffset, length);
              }
              copyProps(Buffer, SafeBuffer);
              SafeBuffer.from = function(arg, encodingOrOffset, length) {
                if (typeof arg === "number") {
                  throw new TypeError("Argument must not be a number");
                }
                return Buffer(arg, encodingOrOffset, length);
              };
              SafeBuffer.alloc = function(size, fill, encoding) {
                if (typeof size !== "number") {
                  throw new TypeError("Argument must be a number");
                }
                var buf = Buffer(size);
                if (fill !== void 0) {
                  if (typeof encoding === "string") {
                    buf.fill(fill, encoding);
                  } else {
                    buf.fill(fill);
                  }
                } else {
                  buf.fill(0);
                }
                return buf;
              };
              SafeBuffer.allocUnsafe = function(size) {
                if (typeof size !== "number") {
                  throw new TypeError("Argument must be a number");
                }
                return Buffer(size);
              };
              SafeBuffer.allocUnsafeSlow = function(size) {
                if (typeof size !== "number") {
                  throw new TypeError("Argument must be a number");
                }
                return buffer.SlowBuffer(size);
              };
            },
            /***/
            5719(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var DESCRIPTORS = __webpack_require__2(5144);
              var definePropertyModule = __webpack_require__2(2333);
              var createPropertyDescriptor = __webpack_require__2(8264);
              module2.exports = DESCRIPTORS ? function(object, key, value) {
                return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
              } : function(object, key, value) {
                object[key] = value;
                return object;
              };
            },
            /***/
            5846(module2) {
              "use strict";
              module2.exports = Object;
            },
            /***/
            5874(module2) {
              "use strict";
              module2.exports = Math.pow;
            },
            /***/
            5888(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var fails = __webpack_require__2(299);
              var isCallable = __webpack_require__2(8681);
              var replacement = /#|\.prototype\./;
              var isForced = function(feature, detection) {
                var value = data[normalize(feature)];
                return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
              };
              var normalize = isForced.normalize = function(string) {
                return String(string).replace(replacement, ".").toLowerCase();
              };
              var data = isForced.data = {};
              var NATIVE = isForced.NATIVE = "N";
              var POLYFILL = isForced.POLYFILL = "P";
              module2.exports = isForced;
            },
            /***/
            5985(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var getBuiltIn = __webpack_require__2(7139);
              var isCallable = __webpack_require__2(8681);
              var isPrototypeOf = __webpack_require__2(9877);
              var USE_SYMBOL_AS_UID = __webpack_require__2(8300);
              var $Object = Object;
              module2.exports = USE_SYMBOL_AS_UID ? function(it) {
                return typeof it == "symbol";
              } : function(it) {
                var $Symbol = getBuiltIn("Symbol");
                return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
              };
            },
            /***/
            6016(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              __webpack_require__2(8376);
              __webpack_require__2(6401);
              __webpack_require__2(2017);
              const isBigEndian = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 18;
              const swap = (b, n, m) => {
                let i = b[n];
                b[n] = b[m];
                b[m] = i;
              };
              const swap32 = (array) => {
                const len = array.length;
                for (let i = 0; i < len; i += 4) {
                  swap(array, i, i + 3);
                  swap(array, i + 1, i + 2);
                }
              };
              const swap32LE = (array) => {
                if (isBigEndian) {
                  swap32(array);
                }
              };
              module2.exports = {
                swap32LE
              };
            },
            /***/
            6044(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var uncurryThis = __webpack_require__2(1212);
              var id = 0;
              var postfix = Math.random();
              var toString = uncurryThis(1.1.toString);
              module2.exports = function(key) {
                return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
              };
            },
            /***/
            6071(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var $isNaN = __webpack_require__2(713);
              module2.exports = function sign(number) {
                if ($isNaN(number) || number === 0) {
                  return number;
                }
                return number < 0 ? -1 : 1;
              };
            },
            /***/
            6089(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(4866), __webpack_require__2(3532), __webpack_require__2(6818), __webpack_require__2(2858));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function() {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var StreamCipher = C_lib.StreamCipher;
                  var C_algo = C.algo;
                  var RC4 = C_algo.RC4 = StreamCipher.extend({
                    _doReset: function() {
                      var key = this._key;
                      var keyWords = key.words;
                      var keySigBytes = key.sigBytes;
                      var S = this._S = [];
                      for (var i = 0; i < 256; i++) {
                        S[i] = i;
                      }
                      for (var i = 0, j = 0; i < 256; i++) {
                        var keyByteIndex = i % keySigBytes;
                        var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
                        j = (j + S[i] + keyByte) % 256;
                        var t = S[i];
                        S[i] = S[j];
                        S[j] = t;
                      }
                      this._i = this._j = 0;
                    },
                    _doProcessBlock: function(M, offset) {
                      M[offset] ^= generateKeystreamWord.call(this);
                    },
                    keySize: 256 / 32,
                    ivSize: 0
                  });
                  function generateKeystreamWord() {
                    var S = this._S;
                    var i = this._i;
                    var j = this._j;
                    var keystreamWord = 0;
                    for (var n = 0; n < 4; n++) {
                      i = (i + 1) % 256;
                      j = (j + S[i]) % 256;
                      var t = S[i];
                      S[i] = S[j];
                      S[j] = t;
                      keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
                    }
                    this._i = i;
                    this._j = j;
                    return keystreamWord;
                  }
                  C.RC4 = StreamCipher._createHelper(RC4);
                  var RC4Drop = C_algo.RC4Drop = RC4.extend({
                    /**
                     * Configuration options.
                     *
                     * @property {number} drop The number of keystream words to drop. Default 192
                     */
                    cfg: RC4.cfg.extend({
                      drop: 192
                    }),
                    _doReset: function() {
                      RC4._doReset.call(this);
                      for (var i = this.cfg.drop; i > 0; i--) {
                        generateKeystreamWord.call(this);
                      }
                    }
                  });
                  C.RC4Drop = StreamCipher._createHelper(RC4Drop);
                })();
                return CryptoJS.RC4;
              });
            },
            /***/
            6092(module2, __unused_webpack_exports, __webpack_require__2) {
              var ___EXPOSE_LOADER_IMPORT___ = __webpack_require__2(2736);
              var ___EXPOSE_LOADER_GET_GLOBAL_THIS___ = __webpack_require__2(2022);
              var ___EXPOSE_LOADER_GLOBAL_THIS___ = ___EXPOSE_LOADER_GET_GLOBAL_THIS___;
              if (typeof ___EXPOSE_LOADER_GLOBAL_THIS___["pdfMake"] === "undefined") ___EXPOSE_LOADER_GLOBAL_THIS___["pdfMake"] = ___EXPOSE_LOADER_IMPORT___;
              module2.exports = ___EXPOSE_LOADER_IMPORT___;
            },
            /***/
            6094(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var whichTypedArray = __webpack_require__2(3381);
              module2.exports = function isTypedArray(value) {
                return !!whichTypedArray(value);
              };
            },
            /***/
            6174(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(3144));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function(Math2) {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var WordArray = C_lib.WordArray;
                  var Hasher = C_lib.Hasher;
                  var C_x64 = C.x64;
                  var X64Word = C_x64.Word;
                  var C_algo = C.algo;
                  var RHO_OFFSETS = [];
                  var PI_INDEXES = [];
                  var ROUND_CONSTANTS = [];
                  (function() {
                    var x = 1, y = 0;
                    for (var t = 0; t < 24; t++) {
                      RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
                      var newX = y % 5;
                      var newY = (2 * x + 3 * y) % 5;
                      x = newX;
                      y = newY;
                    }
                    for (var x = 0; x < 5; x++) {
                      for (var y = 0; y < 5; y++) {
                        PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
                      }
                    }
                    var LFSR = 1;
                    for (var i = 0; i < 24; i++) {
                      var roundConstantMsw = 0;
                      var roundConstantLsw = 0;
                      for (var j = 0; j < 7; j++) {
                        if (LFSR & 1) {
                          var bitPosition = (1 << j) - 1;
                          if (bitPosition < 32) {
                            roundConstantLsw ^= 1 << bitPosition;
                          } else {
                            roundConstantMsw ^= 1 << bitPosition - 32;
                          }
                        }
                        if (LFSR & 128) {
                          LFSR = LFSR << 1 ^ 113;
                        } else {
                          LFSR <<= 1;
                        }
                      }
                      ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
                    }
                  })();
                  var T = [];
                  (function() {
                    for (var i = 0; i < 25; i++) {
                      T[i] = X64Word.create();
                    }
                  })();
                  var SHA3 = C_algo.SHA3 = Hasher.extend({
                    /**
                     * Configuration options.
                     *
                     * @property {number} outputLength
                     *   The desired number of bits in the output hash.
                     *   Only values permitted are: 224, 256, 384, 512.
                     *   Default: 512
                     */
                    cfg: Hasher.cfg.extend({
                      outputLength: 512
                    }),
                    _doReset: function() {
                      var state = this._state = [];
                      for (var i = 0; i < 25; i++) {
                        state[i] = new X64Word.init();
                      }
                      this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
                    },
                    _doProcessBlock: function(M, offset) {
                      var state = this._state;
                      var nBlockSizeLanes = this.blockSize / 2;
                      for (var i = 0; i < nBlockSizeLanes; i++) {
                        var M2i = M[offset + 2 * i];
                        var M2i1 = M[offset + 2 * i + 1];
                        M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
                        M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
                        var lane = state[i];
                        lane.high ^= M2i1;
                        lane.low ^= M2i;
                      }
                      for (var round = 0; round < 24; round++) {
                        for (var x = 0; x < 5; x++) {
                          var tMsw = 0, tLsw = 0;
                          for (var y = 0; y < 5; y++) {
                            var lane = state[x + 5 * y];
                            tMsw ^= lane.high;
                            tLsw ^= lane.low;
                          }
                          var Tx = T[x];
                          Tx.high = tMsw;
                          Tx.low = tLsw;
                        }
                        for (var x = 0; x < 5; x++) {
                          var Tx4 = T[(x + 4) % 5];
                          var Tx1 = T[(x + 1) % 5];
                          var Tx1Msw = Tx1.high;
                          var Tx1Lsw = Tx1.low;
                          var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                          var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                          for (var y = 0; y < 5; y++) {
                            var lane = state[x + 5 * y];
                            lane.high ^= tMsw;
                            lane.low ^= tLsw;
                          }
                        }
                        for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                          var tMsw;
                          var tLsw;
                          var lane = state[laneIndex];
                          var laneMsw = lane.high;
                          var laneLsw = lane.low;
                          var rhoOffset = RHO_OFFSETS[laneIndex];
                          if (rhoOffset < 32) {
                            tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                            tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                          } else {
                            tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                            tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                          }
                          var TPiLane = T[PI_INDEXES[laneIndex]];
                          TPiLane.high = tMsw;
                          TPiLane.low = tLsw;
                        }
                        var T0 = T[0];
                        var state0 = state[0];
                        T0.high = state0.high;
                        T0.low = state0.low;
                        for (var x = 0; x < 5; x++) {
                          for (var y = 0; y < 5; y++) {
                            var laneIndex = x + 5 * y;
                            var lane = state[laneIndex];
                            var TLane = T[laneIndex];
                            var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                            var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                            lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                            lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                          }
                        }
                        var lane = state[0];
                        var roundConstant = ROUND_CONSTANTS[round];
                        lane.high ^= roundConstant.high;
                        lane.low ^= roundConstant.low;
                      }
                    },
                    _doFinalize: function() {
                      var data = this._data;
                      var dataWords = data.words;
                      var nBitsTotal = this._nDataBytes * 8;
                      var nBitsLeft = data.sigBytes * 8;
                      var blockSizeBits = this.blockSize * 32;
                      dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
                      dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
                      data.sigBytes = dataWords.length * 4;
                      this._process();
                      var state = this._state;
                      var outputLengthBytes = this.cfg.outputLength / 8;
                      var outputLengthLanes = outputLengthBytes / 8;
                      var hashWords = [];
                      for (var i = 0; i < outputLengthLanes; i++) {
                        var lane = state[i];
                        var laneMsw = lane.high;
                        var laneLsw = lane.low;
                        laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
                        laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
                        hashWords.push(laneLsw);
                        hashWords.push(laneMsw);
                      }
                      return new WordArray.init(hashWords, outputLengthBytes);
                    },
                    clone: function() {
                      var clone = Hasher.clone.call(this);
                      var state = clone._state = this._state.slice(0);
                      for (var i = 0; i < 25; i++) {
                        state[i] = state[i].clone();
                      }
                      return clone;
                    }
                  });
                  C.SHA3 = Hasher._createHelper(SHA3);
                  C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
                })(Math);
                return CryptoJS.SHA3;
              });
            },
            /***/
            6228(module2) {
              "use strict";
              module2.exports = {
                2: "need dictionary",
                /* Z_NEED_DICT       2  */
                1: "stream end",
                /* Z_STREAM_END      1  */
                0: "",
                /* Z_OK              0  */
                "-1": "file error",
                /* Z_ERRNO         (-1) */
                "-2": "stream error",
                /* Z_STREAM_ERROR  (-2) */
                "-3": "data error",
                /* Z_DATA_ERROR    (-3) */
                "-4": "insufficient memory",
                /* Z_MEM_ERROR     (-4) */
                "-5": "buffer error",
                /* Z_BUF_ERROR     (-5) */
                "-6": "incompatible version"
                /* Z_VERSION_ERROR (-6) */
              };
            },
            /***/
            6255(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var GetIntrinsic = __webpack_require__2(8651);
              var define2 = __webpack_require__2(9295);
              var hasDescriptors = __webpack_require__2(8890)();
              var gOPD = __webpack_require__2(8109);
              var $TypeError = __webpack_require__2(6785);
              var $floor = GetIntrinsic("%Math.floor%");
              module2.exports = function setFunctionLength(fn, length) {
                if (typeof fn !== "function") {
                  throw new $TypeError("`fn` is not a function");
                }
                if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
                  throw new $TypeError("`length` must be a positive 32-bit integer");
                }
                var loose = arguments.length > 2 && !!arguments[2];
                var functionLengthIsConfigurable = true;
                var functionLengthIsWritable = true;
                if ("length" in fn && gOPD) {
                  var desc = gOPD(fn, "length");
                  if (desc && !desc.configurable) {
                    functionLengthIsConfigurable = false;
                  }
                  if (desc && !desc.writable) {
                    functionLengthIsWritable = false;
                  }
                }
                if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
                  if (hasDescriptors) {
                    define2(
                      /** @type {Parameters<define>[0]} */
                      fn,
                      "length",
                      length,
                      true,
                      true
                    );
                  } else {
                    define2(
                      /** @type {Parameters<define>[0]} */
                      fn,
                      "length",
                      length
                    );
                  }
                }
                return fn;
              };
            },
            /***/
            6297(module2) {
              "use strict";
              module2.exports = function(it) {
                return it === null || it === void 0;
              };
            },
            /***/
            6341(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var uncurryThis = __webpack_require__2(1212);
              var toObject = __webpack_require__2(3297);
              var hasOwnProperty = uncurryThis({}.hasOwnProperty);
              module2.exports = Object.hasOwn || function hasOwn(it, key) {
                return hasOwnProperty(toObject(it), key);
              };
            },
            /***/
            6395(module2) {
              "use strict";
              var BAD = 30;
              var TYPE = 12;
              module2.exports = function inflate_fast(strm, start) {
                var state;
                var _in;
                var last;
                var _out;
                var beg;
                var end;
                var dmax;
                var wsize;
                var whave;
                var wnext;
                var s_window;
                var hold;
                var bits;
                var lcode;
                var dcode;
                var lmask;
                var dmask;
                var here;
                var op;
                var len;
                var dist;
                var from;
                var from_source;
                var input, output;
                state = strm.state;
                _in = strm.next_in;
                input = strm.input;
                last = _in + (strm.avail_in - 5);
                _out = strm.next_out;
                output = strm.output;
                beg = _out - (start - strm.avail_out);
                end = _out + (strm.avail_out - 257);
                dmax = state.dmax;
                wsize = state.wsize;
                whave = state.whave;
                wnext = state.wnext;
                s_window = state.window;
                hold = state.hold;
                bits = state.bits;
                lcode = state.lencode;
                dcode = state.distcode;
                lmask = (1 << state.lenbits) - 1;
                dmask = (1 << state.distbits) - 1;
                top:
                  do {
                    if (bits < 15) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    here = lcode[hold & lmask];
                    dolen:
                      for (; ; ) {
                        op = here >>> 24;
                        hold >>>= op;
                        bits -= op;
                        op = here >>> 16 & 255;
                        if (op === 0) {
                          output[_out++] = here & 65535;
                        } else if (op & 16) {
                          len = here & 65535;
                          op &= 15;
                          if (op) {
                            if (bits < op) {
                              hold += input[_in++] << bits;
                              bits += 8;
                            }
                            len += hold & (1 << op) - 1;
                            hold >>>= op;
                            bits -= op;
                          }
                          if (bits < 15) {
                            hold += input[_in++] << bits;
                            bits += 8;
                            hold += input[_in++] << bits;
                            bits += 8;
                          }
                          here = dcode[hold & dmask];
                          dodist:
                            for (; ; ) {
                              op = here >>> 24;
                              hold >>>= op;
                              bits -= op;
                              op = here >>> 16 & 255;
                              if (op & 16) {
                                dist = here & 65535;
                                op &= 15;
                                if (bits < op) {
                                  hold += input[_in++] << bits;
                                  bits += 8;
                                  if (bits < op) {
                                    hold += input[_in++] << bits;
                                    bits += 8;
                                  }
                                }
                                dist += hold & (1 << op) - 1;
                                if (dist > dmax) {
                                  strm.msg = "invalid distance too far back";
                                  state.mode = BAD;
                                  break top;
                                }
                                hold >>>= op;
                                bits -= op;
                                op = _out - beg;
                                if (dist > op) {
                                  op = dist - op;
                                  if (op > whave) {
                                    if (state.sane) {
                                      strm.msg = "invalid distance too far back";
                                      state.mode = BAD;
                                      break top;
                                    }
                                  }
                                  from = 0;
                                  from_source = s_window;
                                  if (wnext === 0) {
                                    from += wsize - op;
                                    if (op < len) {
                                      len -= op;
                                      do {
                                        output[_out++] = s_window[from++];
                                      } while (--op);
                                      from = _out - dist;
                                      from_source = output;
                                    }
                                  } else if (wnext < op) {
                                    from += wsize + wnext - op;
                                    op -= wnext;
                                    if (op < len) {
                                      len -= op;
                                      do {
                                        output[_out++] = s_window[from++];
                                      } while (--op);
                                      from = 0;
                                      if (wnext < len) {
                                        op = wnext;
                                        len -= op;
                                        do {
                                          output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = _out - dist;
                                        from_source = output;
                                      }
                                    }
                                  } else {
                                    from += wnext - op;
                                    if (op < len) {
                                      len -= op;
                                      do {
                                        output[_out++] = s_window[from++];
                                      } while (--op);
                                      from = _out - dist;
                                      from_source = output;
                                    }
                                  }
                                  while (len > 2) {
                                    output[_out++] = from_source[from++];
                                    output[_out++] = from_source[from++];
                                    output[_out++] = from_source[from++];
                                    len -= 3;
                                  }
                                  if (len) {
                                    output[_out++] = from_source[from++];
                                    if (len > 1) {
                                      output[_out++] = from_source[from++];
                                    }
                                  }
                                } else {
                                  from = _out - dist;
                                  do {
                                    output[_out++] = output[from++];
                                    output[_out++] = output[from++];
                                    output[_out++] = output[from++];
                                    len -= 3;
                                  } while (len > 2);
                                  if (len) {
                                    output[_out++] = output[from++];
                                    if (len > 1) {
                                      output[_out++] = output[from++];
                                    }
                                  }
                                }
                              } else if ((op & 64) === 0) {
                                here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                                continue dodist;
                              } else {
                                strm.msg = "invalid distance code";
                                state.mode = BAD;
                                break top;
                              }
                              break;
                            }
                        } else if ((op & 64) === 0) {
                          here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                          continue dolen;
                        } else if (op & 32) {
                          state.mode = TYPE;
                          break top;
                        } else {
                          strm.msg = "invalid literal/length code";
                          state.mode = BAD;
                          break top;
                        }
                        break;
                      }
                  } while (_in < last && _out < end);
                len = bits >> 3;
                _in -= len;
                bits -= len << 3;
                hold &= (1 << bits) - 1;
                strm.next_in = _in;
                strm.next_out = _out;
                strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
                strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
                state.hold = hold;
                state.bits = bits;
                return;
              };
            },
            /***/
            6401(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var globalThis2 = __webpack_require__2(7756);
              var call = __webpack_require__2(8993);
              var ArrayBufferViewCore = __webpack_require__2(4074);
              var lengthOfArrayLike = __webpack_require__2(4730);
              var toOffset = __webpack_require__2(4001);
              var toIndexedObject = __webpack_require__2(3297);
              var fails = __webpack_require__2(299);
              var RangeError2 = globalThis2.RangeError;
              var Int8Array2 = globalThis2.Int8Array;
              var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
              var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
              var aTypedArray = ArrayBufferViewCore.aTypedArray;
              var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
              var WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS = !fails(function() {
                var array = new Uint8ClampedArray(2);
                call($set, array, { length: 1, 0: 3 }, 1);
                return array[1] !== 3;
              });
              var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function() {
                var array = new Int8Array2(2);
                array.set(1);
                array.set("2", 1);
                return array[0] !== 0 || array[1] !== 2;
              });
              exportTypedArrayMethod("set", function set(arrayLike) {
                aTypedArray(this);
                var offset = toOffset(arguments.length > 1 ? arguments[1] : void 0, 1);
                var src = toIndexedObject(arrayLike);
                if (WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS) return call($set, this, src, offset);
                var length = this.length;
                var len = lengthOfArrayLike(src);
                var index = 0;
                if (len + offset > length) throw new RangeError2("Wrong length");
                while (index < len) this[offset + index] = src[index++];
              }, !WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);
            },
            /***/
            6465(module2, __unused_webpack_exports, __webpack_require__2) {
              module2.exports = deprecate;
              function deprecate(fn, msg) {
                if (config("noDeprecation")) {
                  return fn;
                }
                var warned = false;
                function deprecated() {
                  if (!warned) {
                    if (config("throwDeprecation")) {
                      throw new Error(msg);
                    } else if (config("traceDeprecation")) {
                      console.trace(msg);
                    } else {
                      console.warn(msg);
                    }
                    warned = true;
                  }
                  return fn.apply(this, arguments);
                }
                return deprecated;
              }
              function config(name) {
                try {
                  if (!__webpack_require__2.g.localStorage) return false;
                } catch (_) {
                  return false;
                }
                var val = __webpack_require__2.g.localStorage[name];
                if (null == val) return false;
                return String(val).toLowerCase() === "true";
              }
            },
            /***/
            6515(module2) {
              "use strict";
              var toStr = Object.prototype.toString;
              module2.exports = function isArguments(value) {
                var str = toStr.call(value);
                var isArgs = str === "[object Arguments]";
                if (!isArgs) {
                  isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
                }
                return isArgs;
              };
            },
            /***/
            6521(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var objectKeys = __webpack_require__2(5643);
              var hasSymbols = __webpack_require__2(2843)();
              var callBound = __webpack_require__2(2774);
              var $Object = __webpack_require__2(5846);
              var $push = callBound("Array.prototype.push");
              var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
              var originalGetSymbols = hasSymbols ? $Object.getOwnPropertySymbols : null;
              module2.exports = function assign(target, source1) {
                if (target == null) {
                  throw new TypeError("target must be an object");
                }
                var to = $Object(target);
                if (arguments.length === 1) {
                  return to;
                }
                for (var s = 1; s < arguments.length; ++s) {
                  var from = $Object(arguments[s]);
                  var keys = objectKeys(from);
                  var getSymbols = hasSymbols && ($Object.getOwnPropertySymbols || originalGetSymbols);
                  if (getSymbols) {
                    var syms = getSymbols(from);
                    for (var j = 0; j < syms.length; ++j) {
                      var key = syms[j];
                      if ($propIsEnumerable(from, key)) {
                        $push(keys, key);
                      }
                    }
                  }
                  for (var i = 0; i < keys.length; ++i) {
                    var nextKey = keys[i];
                    if ($propIsEnumerable(from, nextKey)) {
                      var propValue = from[nextKey];
                      to[nextKey] = propValue;
                    }
                  }
                }
                return to;
              };
            },
            /***/
            6582(__unused_webpack_module, exports2, __webpack_require__2) {
              "use strict";
              var __webpack_unused_export__;
              __webpack_unused_export__ = {
                value: true
              };
              exports2.A = void 0;
              var _source = _interopRequireDefault(__webpack_require__2(7696));
              function _interopRequireDefault(e) {
                return e && e.__esModule ? e : { default: e };
              }
              var _default = exports2.A = _source.default;
            },
            /***/
            6601(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var setFunctionLength = __webpack_require__2(6255);
              var $defineProperty = __webpack_require__2(6649);
              var callBindBasic = __webpack_require__2(6688);
              var applyBind = __webpack_require__2(8619);
              module2.exports = function callBind(originalFunction) {
                var func = callBindBasic(arguments);
                var adjustedLength = originalFunction.length - (arguments.length - 1);
                return setFunctionLength(
                  func,
                  1 + (adjustedLength > 0 ? adjustedLength : 0),
                  true
                );
              };
              if ($defineProperty) {
                $defineProperty(module2.exports, "apply", { value: applyBind });
              } else {
                module2.exports.apply = applyBind;
              }
            },
            /***/
            6626(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var hasSymbols = __webpack_require__2(2843);
              module2.exports = function hasToStringTagShams() {
                return hasSymbols() && !!Symbol.toStringTag;
              };
            },
            /***/
            6649(module2) {
              "use strict";
              var $defineProperty = Object.defineProperty || false;
              if ($defineProperty) {
                try {
                  $defineProperty({}, "a", { value: 1 });
                } catch (e) {
                  $defineProperty = false;
                }
              }
              module2.exports = $defineProperty;
            },
            /***/
            6688(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var bind = __webpack_require__2(5049);
              var $TypeError = __webpack_require__2(6785);
              var $call = __webpack_require__2(78);
              var $actualApply = __webpack_require__2(7802);
              module2.exports = function callBindBasic(args) {
                if (args.length < 1 || typeof args[0] !== "function") {
                  throw new $TypeError("a function is required");
                }
                return $actualApply(bind, $call, args);
              };
            },
            /***/
            6729(__unused_webpack_module, exports2, __webpack_require__2) {
              "use strict";
              var process = __webpack_require__2(9964);
              var Buffer = __webpack_require__2(783).Buffer;
              var Transform = __webpack_require__2(9760).Transform;
              var binding = __webpack_require__2(2908);
              var util = __webpack_require__2(7187);
              var assert = __webpack_require__2(7801).ok;
              var kMaxLength = __webpack_require__2(783).kMaxLength;
              var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes";
              binding.Z_MIN_WINDOWBITS = 8;
              binding.Z_MAX_WINDOWBITS = 15;
              binding.Z_DEFAULT_WINDOWBITS = 15;
              binding.Z_MIN_CHUNK = 64;
              binding.Z_MAX_CHUNK = Infinity;
              binding.Z_DEFAULT_CHUNK = 16 * 1024;
              binding.Z_MIN_MEMLEVEL = 1;
              binding.Z_MAX_MEMLEVEL = 9;
              binding.Z_DEFAULT_MEMLEVEL = 8;
              binding.Z_MIN_LEVEL = -1;
              binding.Z_MAX_LEVEL = 9;
              binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
              var bkeys = Object.keys(binding);
              for (var bk = 0; bk < bkeys.length; bk++) {
                var bkey = bkeys[bk];
                if (bkey.match(/^Z/)) {
                  Object.defineProperty(exports2, bkey, {
                    enumerable: true,
                    value: binding[bkey],
                    writable: false
                  });
                }
              }
              var codes = {
                Z_OK: binding.Z_OK,
                Z_STREAM_END: binding.Z_STREAM_END,
                Z_NEED_DICT: binding.Z_NEED_DICT,
                Z_ERRNO: binding.Z_ERRNO,
                Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
                Z_DATA_ERROR: binding.Z_DATA_ERROR,
                Z_MEM_ERROR: binding.Z_MEM_ERROR,
                Z_BUF_ERROR: binding.Z_BUF_ERROR,
                Z_VERSION_ERROR: binding.Z_VERSION_ERROR
              };
              var ckeys = Object.keys(codes);
              for (var ck = 0; ck < ckeys.length; ck++) {
                var ckey = ckeys[ck];
                codes[codes[ckey]] = ckey;
              }
              Object.defineProperty(exports2, "codes", {
                enumerable: true,
                value: Object.freeze(codes),
                writable: false
              });
              exports2.Deflate = Deflate;
              exports2.Inflate = Inflate;
              exports2.Gzip = Gzip;
              exports2.Gunzip = Gunzip;
              exports2.DeflateRaw = DeflateRaw;
              exports2.InflateRaw = InflateRaw;
              exports2.Unzip = Unzip;
              exports2.createDeflate = function(o) {
                return new Deflate(o);
              };
              exports2.createInflate = function(o) {
                return new Inflate(o);
              };
              exports2.createDeflateRaw = function(o) {
                return new DeflateRaw(o);
              };
              exports2.createInflateRaw = function(o) {
                return new InflateRaw(o);
              };
              exports2.createGzip = function(o) {
                return new Gzip(o);
              };
              exports2.createGunzip = function(o) {
                return new Gunzip(o);
              };
              exports2.createUnzip = function(o) {
                return new Unzip(o);
              };
              exports2.deflate = function(buffer, opts, callback) {
                if (typeof opts === "function") {
                  callback = opts;
                  opts = {};
                }
                return zlibBuffer(new Deflate(opts), buffer, callback);
              };
              exports2.deflateSync = function(buffer, opts) {
                return zlibBufferSync(new Deflate(opts), buffer);
              };
              exports2.gzip = function(buffer, opts, callback) {
                if (typeof opts === "function") {
                  callback = opts;
                  opts = {};
                }
                return zlibBuffer(new Gzip(opts), buffer, callback);
              };
              exports2.gzipSync = function(buffer, opts) {
                return zlibBufferSync(new Gzip(opts), buffer);
              };
              exports2.deflateRaw = function(buffer, opts, callback) {
                if (typeof opts === "function") {
                  callback = opts;
                  opts = {};
                }
                return zlibBuffer(new DeflateRaw(opts), buffer, callback);
              };
              exports2.deflateRawSync = function(buffer, opts) {
                return zlibBufferSync(new DeflateRaw(opts), buffer);
              };
              exports2.unzip = function(buffer, opts, callback) {
                if (typeof opts === "function") {
                  callback = opts;
                  opts = {};
                }
                return zlibBuffer(new Unzip(opts), buffer, callback);
              };
              exports2.unzipSync = function(buffer, opts) {
                return zlibBufferSync(new Unzip(opts), buffer);
              };
              exports2.inflate = function(buffer, opts, callback) {
                if (typeof opts === "function") {
                  callback = opts;
                  opts = {};
                }
                return zlibBuffer(new Inflate(opts), buffer, callback);
              };
              exports2.inflateSync = function(buffer, opts) {
                return zlibBufferSync(new Inflate(opts), buffer);
              };
              exports2.gunzip = function(buffer, opts, callback) {
                if (typeof opts === "function") {
                  callback = opts;
                  opts = {};
                }
                return zlibBuffer(new Gunzip(opts), buffer, callback);
              };
              exports2.gunzipSync = function(buffer, opts) {
                return zlibBufferSync(new Gunzip(opts), buffer);
              };
              exports2.inflateRaw = function(buffer, opts, callback) {
                if (typeof opts === "function") {
                  callback = opts;
                  opts = {};
                }
                return zlibBuffer(new InflateRaw(opts), buffer, callback);
              };
              exports2.inflateRawSync = function(buffer, opts) {
                return zlibBufferSync(new InflateRaw(opts), buffer);
              };
              function zlibBuffer(engine, buffer, callback) {
                var buffers = [];
                var nread = 0;
                engine.on("error", onError);
                engine.on("end", onEnd);
                engine.end(buffer);
                flow();
                function flow() {
                  var chunk;
                  while (null !== (chunk = engine.read())) {
                    buffers.push(chunk);
                    nread += chunk.length;
                  }
                  engine.once("readable", flow);
                }
                function onError(err) {
                  engine.removeListener("end", onEnd);
                  engine.removeListener("readable", flow);
                  callback(err);
                }
                function onEnd() {
                  var buf;
                  var err = null;
                  if (nread >= kMaxLength) {
                    err = new RangeError(kRangeErrorMessage);
                  } else {
                    buf = Buffer.concat(buffers, nread);
                  }
                  buffers = [];
                  engine.close();
                  callback(err, buf);
                }
              }
              function zlibBufferSync(engine, buffer) {
                if (typeof buffer === "string") buffer = Buffer.from(buffer);
                if (!Buffer.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
                var flushFlag = engine._finishFlushFlag;
                return engine._processChunk(buffer, flushFlag);
              }
              function Deflate(opts) {
                if (!(this instanceof Deflate)) return new Deflate(opts);
                Zlib.call(this, opts, binding.DEFLATE);
              }
              function Inflate(opts) {
                if (!(this instanceof Inflate)) return new Inflate(opts);
                Zlib.call(this, opts, binding.INFLATE);
              }
              function Gzip(opts) {
                if (!(this instanceof Gzip)) return new Gzip(opts);
                Zlib.call(this, opts, binding.GZIP);
              }
              function Gunzip(opts) {
                if (!(this instanceof Gunzip)) return new Gunzip(opts);
                Zlib.call(this, opts, binding.GUNZIP);
              }
              function DeflateRaw(opts) {
                if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
                Zlib.call(this, opts, binding.DEFLATERAW);
              }
              function InflateRaw(opts) {
                if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
                Zlib.call(this, opts, binding.INFLATERAW);
              }
              function Unzip(opts) {
                if (!(this instanceof Unzip)) return new Unzip(opts);
                Zlib.call(this, opts, binding.UNZIP);
              }
              function isValidFlushFlag(flag) {
                return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;
              }
              function Zlib(opts, mode) {
                var _this = this;
                this._opts = opts = opts || {};
                this._chunkSize = opts.chunkSize || exports2.Z_DEFAULT_CHUNK;
                Transform.call(this, opts);
                if (opts.flush && !isValidFlushFlag(opts.flush)) {
                  throw new Error("Invalid flush flag: " + opts.flush);
                }
                if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
                  throw new Error("Invalid flush flag: " + opts.finishFlush);
                }
                this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
                this._finishFlushFlag = typeof opts.finishFlush !== "undefined" ? opts.finishFlush : binding.Z_FINISH;
                if (opts.chunkSize) {
                  if (opts.chunkSize < exports2.Z_MIN_CHUNK || opts.chunkSize > exports2.Z_MAX_CHUNK) {
                    throw new Error("Invalid chunk size: " + opts.chunkSize);
                  }
                }
                if (opts.windowBits) {
                  if (opts.windowBits < exports2.Z_MIN_WINDOWBITS || opts.windowBits > exports2.Z_MAX_WINDOWBITS) {
                    throw new Error("Invalid windowBits: " + opts.windowBits);
                  }
                }
                if (opts.level) {
                  if (opts.level < exports2.Z_MIN_LEVEL || opts.level > exports2.Z_MAX_LEVEL) {
                    throw new Error("Invalid compression level: " + opts.level);
                  }
                }
                if (opts.memLevel) {
                  if (opts.memLevel < exports2.Z_MIN_MEMLEVEL || opts.memLevel > exports2.Z_MAX_MEMLEVEL) {
                    throw new Error("Invalid memLevel: " + opts.memLevel);
                  }
                }
                if (opts.strategy) {
                  if (opts.strategy != exports2.Z_FILTERED && opts.strategy != exports2.Z_HUFFMAN_ONLY && opts.strategy != exports2.Z_RLE && opts.strategy != exports2.Z_FIXED && opts.strategy != exports2.Z_DEFAULT_STRATEGY) {
                    throw new Error("Invalid strategy: " + opts.strategy);
                  }
                }
                if (opts.dictionary) {
                  if (!Buffer.isBuffer(opts.dictionary)) {
                    throw new Error("Invalid dictionary: it should be a Buffer instance");
                  }
                }
                this._handle = new binding.Zlib(mode);
                var self2 = this;
                this._hadError = false;
                this._handle.onerror = function(message, errno) {
                  _close(self2);
                  self2._hadError = true;
                  var error = new Error(message);
                  error.errno = errno;
                  error.code = exports2.codes[errno];
                  self2.emit("error", error);
                };
                var level = exports2.Z_DEFAULT_COMPRESSION;
                if (typeof opts.level === "number") level = opts.level;
                var strategy = exports2.Z_DEFAULT_STRATEGY;
                if (typeof opts.strategy === "number") strategy = opts.strategy;
                this._handle.init(opts.windowBits || exports2.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports2.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
                this._buffer = Buffer.allocUnsafe(this._chunkSize);
                this._offset = 0;
                this._level = level;
                this._strategy = strategy;
                this.once("end", this.close);
                Object.defineProperty(this, "_closed", {
                  get: function() {
                    return !_this._handle;
                  },
                  configurable: true,
                  enumerable: true
                });
              }
              util.inherits(Zlib, Transform);
              Zlib.prototype.params = function(level, strategy, callback) {
                if (level < exports2.Z_MIN_LEVEL || level > exports2.Z_MAX_LEVEL) {
                  throw new RangeError("Invalid compression level: " + level);
                }
                if (strategy != exports2.Z_FILTERED && strategy != exports2.Z_HUFFMAN_ONLY && strategy != exports2.Z_RLE && strategy != exports2.Z_FIXED && strategy != exports2.Z_DEFAULT_STRATEGY) {
                  throw new TypeError("Invalid strategy: " + strategy);
                }
                if (this._level !== level || this._strategy !== strategy) {
                  var self2 = this;
                  this.flush(binding.Z_SYNC_FLUSH, function() {
                    assert(self2._handle, "zlib binding closed");
                    self2._handle.params(level, strategy);
                    if (!self2._hadError) {
                      self2._level = level;
                      self2._strategy = strategy;
                      if (callback) callback();
                    }
                  });
                } else {
                  process.nextTick(callback);
                }
              };
              Zlib.prototype.reset = function() {
                assert(this._handle, "zlib binding closed");
                return this._handle.reset();
              };
              Zlib.prototype._flush = function(callback) {
                this._transform(Buffer.alloc(0), "", callback);
              };
              Zlib.prototype.flush = function(kind, callback) {
                var _this2 = this;
                var ws = this._writableState;
                if (typeof kind === "function" || kind === void 0 && !callback) {
                  callback = kind;
                  kind = binding.Z_FULL_FLUSH;
                }
                if (ws.ended) {
                  if (callback) process.nextTick(callback);
                } else if (ws.ending) {
                  if (callback) this.once("end", callback);
                } else if (ws.needDrain) {
                  if (callback) {
                    this.once("drain", function() {
                      return _this2.flush(kind, callback);
                    });
                  }
                } else {
                  this._flushFlag = kind;
                  this.write(Buffer.alloc(0), "", callback);
                }
              };
              Zlib.prototype.close = function(callback) {
                _close(this, callback);
                process.nextTick(emitCloseNT, this);
              };
              function _close(engine, callback) {
                if (callback) process.nextTick(callback);
                if (!engine._handle) return;
                engine._handle.close();
                engine._handle = null;
              }
              function emitCloseNT(self2) {
                self2.emit("close");
              }
              Zlib.prototype._transform = function(chunk, encoding, cb) {
                var flushFlag;
                var ws = this._writableState;
                var ending = ws.ending || ws.ended;
                var last = ending && (!chunk || ws.length === chunk.length);
                if (chunk !== null && !Buffer.isBuffer(chunk)) return cb(new Error("invalid input"));
                if (!this._handle) return cb(new Error("zlib binding closed"));
                if (last) flushFlag = this._finishFlushFlag;
                else {
                  flushFlag = this._flushFlag;
                  if (chunk.length >= ws.length) {
                    this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
                  }
                }
                this._processChunk(chunk, flushFlag, cb);
              };
              Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
                var availInBefore = chunk && chunk.length;
                var availOutBefore = this._chunkSize - this._offset;
                var inOff = 0;
                var self2 = this;
                var async = typeof cb === "function";
                if (!async) {
                  var buffers = [];
                  var nread = 0;
                  var error;
                  this.on("error", function(er) {
                    error = er;
                  });
                  assert(this._handle, "zlib binding closed");
                  do {
                    var res = this._handle.writeSync(
                      flushFlag,
                      chunk,
                      // in
                      inOff,
                      // in_off
                      availInBefore,
                      // in_len
                      this._buffer,
                      // out
                      this._offset,
                      //out_off
                      availOutBefore
                    );
                  } while (!this._hadError && callback(res[0], res[1]));
                  if (this._hadError) {
                    throw error;
                  }
                  if (nread >= kMaxLength) {
                    _close(this);
                    throw new RangeError(kRangeErrorMessage);
                  }
                  var buf = Buffer.concat(buffers, nread);
                  _close(this);
                  return buf;
                }
                assert(this._handle, "zlib binding closed");
                var req = this._handle.write(
                  flushFlag,
                  chunk,
                  // in
                  inOff,
                  // in_off
                  availInBefore,
                  // in_len
                  this._buffer,
                  // out
                  this._offset,
                  //out_off
                  availOutBefore
                );
                req.buffer = chunk;
                req.callback = callback;
                function callback(availInAfter, availOutAfter) {
                  if (this) {
                    this.buffer = null;
                    this.callback = null;
                  }
                  if (self2._hadError) return;
                  var have = availOutBefore - availOutAfter;
                  assert(have >= 0, "have should not go down");
                  if (have > 0) {
                    var out = self2._buffer.slice(self2._offset, self2._offset + have);
                    self2._offset += have;
                    if (async) {
                      self2.push(out);
                    } else {
                      buffers.push(out);
                      nread += out.length;
                    }
                  }
                  if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
                    availOutBefore = self2._chunkSize;
                    self2._offset = 0;
                    self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
                  }
                  if (availOutAfter === 0) {
                    inOff += availInBefore - availInAfter;
                    availInBefore = availInAfter;
                    if (!async) return true;
                    var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
                    newReq.callback = callback;
                    newReq.buffer = chunk;
                    return;
                  }
                  if (!async) return false;
                  cb();
                }
              };
              util.inherits(Deflate, Zlib);
              util.inherits(Inflate, Zlib);
              util.inherits(Gzip, Zlib);
              util.inherits(Gunzip, Zlib);
              util.inherits(DeflateRaw, Zlib);
              util.inherits(InflateRaw, Zlib);
              util.inherits(Unzip, Zlib);
            },
            /***/
            6781(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              function _slicedToArray(arr, i) {
                return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
              }
              function _nonIterableRest() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              function _unsupportedIterableToArray(o, minLen) {
                if (!o) return;
                if (typeof o === "string") return _arrayLikeToArray(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor) n = o.constructor.name;
                if (n === "Map" || n === "Set") return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
              }
              function _arrayLikeToArray(arr, len) {
                if (len == null || len > arr.length) len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
                return arr2;
              }
              function _iterableToArrayLimit(r, l) {
                var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
                if (null != t) {
                  var e, n, i, u, a = [], f = true, o = false;
                  try {
                    if (i = (t = t.call(r)).next, 0 === l) {
                      if (Object(t) !== t) return;
                      f = false;
                    } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
                  } catch (r2) {
                    o = true, n = r2;
                  } finally {
                    try {
                      if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
                    } finally {
                      if (o) throw n;
                    }
                  }
                  return a;
                }
              }
              function _arrayWithHoles(arr) {
                if (Array.isArray(arr)) return arr;
              }
              function _typeof(o) {
                "@babel/helpers - typeof";
                return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
                  return typeof o2;
                } : function(o2) {
                  return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
                }, _typeof(o);
              }
              var regexFlagsSupported = /a/g.flags !== void 0;
              var arrayFromSet = function arrayFromSet2(set) {
                var array = [];
                set.forEach(function(value) {
                  return array.push(value);
                });
                return array;
              };
              var arrayFromMap = function arrayFromMap2(map) {
                var array = [];
                map.forEach(function(value, key) {
                  return array.push([key, value]);
                });
                return array;
              };
              var objectIs = Object.is ? Object.is : __webpack_require__2(8527);
              var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
                return [];
              };
              var numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__2(7051);
              function uncurryThis(f) {
                return f.call.bind(f);
              }
              var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
              var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
              var objectToString = uncurryThis(Object.prototype.toString);
              var _require$types = __webpack_require__2(7187).types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
              function isNonIndex(key) {
                if (key.length === 0 || key.length > 10) return true;
                for (var i = 0; i < key.length; i++) {
                  var code = key.charCodeAt(i);
                  if (code < 48 || code > 57) return true;
                }
                return key.length === 10 && key >= Math.pow(2, 32);
              }
              function getOwnNonIndexProperties(value) {
                return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
              }
              function compare(a, b) {
                if (a === b) {
                  return 0;
                }
                var x = a.length;
                var y = b.length;
                for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                  if (a[i] !== b[i]) {
                    x = a[i];
                    y = b[i];
                    break;
                  }
                }
                if (x < y) {
                  return -1;
                }
                if (y < x) {
                  return 1;
                }
                return 0;
              }
              var ONLY_ENUMERABLE = void 0;
              var kStrict = true;
              var kLoose = false;
              var kNoIterator = 0;
              var kIsArray = 1;
              var kIsSet = 2;
              var kIsMap = 3;
              function areSimilarRegExps(a, b) {
                return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
              }
              function areSimilarFloatArrays(a, b) {
                if (a.byteLength !== b.byteLength) {
                  return false;
                }
                for (var offset = 0; offset < a.byteLength; offset++) {
                  if (a[offset] !== b[offset]) {
                    return false;
                  }
                }
                return true;
              }
              function areSimilarTypedArrays(a, b) {
                if (a.byteLength !== b.byteLength) {
                  return false;
                }
                return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
              }
              function areEqualArrayBuffers(buf1, buf2) {
                return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
              }
              function isEqualBoxedPrimitive(val1, val2) {
                if (isNumberObject(val1)) {
                  return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
                }
                if (isStringObject(val1)) {
                  return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
                }
                if (isBooleanObject(val1)) {
                  return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
                }
                if (isBigIntObject(val1)) {
                  return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
                }
                return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
              }
              function innerDeepEqual(val1, val2, strict, memos) {
                if (val1 === val2) {
                  if (val1 !== 0) return true;
                  return strict ? objectIs(val1, val2) : true;
                }
                if (strict) {
                  if (_typeof(val1) !== "object") {
                    return typeof val1 === "number" && numberIsNaN(val1) && numberIsNaN(val2);
                  }
                  if (_typeof(val2) !== "object" || val1 === null || val2 === null) {
                    return false;
                  }
                  if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
                    return false;
                  }
                } else {
                  if (val1 === null || _typeof(val1) !== "object") {
                    if (val2 === null || _typeof(val2) !== "object") {
                      return val1 == val2;
                    }
                    return false;
                  }
                  if (val2 === null || _typeof(val2) !== "object") {
                    return false;
                  }
                }
                var val1Tag = objectToString(val1);
                var val2Tag = objectToString(val2);
                if (val1Tag !== val2Tag) {
                  return false;
                }
                if (Array.isArray(val1)) {
                  if (val1.length !== val2.length) {
                    return false;
                  }
                  var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                  var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                  if (keys1.length !== keys2.length) {
                    return false;
                  }
                  return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
                }
                if (val1Tag === "[object Object]") {
                  if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
                    return false;
                  }
                }
                if (isDate(val1)) {
                  if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
                    return false;
                  }
                } else if (isRegExp(val1)) {
                  if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
                    return false;
                  }
                } else if (isNativeError(val1) || val1 instanceof Error) {
                  if (val1.message !== val2.message || val1.name !== val2.name) {
                    return false;
                  }
                } else if (isArrayBufferView(val1)) {
                  if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
                    if (!areSimilarFloatArrays(val1, val2)) {
                      return false;
                    }
                  } else if (!areSimilarTypedArrays(val1, val2)) {
                    return false;
                  }
                  var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                  var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                  if (_keys.length !== _keys2.length) {
                    return false;
                  }
                  return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
                } else if (isSet(val1)) {
                  if (!isSet(val2) || val1.size !== val2.size) {
                    return false;
                  }
                  return keyCheck(val1, val2, strict, memos, kIsSet);
                } else if (isMap(val1)) {
                  if (!isMap(val2) || val1.size !== val2.size) {
                    return false;
                  }
                  return keyCheck(val1, val2, strict, memos, kIsMap);
                } else if (isAnyArrayBuffer(val1)) {
                  if (!areEqualArrayBuffers(val1, val2)) {
                    return false;
                  }
                } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
                  return false;
                }
                return keyCheck(val1, val2, strict, memos, kNoIterator);
              }
              function getEnumerables(val, keys) {
                return keys.filter(function(k) {
                  return propertyIsEnumerable(val, k);
                });
              }
              function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
                if (arguments.length === 5) {
                  aKeys = Object.keys(val1);
                  var bKeys = Object.keys(val2);
                  if (aKeys.length !== bKeys.length) {
                    return false;
                  }
                }
                var i = 0;
                for (; i < aKeys.length; i++) {
                  if (!hasOwnProperty(val2, aKeys[i])) {
                    return false;
                  }
                }
                if (strict && arguments.length === 5) {
                  var symbolKeysA = objectGetOwnPropertySymbols(val1);
                  if (symbolKeysA.length !== 0) {
                    var count = 0;
                    for (i = 0; i < symbolKeysA.length; i++) {
                      var key = symbolKeysA[i];
                      if (propertyIsEnumerable(val1, key)) {
                        if (!propertyIsEnumerable(val2, key)) {
                          return false;
                        }
                        aKeys.push(key);
                        count++;
                      } else if (propertyIsEnumerable(val2, key)) {
                        return false;
                      }
                    }
                    var symbolKeysB = objectGetOwnPropertySymbols(val2);
                    if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                      return false;
                    }
                  } else {
                    var _symbolKeysB = objectGetOwnPropertySymbols(val2);
                    if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
                      return false;
                    }
                  }
                }
                if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
                  return true;
                }
                if (memos === void 0) {
                  memos = {
                    val1: /* @__PURE__ */ new Map(),
                    val2: /* @__PURE__ */ new Map(),
                    position: 0
                  };
                } else {
                  var val2MemoA = memos.val1.get(val1);
                  if (val2MemoA !== void 0) {
                    var val2MemoB = memos.val2.get(val2);
                    if (val2MemoB !== void 0) {
                      return val2MemoA === val2MemoB;
                    }
                  }
                  memos.position++;
                }
                memos.val1.set(val1, memos.position);
                memos.val2.set(val2, memos.position);
                var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
                memos.val1.delete(val1);
                memos.val2.delete(val2);
                return areEq;
              }
              function setHasEqualElement(set, val1, strict, memo) {
                var setValues = arrayFromSet(set);
                for (var i = 0; i < setValues.length; i++) {
                  var val2 = setValues[i];
                  if (innerDeepEqual(val1, val2, strict, memo)) {
                    set.delete(val2);
                    return true;
                  }
                }
                return false;
              }
              function findLooseMatchingPrimitives(prim) {
                switch (_typeof(prim)) {
                  case "undefined":
                    return null;
                  case "object":
                    return void 0;
                  case "symbol":
                    return false;
                  case "string":
                    prim = +prim;
                  case "number":
                    if (numberIsNaN(prim)) {
                      return false;
                    }
                }
                return true;
              }
              function setMightHaveLoosePrim(a, b, prim) {
                var altValue = findLooseMatchingPrimitives(prim);
                if (altValue != null) return altValue;
                return b.has(altValue) && !a.has(altValue);
              }
              function mapMightHaveLoosePrim(a, b, prim, item, memo) {
                var altValue = findLooseMatchingPrimitives(prim);
                if (altValue != null) {
                  return altValue;
                }
                var curB = b.get(altValue);
                if (curB === void 0 && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
                  return false;
                }
                return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
              }
              function setEquiv(a, b, strict, memo) {
                var set = null;
                var aValues = arrayFromSet(a);
                for (var i = 0; i < aValues.length; i++) {
                  var val = aValues[i];
                  if (_typeof(val) === "object" && val !== null) {
                    if (set === null) {
                      set = /* @__PURE__ */ new Set();
                    }
                    set.add(val);
                  } else if (!b.has(val)) {
                    if (strict) return false;
                    if (!setMightHaveLoosePrim(a, b, val)) {
                      return false;
                    }
                    if (set === null) {
                      set = /* @__PURE__ */ new Set();
                    }
                    set.add(val);
                  }
                }
                if (set !== null) {
                  var bValues = arrayFromSet(b);
                  for (var _i = 0; _i < bValues.length; _i++) {
                    var _val = bValues[_i];
                    if (_typeof(_val) === "object" && _val !== null) {
                      if (!setHasEqualElement(set, _val, strict, memo)) return false;
                    } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
                      return false;
                    }
                  }
                  return set.size === 0;
                }
                return true;
              }
              function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
                var setValues = arrayFromSet(set);
                for (var i = 0; i < setValues.length; i++) {
                  var key2 = setValues[i];
                  if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
                    set.delete(key2);
                    return true;
                  }
                }
                return false;
              }
              function mapEquiv(a, b, strict, memo) {
                var set = null;
                var aEntries = arrayFromMap(a);
                for (var i = 0; i < aEntries.length; i++) {
                  var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
                  if (_typeof(key) === "object" && key !== null) {
                    if (set === null) {
                      set = /* @__PURE__ */ new Set();
                    }
                    set.add(key);
                  } else {
                    var item2 = b.get(key);
                    if (item2 === void 0 && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
                      if (strict) return false;
                      if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
                      if (set === null) {
                        set = /* @__PURE__ */ new Set();
                      }
                      set.add(key);
                    }
                  }
                }
                if (set !== null) {
                  var bEntries = arrayFromMap(b);
                  for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
                    var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), _key = _bEntries$_i[0], item = _bEntries$_i[1];
                    if (_typeof(_key) === "object" && _key !== null) {
                      if (!mapHasEqualEntry(set, a, _key, item, strict, memo)) return false;
                    } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a, _key, item, false, memo)) {
                      return false;
                    }
                  }
                  return set.size === 0;
                }
                return true;
              }
              function objEquiv(a, b, strict, keys, memos, iterationType) {
                var i = 0;
                if (iterationType === kIsSet) {
                  if (!setEquiv(a, b, strict, memos)) {
                    return false;
                  }
                } else if (iterationType === kIsMap) {
                  if (!mapEquiv(a, b, strict, memos)) {
                    return false;
                  }
                } else if (iterationType === kIsArray) {
                  for (; i < a.length; i++) {
                    if (hasOwnProperty(a, i)) {
                      if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
                        return false;
                      }
                    } else if (hasOwnProperty(b, i)) {
                      return false;
                    } else {
                      var keysA = Object.keys(a);
                      for (; i < keysA.length; i++) {
                        var key = keysA[i];
                        if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                          return false;
                        }
                      }
                      if (keysA.length !== Object.keys(b).length) {
                        return false;
                      }
                      return true;
                    }
                  }
                }
                for (i = 0; i < keys.length; i++) {
                  var _key2 = keys[i];
                  if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) {
                    return false;
                  }
                }
                return true;
              }
              function isDeepEqual(val1, val2) {
                return innerDeepEqual(val1, val2, kLoose);
              }
              function isDeepStrictEqual(val1, val2) {
                return innerDeepEqual(val1, val2, kStrict);
              }
              module2.exports = {
                isDeepEqual,
                isDeepStrictEqual
              };
            },
            /***/
            6785(module2) {
              "use strict";
              module2.exports = TypeError;
            },
            /***/
            6811(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              "use strict";
              var __webpack_dirname__ = "/";
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                "default": () => __WEBPACK_DEFAULT_EXPORT__
                /* harmony export */
              });
              var Buffer = __webpack_require__2(783)["Buffer"];
              const normalizeFilename = (filename) => {
                if (filename.indexOf(__webpack_dirname__) === 0) {
                  filename = filename.substring(__webpack_dirname__.length);
                }
                if (filename.indexOf("/") === 0) {
                  filename = filename.substring(1);
                }
                return filename;
              };
              class VirtualFileSystem {
                constructor() {
                  this.storage = {};
                }
                /**
                 * @param {string} filename
                 * @returns {boolean}
                 */
                existsSync(filename) {
                  const normalizedFilename = normalizeFilename(filename);
                  return typeof this.storage[normalizedFilename] !== "undefined";
                }
                /**
                 * @param {string} filename
                 * @param {?string|?object} options
                 * @returns {string|Buffer}
                 */
                readFileSync(filename, options) {
                  const normalizedFilename = normalizeFilename(filename);
                  const encoding = typeof options === "object" ? options.encoding : options;
                  if (!this.existsSync(normalizedFilename)) {
                    throw new Error(`File '${normalizedFilename}' not found in virtual file system`);
                  }
                  const buffer = this.storage[normalizedFilename];
                  if (encoding) {
                    return buffer.toString(encoding);
                  }
                  return buffer;
                }
                /**
                 * @param {string} filename
                 * @param {string|Buffer} content
                 * @param {?string|?object} options
                 */
                writeFileSync(filename, content, options) {
                  const normalizedFilename = normalizeFilename(filename);
                  const encoding = typeof options === "object" ? options.encoding : options;
                  if (!content && !options) {
                    throw new Error("No content");
                  }
                  this.storage[normalizedFilename] = encoding || typeof content === "string" ? new Buffer(content, encoding) : content;
                }
              }
              const __WEBPACK_DEFAULT_EXPORT__ = new VirtualFileSystem();
            },
            /***/
            6818(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(9663), __webpack_require__2(8865));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function() {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var Base = C_lib.Base;
                  var WordArray = C_lib.WordArray;
                  var C_algo = C.algo;
                  var MD5 = C_algo.MD5;
                  var EvpKDF = C_algo.EvpKDF = Base.extend({
                    /**
                     * Configuration options.
                     *
                     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
                     * @property {Hasher} hasher The hash algorithm to use. Default: MD5
                     * @property {number} iterations The number of iterations to perform. Default: 1
                     */
                    cfg: Base.extend({
                      keySize: 128 / 32,
                      hasher: MD5,
                      iterations: 1
                    }),
                    /**
                     * Initializes a newly created key derivation function.
                     *
                     * @param {Object} cfg (Optional) The configuration options to use for the derivation.
                     *
                     * @example
                     *
                     *     var kdf = CryptoJS.algo.EvpKDF.create();
                     *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
                     *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
                     */
                    init: function(cfg) {
                      this.cfg = this.cfg.extend(cfg);
                    },
                    /**
                     * Derives a key from a password.
                     *
                     * @param {WordArray|string} password The password.
                     * @param {WordArray|string} salt A salt.
                     *
                     * @return {WordArray} The derived key.
                     *
                     * @example
                     *
                     *     var key = kdf.compute(password, salt);
                     */
                    compute: function(password, salt) {
                      var block;
                      var cfg = this.cfg;
                      var hasher = cfg.hasher.create();
                      var derivedKey = WordArray.create();
                      var derivedKeyWords = derivedKey.words;
                      var keySize = cfg.keySize;
                      var iterations = cfg.iterations;
                      while (derivedKeyWords.length < keySize) {
                        if (block) {
                          hasher.update(block);
                        }
                        block = hasher.update(password).finalize(salt);
                        hasher.reset();
                        for (var i = 1; i < iterations; i++) {
                          block = hasher.finalize(block);
                          hasher.reset();
                        }
                        derivedKey.concat(block);
                      }
                      derivedKey.sigBytes = keySize * 4;
                      return derivedKey;
                    }
                  });
                  C.EvpKDF = function(password, salt, cfg) {
                    return EvpKDF.create(cfg).compute(password, salt);
                  };
                })();
                return CryptoJS.EvpKDF;
              });
            },
            /***/
            6822(module2) {
              "use strict";
              module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
            },
            /***/
            6843(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(2858));
                } else {
                }
              })(void 0, function(CryptoJS) {
                CryptoJS.mode.CTR = function() {
                  var CTR = CryptoJS.lib.BlockCipherMode.extend();
                  var Encryptor = CTR.Encryptor = CTR.extend({
                    processBlock: function(words, offset) {
                      var cipher = this._cipher;
                      var blockSize = cipher.blockSize;
                      var iv = this._iv;
                      var counter = this._counter;
                      if (iv) {
                        counter = this._counter = iv.slice(0);
                        this._iv = void 0;
                      }
                      var keystream = counter.slice(0);
                      cipher.encryptBlock(keystream, 0);
                      counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
                      for (var i = 0; i < blockSize; i++) {
                        words[offset + i] ^= keystream[i];
                      }
                    }
                  });
                  CTR.Decryptor = Encryptor;
                  return CTR;
                }();
                return CryptoJS.mode.CTR;
              });
            },
            /***/
            6861(module2, exports2, __webpack_require__2) {
              "use strict";
              __webpack_require__2(8376);
              __webpack_require__2(6401);
              __webpack_require__2(2017);
              ;
              (function(root, factory) {
                if (true) {
                  module2.exports = exports2 = factory();
                } else {
                }
              })(void 0, function() {
                var CryptoJS = CryptoJS || function(Math2, undefined2) {
                  var crypto;
                  if (typeof window !== "undefined" && window.crypto) {
                    crypto = window.crypto;
                  }
                  if (typeof self !== "undefined" && self.crypto) {
                    crypto = self.crypto;
                  }
                  if (typeof globalThis !== "undefined" && globalThis.crypto) {
                    crypto = globalThis.crypto;
                  }
                  if (!crypto && typeof window !== "undefined" && window.msCrypto) {
                    crypto = window.msCrypto;
                  }
                  if (!crypto && typeof __webpack_require__2.g !== "undefined" && __webpack_require__2.g.crypto) {
                    crypto = __webpack_require__2.g.crypto;
                  }
                  if (!crypto && true) {
                    try {
                      crypto = __webpack_require__2(477);
                    } catch (err) {
                    }
                  }
                  var cryptoSecureRandomInt = function() {
                    if (crypto) {
                      if (typeof crypto.getRandomValues === "function") {
                        try {
                          return crypto.getRandomValues(new Uint32Array(1))[0];
                        } catch (err) {
                        }
                      }
                      if (typeof crypto.randomBytes === "function") {
                        try {
                          return crypto.randomBytes(4).readInt32LE();
                        } catch (err) {
                        }
                      }
                    }
                    throw new Error("Native crypto module could not be used to get secure random number.");
                  };
                  var create = Object.create || /* @__PURE__ */ function() {
                    function F() {
                    }
                    return function(obj) {
                      var subtype;
                      F.prototype = obj;
                      subtype = new F();
                      F.prototype = null;
                      return subtype;
                    };
                  }();
                  var C = {};
                  var C_lib = C.lib = {};
                  var Base = C_lib.Base = /* @__PURE__ */ function() {
                    return {
                      /**
                       * Creates a new object that inherits from this object.
                       *
                       * @param {Object} overrides Properties to copy into the new object.
                       *
                       * @return {Object} The new object.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var MyType = CryptoJS.lib.Base.extend({
                       *         field: 'value',
                       *
                       *         method: function () {
                       *         }
                       *     });
                       */
                      extend: function(overrides) {
                        var subtype = create(this);
                        if (overrides) {
                          subtype.mixIn(overrides);
                        }
                        if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                          subtype.init = function() {
                            subtype.$super.init.apply(this, arguments);
                          };
                        }
                        subtype.init.prototype = subtype;
                        subtype.$super = this;
                        return subtype;
                      },
                      /**
                       * Extends this object and runs the init method.
                       * Arguments to create() will be passed to init().
                       *
                       * @return {Object} The new object.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var instance = MyType.create();
                       */
                      create: function() {
                        var instance = this.extend();
                        instance.init.apply(instance, arguments);
                        return instance;
                      },
                      /**
                       * Initializes a newly created object.
                       * Override this method to add some logic when your objects are created.
                       *
                       * @example
                       *
                       *     var MyType = CryptoJS.lib.Base.extend({
                       *         init: function () {
                       *             // ...
                       *         }
                       *     });
                       */
                      init: function() {
                      },
                      /**
                       * Copies properties into this object.
                       *
                       * @param {Object} properties The properties to mix in.
                       *
                       * @example
                       *
                       *     MyType.mixIn({
                       *         field: 'value'
                       *     });
                       */
                      mixIn: function(properties) {
                        for (var propertyName in properties) {
                          if (properties.hasOwnProperty(propertyName)) {
                            this[propertyName] = properties[propertyName];
                          }
                        }
                        if (properties.hasOwnProperty("toString")) {
                          this.toString = properties.toString;
                        }
                      },
                      /**
                       * Creates a copy of this object.
                       *
                       * @return {Object} The clone.
                       *
                       * @example
                       *
                       *     var clone = instance.clone();
                       */
                      clone: function() {
                        return this.init.prototype.extend(this);
                      }
                    };
                  }();
                  var WordArray = C_lib.WordArray = Base.extend({
                    /**
                     * Initializes a newly created word array.
                     *
                     * @param {Array} words (Optional) An array of 32-bit words.
                     * @param {number} sigBytes (Optional) The number of significant bytes in the words.
                     *
                     * @example
                     *
                     *     var wordArray = CryptoJS.lib.WordArray.create();
                     *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
                     *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
                     */
                    init: function(words, sigBytes) {
                      words = this.words = words || [];
                      if (sigBytes != undefined2) {
                        this.sigBytes = sigBytes;
                      } else {
                        this.sigBytes = words.length * 4;
                      }
                    },
                    /**
                     * Converts this word array to a string.
                     *
                     * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
                     *
                     * @return {string} The stringified word array.
                     *
                     * @example
                     *
                     *     var string = wordArray + '';
                     *     var string = wordArray.toString();
                     *     var string = wordArray.toString(CryptoJS.enc.Utf8);
                     */
                    toString: function(encoder) {
                      return (encoder || Hex).stringify(this);
                    },
                    /**
                     * Concatenates a word array to this word array.
                     *
                     * @param {WordArray} wordArray The word array to append.
                     *
                     * @return {WordArray} This word array.
                     *
                     * @example
                     *
                     *     wordArray1.concat(wordArray2);
                     */
                    concat: function(wordArray) {
                      var thisWords = this.words;
                      var thatWords = wordArray.words;
                      var thisSigBytes = this.sigBytes;
                      var thatSigBytes = wordArray.sigBytes;
                      this.clamp();
                      if (thisSigBytes % 4) {
                        for (var i = 0; i < thatSigBytes; i++) {
                          var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                          thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
                        }
                      } else {
                        for (var j = 0; j < thatSigBytes; j += 4) {
                          thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
                        }
                      }
                      this.sigBytes += thatSigBytes;
                      return this;
                    },
                    /**
                     * Removes insignificant bits.
                     *
                     * @example
                     *
                     *     wordArray.clamp();
                     */
                    clamp: function() {
                      var words = this.words;
                      var sigBytes = this.sigBytes;
                      words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
                      words.length = Math2.ceil(sigBytes / 4);
                    },
                    /**
                     * Creates a copy of this word array.
                     *
                     * @return {WordArray} The clone.
                     *
                     * @example
                     *
                     *     var clone = wordArray.clone();
                     */
                    clone: function() {
                      var clone = Base.clone.call(this);
                      clone.words = this.words.slice(0);
                      return clone;
                    },
                    /**
                     * Creates a word array filled with random bytes.
                     *
                     * @param {number} nBytes The number of random bytes to generate.
                     *
                     * @return {WordArray} The random word array.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var wordArray = CryptoJS.lib.WordArray.random(16);
                     */
                    random: function(nBytes) {
                      var words = [];
                      for (var i = 0; i < nBytes; i += 4) {
                        words.push(cryptoSecureRandomInt());
                      }
                      return new WordArray.init(words, nBytes);
                    }
                  });
                  var C_enc = C.enc = {};
                  var Hex = C_enc.Hex = {
                    /**
                     * Converts a word array to a hex string.
                     *
                     * @param {WordArray} wordArray The word array.
                     *
                     * @return {string} The hex string.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
                     */
                    stringify: function(wordArray) {
                      var words = wordArray.words;
                      var sigBytes = wordArray.sigBytes;
                      var hexChars = [];
                      for (var i = 0; i < sigBytes; i++) {
                        var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                        hexChars.push((bite >>> 4).toString(16));
                        hexChars.push((bite & 15).toString(16));
                      }
                      return hexChars.join("");
                    },
                    /**
                     * Converts a hex string to a word array.
                     *
                     * @param {string} hexStr The hex string.
                     *
                     * @return {WordArray} The word array.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
                     */
                    parse: function(hexStr) {
                      var hexStrLength = hexStr.length;
                      var words = [];
                      for (var i = 0; i < hexStrLength; i += 2) {
                        words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
                      }
                      return new WordArray.init(words, hexStrLength / 2);
                    }
                  };
                  var Latin1 = C_enc.Latin1 = {
                    /**
                     * Converts a word array to a Latin1 string.
                     *
                     * @param {WordArray} wordArray The word array.
                     *
                     * @return {string} The Latin1 string.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
                     */
                    stringify: function(wordArray) {
                      var words = wordArray.words;
                      var sigBytes = wordArray.sigBytes;
                      var latin1Chars = [];
                      for (var i = 0; i < sigBytes; i++) {
                        var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                        latin1Chars.push(String.fromCharCode(bite));
                      }
                      return latin1Chars.join("");
                    },
                    /**
                     * Converts a Latin1 string to a word array.
                     *
                     * @param {string} latin1Str The Latin1 string.
                     *
                     * @return {WordArray} The word array.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
                     */
                    parse: function(latin1Str) {
                      var latin1StrLength = latin1Str.length;
                      var words = [];
                      for (var i = 0; i < latin1StrLength; i++) {
                        words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
                      }
                      return new WordArray.init(words, latin1StrLength);
                    }
                  };
                  var Utf8 = C_enc.Utf8 = {
                    /**
                     * Converts a word array to a UTF-8 string.
                     *
                     * @param {WordArray} wordArray The word array.
                     *
                     * @return {string} The UTF-8 string.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
                     */
                    stringify: function(wordArray) {
                      try {
                        return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                      } catch (e) {
                        throw new Error("Malformed UTF-8 data");
                      }
                    },
                    /**
                     * Converts a UTF-8 string to a word array.
                     *
                     * @param {string} utf8Str The UTF-8 string.
                     *
                     * @return {WordArray} The word array.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
                     */
                    parse: function(utf8Str) {
                      return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
                    }
                  };
                  var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
                    /**
                     * Resets this block algorithm's data buffer to its initial state.
                     *
                     * @example
                     *
                     *     bufferedBlockAlgorithm.reset();
                     */
                    reset: function() {
                      this._data = new WordArray.init();
                      this._nDataBytes = 0;
                    },
                    /**
                     * Adds new data to this block algorithm's buffer.
                     *
                     * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
                     *
                     * @example
                     *
                     *     bufferedBlockAlgorithm._append('data');
                     *     bufferedBlockAlgorithm._append(wordArray);
                     */
                    _append: function(data) {
                      if (typeof data == "string") {
                        data = Utf8.parse(data);
                      }
                      this._data.concat(data);
                      this._nDataBytes += data.sigBytes;
                    },
                    /**
                     * Processes available data blocks.
                     *
                     * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
                     *
                     * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
                     *
                     * @return {WordArray} The processed data.
                     *
                     * @example
                     *
                     *     var processedData = bufferedBlockAlgorithm._process();
                     *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
                     */
                    _process: function(doFlush) {
                      var processedWords;
                      var data = this._data;
                      var dataWords = data.words;
                      var dataSigBytes = data.sigBytes;
                      var blockSize = this.blockSize;
                      var blockSizeBytes = blockSize * 4;
                      var nBlocksReady = dataSigBytes / blockSizeBytes;
                      if (doFlush) {
                        nBlocksReady = Math2.ceil(nBlocksReady);
                      } else {
                        nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
                      }
                      var nWordsReady = nBlocksReady * blockSize;
                      var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
                      if (nWordsReady) {
                        for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                          this._doProcessBlock(dataWords, offset);
                        }
                        processedWords = dataWords.splice(0, nWordsReady);
                        data.sigBytes -= nBytesReady;
                      }
                      return new WordArray.init(processedWords, nBytesReady);
                    },
                    /**
                     * Creates a copy of this object.
                     *
                     * @return {Object} The clone.
                     *
                     * @example
                     *
                     *     var clone = bufferedBlockAlgorithm.clone();
                     */
                    clone: function() {
                      var clone = Base.clone.call(this);
                      clone._data = this._data.clone();
                      return clone;
                    },
                    _minBufferSize: 0
                  });
                  var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
                    /**
                     * Configuration options.
                     */
                    cfg: Base.extend(),
                    /**
                     * Initializes a newly created hasher.
                     *
                     * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
                     *
                     * @example
                     *
                     *     var hasher = CryptoJS.algo.SHA256.create();
                     */
                    init: function(cfg) {
                      this.cfg = this.cfg.extend(cfg);
                      this.reset();
                    },
                    /**
                     * Resets this hasher to its initial state.
                     *
                     * @example
                     *
                     *     hasher.reset();
                     */
                    reset: function() {
                      BufferedBlockAlgorithm.reset.call(this);
                      this._doReset();
                    },
                    /**
                     * Updates this hasher with a message.
                     *
                     * @param {WordArray|string} messageUpdate The message to append.
                     *
                     * @return {Hasher} This hasher.
                     *
                     * @example
                     *
                     *     hasher.update('message');
                     *     hasher.update(wordArray);
                     */
                    update: function(messageUpdate) {
                      this._append(messageUpdate);
                      this._process();
                      return this;
                    },
                    /**
                     * Finalizes the hash computation.
                     * Note that the finalize operation is effectively a destructive, read-once operation.
                     *
                     * @param {WordArray|string} messageUpdate (Optional) A final message update.
                     *
                     * @return {WordArray} The hash.
                     *
                     * @example
                     *
                     *     var hash = hasher.finalize();
                     *     var hash = hasher.finalize('message');
                     *     var hash = hasher.finalize(wordArray);
                     */
                    finalize: function(messageUpdate) {
                      if (messageUpdate) {
                        this._append(messageUpdate);
                      }
                      var hash = this._doFinalize();
                      return hash;
                    },
                    blockSize: 512 / 32,
                    /**
                     * Creates a shortcut function to a hasher's object interface.
                     *
                     * @param {Hasher} hasher The hasher to create a helper for.
                     *
                     * @return {Function} The shortcut function.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
                     */
                    _createHelper: function(hasher) {
                      return function(message, cfg) {
                        return new hasher.init(cfg).finalize(message);
                      };
                    },
                    /**
                     * Creates a shortcut function to the HMAC's object interface.
                     *
                     * @param {Hasher} hasher The hasher to use in this HMAC helper.
                     *
                     * @return {Function} The shortcut function.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
                     */
                    _createHmacHelper: function(hasher) {
                      return function(message, key) {
                        return new C_algo.HMAC.init(hasher, key).finalize(message);
                      };
                    }
                  });
                  var C_algo = C.algo = {};
                  return C;
                }(Math);
                return CryptoJS;
              });
            },
            /***/
            6911(module2) {
              "use strict";
              function adler32(adler, buf, len, pos) {
                var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
                while (len !== 0) {
                  n = len > 2e3 ? 2e3 : len;
                  len -= n;
                  do {
                    s1 = s1 + buf[pos++] | 0;
                    s2 = s2 + s1 | 0;
                  } while (--n);
                  s1 %= 65521;
                  s2 %= 65521;
                }
                return s1 | s2 << 16 | 0;
              }
              module2.exports = adler32;
            },
            /***/
            6921(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var NATIVE_WEAK_MAP = __webpack_require__2(1194);
              var globalThis2 = __webpack_require__2(7756);
              var isObject = __webpack_require__2(3598);
              var createNonEnumerableProperty = __webpack_require__2(5719);
              var hasOwn = __webpack_require__2(6341);
              var shared = __webpack_require__2(3793);
              var sharedKey = __webpack_require__2(7099);
              var hiddenKeys = __webpack_require__2(2993);
              var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
              var TypeError2 = globalThis2.TypeError;
              var WeakMap2 = globalThis2.WeakMap;
              var set, get, has;
              var enforce = function(it) {
                return has(it) ? get(it) : set(it, {});
              };
              var getterFor = function(TYPE) {
                return function(it) {
                  var state;
                  if (!isObject(it) || (state = get(it)).type !== TYPE) {
                    throw new TypeError2("Incompatible receiver, " + TYPE + " required");
                  }
                  return state;
                };
              };
              if (NATIVE_WEAK_MAP || shared.state) {
                var store = shared.state || (shared.state = new WeakMap2());
                store.get = store.get;
                store.has = store.has;
                store.set = store.set;
                set = function(it, metadata) {
                  if (store.has(it)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
                  metadata.facade = it;
                  store.set(it, metadata);
                  return metadata;
                };
                get = function(it) {
                  return store.get(it) || {};
                };
                has = function(it) {
                  return store.has(it);
                };
              } else {
                var STATE = sharedKey("state");
                hiddenKeys[STATE] = true;
                set = function(it, metadata) {
                  if (hasOwn(it, STATE)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
                  metadata.facade = it;
                  createNonEnumerableProperty(it, STATE, metadata);
                  return metadata;
                };
                get = function(it) {
                  return hasOwn(it, STATE) ? it[STATE] : {};
                };
                has = function(it) {
                  return hasOwn(it, STATE);
                };
              }
              module2.exports = {
                set,
                get,
                has,
                enforce,
                getterFor
              };
            },
            /***/
            7043(__unused_webpack_module, exports2) {
              var CONTEXT_LSB6 = 0;
              var CONTEXT_MSB6 = 1;
              var CONTEXT_UTF8 = 2;
              var CONTEXT_SIGNED = 3;
              exports2.lookup = new Uint8Array([
                /* CONTEXT_UTF8, last byte. */
                /* ASCII range. */
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                4,
                4,
                0,
                0,
                4,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                8,
                12,
                16,
                12,
                12,
                20,
                12,
                16,
                24,
                28,
                12,
                12,
                32,
                12,
                36,
                12,
                44,
                44,
                44,
                44,
                44,
                44,
                44,
                44,
                44,
                44,
                32,
                32,
                24,
                40,
                28,
                12,
                12,
                48,
                52,
                52,
                52,
                48,
                52,
                52,
                52,
                48,
                52,
                52,
                52,
                52,
                52,
                48,
                52,
                52,
                52,
                52,
                52,
                48,
                52,
                52,
                52,
                52,
                52,
                24,
                12,
                28,
                12,
                12,
                12,
                56,
                60,
                60,
                60,
                56,
                60,
                60,
                60,
                56,
                60,
                60,
                60,
                60,
                60,
                56,
                60,
                60,
                60,
                60,
                60,
                56,
                60,
                60,
                60,
                60,
                60,
                24,
                12,
                28,
                12,
                0,
                /* UTF8 continuation byte range. */
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                /* UTF8 lead byte range. */
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                2,
                3,
                /* CONTEXT_UTF8 second last byte. */
                /* ASCII range. */
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                1,
                1,
                1,
                1,
                1,
                1,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                1,
                1,
                1,
                1,
                0,
                /* UTF8 continuation byte range. */
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                /* UTF8 lead byte range. */
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                /* CONTEXT_SIGNED, second last byte. */
                0,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                1,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                2,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                3,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                4,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                5,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                6,
                7,
                /* CONTEXT_SIGNED, last byte, same as the above values shifted by 3 bits. */
                0,
                8,
                8,
                8,
                8,
                8,
                8,
                8,
                8,
                8,
                8,
                8,
                8,
                8,
                8,
                8,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                16,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                24,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                32,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                40,
                48,
                48,
                48,
                48,
                48,
                48,
                48,
                48,
                48,
                48,
                48,
                48,
                48,
                48,
                48,
                56,
                /* CONTEXT_LSB6, last byte. */
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51,
                52,
                53,
                54,
                55,
                56,
                57,
                58,
                59,
                60,
                61,
                62,
                63,
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51,
                52,
                53,
                54,
                55,
                56,
                57,
                58,
                59,
                60,
                61,
                62,
                63,
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51,
                52,
                53,
                54,
                55,
                56,
                57,
                58,
                59,
                60,
                61,
                62,
                63,
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51,
                52,
                53,
                54,
                55,
                56,
                57,
                58,
                59,
                60,
                61,
                62,
                63,
                /* CONTEXT_MSB6, last byte. */
                0,
                0,
                0,
                0,
                1,
                1,
                1,
                1,
                2,
                2,
                2,
                2,
                3,
                3,
                3,
                3,
                4,
                4,
                4,
                4,
                5,
                5,
                5,
                5,
                6,
                6,
                6,
                6,
                7,
                7,
                7,
                7,
                8,
                8,
                8,
                8,
                9,
                9,
                9,
                9,
                10,
                10,
                10,
                10,
                11,
                11,
                11,
                11,
                12,
                12,
                12,
                12,
                13,
                13,
                13,
                13,
                14,
                14,
                14,
                14,
                15,
                15,
                15,
                15,
                16,
                16,
                16,
                16,
                17,
                17,
                17,
                17,
                18,
                18,
                18,
                18,
                19,
                19,
                19,
                19,
                20,
                20,
                20,
                20,
                21,
                21,
                21,
                21,
                22,
                22,
                22,
                22,
                23,
                23,
                23,
                23,
                24,
                24,
                24,
                24,
                25,
                25,
                25,
                25,
                26,
                26,
                26,
                26,
                27,
                27,
                27,
                27,
                28,
                28,
                28,
                28,
                29,
                29,
                29,
                29,
                30,
                30,
                30,
                30,
                31,
                31,
                31,
                31,
                32,
                32,
                32,
                32,
                33,
                33,
                33,
                33,
                34,
                34,
                34,
                34,
                35,
                35,
                35,
                35,
                36,
                36,
                36,
                36,
                37,
                37,
                37,
                37,
                38,
                38,
                38,
                38,
                39,
                39,
                39,
                39,
                40,
                40,
                40,
                40,
                41,
                41,
                41,
                41,
                42,
                42,
                42,
                42,
                43,
                43,
                43,
                43,
                44,
                44,
                44,
                44,
                45,
                45,
                45,
                45,
                46,
                46,
                46,
                46,
                47,
                47,
                47,
                47,
                48,
                48,
                48,
                48,
                49,
                49,
                49,
                49,
                50,
                50,
                50,
                50,
                51,
                51,
                51,
                51,
                52,
                52,
                52,
                52,
                53,
                53,
                53,
                53,
                54,
                54,
                54,
                54,
                55,
                55,
                55,
                55,
                56,
                56,
                56,
                56,
                57,
                57,
                57,
                57,
                58,
                58,
                58,
                58,
                59,
                59,
                59,
                59,
                60,
                60,
                60,
                60,
                61,
                61,
                61,
                61,
                62,
                62,
                62,
                62,
                63,
                63,
                63,
                63,
                /* CONTEXT_{M,L}SB6, second last byte, */
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
              ]);
              exports2.lookupOffsets = new Uint16Array([
                /* CONTEXT_LSB6 */
                1024,
                1536,
                /* CONTEXT_MSB6 */
                1280,
                1536,
                /* CONTEXT_UTF8 */
                0,
                256,
                /* CONTEXT_SIGNED */
                768,
                512
              ]);
            },
            /***/
            7051(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var callBind = __webpack_require__2(6601);
              var define2 = __webpack_require__2(5421);
              var implementation = __webpack_require__2(2621);
              var getPolyfill = __webpack_require__2(1320);
              var shim = __webpack_require__2(5074);
              var polyfill = callBind(getPolyfill(), Number);
              define2(polyfill, {
                getPolyfill,
                implementation,
                shim
              });
              module2.exports = polyfill;
            },
            /***/
            7099(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var shared = __webpack_require__2(997);
              var uid = __webpack_require__2(6044);
              var keys = shared("keys");
              module2.exports = function(key) {
                return keys[key] || (keys[key] = uid(key));
              };
            },
            /***/
            7106(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var reflectGetProto = __webpack_require__2(6822);
              var originalGetProto = __webpack_require__2(3766);
              var getDunderProto = __webpack_require__2(9302);
              module2.exports = reflectGetProto ? function getProto(O) {
                return reflectGetProto(O);
              } : originalGetProto ? function getProto(O) {
                if (!O || typeof O !== "object" && typeof O !== "function") {
                  throw new TypeError("getProto: not an object");
                }
                return originalGetProto(O);
              } : getDunderProto ? function getProto(O) {
                return getDunderProto(O);
              } : null;
            },
            /***/
            7133(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              "use strict";
              __webpack_require__2.d(__webpack_exports__2, {
                "default": () => (
                  /* binding */
                  browser_extensions
                )
              });
              var pdfkit_es = __webpack_require__2(3232);
              ;
              var Buffer = __webpack_require__2(783)["Buffer"];
              const typeName = (bold, italics) => {
                let type = "normal";
                if (bold && italics) {
                  type = "bolditalics";
                } else if (bold) {
                  type = "bold";
                } else if (italics) {
                  type = "italics";
                }
                return type;
              };
              class PDFDocument extends pdfkit_es.A {
                constructor(fonts, images, patterns, attachments, options, virtualfs) {
                  if (fonts === void 0) {
                    fonts = {};
                  }
                  if (images === void 0) {
                    images = {};
                  }
                  if (patterns === void 0) {
                    patterns = {};
                  }
                  if (attachments === void 0) {
                    attachments = {};
                  }
                  if (options === void 0) {
                    options = {};
                  }
                  if (virtualfs === void 0) {
                    virtualfs = null;
                  }
                  super(options);
                  this.fonts = {};
                  this.fontCache = {};
                  for (let font in fonts) {
                    if (fonts.hasOwnProperty(font)) {
                      let fontDef = fonts[font];
                      this.fonts[font] = {
                        normal: fontDef.normal,
                        bold: fontDef.bold,
                        italics: fontDef.italics,
                        bolditalics: fontDef.bolditalics
                      };
                    }
                  }
                  this.patterns = {};
                  for (let pattern in patterns) {
                    if (patterns.hasOwnProperty(pattern)) {
                      let patternDef = patterns[pattern];
                      this.patterns[pattern] = this.pattern(patternDef.boundingBox, patternDef.xStep, patternDef.yStep, patternDef.pattern, patternDef.colored);
                    }
                  }
                  this.images = images;
                  this.attachments = attachments;
                  this.virtualfs = virtualfs;
                }
                getFontType(bold, italics) {
                  return typeName(bold, italics);
                }
                getFontFile(familyName, bold, italics) {
                  let type = this.getFontType(bold, italics);
                  if (!this.fonts[familyName] || !this.fonts[familyName][type]) {
                    return null;
                  }
                  return this.fonts[familyName][type];
                }
                provideFont(familyName, bold, italics) {
                  let type = this.getFontType(bold, italics);
                  if (this.getFontFile(familyName, bold, italics) === null) {
                    throw new Error(`Font '${familyName}' in style '${type}' is not defined in the font section of the document definition.`);
                  }
                  this.fontCache[familyName] = this.fontCache[familyName] || {};
                  if (!this.fontCache[familyName][type]) {
                    let def = this.fonts[familyName][type];
                    if (!Array.isArray(def)) {
                      def = [def];
                    }
                    if (this.virtualfs && this.virtualfs.existsSync(def[0])) {
                      def[0] = this.virtualfs.readFileSync(def[0]);
                    }
                    this.fontCache[familyName][type] = this.font(...def)._font;
                  }
                  return this.fontCache[familyName][type];
                }
                provideImage(src) {
                  const realImageSrc = (src2) => {
                    let image2 = this.images[src2];
                    if (!image2) {
                      return src2;
                    }
                    if (this.virtualfs && this.virtualfs.existsSync(image2)) {
                      return this.virtualfs.readFileSync(image2);
                    }
                    let index = image2.indexOf("base64,");
                    if (index < 0) {
                      return this.images[src2];
                    }
                    return Buffer.from(image2.substring(index + 7), "base64");
                  };
                  if (this._imageRegistry[src]) {
                    return this._imageRegistry[src];
                  }
                  let image;
                  try {
                    image = this.openImage(realImageSrc(src));
                    if (!image) {
                      throw new Error("No image");
                    }
                  } catch (error) {
                    throw new Error(`Invalid image: ${error.toString()}
Images dictionary should contain dataURL entries (or local file paths in node.js)`);
                  }
                  image.embed(this);
                  this._imageRegistry[src] = image;
                  return image;
                }
                /**
                 * @param {Array} color pdfmake format: [<pattern name>, <color>]
                 * @returns {Array} pdfkit format: [<pattern object>, <color>]
                 */
                providePattern(color) {
                  if (Array.isArray(color) && color.length === 2) {
                    return [this.patterns[color[0]], color[1]];
                  }
                  return null;
                }
                provideAttachment(src) {
                  const checkRequired = (obj) => {
                    if (!obj) {
                      throw new Error("No attachment");
                    }
                    if (!obj.src) {
                      throw new Error('The "src" key is required for attachments');
                    }
                    return obj;
                  };
                  if (typeof src === "object") {
                    return checkRequired(src);
                  }
                  let attachment = checkRequired(this.attachments[src]);
                  if (this.virtualfs && this.virtualfs.existsSync(attachment.src)) {
                    return this.virtualfs.readFileSync(attachment.src);
                  }
                  return attachment;
                }
                setOpenActionAsPrint() {
                  let printActionRef = this.ref({
                    Type: "Action",
                    S: "Named",
                    N: "Print"
                  });
                  this._root.data.OpenAction = printActionRef;
                  printActionRef.end();
                }
              }
              const src_PDFDocument = PDFDocument;
              ;
              function isString(variable) {
                return typeof variable === "string" || variable instanceof String;
              }
              function isNumber(variable) {
                return (typeof variable === "number" || variable instanceof Number) && !Number.isNaN(variable);
              }
              function isPositiveInteger(variable) {
                if (!isNumber(variable) || !Number.isInteger(variable) || variable <= 0) {
                  return false;
                }
                return true;
              }
              function isObject(variable) {
                return variable !== null && !Array.isArray(variable) && !isString(variable) && !isNumber(variable) && typeof variable === "object";
              }
              function isEmptyObject(variable) {
                return isObject(variable) && Object.keys(variable).length === 0;
              }
              function isValue(variable) {
                return variable !== void 0 && variable !== null;
              }
              ;
              function fontStringify(key, val) {
                if (key === "font") {
                  return "font";
                }
                return val;
              }
              function stringifyNode(node) {
                return JSON.stringify(node, fontStringify);
              }
              function getNodeId(node) {
                if (node.id) {
                  return node.id;
                }
                if (Array.isArray(node.text)) {
                  for (let n of node.text) {
                    let nodeId = getNodeId(n);
                    if (nodeId) {
                      return nodeId;
                    }
                  }
                }
                return null;
              }
              function getNodeMargin(node, styleStack) {
                function processSingleMargins(node2, currentMargin, defaultMargin) {
                  if (defaultMargin === void 0) {
                    defaultMargin = 0;
                  }
                  if (node2.marginLeft !== void 0 || node2.marginTop !== void 0 || node2.marginRight !== void 0 || node2.marginBottom !== void 0) {
                    return [node2.marginLeft ?? currentMargin[0] ?? defaultMargin, node2.marginTop ?? currentMargin[1] ?? defaultMargin, node2.marginRight ?? currentMargin[2] ?? defaultMargin, node2.marginBottom ?? currentMargin[3] ?? defaultMargin];
                  }
                  return currentMargin;
                }
                function flattenStyleArray(styleArray, styleStack2, visited) {
                  if (visited === void 0) {
                    visited = /* @__PURE__ */ new Set();
                  }
                  styleArray = Array.isArray(styleArray) ? styleArray : [styleArray];
                  if (!styleArray.every((item) => isString(item))) {
                    return {};
                  }
                  let flattenedStyles = {};
                  for (let index = 0; index < styleArray.length; index++) {
                    let styleName = styleArray[index];
                    let style = styleStack2.styleDictionary[styleName];
                    if (style === void 0) {
                      continue;
                    }
                    if (visited.has(styleName)) {
                      continue;
                    }
                    visited.add(styleName);
                    if (style.extends !== void 0) {
                      flattenedStyles = {
                        ...flattenStyleArray(style.extends, styleStack2, visited),
                        ...flattenedStyles
                      };
                    }
                    if (style.margin !== void 0) {
                      flattenedStyles = {
                        margin: convertMargin(style.margin)
                      };
                      continue;
                    }
                    flattenedStyles = {
                      margin: processSingleMargins(style, flattenedStyles.margin ?? {}, void 0)
                    };
                  }
                  return flattenedStyles;
                }
                function convertMargin(margin2) {
                  if (isNumber(margin2)) {
                    margin2 = [margin2, margin2, margin2, margin2];
                  } else if (Array.isArray(margin2)) {
                    if (margin2.length === 2) {
                      margin2 = [margin2[0], margin2[1], margin2[0], margin2[1]];
                    }
                  }
                  return margin2;
                }
                let margin = [void 0, void 0, void 0, void 0];
                if (node.style) {
                  let styleArray = Array.isArray(node.style) ? node.style : [node.style];
                  let flattenedStyleArray = flattenStyleArray(styleArray, styleStack);
                  if (flattenedStyleArray) {
                    margin = processSingleMargins(flattenedStyleArray, margin);
                  }
                  if (flattenedStyleArray.margin) {
                    margin = convertMargin(flattenedStyleArray.margin);
                  }
                }
                margin = processSingleMargins(node, margin);
                if (node.margin !== void 0) {
                  margin = convertMargin(node.margin);
                }
                if (margin[0] === void 0 && margin[1] === void 0 && margin[2] === void 0 && margin[3] === void 0) {
                  return null;
                }
                return margin;
              }
              ;
              var DocPreprocessor_Buffer = __webpack_require__2(783)["Buffer"];
              const convertValueToString = (value) => {
                if (isString(value)) {
                  return value.replace(/\t/g, "    ");
                } else if (isNumber(value) || typeof value === "boolean") {
                  return value.toString();
                } else if (!isValue(value) || isEmptyObject(value)) {
                  return "";
                }
                return value;
              };
              class DocPreprocessor {
                preprocessDocument(docStructure) {
                  this.parentNode = null;
                  this.tocs = [];
                  this.nodeReferences = [];
                  return this.preprocessNode(docStructure, true);
                }
                preprocessBlock(node) {
                  this.parentNode = null;
                  this.tocs = [];
                  this.nodeReferences = [];
                  return this.preprocessNode(node);
                }
                preprocessNode(node, isSectionAllowed) {
                  if (isSectionAllowed === void 0) {
                    isSectionAllowed = false;
                  }
                  if (Array.isArray(node)) {
                    node = {
                      stack: node
                    };
                  } else if (isString(node) || isNumber(node) || typeof node === "boolean" || !isValue(node) || isEmptyObject(node)) {
                    node = {
                      text: convertValueToString(node)
                    };
                  } else if ("text" in node) {
                    node.text = convertValueToString(node.text);
                  }
                  if (node.section) {
                    if (!isSectionAllowed) {
                      throw new Error(`Incorrect document structure, section node is only allowed at the root level of document structure: ${stringifyNode(node)}`);
                    }
                    return this.preprocessSection(node);
                  } else if (node.columns) {
                    return this.preprocessColumns(node);
                  } else if (node.stack) {
                    return this.preprocessVerticalContainer(node, isSectionAllowed);
                  } else if (node.ul) {
                    return this.preprocessList(node);
                  } else if (node.ol) {
                    return this.preprocessList(node);
                  } else if (node.table) {
                    return this.preprocessTable(node);
                  } else if (node.text !== void 0) {
                    return this.preprocessText(node);
                  } else if (node.toc) {
                    return this.preprocessToc(node);
                  } else if (node.image) {
                    return this.preprocessImage(node);
                  } else if (node.svg) {
                    return this.preprocessSVG(node);
                  } else if (node.canvas) {
                    return this.preprocessCanvas(node);
                  } else if (node.qr) {
                    return this.preprocessQr(node);
                  } else if (node.attachment) {
                    return this.preprocessAttachment(node);
                  } else if (node.pageReference || node.textReference) {
                    return this.preprocessText(node);
                  } else {
                    throw new Error(`Unrecognized document structure: ${stringifyNode(node)}`);
                  }
                }
                preprocessSection(node) {
                  node.section = this.preprocessNode(node.section);
                  return node;
                }
                preprocessColumns(node) {
                  let columns = node.columns;
                  for (let i2 = 0, l = columns.length; i2 < l; i2++) {
                    columns[i2] = this.preprocessNode(columns[i2]);
                  }
                  return node;
                }
                preprocessVerticalContainer(node, isSectionAllowed) {
                  let items = node.stack;
                  for (let i2 = 0, l = items.length; i2 < l; i2++) {
                    items[i2] = this.preprocessNode(items[i2], isSectionAllowed);
                  }
                  return node;
                }
                preprocessList(node) {
                  let items = node.ul || node.ol;
                  for (let i2 = 0, l = items.length; i2 < l; i2++) {
                    items[i2] = this.preprocessNode(items[i2]);
                  }
                  return node;
                }
                preprocessTable(node) {
                  let col;
                  let row;
                  let cols;
                  let rows;
                  for (col = 0, cols = node.table.body[0].length; col < cols; col++) {
                    for (row = 0, rows = node.table.body.length; row < rows; row++) {
                      let rowData = node.table.body[row];
                      let data = rowData[col];
                      if (data !== void 0) {
                        if (data === null) {
                          data = "";
                        }
                        if (!data._span) {
                          rowData[col] = this.preprocessNode(data);
                        }
                      }
                    }
                  }
                  return node;
                }
                preprocessText(node) {
                  if (node.tocItem) {
                    if (!Array.isArray(node.tocItem)) {
                      node.tocItem = [node.tocItem];
                    }
                    for (let i2 = 0, l = node.tocItem.length; i2 < l; i2++) {
                      if (!isString(node.tocItem[i2])) {
                        node.tocItem[i2] = "_default_";
                      }
                      let tocItemId = node.tocItem[i2];
                      if (!this.tocs[tocItemId]) {
                        this.tocs[tocItemId] = {
                          toc: {
                            _items: [],
                            _pseudo: true
                          }
                        };
                      }
                      if (!node.id) {
                        node.id = `toc-${tocItemId}-${this.tocs[tocItemId].toc._items.length}`;
                      }
                      let tocItemRef = {
                        _nodeRef: this._getNodeForNodeRef(node),
                        _textNodeRef: node
                      };
                      this.tocs[tocItemId].toc._items.push(tocItemRef);
                    }
                  }
                  if (node.id) {
                    if (this.nodeReferences[node.id]) {
                      if (!this.nodeReferences[node.id]._pseudo) {
                        throw new Error(`Node id '${node.id}' already exists`);
                      }
                      this.nodeReferences[node.id]._nodeRef = this._getNodeForNodeRef(node);
                      this.nodeReferences[node.id]._textNodeRef = node;
                      this.nodeReferences[node.id]._pseudo = false;
                    } else {
                      this.nodeReferences[node.id] = {
                        _nodeRef: this._getNodeForNodeRef(node),
                        _textNodeRef: node
                      };
                    }
                  }
                  if (node.pageReference) {
                    if (!this.nodeReferences[node.pageReference]) {
                      this.nodeReferences[node.pageReference] = {
                        _nodeRef: {},
                        _textNodeRef: {},
                        _pseudo: true
                      };
                    }
                    node.text = "00000";
                    node.linkToDestination = node.pageReference;
                    node._pageRef = this.nodeReferences[node.pageReference];
                  }
                  if (node.textReference) {
                    if (!this.nodeReferences[node.textReference]) {
                      this.nodeReferences[node.textReference] = {
                        _nodeRef: {},
                        _pseudo: true
                      };
                    }
                    node.text = "";
                    node.linkToDestination = node.textReference;
                    node._textRef = this.nodeReferences[node.textReference];
                  }
                  if (node.text && node.text.text) {
                    node.text = [this.preprocessNode(node.text)];
                  } else if (Array.isArray(node.text)) {
                    let isSetParentNode = false;
                    if (this.parentNode === null) {
                      this.parentNode = node;
                      isSetParentNode = true;
                    }
                    for (let i2 = 0, l = node.text.length; i2 < l; i2++) {
                      node.text[i2] = this.preprocessNode(node.text[i2]);
                    }
                    if (isSetParentNode) {
                      this.parentNode = null;
                    }
                  }
                  return node;
                }
                preprocessToc(node) {
                  if (!node.toc.id) {
                    node.toc.id = "_default_";
                  }
                  node.toc.title = node.toc.title ? this.preprocessNode(node.toc.title) : null;
                  node.toc._items = [];
                  if (this.tocs[node.toc.id]) {
                    if (!this.tocs[node.toc.id].toc._pseudo) {
                      throw new Error(`TOC '${node.toc.id}' already exists`);
                    }
                    node.toc._items = this.tocs[node.toc.id].toc._items;
                  }
                  this.tocs[node.toc.id] = node;
                  return node;
                }
                preprocessImage(node) {
                  if (node.image.type !== void 0 && node.image.data !== void 0 && node.image.type === "Buffer" && Array.isArray(node.image.data)) {
                    node.image = DocPreprocessor_Buffer.from(node.image.data);
                  }
                  return node;
                }
                preprocessCanvas(node) {
                  return node;
                }
                preprocessSVG(node) {
                  return node;
                }
                preprocessQr(node) {
                  return node;
                }
                preprocessAttachment(node) {
                  return node;
                }
                _getNodeForNodeRef(node) {
                  if (this.parentNode) {
                    return this.parentNode;
                  }
                  return node;
                }
              }
              const src_DocPreprocessor = DocPreprocessor;
              var unicode_trie = __webpack_require__2(7571);
              var b64 = __webpack_require__2(3915);
              ;
              var $557adaaeb0c7885f$exports = {};
              "use strict";
              const $1627905f8be2ef3f$export$af862512e23cb54 = 0;
              const $1627905f8be2ef3f$export$9bf3043cb7503aa1 = 1;
              const $1627905f8be2ef3f$export$6d0b2a5dd774590a = 2;
              const $1627905f8be2ef3f$export$bf0b2277bd569ea1 = 3;
              const $1627905f8be2ef3f$export$bad2a840ccda93b6 = 4;
              const $1627905f8be2ef3f$export$fb4028874a74450 = 5;
              const $1627905f8be2ef3f$export$463bd1ce0149c55e = 6;
              const $1627905f8be2ef3f$export$2e8caadc521d7cbb = 7;
              const $1627905f8be2ef3f$export$bfe27467c1de9413 = 8;
              const $1627905f8be2ef3f$export$af5f8d68aad3cd3a = 9;
              const $1627905f8be2ef3f$export$6b7e017d6825d38f = 10;
              const $1627905f8be2ef3f$export$8227ca023eb0daaa = 11;
              const $1627905f8be2ef3f$export$1bb1140fe1358b00 = 12;
              const $1627905f8be2ef3f$export$f3e416a182673355 = 13;
              const $1627905f8be2ef3f$export$8be180ec26319f9f = 14;
              const $1627905f8be2ef3f$export$70824c8942178d60 = 15;
              const $1627905f8be2ef3f$export$24aa617c849a894a = 16;
              const $1627905f8be2ef3f$export$a73c4d14459b698d = 17;
              const $1627905f8be2ef3f$export$921068d8846a1559 = 18;
              const $1627905f8be2ef3f$export$8b85a4f193482778 = 19;
              const $1627905f8be2ef3f$export$b2fd9c01d360241f = 20;
              const $1627905f8be2ef3f$export$dcd191669c0a595f = 21;
              const $1627905f8be2ef3f$export$9e5d732f3676a9ba = 22;
              const $1627905f8be2ef3f$export$cb94397127ac9363 = 23;
              const $1627905f8be2ef3f$export$746be9e3a3dfff1f = 24;
              const $1627905f8be2ef3f$export$96e3e682276c47cf = 25;
              const $1627905f8be2ef3f$export$fc2ff69ee2cb01bf = 26;
              const $1627905f8be2ef3f$export$8999624a7bae9d04 = 27;
              const $1627905f8be2ef3f$export$1dff41d5c0caca01 = 28;
              const $1627905f8be2ef3f$export$ddb7a6c76d9d93eb = 29;
              const $1627905f8be2ef3f$export$7e93eb3105e4786d = 30;
              const $1627905f8be2ef3f$export$30a74a373318dec6 = 31;
              const $1627905f8be2ef3f$export$54caeea5e6dab1f = 32;
              const $1627905f8be2ef3f$export$d710c5f50fc7496a = 33;
              const $1627905f8be2ef3f$export$66498d28055820a9 = 34;
              const $1627905f8be2ef3f$export$eb6c6d0b7c8826f2 = 35;
              const $1627905f8be2ef3f$export$de92be486109a1df = 36;
              const $1627905f8be2ef3f$export$606cfc2a8896c91f = 37;
              const $1627905f8be2ef3f$export$e51d3c675bb0140d = 38;
              const $1627905f8be2ef3f$export$da51c6332ad11d7b = 39;
              const $1627905f8be2ef3f$export$bea437c40441867d = 40;
              const $1627905f8be2ef3f$export$c4c7eecbfed13dc9 = 41;
              const $1627905f8be2ef3f$export$98e1f8a379849661 = 42;
              const $32627af916ac1b00$export$98f50d781a474745 = 0;
              const $32627af916ac1b00$export$12ee1f8f5315ca7e = 1;
              const $32627af916ac1b00$export$e4965ce242860454 = 2;
              const $32627af916ac1b00$export$8f14048969dcd45e = 3;
              const $32627af916ac1b00$export$133eb141bf58aff4 = 4;
              const $32627af916ac1b00$export$5bdb8ccbf5c57afc = [
                //OP   , CL    , CP    , QU    , GL    , NS    , EX    , SY    , IS    , PR    , PO    , NU    , AL    , HL    , ID    , IN    , HY    , BA    , BB    , B2    , ZW    , CM    , WJ    , H2    , H3    , JL    , JV    , JT    , RI    , EB    , EM    , ZWJ   , CB
                [
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$8f14048969dcd45e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e
                ],
                [
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ],
                [
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$e4965ce242860454,
                  $32627af916ac1b00$export$133eb141bf58aff4,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$98f50d781a474745,
                  $32627af916ac1b00$export$12ee1f8f5315ca7e,
                  $32627af916ac1b00$export$98f50d781a474745
                ]
                // CB
              ];
              const $557adaaeb0c7885f$var$data = b64.toByteArray("AAgOAAAAAAAQ4QAAAQ0P8vDtnQuMXUUZx+eyu7d7797d9m5bHoWltKVUlsjLWE0VJNigQoMVqkStEoNQQUl5GIo1KKmogEgqkKbBRki72lYabZMGKoGAjQRtJJDaCCIRiiigREBQS3z+xzOTnZ3O+3HOhd5NfpkzZx7fN9988zivu2M9hGwB28F94DnwEngd/Asc1EtIs9c/bIPDwCxwLDgezHcodyo4w5C+CCwBS8FnwSXgCnA1uFbI93XwbXAbWAfWgx+CzWAb+An4KfgFeAzsYWWfYuFz4CXwGvgb+Dfo6yNkEEwGh4CZYB44FpwI3g1OY+kfBItZOo2fB84Hy8DF4HJwNbiWpV8PVoO1LH4n2NRXyN+KcAd4kNVP9XsY4aPgcfAbsBfs6SniL4K/sPjfEf6HlanXCRkCw2BGvUh/keWfXS/CY+pFXs7x9XHmM94LTmWIeU2cgbxnS/k/B3kf86jDhU8L9V2E40vAFWAlWFUfb++NOL4F3C7JX4/4GiE+hvgWsF0oS7mXldspnN+F493gyXrh9xTav0cg3EvzgVfBG6wsmVSEkxBOBgdPGpd7JI6PnqRvJ68/xlbHof53gPeA94OzwLngk+ACsAwsByvASrAK3MB0Ws3CtQjvBJvAVrADPMDSHkb4CNijaccTwvnf4fiPEs8Lxy+D18A/QU8/xjgYBjPAbDAKTgYLwOngTHAO+EQ/8wuEF4EvsPiVCFf2+9tsFStzA8LVHuXXBsi6QyqzUYiPMR/7Mc7dAx7oL8bzw/3u/Bw8Bp4Az4AXwCtgHzsmDXP5fiF9iiVvly5d0sHngar16NKlS5cuXbp06fLmYlqHXrcd3ph4P0THUY3iXh49novju4S0tzfs5d+JPKewfAsRntZb3K9ZhOMlrO6lCC8An28U9+OuovcPcPxlVu5rCL/VmHh/iHIrzn3fIPu7SN8Axmg+8AOwEWwCm7tp3bRuWjetm5Y8bSu4B9zbKO6ZVsnORrVU3f4uXTqZ2H3sLoyx3eDXjfDndE9qyj6L838CfwVvgFpzYnof4oNgOhgBc8Fos9DrZIQLmtXPP1MmF6wGj4H+KXoWguvADkXaPil+YpuQy8Am8Ey7ODdtmJDF4HowBp4De6HDTNjhfHAHeBr0DBBy0kDxfPbcgSIusgrcWhtnJ8vL+TPix7UIOQtcBq4C28Cr4KRBnANbwSuDE+s50JgyNNFuXbp06XIgsXjIvPafjvXozKY+fVFz/z0LT1uCtKVSWbrOLWPnztG8e0Xfy7ol8XtZJi7WtG+5od2UFXQ/A12vUeS7jp27yVKHjdsU9lXB869TyNvAzt0lpP2oWbwLdjiO78bx/Sz+EMJHwK9Y/LcIfw+eZ3F67/Hl5vh9xX80J+rwX8SvRDhpgL17iPAQMHNArfPrqHPewLheI+AERV6efwV418B4nOZ/H+IfYHV8GOF5LJ3eAz0fx8sM9S0fUNud39O9CulfGZhY5huI3wzWgNvBelbHZoTbNPVpfYjKQpkHwUNgl0LWblbnk0LbbDxr0OMFpL3iqWdu9nWYPlVAWkXY39LnGdCkDbeqv1YNbfcMQ3t9oe8lzm6NH9N1ZB6Ln4BwfkJZJk7RyFnYKt6b/JDQXx9p5X+eFdqOjzM9P9MB/lUlFzr20aXIdzlY4dmn9F3YqtvoO76/2hp/D/xA5Zue88nNyL8GbFbs075X0tyUig3Qd2MCnf//HjnzpbsR3g9+1kHzzVjdnE71/qVBX9rGPUh/ysNWe1neFzvIDi5zAufV1sT0N0poR22wkFUfTOPfA4N2mbZ5fSrqOHSw+IbkSBbOGSzSRgf91/GTUWYBOB2cIZQ/G8cfBZ8CFwrnL8XxF8FKcA24jqXdiPA7Qr61OF7H4mMItwzuv2/YLth1ISt3Hzu3k4W7EH5JqPdRHD/O4k+z8A8IX5Lq3y7Z4nXE9xn6kX6vQ4bKfy+ok+hH+xf3hq9dnTTHhjKd2GmDuWA242iHMq4cC7A8kJ7i8o1+skSa7Jieo38HCWnoNjKFhdSFBxzpZ7QE6lI8N4S14aASZcryaV/WWHw66f6NHuCoxuQxmvM56GX9QMd8Q4D65ywGP+ZzRJuM+zQvx/MOS2VFeqQ4IXnH26zM9Xe6/E6D+4foAzzuajPZp8Qyw5ayZVDWuH0z0BtYRkeIDqH9KO9VbH1btd/lhNqCzvl8zeLnG0S/hnU6baHfpiuO6yy0rd+DHURo/zYF5H26j03rQsip2ndzz82u1z9N4VjWKWeb68Tedpt95HRVXp7H1R6p+/Wt4FPy/PpWwscOLRJ+PVWF/+W0iVyGzs18TIvXkOJ1Wxm66vSXz+vylenrZcj1ub439W+K8RNCGTJi2p/TJ1K23VaXr35tRpnzmjxequgfcfyk6B/TGBVlyedsNgpdd/h+W1U3P99QyFPNo1X3TwpM/WLTIWYfoBqXrv6iskHZ/RFr79R6hIyHBrH3f1nrUVnjP8SnZZ+rYtzr9Exld5MNbPNErusAPg+77u/eDOPftU9yj39TH7rezxd1LvsZQJlzkWlOirG/79zjMj/mtHUKu7vKy+3/LnXr9okyKedjX5/0He9iP/j63LwOQdarEVlfy8OO/Lqw023j6xcqmwxLiOd6heM2i9cV9LJy8jMJ23yQ+rpbfu7EQ/pXE8KYvUSqvVnb4XzZa6LrHMXHR+zcLvqWbm/Bn0/HzIs6fWPHoat8XfnDKmZGxRxeMbn2UqZ5Q94nmcZRbqqUXbZ8+lcjE+cPX11t814orvvAXNcG8vqj2vvk1MGn3anlj0bIT72v47bvE+Lc98T9b6r7AKn6j+8Duf7D0nnZx/j7Zjn0j9nbpSTndaLr9WNLivP+iN23xF7L+fqv6ZouFyb78jxVXvv5jJ9YUs9/sddO8h7KNg5jrhfaJGztT6G7KF+1d6yCmD5Kdb2fan60rSc552fZr3zeQ9DpnPp+Si5cx5Ktv2QfSzF/mMbWdOm46rFI4XstnU9xeqX4NKb7TKEdcr6pZOK3ID1k/LvFHkVczEuZLEDr499YqvqBym1aEHWgcvoYOtv0M91qQl5TfpO/in6rWx8OVpT1Wedkv3f5xom3T/xeR/6Gx6V86PWAOB4bBpqWdN+yTcVxjIyGRz/FrDGu6w/3d7kPm8StX8RyPu+uuvpNju/vTLJV37GpvoM0oZPnW87VLnL/5pDno1NoW1R6yedU6TyUv3u19a3KFnIbTLYz+ZCLP4T0tU1uivFgso0pnsJ/UtXvarNY28Xq5cvkBDrQP/E5ZaiuQwwfmTlsOiQRU1fMuqrDd/3ISSuwjOwXOfTyGUMpZIXq4GpLn3pUcdfzch2x7XO1u2uZHOPb1G6b3Xg9PH1IIWeEpJlPQtqos2EKW8b0u8rnuP1UeVLoXJb9be0uG9nnbchjU+XTszT5VeNBThPHnc5OKj1U9aj0GTHIVaGy1YhEWT4ixns00DT+XEzWn/7VAsIc63Cov3OdyhwjrnaqQqZvWKXdypRdlq+k8msZ031U+Rm4fA+3TtyeR9hwfW9G9yxDN0fZMN33F+9TE6md4hwoxumfaUzI9fN3PFT3xVV2msrQ3UsnChm6Nulk8TndpS28D3zX9tTIPsF/z7Am5OkTjm1tI1JZW74+4VgsZ0N3L1yXV3WeP5uR7TGHHdvC3JQlxybfpd22tDlk/2eofRK8TzrN/qnar/K/OUTth6I/+jAnEptNbPvFHP2gs40N3+dfMWtwqvVct7/wfd8gtQ7imifial9ZJ9/3IHLYU6eDj3+4PhsNhX+vwvcWLnu6kGfEMe8DuciPfUfGZB8X/7HJy/Gefe5n+VRGFd/wyP2ta7/LO4yh/sbLV/k9lev6kfO9Dt/5U67b1/6u/epqB1U9Me23jfHY9sscAg4tkbLl+e4/U36rJ9ddxfd6sg5vq5ice42Wpk/pb9FOJ36/W9tpv4kbC79nUbZceX8Zu6/qJ+P3WvhvA8v3reh7Jbn2d6rrNC7XNZTLma4Ba0JI9efX2uLzF5scG/w9UNU1ZxW+ymUfzELeTllXlQ1rUuhzjS5fp9c964iFBOqeSz63bU065nZKdU+mDEz3qHIjjifquw0pnb/raRtvrnsYcb46ihT3taoYz6brdNW9l6rWRnE/navdPn1XlR1km7hcz1WlH/elKuSOSvLLuE8U6m8uzwRdfcGl73VyTHuyMvzJ1Sa2cWDTP/Z63Kc94n2B1PYr24dz1JlyHLlcP+S4B6vD1c9EW4q2LWstCvUjeVy63k/LMYdUNd5D1xQfvVTzX1VjkMsUv88N8VH5fReVn/Fjn++/h6X6Q8a6b1/q3g/i/ewi0/Scs8zxXeV6mWIOUPlPzBgdFerW+bZrm2P18dnjuK6HunEp+rHvPMXbr+sHVb/lnL+pTP57jPw9Cvk3PW178JD9qChfzuvTf7Htl38L1QUf/VKu9SFjwWbTWPvFEvu7Uq76y7+31g6QlYPc669pbsm9Xur2LWI9Pu8ypfDXqm3A2z8s1FWGn4ntL9NfQu2oSlftX9uetvTtv7J8Ql4zxfXGZ3zk8PeQ9w59x2uMfqI8/q5eKh/l9cb2rwsu9rSNl06ZP2Pmxtz+rNMx93yno0n2/82rVH7rQ+y9P15H6FyRun9ViH81ATmffI7nJ5r8uXXW6enbP6b/B8/l5OifVHYLnb9S39s2zcc+Ph+rh8+eQgVPS72elzGWY/tUtbbabBpDiI7yN1q6/4th2y+ErAc5+9BVvu/7KamJbWNZeuqI/R4tRf+YyD1HmOZM1bMV3/14Sn10c0Xu+Sj1nOXb5jL73ncdy02uvlXZNde65dOHYl7Vs4KYuS6FzWLn2zJlpZqPXPVPOa5yzKOyn1VhT9lmMfdbfH7D11Wf2PXN5h9y+dD287+qxgSnaYmnIrRtIb8pJe6/Uv9OVer6Whn0zfGO/BEloZI9ojmfAlUflClDd178bTmVHVTpZXOkAlk/lb42UujmI89HH5V+cl7XtowY6vTxLVWok6UrGzoGTHN+bB+6ri05687VNpvfuvRfaP2uMlNQth1D5JjGelm/8yn+9p3p/7qk9gnfeddXZmq/Sm333PJT659Kv1zjNbZ9uv2Oi//67CV8/N1nj1DmviyXDNVeJkaeaX8UsyesYg8cu2+NvdaPfb+lLDu5tvt/");
              const $557adaaeb0c7885f$var$classTrie = new unicode_trie($557adaaeb0c7885f$var$data);
              const $557adaaeb0c7885f$var$mapClass = function(c) {
                switch (c) {
                  case $1627905f8be2ef3f$export$d710c5f50fc7496a:
                    return $1627905f8be2ef3f$export$1bb1140fe1358b00;
                  case $1627905f8be2ef3f$export$da51c6332ad11d7b:
                  case $1627905f8be2ef3f$export$bea437c40441867d:
                  case $1627905f8be2ef3f$export$98e1f8a379849661:
                    return $1627905f8be2ef3f$export$1bb1140fe1358b00;
                  case $1627905f8be2ef3f$export$eb6c6d0b7c8826f2:
                    return $1627905f8be2ef3f$export$fb4028874a74450;
                  default:
                    return c;
                }
              };
              const $557adaaeb0c7885f$var$mapFirst = function(c) {
                switch (c) {
                  case $1627905f8be2ef3f$export$606cfc2a8896c91f:
                  case $1627905f8be2ef3f$export$e51d3c675bb0140d:
                    return $1627905f8be2ef3f$export$66498d28055820a9;
                  case $1627905f8be2ef3f$export$c4c7eecbfed13dc9:
                    return $1627905f8be2ef3f$export$9e5d732f3676a9ba;
                  default:
                    return c;
                }
              };
              class $557adaaeb0c7885f$var$Break {
                constructor(position, required = false) {
                  this.position = position;
                  this.required = required;
                }
              }
              class $557adaaeb0c7885f$var$LineBreaker {
                nextCodePoint() {
                  const code = this.string.charCodeAt(this.pos++);
                  const next = this.string.charCodeAt(this.pos);
                  if (55296 <= code && code <= 56319 && 56320 <= next && next <= 57343) {
                    this.pos++;
                    return (code - 55296) * 1024 + (next - 56320) + 65536;
                  }
                  return code;
                }
                nextCharClass() {
                  return $557adaaeb0c7885f$var$mapClass($557adaaeb0c7885f$var$classTrie.get(this.nextCodePoint()));
                }
                getSimpleBreak() {
                  switch (this.nextClass) {
                    case $1627905f8be2ef3f$export$c4c7eecbfed13dc9:
                      return false;
                    case $1627905f8be2ef3f$export$66498d28055820a9:
                    case $1627905f8be2ef3f$export$606cfc2a8896c91f:
                    case $1627905f8be2ef3f$export$e51d3c675bb0140d:
                      this.curClass = $1627905f8be2ef3f$export$66498d28055820a9;
                      return false;
                    case $1627905f8be2ef3f$export$de92be486109a1df:
                      this.curClass = $1627905f8be2ef3f$export$de92be486109a1df;
                      return false;
                  }
                  return null;
                }
                getPairTableBreak(lastClass) {
                  let shouldBreak = false;
                  switch ($32627af916ac1b00$export$5bdb8ccbf5c57afc[this.curClass][this.nextClass]) {
                    case $32627af916ac1b00$export$98f50d781a474745:
                      shouldBreak = true;
                      break;
                    case $32627af916ac1b00$export$12ee1f8f5315ca7e:
                      shouldBreak = lastClass === $1627905f8be2ef3f$export$c4c7eecbfed13dc9;
                      break;
                    case $32627af916ac1b00$export$e4965ce242860454:
                      shouldBreak = lastClass === $1627905f8be2ef3f$export$c4c7eecbfed13dc9;
                      if (!shouldBreak) {
                        shouldBreak = false;
                        return shouldBreak;
                      }
                      break;
                    case $32627af916ac1b00$export$8f14048969dcd45e:
                      if (lastClass !== $1627905f8be2ef3f$export$c4c7eecbfed13dc9) return shouldBreak;
                      break;
                    case $32627af916ac1b00$export$133eb141bf58aff4:
                      break;
                  }
                  if (this.LB8a) shouldBreak = false;
                  if (this.LB21a && (this.curClass === $1627905f8be2ef3f$export$24aa617c849a894a || this.curClass === $1627905f8be2ef3f$export$a73c4d14459b698d)) {
                    shouldBreak = false;
                    this.LB21a = false;
                  } else this.LB21a = this.curClass === $1627905f8be2ef3f$export$f3e416a182673355;
                  if (this.curClass === $1627905f8be2ef3f$export$1dff41d5c0caca01) {
                    this.LB30a++;
                    if (this.LB30a == 2 && this.nextClass === $1627905f8be2ef3f$export$1dff41d5c0caca01) {
                      shouldBreak = true;
                      this.LB30a = 0;
                    }
                  } else this.LB30a = 0;
                  this.curClass = this.nextClass;
                  return shouldBreak;
                }
                nextBreak() {
                  if (this.curClass == null) {
                    let firstClass = this.nextCharClass();
                    this.curClass = $557adaaeb0c7885f$var$mapFirst(firstClass);
                    this.nextClass = firstClass;
                    this.LB8a = firstClass === $1627905f8be2ef3f$export$30a74a373318dec6;
                    this.LB30a = 0;
                  }
                  while (this.pos < this.string.length) {
                    this.lastPos = this.pos;
                    const lastClass = this.nextClass;
                    this.nextClass = this.nextCharClass();
                    if (this.curClass === $1627905f8be2ef3f$export$66498d28055820a9 || this.curClass === $1627905f8be2ef3f$export$de92be486109a1df && this.nextClass !== $1627905f8be2ef3f$export$606cfc2a8896c91f) {
                      this.curClass = $557adaaeb0c7885f$var$mapFirst($557adaaeb0c7885f$var$mapClass(this.nextClass));
                      return new $557adaaeb0c7885f$var$Break(this.lastPos, true);
                    }
                    let shouldBreak = this.getSimpleBreak();
                    if (shouldBreak === null) shouldBreak = this.getPairTableBreak(lastClass);
                    this.LB8a = this.nextClass === $1627905f8be2ef3f$export$30a74a373318dec6;
                    if (shouldBreak) return new $557adaaeb0c7885f$var$Break(this.lastPos);
                  }
                  if (this.lastPos < this.string.length) {
                    this.lastPos = this.string.length;
                    return new $557adaaeb0c7885f$var$Break(this.string.length);
                  }
                  return null;
                }
                constructor(string) {
                  this.string = string;
                  this.pos = 0;
                  this.lastPos = 0;
                  this.curClass = null;
                  this.nextClass = null;
                  this.LB8a = false;
                  this.LB21a = false;
                  this.LB30a = 0;
                }
              }
              $557adaaeb0c7885f$exports = $557adaaeb0c7885f$var$LineBreaker;
              ;
              class StyleContextStack {
                /**
                 * @param {object} styleDictionary named styles dictionary
                 * @param {object} defaultStyle optional default style definition
                 */
                constructor(styleDictionary, defaultStyle) {
                  if (defaultStyle === void 0) {
                    defaultStyle = {};
                  }
                  this.styleDictionary = styleDictionary;
                  this.defaultStyle = defaultStyle;
                  this.styleOverrides = [];
                }
                /**
                 * Creates cloned version of current stack
                 *
                 * @returns {StyleContextStack} current stack snapshot
                 */
                clone() {
                  let stack = new StyleContextStack(this.styleDictionary, this.defaultStyle);
                  this.styleOverrides.forEach((item) => {
                    stack.styleOverrides.push(item);
                  });
                  return stack;
                }
                /**
                 * Pushes style-name or style-overrides-object onto the stack for future evaluation
                 *
                 * @param {string|object} styleNameOrOverride style-name (referring to styleDictionary) or
                 *                                            a new dictionary defining overriding properties
                 */
                push(styleNameOrOverride) {
                  this.styleOverrides.push(styleNameOrOverride);
                }
                /**
                 * Removes last style-name or style-overrides-object from the stack
                 *
                 * @param {number} howMany optional number of elements to be popped (if not specified,
                 *                         one element will be removed from the stack)
                 */
                pop(howMany) {
                  if (howMany === void 0) {
                    howMany = 1;
                  }
                  while (howMany-- > 0) {
                    this.styleOverrides.pop();
                  }
                }
                /**
                 * Creates a set of named styles or/and a style-overrides-object based on the item,
                 * pushes those elements onto the stack for future evaluation and returns the number
                 * of elements pushed, so they can be easily popped then.
                 *
                 * @param {object} item - an object with optional style property and/or style overrides
                 * @returns {number} the number of items pushed onto the stack
                 */
                autopush(item) {
                  if (isString(item)) {
                    return 0;
                  }
                  if (typeof item.section !== "undefined") {
                    return 0;
                  }
                  let styleNames = [];
                  if (item.style) {
                    if (Array.isArray(item.style)) {
                      styleNames = item.style;
                    } else {
                      styleNames = [item.style];
                    }
                  }
                  for (let i2 = 0, l = styleNames.length; i2 < l; i2++) {
                    this.push(styleNames[i2]);
                  }
                  this.push(item);
                  return styleNames.length + 1;
                }
                /**
                 * Automatically pushes elements onto the stack, using autopush based on item,
                 * executes callback and then pops elements back. Returns value returned by callback
                 *
                 * @param {object} item - an object with optional style property and/or style overrides
                 * @param {Function} callback to be called between autopush and pop
                 * @returns {object} value returned by callback
                 */
                auto(item, callback) {
                  let pushedItems = this.autopush(item);
                  let result = callback();
                  if (pushedItems > 0) {
                    this.pop(pushedItems);
                  }
                  return result;
                }
                /**
                 * Evaluates stack and returns value of a named property
                 *
                 * @param {string} property - property name
                 * @returns {?any} property value or null if not found
                 */
                getProperty(property) {
                  var _this = this;
                  const getStylePropertyFromStyle = function(styleName, property2, visited) {
                    if (visited === void 0) {
                      visited = /* @__PURE__ */ new Set();
                    }
                    if (visited.has(styleName)) {
                      return void 0;
                    }
                    visited.add(styleName);
                    const style = _this.styleDictionary[styleName];
                    if (!style) {
                      return void 0;
                    }
                    if (isValue(style[property2])) {
                      return style[property2];
                    }
                    if (style.extends) {
                      let parents = Array.isArray(style.extends) ? style.extends : [style.extends];
                      for (let i2 = parents.length - 1; i2 >= 0; i2--) {
                        let value = getStylePropertyFromStyle(parents[i2], property2, visited);
                        if (isValue(value)) {
                          return value;
                        }
                      }
                    }
                    return void 0;
                  };
                  if (this.styleOverrides) {
                    for (let i2 = this.styleOverrides.length - 1; i2 >= 0; i2--) {
                      let item = this.styleOverrides[i2];
                      if (isString(item)) {
                        let value = getStylePropertyFromStyle(item, property);
                        if (isValue(value)) {
                          return value;
                        }
                      } else if (isValue(item[property])) {
                        return item[property];
                      }
                    }
                  }
                  return this.defaultStyle && this.defaultStyle[property];
                }
                /**
                 * @param {object} item
                 * @param {StyleContextStack} styleContextStack
                 * @param {string} property
                 * @param {any} defaultValue
                 * @returns {any}
                 */
                static getStyleProperty(item, styleContextStack, property, defaultValue) {
                  let value;
                  if (isValue(item[property])) {
                    return item[property];
                  }
                  if (!styleContextStack) {
                    return defaultValue;
                  }
                  styleContextStack.auto(item, () => {
                    value = styleContextStack.getProperty(property);
                  });
                  return isValue(value) ? value : defaultValue;
                }
                /**
                 * @param {object} source
                 * @param {object} destination
                 * @returns {object}
                 */
                static copyStyle(source, destination) {
                  if (source === void 0) {
                    source = {};
                  }
                  if (destination === void 0) {
                    destination = {};
                  }
                  for (let key in source) {
                    if (key != "text" && source.hasOwnProperty(key)) {
                      destination[key] = source[key];
                    }
                  }
                  return destination;
                }
              }
              const src_StyleContextStack = StyleContextStack;
              ;
              const splitWords = function(text, noWrap, breakAll) {
                if (breakAll === void 0) {
                  breakAll = false;
                }
                let words = [];
                if (text === void 0 || text === null) {
                  text = "";
                } else {
                  text = String(text);
                }
                if (noWrap) {
                  words.push({
                    text
                  });
                  return words;
                }
                if (breakAll) {
                  return text.split("").map((c) => {
                    if (c.match(/^\n$|^\r$/)) {
                      return {
                        text: "",
                        lineEnd: true
                      };
                    }
                    return {
                      text: c
                    };
                  });
                }
                if (text.length === 0) {
                  words.push({
                    text: ""
                  });
                  return words;
                }
                let breaker = new $557adaaeb0c7885f$exports(text);
                let last = 0;
                let bk;
                while (bk = breaker.nextBreak()) {
                  let word = text.slice(last, bk.position);
                  if (bk.required || word.match(/\r?\n$|\r$/)) {
                    word = word.replace(/\r?\n$|\r$/, "");
                    words.push({
                      text: word,
                      lineEnd: true
                    });
                  } else {
                    words.push({
                      text: word
                    });
                  }
                  last = bk.position;
                }
                return words;
              };
              const getFirstWord = (words, noWrap) => {
                let word = words[0];
                if (word === void 0) {
                  return null;
                }
                if (noWrap) {
                  let tmpWords = splitWords(word.text, false);
                  if (tmpWords[0] === void 0) {
                    return null;
                  }
                  word = tmpWords[0];
                }
                return word.text;
              };
              const getLastWord = (words, noWrap) => {
                let word = words[words.length - 1];
                if (word === void 0) {
                  return null;
                }
                if (word.lineEnd) {
                  return null;
                }
                if (noWrap) {
                  let tmpWords = splitWords(word.text, false);
                  if (tmpWords[tmpWords.length - 1] === void 0) {
                    return null;
                  }
                  word = tmpWords[tmpWords.length - 1];
                }
                return word.text;
              };
              class TextBreaker {
                /**
                 * @param {string|Array} texts
                 * @param {StyleContextStack} styleContextStack
                 * @returns {Array}
                 */
                getBreaks(texts, styleContextStack) {
                  let results = [];
                  if (!Array.isArray(texts)) {
                    texts = [texts];
                  }
                  let lastWord = null;
                  for (let i2 = 0, l = texts.length; i2 < l; i2++) {
                    let item = texts[i2];
                    let style = null;
                    let words;
                    let breakAll = src_StyleContextStack.getStyleProperty(item || {}, styleContextStack, "wordBreak", "normal") === "break-all";
                    let noWrap = src_StyleContextStack.getStyleProperty(item || {}, styleContextStack, "noWrap", false);
                    if (isObject(item)) {
                      if (item._textRef && item._textRef._textNodeRef.text) {
                        item.text = item._textRef._textNodeRef.text;
                      }
                      words = splitWords(item.text, noWrap, breakAll);
                      style = src_StyleContextStack.copyStyle(item);
                    } else {
                      words = splitWords(item, noWrap, breakAll);
                    }
                    if (lastWord && words.length) {
                      let firstWord = getFirstWord(words, noWrap);
                      let wrapWords = splitWords(lastWord + firstWord, false);
                      if (wrapWords.length === 1) {
                        results[results.length - 1].noNewLine = true;
                      }
                    }
                    for (let i22 = 0, l2 = words.length; i22 < l2; i22++) {
                      let result = {
                        text: words[i22].text
                      };
                      if (words[i22].lineEnd) {
                        result.lineEnd = true;
                      }
                      src_StyleContextStack.copyStyle(style, result);
                      results.push(result);
                    }
                    lastWord = null;
                    if (i2 + 1 < l) {
                      lastWord = getLastWord(words, noWrap);
                    }
                  }
                  return results;
                }
              }
              const src_TextBreaker = TextBreaker;
              ;
              const LEADING = /^(\s)+/g;
              const TRAILING = /(\s)+$/g;
              const flattenTextArray = (array) => {
                function flatten(array2) {
                  return array2.reduce((prev, cur) => {
                    let current = Array.isArray(cur.text) ? flatten(cur.text) : cur;
                    let more = [].concat(current).some(Array.isArray);
                    return prev.concat(more ? flatten(current) : current);
                  }, []);
                }
                if (!Array.isArray(array)) {
                  array = [array];
                }
                array = flatten(array);
                return array;
              };
              class TextInlines {
                /**
                 * @param {object} pdfDocument object is instance of PDFDocument
                 */
                constructor(pdfDocument) {
                  this.pdfDocument = pdfDocument;
                }
                /**
                 * Converts an array of strings (or inline-definition-objects) into a collection
                 * of inlines and calculated minWidth/maxWidth and their min/max widths
                 *
                 * @param {Array|object} textArray an array of inline-definition-objects (or strings)
                 * @param {StyleContextStack} styleContextStack current style stack
                 * @returns {object} collection of inlines, minWidth, maxWidth
                 */
                buildInlines(textArray, styleContextStack) {
                  const getTrimmedWidth = (item) => {
                    return Math.max(0, item.width - item.leadingCut - item.trailingCut);
                  };
                  let minWidth = 0;
                  let maxWidth = 0;
                  let currentLineWidth;
                  let flattenedTextArray = flattenTextArray(textArray);
                  const textBreaker = new src_TextBreaker();
                  let brokenText = textBreaker.getBreaks(flattenedTextArray, styleContextStack);
                  let measuredText = this.measure(brokenText, styleContextStack);
                  measuredText.forEach((inline) => {
                    minWidth = Math.max(minWidth, getTrimmedWidth(inline));
                    if (!currentLineWidth) {
                      currentLineWidth = {
                        width: 0,
                        leadingCut: inline.leadingCut,
                        trailingCut: 0
                      };
                    }
                    currentLineWidth.width += inline.width;
                    currentLineWidth.trailingCut = inline.trailingCut;
                    maxWidth = Math.max(maxWidth, getTrimmedWidth(currentLineWidth));
                    if (inline.lineEnd) {
                      currentLineWidth = null;
                    }
                  });
                  if (src_StyleContextStack.getStyleProperty({}, styleContextStack, "noWrap", false)) {
                    minWidth = maxWidth;
                  }
                  return {
                    items: measuredText,
                    minWidth,
                    maxWidth
                  };
                }
                measure(array, styleContextStack) {
                  if (array.length) {
                    let leadingIndent = src_StyleContextStack.getStyleProperty(array[0], styleContextStack, "leadingIndent", 0);
                    if (leadingIndent) {
                      array[0].leadingCut = -leadingIndent;
                      array[0].leadingIndent = leadingIndent;
                    }
                  }
                  array.forEach((item) => {
                    let font = src_StyleContextStack.getStyleProperty(item, styleContextStack, "font", "Roboto");
                    let bold = src_StyleContextStack.getStyleProperty(item, styleContextStack, "bold", false);
                    let italics = src_StyleContextStack.getStyleProperty(item, styleContextStack, "italics", false);
                    item.font = this.pdfDocument.provideFont(font, bold, italics);
                    item.alignment = src_StyleContextStack.getStyleProperty(item, styleContextStack, "alignment", "left");
                    item.fontSize = src_StyleContextStack.getStyleProperty(item, styleContextStack, "fontSize", 12);
                    item.fontFeatures = src_StyleContextStack.getStyleProperty(item, styleContextStack, "fontFeatures", null);
                    item.characterSpacing = src_StyleContextStack.getStyleProperty(item, styleContextStack, "characterSpacing", 0);
                    item.color = src_StyleContextStack.getStyleProperty(item, styleContextStack, "color", "black");
                    item.decoration = src_StyleContextStack.getStyleProperty(item, styleContextStack, "decoration", null);
                    item.decorationColor = src_StyleContextStack.getStyleProperty(item, styleContextStack, "decorationColor", null);
                    item.decorationStyle = src_StyleContextStack.getStyleProperty(item, styleContextStack, "decorationStyle", null);
                    item.decorationThickness = src_StyleContextStack.getStyleProperty(item, styleContextStack, "decorationThickness", null);
                    item.background = src_StyleContextStack.getStyleProperty(item, styleContextStack, "background", null);
                    item.link = src_StyleContextStack.getStyleProperty(item, styleContextStack, "link", null);
                    item.linkToPage = src_StyleContextStack.getStyleProperty(item, styleContextStack, "linkToPage", null);
                    item.linkToDestination = src_StyleContextStack.getStyleProperty(item, styleContextStack, "linkToDestination", null);
                    item.noWrap = src_StyleContextStack.getStyleProperty(item, styleContextStack, "noWrap", null);
                    item.opacity = src_StyleContextStack.getStyleProperty(item, styleContextStack, "opacity", 1);
                    item.sup = src_StyleContextStack.getStyleProperty(item, styleContextStack, "sup", false);
                    item.sub = src_StyleContextStack.getStyleProperty(item, styleContextStack, "sub", false);
                    if (item.sup || item.sub) {
                      item.fontSize *= 0.58;
                    }
                    let lineHeight = src_StyleContextStack.getStyleProperty(item, styleContextStack, "lineHeight", 1);
                    item.width = this.widthOfText(item.text, item);
                    item.height = item.font.lineHeight(item.fontSize) * lineHeight;
                    if (!item.leadingCut) {
                      item.leadingCut = 0;
                    }
                    let preserveLeadingSpaces = src_StyleContextStack.getStyleProperty(item, styleContextStack, "preserveLeadingSpaces", false);
                    if (!preserveLeadingSpaces) {
                      let leadingSpaces = item.text.match(LEADING);
                      if (leadingSpaces) {
                        item.leadingCut += this.widthOfText(leadingSpaces[0], item);
                      }
                    }
                    item.trailingCut = 0;
                    let preserveTrailingSpaces = src_StyleContextStack.getStyleProperty(item, styleContextStack, "preserveTrailingSpaces", false);
                    if (!preserveTrailingSpaces) {
                      let trailingSpaces = item.text.match(TRAILING);
                      if (trailingSpaces) {
                        item.trailingCut = this.widthOfText(trailingSpaces[0], item);
                      }
                    }
                  }, this);
                  return array;
                }
                /**
                 * Width of text
                 *
                 * @param {string} text
                 * @param {object} inline
                 * @returns {number}
                 */
                widthOfText(text, inline) {
                  return inline.font.widthOfString(text, inline.fontSize, inline.fontFeatures) + (inline.characterSpacing || 0) * (text.length - 1);
                }
                /**
                 * Returns size of the specified string (without breaking it) using the current style
                 *
                 * @param {string} text text to be measured
                 * @param {object} styleContextStack current style stack
                 * @returns {object} size of the specified string
                 */
                sizeOfText(text, styleContextStack) {
                  let fontName = src_StyleContextStack.getStyleProperty({}, styleContextStack, "font", "Roboto");
                  let fontSize = src_StyleContextStack.getStyleProperty({}, styleContextStack, "fontSize", 12);
                  let fontFeatures = src_StyleContextStack.getStyleProperty({}, styleContextStack, "fontFeatures", null);
                  let bold = src_StyleContextStack.getStyleProperty({}, styleContextStack, "bold", false);
                  let italics = src_StyleContextStack.getStyleProperty({}, styleContextStack, "italics", false);
                  let lineHeight = src_StyleContextStack.getStyleProperty({}, styleContextStack, "lineHeight", 1);
                  let characterSpacing = src_StyleContextStack.getStyleProperty({}, styleContextStack, "characterSpacing", 0);
                  let font = this.pdfDocument.provideFont(fontName, bold, italics);
                  return {
                    width: this.widthOfText(text, {
                      font,
                      fontSize,
                      characterSpacing,
                      fontFeatures
                    }),
                    height: font.lineHeight(fontSize) * lineHeight,
                    fontSize,
                    lineHeight,
                    ascender: font.ascender / 1e3 * fontSize,
                    descender: font.descender / 1e3 * fontSize
                  };
                }
                /**
                 * Returns size of the specified rotated string (without breaking it) using the current style
                 *
                 * @param {string} text text to be measured
                 * @param {number} angle
                 * @param {object} styleContextStack current style stack
                 * @returns {object} size of the specified string
                 */
                sizeOfRotatedText(text, angle, styleContextStack) {
                  let angleRad = angle * Math.PI / -180;
                  let size = this.sizeOfText(text, styleContextStack);
                  return {
                    width: Math.abs(size.height * Math.sin(angleRad)) + Math.abs(size.width * Math.cos(angleRad)),
                    height: Math.abs(size.width * Math.sin(angleRad)) + Math.abs(size.height * Math.cos(angleRad))
                  };
                }
              }
              const src_TextInlines = TextInlines;
              ;
              function buildColumnWidths(columns, availableWidth, offsetTotal, tableNode) {
                if (offsetTotal === void 0) {
                  offsetTotal = 0;
                }
                let autoColumns = [];
                let autoMin = 0;
                let autoMax = 0;
                let starColumns = [];
                let starMaxMin = 0;
                let starMaxMax = 0;
                let fixedColumns = [];
                let initial_availableWidth = availableWidth;
                columns.forEach((column) => {
                  if (isAutoColumn(column)) {
                    autoColumns.push(column);
                    autoMin += column._minWidth;
                    autoMax += column._maxWidth;
                  } else if (isStarColumn(column)) {
                    starColumns.push(column);
                    starMaxMin = Math.max(starMaxMin, column._minWidth);
                    starMaxMax = Math.max(starMaxMax, column._maxWidth);
                  } else {
                    fixedColumns.push(column);
                  }
                });
                fixedColumns.forEach((col, colIndex) => {
                  if (isString(col.width) && /\d+%/.test(col.width)) {
                    let reservedWidth = 0;
                    if (tableNode) {
                      const paddingLeft = tableNode._layout.paddingLeft(colIndex, tableNode);
                      const paddingRight = tableNode._layout.paddingRight(colIndex, tableNode);
                      const borderLeft = tableNode._layout.vLineWidth(colIndex, tableNode);
                      const borderRight = tableNode._layout.vLineWidth(colIndex + 1, tableNode);
                      if (colIndex === 0) {
                        reservedWidth = paddingLeft + paddingRight + borderLeft + borderRight / 2;
                      } else if (colIndex === fixedColumns.length - 1) {
                        reservedWidth = paddingLeft + paddingRight + borderLeft / 2 + borderRight;
                      } else {
                        reservedWidth = paddingLeft + paddingRight + borderLeft / 2 + borderRight / 2;
                      }
                    }
                    const totalAvailableWidth = initial_availableWidth + offsetTotal;
                    col.width = parseFloat(col.width) * totalAvailableWidth / 100 - reservedWidth;
                  }
                  if (col.width < col._minWidth && col.elasticWidth) {
                    col._calcWidth = col._minWidth;
                  } else {
                    col._calcWidth = col.width;
                  }
                  availableWidth -= col._calcWidth;
                });
                let minW = autoMin + starMaxMin * starColumns.length;
                let maxW = autoMax + starMaxMax * starColumns.length;
                if (minW >= availableWidth) {
                  autoColumns.forEach((col) => {
                    col._calcWidth = col._minWidth;
                  });
                  starColumns.forEach((col) => {
                    col._calcWidth = starMaxMin;
                  });
                } else {
                  if (maxW < availableWidth) {
                    autoColumns.forEach((col) => {
                      col._calcWidth = col._maxWidth;
                      availableWidth -= col._calcWidth;
                    });
                  } else {
                    let W = availableWidth - minW;
                    let D = maxW - minW;
                    autoColumns.forEach((col) => {
                      let d = col._maxWidth - col._minWidth;
                      col._calcWidth = col._minWidth + d * W / D;
                      availableWidth -= col._calcWidth;
                    });
                  }
                  if (starColumns.length > 0) {
                    let starSize = availableWidth / starColumns.length;
                    starColumns.forEach((col) => {
                      col._calcWidth = starSize;
                    });
                  }
                }
              }
              function isAutoColumn(column) {
                return column.width === "auto";
              }
              function isStarColumn(column) {
                return column.width === null || column.width === void 0 || column.width === "*" || column.width === "star";
              }
              function measureMinMax(columns) {
                let result = {
                  min: 0,
                  max: 0
                };
                let maxStar = {
                  min: 0,
                  max: 0
                };
                let starCount = 0;
                for (let i2 = 0, l = columns.length; i2 < l; i2++) {
                  let c = columns[i2];
                  if (isStarColumn(c)) {
                    maxStar.min = Math.max(maxStar.min, c._minWidth);
                    maxStar.max = Math.max(maxStar.max, c._maxWidth);
                    starCount++;
                  } else if (isAutoColumn(c)) {
                    result.min += c._minWidth;
                    result.max += c._maxWidth;
                  } else {
                    result.min += c.width !== void 0 && c.width || c._minWidth;
                    result.max += c.width !== void 0 && c.width || c._maxWidth;
                  }
                }
                if (starCount) {
                  result.min += starCount * maxStar.min;
                  result.max += starCount * maxStar.max;
                }
                return result;
              }
              const columnCalculator = {
                buildColumnWidths,
                measureMinMax,
                isAutoColumn,
                isStarColumn
              };
              ;
              const tableLayouts = {
                noBorders: {
                  hLineWidth(i2) {
                    return 0;
                  },
                  vLineWidth(i2) {
                    return 0;
                  },
                  paddingLeft(i2) {
                    return i2 && 4 || 0;
                  },
                  paddingRight(i2, node) {
                    return i2 < node.table.widths.length - 1 ? 4 : 0;
                  }
                },
                headerLineOnly: {
                  hLineWidth(i2, node) {
                    if (i2 === 0 || i2 === node.table.body.length) {
                      return 0;
                    }
                    return i2 === node.table.headerRows ? 2 : 0;
                  },
                  vLineWidth(i2) {
                    return 0;
                  },
                  paddingLeft(i2) {
                    return i2 === 0 ? 0 : 8;
                  },
                  paddingRight(i2, node) {
                    return i2 === node.table.widths.length - 1 ? 0 : 8;
                  }
                },
                lightHorizontalLines: {
                  hLineWidth(i2, node) {
                    if (i2 === 0 || i2 === node.table.body.length) {
                      return 0;
                    }
                    return i2 === node.table.headerRows ? 2 : 1;
                  },
                  vLineWidth(i2) {
                    return 0;
                  },
                  hLineColor(i2) {
                    return i2 === 1 ? "black" : "#aaa";
                  },
                  paddingLeft(i2) {
                    return i2 === 0 ? 0 : 8;
                  },
                  paddingRight(i2, node) {
                    return i2 === node.table.widths.length - 1 ? 0 : 8;
                  }
                }
              };
              const defaultTableLayout = {
                hLineWidth(i2, node) {
                  return 1;
                },
                vLineWidth(i2, node) {
                  return 1;
                },
                hLineColor(i2, node) {
                  return "black";
                },
                vLineColor(i2, node) {
                  return "black";
                },
                hLineStyle(i2, node) {
                  return null;
                },
                vLineStyle(i2, node) {
                  return null;
                },
                paddingLeft(i2, node) {
                  return 4;
                },
                paddingRight(i2, node) {
                  return 4;
                },
                paddingTop(i2, node) {
                  return 2;
                },
                paddingBottom(i2, node) {
                  return 2;
                },
                fillColor(i2, node) {
                  return null;
                },
                fillOpacity(i2, node) {
                  return 1;
                },
                defaultBorder: true
              };
              ;
              function pack() {
                let result = {};
                for (let i2 = 0, l = arguments.length; i2 < l; i2++) {
                  let obj = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
                  if (obj) {
                    for (let key in obj) {
                      if (obj.hasOwnProperty(key)) {
                        result[key] = obj[key];
                      }
                    }
                  }
                }
                return result;
              }
              function offsetVector(vector, x, y) {
                switch (vector.type) {
                  case "ellipse":
                  case "rect":
                    vector.x += x;
                    vector.y += y;
                    break;
                  case "line":
                    vector.x1 += x;
                    vector.x2 += x;
                    vector.y1 += y;
                    vector.y2 += y;
                    break;
                  case "polyline":
                    for (let i2 = 0, l = vector.points.length; i2 < l; i2++) {
                      vector.points[i2].x += x;
                      vector.points[i2].y += y;
                    }
                    break;
                }
              }
              function convertToDynamicContent(staticContent) {
                return () => (
                  // copy to new object
                  JSON.parse(JSON.stringify(staticContent))
                );
              }
              ;
              var VERSIONS = [null, [[10, 7, 17, 13], [1, 1, 1, 1], []], [[16, 10, 28, 22], [1, 1, 1, 1], [4, 16]], [[26, 15, 22, 18], [1, 1, 2, 2], [4, 20]], [[18, 20, 16, 26], [2, 1, 4, 2], [4, 24]], [[24, 26, 22, 18], [2, 1, 4, 4], [4, 28]], [[16, 18, 28, 24], [4, 2, 4, 4], [4, 32]], [[18, 20, 26, 18], [4, 2, 5, 6], [4, 20, 36]], [[22, 24, 26, 22], [4, 2, 6, 6], [4, 22, 40]], [[22, 30, 24, 20], [5, 2, 8, 8], [4, 24, 44]], [[26, 18, 28, 24], [5, 4, 8, 8], [4, 26, 48]], [[30, 20, 24, 28], [5, 4, 11, 8], [4, 28, 52]], [[22, 24, 28, 26], [8, 4, 11, 10], [4, 30, 56]], [[22, 26, 22, 24], [9, 4, 16, 12], [4, 32, 60]], [[24, 30, 24, 20], [9, 4, 16, 16], [4, 24, 44, 64]], [[24, 22, 24, 30], [10, 6, 18, 12], [4, 24, 46, 68]], [[28, 24, 30, 24], [10, 6, 16, 17], [4, 24, 48, 72]], [[28, 28, 28, 28], [11, 6, 19, 16], [4, 28, 52, 76]], [[26, 30, 28, 28], [13, 6, 21, 18], [4, 28, 54, 80]], [[26, 28, 26, 26], [14, 7, 25, 21], [4, 28, 56, 84]], [[26, 28, 28, 30], [16, 8, 25, 20], [4, 32, 60, 88]], [[26, 28, 30, 28], [17, 8, 25, 23], [4, 26, 48, 70, 92]], [[28, 28, 24, 30], [17, 9, 34, 23], [4, 24, 48, 72, 96]], [[28, 30, 30, 30], [18, 9, 30, 25], [4, 28, 52, 76, 100]], [[28, 30, 30, 30], [20, 10, 32, 27], [4, 26, 52, 78, 104]], [[28, 26, 30, 30], [21, 12, 35, 29], [4, 30, 56, 82, 108]], [[28, 28, 30, 28], [23, 12, 37, 34], [4, 28, 56, 84, 112]], [[28, 30, 30, 30], [25, 12, 40, 34], [4, 32, 60, 88, 116]], [[28, 30, 30, 30], [26, 13, 42, 35], [4, 24, 48, 72, 96, 120]], [[28, 30, 30, 30], [28, 14, 45, 38], [4, 28, 52, 76, 100, 124]], [[28, 30, 30, 30], [29, 15, 48, 40], [4, 24, 50, 76, 102, 128]], [[28, 30, 30, 30], [31, 16, 51, 43], [4, 28, 54, 80, 106, 132]], [[28, 30, 30, 30], [33, 17, 54, 45], [4, 32, 58, 84, 110, 136]], [[28, 30, 30, 30], [35, 18, 57, 48], [4, 28, 56, 84, 112, 140]], [[28, 30, 30, 30], [37, 19, 60, 51], [4, 32, 60, 88, 116, 144]], [[28, 30, 30, 30], [38, 19, 63, 53], [4, 28, 52, 76, 100, 124, 148]], [[28, 30, 30, 30], [40, 20, 66, 56], [4, 22, 48, 74, 100, 126, 152]], [[28, 30, 30, 30], [43, 21, 70, 59], [4, 26, 52, 78, 104, 130, 156]], [[28, 30, 30, 30], [45, 22, 74, 62], [4, 30, 56, 82, 108, 134, 160]], [[28, 30, 30, 30], [47, 24, 77, 65], [4, 24, 52, 80, 108, 136, 164]], [[28, 30, 30, 30], [49, 25, 81, 68], [4, 28, 56, 84, 112, 140, 168]]];
              var MODE_TERMINATOR = 0;
              var MODE_NUMERIC = 1, MODE_ALPHANUMERIC = 2, MODE_OCTET = 4, MODE_KANJI = 8;
              var NUMERIC_REGEXP = /^\d*$/;
              var ALPHANUMERIC_REGEXP = /^[A-Za-z0-9 $%*+\-./:]*$/;
              var ALPHANUMERIC_OUT_REGEXP = /^[A-Z0-9 $%*+\-./:]*$/;
              var ECCLEVEL_L = 1, ECCLEVEL_M = 0, ECCLEVEL_Q = 3, ECCLEVEL_H = 2;
              var GF256_MAP = [], GF256_INVMAP = [-1];
              for (var i = 0, v = 1; i < 255; ++i) {
                GF256_MAP.push(v);
                GF256_INVMAP[v] = i;
                v = v * 2 ^ (v >= 128 ? 285 : 0);
              }
              var GF256_GENPOLY = [[]];
              for (var i = 0; i < 30; ++i) {
                var prevpoly = GF256_GENPOLY[i], poly = [];
                for (var j = 0; j <= i; ++j) {
                  var a = j < i ? GF256_MAP[prevpoly[j]] : 0;
                  var b = GF256_MAP[(i + (prevpoly[j - 1] || 0)) % 255];
                  poly.push(GF256_INVMAP[a ^ b]);
                }
                GF256_GENPOLY.push(poly);
              }
              var ALPHANUMERIC_MAP = {};
              for (var i = 0; i < 45; ++i) {
                ALPHANUMERIC_MAP["0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".charAt(i)] = i;
              }
              var MASKFUNCS = [function(i2, j2) {
                return (i2 + j2) % 2 === 0;
              }, function(i2, j2) {
                return i2 % 2 === 0;
              }, function(i2, j2) {
                return j2 % 3 === 0;
              }, function(i2, j2) {
                return (i2 + j2) % 3 === 0;
              }, function(i2, j2) {
                return ((i2 / 2 | 0) + (j2 / 3 | 0)) % 2 === 0;
              }, function(i2, j2) {
                return i2 * j2 % 2 + i2 * j2 % 3 === 0;
              }, function(i2, j2) {
                return (i2 * j2 % 2 + i2 * j2 % 3) % 2 === 0;
              }, function(i2, j2) {
                return ((i2 + j2) % 2 + i2 * j2 % 3) % 2 === 0;
              }];
              var needsverinfo = function(ver) {
                return ver > 6;
              };
              var getsizebyver = function(ver) {
                return 4 * ver + 17;
              };
              var nfullbits = function(ver) {
                var v2 = VERSIONS[ver];
                var nbits = 16 * ver * ver + 128 * ver + 64;
                if (needsverinfo(ver)) nbits -= 36;
                if (v2[2].length) {
                  nbits -= 25 * v2[2].length * v2[2].length - 10 * v2[2].length - 55;
                }
                return nbits;
              };
              var ndatabits = function(ver, ecclevel) {
                var nbits = nfullbits(ver) & ~7;
                var v2 = VERSIONS[ver];
                nbits -= 8 * v2[0][ecclevel] * v2[1][ecclevel];
                return nbits;
              };
              var ndatalenbits = function(ver, mode) {
                switch (mode) {
                  case MODE_NUMERIC:
                    return ver < 10 ? 10 : ver < 27 ? 12 : 14;
                  case MODE_ALPHANUMERIC:
                    return ver < 10 ? 9 : ver < 27 ? 11 : 13;
                  case MODE_OCTET:
                    return ver < 10 ? 8 : 16;
                  case MODE_KANJI:
                    return ver < 10 ? 8 : ver < 27 ? 10 : 12;
                }
              };
              var getmaxdatalen = function(ver, mode, ecclevel) {
                var nbits = ndatabits(ver, ecclevel) - 4 - ndatalenbits(ver, mode);
                switch (mode) {
                  case MODE_NUMERIC:
                    return (nbits / 10 | 0) * 3 + (nbits % 10 < 4 ? 0 : nbits % 10 < 7 ? 1 : 2);
                  case MODE_ALPHANUMERIC:
                    return (nbits / 11 | 0) * 2 + (nbits % 11 < 6 ? 0 : 1);
                  case MODE_OCTET:
                    return nbits / 8 | 0;
                  case MODE_KANJI:
                    return nbits / 13 | 0;
                }
              };
              var validatedata = function(mode, data) {
                switch (mode) {
                  case MODE_NUMERIC:
                    if (!data.match(NUMERIC_REGEXP)) return null;
                    return data;
                  case MODE_ALPHANUMERIC:
                    if (!data.match(ALPHANUMERIC_REGEXP)) return null;
                    return data.toUpperCase();
                  case MODE_OCTET:
                    if (typeof data === "string") {
                      var newdata = [];
                      for (var i2 = 0; i2 < data.length; ++i2) {
                        var ch = data.charCodeAt(i2);
                        if (ch < 128) {
                          newdata.push(ch);
                        } else if (ch < 2048) {
                          newdata.push(192 | ch >> 6, 128 | ch & 63);
                        } else if (ch < 65536) {
                          newdata.push(224 | ch >> 12, 128 | ch >> 6 & 63, 128 | ch & 63);
                        } else {
                          newdata.push(240 | ch >> 18, 128 | ch >> 12 & 63, 128 | ch >> 6 & 63, 128 | ch & 63);
                        }
                      }
                      return newdata;
                    } else {
                      return data;
                    }
                }
              };
              var encode = function(ver, mode, data, maxbuflen) {
                var buf = [];
                var bits = 0, remaining = 8;
                var datalen = data.length;
                var pack2 = function(x, n) {
                  if (n >= remaining) {
                    buf.push(bits | x >> (n -= remaining));
                    while (n >= 8) buf.push(x >> (n -= 8) & 255);
                    bits = 0;
                    remaining = 8;
                  }
                  if (n > 0) bits |= (x & (1 << n) - 1) << (remaining -= n);
                };
                var nlenbits = ndatalenbits(ver, mode);
                pack2(mode, 4);
                pack2(datalen, nlenbits);
                switch (mode) {
                  case MODE_NUMERIC:
                    for (var i2 = 2; i2 < datalen; i2 += 3) {
                      pack2(parseInt(data.substring(i2 - 2, i2 + 1), 10), 10);
                    }
                    pack2(parseInt(data.substring(i2 - 2), 10), [0, 4, 7][datalen % 3]);
                    break;
                  case MODE_ALPHANUMERIC:
                    for (var i2 = 1; i2 < datalen; i2 += 2) {
                      pack2(ALPHANUMERIC_MAP[data.charAt(i2 - 1)] * 45 + ALPHANUMERIC_MAP[data.charAt(i2)], 11);
                    }
                    if (datalen % 2 == 1) {
                      pack2(ALPHANUMERIC_MAP[data.charAt(i2 - 1)], 6);
                    }
                    break;
                  case MODE_OCTET:
                    for (var i2 = 0; i2 < datalen; ++i2) {
                      pack2(data[i2], 8);
                    }
                    break;
                }
                pack2(MODE_TERMINATOR, 4);
                if (remaining < 8) buf.push(bits);
                while (buf.length + 1 < maxbuflen) buf.push(236, 17);
                if (buf.length < maxbuflen) buf.push(236);
                return buf;
              };
              var calculateecc = function(poly2, genpoly) {
                var modulus = poly2.slice(0);
                var polylen = poly2.length, genpolylen = genpoly.length;
                for (var i2 = 0; i2 < genpolylen; ++i2) modulus.push(0);
                for (var i2 = 0; i2 < polylen; ) {
                  var quotient = GF256_INVMAP[modulus[i2++]];
                  if (quotient >= 0) {
                    for (var j2 = 0; j2 < genpolylen; ++j2) {
                      modulus[i2 + j2] ^= GF256_MAP[(quotient + genpoly[j2]) % 255];
                    }
                  }
                }
                return modulus.slice(polylen);
              };
              var augumenteccs = function(poly2, nblocks, genpoly) {
                var subsizes = [];
                var subsize = poly2.length / nblocks | 0, subsize0 = 0;
                var pivot = nblocks - poly2.length % nblocks;
                for (var i2 = 0; i2 < pivot; ++i2) {
                  subsizes.push(subsize0);
                  subsize0 += subsize;
                }
                for (var i2 = pivot; i2 < nblocks; ++i2) {
                  subsizes.push(subsize0);
                  subsize0 += subsize + 1;
                }
                subsizes.push(subsize0);
                var eccs = [];
                for (var i2 = 0; i2 < nblocks; ++i2) {
                  eccs.push(calculateecc(poly2.slice(subsizes[i2], subsizes[i2 + 1]), genpoly));
                }
                var result = [];
                var nitemsperblock = poly2.length / nblocks | 0;
                for (var i2 = 0; i2 < nitemsperblock; ++i2) {
                  for (var j2 = 0; j2 < nblocks; ++j2) {
                    result.push(poly2[subsizes[j2] + i2]);
                  }
                }
                for (var j2 = pivot; j2 < nblocks; ++j2) {
                  result.push(poly2[subsizes[j2 + 1] - 1]);
                }
                for (var i2 = 0; i2 < genpoly.length; ++i2) {
                  for (var j2 = 0; j2 < nblocks; ++j2) {
                    result.push(eccs[j2][i2]);
                  }
                }
                return result;
              };
              var augumentbch = function(poly2, p, genpoly, q) {
                var modulus = poly2 << q;
                for (var i2 = p - 1; i2 >= 0; --i2) {
                  if (modulus >> q + i2 & 1) modulus ^= genpoly << i2;
                }
                return poly2 << q | modulus;
              };
              var makebasematrix = function(ver) {
                var v2 = VERSIONS[ver], n = getsizebyver(ver);
                var matrix = [], reserved = [];
                for (var i2 = 0; i2 < n; ++i2) {
                  matrix.push([]);
                  reserved.push([]);
                }
                var blit = function(y, x, h, w, bits) {
                  for (var i3 = 0; i3 < h; ++i3) {
                    for (var j3 = 0; j3 < w; ++j3) {
                      matrix[y + i3][x + j3] = bits[i3] >> j3 & 1;
                      reserved[y + i3][x + j3] = 1;
                    }
                  }
                };
                blit(0, 0, 9, 9, [127, 65, 93, 93, 93, 65, 383, 0, 64]);
                blit(n - 8, 0, 8, 9, [256, 127, 65, 93, 93, 93, 65, 127]);
                blit(0, n - 8, 9, 8, [254, 130, 186, 186, 186, 130, 254, 0, 0]);
                for (var i2 = 9; i2 < n - 8; ++i2) {
                  matrix[6][i2] = matrix[i2][6] = ~i2 & 1;
                  reserved[6][i2] = reserved[i2][6] = 1;
                }
                var aligns = v2[2], m = aligns.length;
                for (var i2 = 0; i2 < m; ++i2) {
                  var minj = i2 === 0 || i2 === m - 1 ? 1 : 0, maxj = i2 === 0 ? m - 1 : m;
                  for (var j2 = minj; j2 < maxj; ++j2) {
                    blit(aligns[i2], aligns[j2], 5, 5, [31, 17, 21, 17, 31]);
                  }
                }
                if (needsverinfo(ver)) {
                  var code = augumentbch(ver, 6, 7973, 12);
                  var k = 0;
                  for (var i2 = 0; i2 < 6; ++i2) {
                    for (var j2 = 0; j2 < 3; ++j2) {
                      matrix[i2][n - 11 + j2] = matrix[n - 11 + j2][i2] = code >> k++ & 1;
                      reserved[i2][n - 11 + j2] = reserved[n - 11 + j2][i2] = 1;
                    }
                  }
                }
                return {
                  matrix,
                  reserved
                };
              };
              var putdata = function(matrix, reserved, buf) {
                var n = matrix.length;
                var k = 0, dir = -1;
                for (var i2 = n - 1; i2 >= 0; i2 -= 2) {
                  if (i2 == 6) --i2;
                  var jj = dir < 0 ? n - 1 : 0;
                  for (var j2 = 0; j2 < n; ++j2) {
                    for (var ii = i2; ii > i2 - 2; --ii) {
                      if (!reserved[jj][ii]) {
                        matrix[jj][ii] = buf[k >> 3] >> (~k & 7) & 1;
                        ++k;
                      }
                    }
                    jj += dir;
                  }
                  dir = -dir;
                }
                return matrix;
              };
              var maskdata = function(matrix, reserved, mask) {
                var maskf = MASKFUNCS[mask];
                var n = matrix.length;
                for (var i2 = 0; i2 < n; ++i2) {
                  for (var j2 = 0; j2 < n; ++j2) {
                    if (!reserved[i2][j2]) matrix[i2][j2] ^= maskf(i2, j2);
                  }
                }
                return matrix;
              };
              var putformatinfo = function(matrix, reserved, ecclevel, mask) {
                var n = matrix.length;
                var code = augumentbch(ecclevel << 3 | mask, 5, 1335, 10) ^ 21522;
                for (var i2 = 0; i2 < 15; ++i2) {
                  var r = [0, 1, 2, 3, 4, 5, 7, 8, n - 7, n - 6, n - 5, n - 4, n - 3, n - 2, n - 1][i2];
                  var c = [n - 1, n - 2, n - 3, n - 4, n - 5, n - 6, n - 7, n - 8, 7, 5, 4, 3, 2, 1, 0][i2];
                  matrix[r][8] = matrix[8][c] = code >> i2 & 1;
                }
                return matrix;
              };
              var evaluatematrix = function(matrix) {
                var PENALTY_CONSECUTIVE = 3;
                var PENALTY_TWOBYTWO = 3;
                var PENALTY_FINDERLIKE = 40;
                var PENALTY_DENSITY = 10;
                var evaluategroup = function(groups2) {
                  var score2 = 0;
                  for (var i3 = 0; i3 < groups2.length; ++i3) {
                    if (groups2[i3] >= 5) score2 += PENALTY_CONSECUTIVE + (groups2[i3] - 5);
                  }
                  for (var i3 = 5; i3 < groups2.length; i3 += 2) {
                    var p2 = groups2[i3];
                    if (groups2[i3 - 1] == p2 && groups2[i3 - 2] == 3 * p2 && groups2[i3 - 3] == p2 && groups2[i3 - 4] == p2 && (groups2[i3 - 5] >= 4 * p2 || groups2[i3 + 1] >= 4 * p2)) {
                      score2 += PENALTY_FINDERLIKE;
                    }
                  }
                  return score2;
                };
                var n = matrix.length;
                var score = 0, nblacks = 0;
                for (var i2 = 0; i2 < n; ++i2) {
                  var row = matrix[i2];
                  var groups;
                  groups = [0];
                  for (var j2 = 0; j2 < n; ) {
                    var k;
                    for (k = 0; j2 < n && row[j2]; ++k) ++j2;
                    groups.push(k);
                    for (k = 0; j2 < n && !row[j2]; ++k) ++j2;
                    groups.push(k);
                  }
                  score += evaluategroup(groups);
                  groups = [0];
                  for (var j2 = 0; j2 < n; ) {
                    var k;
                    for (k = 0; j2 < n && matrix[j2][i2]; ++k) ++j2;
                    groups.push(k);
                    for (k = 0; j2 < n && !matrix[j2][i2]; ++k) ++j2;
                    groups.push(k);
                  }
                  score += evaluategroup(groups);
                  var nextrow = matrix[i2 + 1] || [];
                  nblacks += row[0];
                  for (var j2 = 1; j2 < n; ++j2) {
                    var p = row[j2];
                    nblacks += p;
                    if (row[j2 - 1] == p && nextrow[j2] === p && nextrow[j2 - 1] === p) {
                      score += PENALTY_TWOBYTWO;
                    }
                  }
                }
                score += PENALTY_DENSITY * (Math.abs(nblacks / n / n - 0.5) / 0.05 | 0);
                return score;
              };
              var generate = function(data, ver, mode, ecclevel, mask) {
                var v2 = VERSIONS[ver];
                var buf = encode(ver, mode, data, ndatabits(ver, ecclevel) >> 3);
                buf = augumenteccs(buf, v2[1][ecclevel], GF256_GENPOLY[v2[0][ecclevel]]);
                var result = makebasematrix(ver);
                var matrix = result.matrix, reserved = result.reserved;
                putdata(matrix, reserved, buf);
                if (mask < 0) {
                  maskdata(matrix, reserved, 0);
                  putformatinfo(matrix, reserved, ecclevel, 0);
                  var bestmask = 0, bestscore = evaluatematrix(matrix);
                  maskdata(matrix, reserved, 0);
                  for (mask = 1; mask < 8; ++mask) {
                    maskdata(matrix, reserved, mask);
                    putformatinfo(matrix, reserved, ecclevel, mask);
                    var score = evaluatematrix(matrix);
                    if (bestscore > score) {
                      bestscore = score;
                      bestmask = mask;
                    }
                    maskdata(matrix, reserved, mask);
                  }
                  mask = bestmask;
                }
                maskdata(matrix, reserved, mask);
                putformatinfo(matrix, reserved, ecclevel, mask);
                return matrix;
              };
              function generateFrame(data, options) {
                var MODES = {
                  "numeric": MODE_NUMERIC,
                  "alphanumeric": MODE_ALPHANUMERIC,
                  "octet": MODE_OCTET
                };
                var ECCLEVELS = {
                  "L": ECCLEVEL_L,
                  "M": ECCLEVEL_M,
                  "Q": ECCLEVEL_Q,
                  "H": ECCLEVEL_H
                };
                options = options || {};
                var ver = options.version || -1;
                var ecclevel = ECCLEVELS[(options.eccLevel || "L").toUpperCase()];
                var mode = options.mode ? MODES[options.mode.toLowerCase()] : -1;
                var mask = "mask" in options ? options.mask : -1;
                if (mode < 0) {
                  if (typeof data === "string") {
                    if (data.match(NUMERIC_REGEXP)) {
                      mode = MODE_NUMERIC;
                    } else if (data.match(ALPHANUMERIC_OUT_REGEXP)) {
                      mode = MODE_ALPHANUMERIC;
                    } else {
                      mode = MODE_OCTET;
                    }
                  } else {
                    mode = MODE_OCTET;
                  }
                } else if (!(mode == MODE_NUMERIC || mode == MODE_ALPHANUMERIC || mode == MODE_OCTET)) {
                  throw "invalid or unsupported mode";
                }
                data = validatedata(mode, data);
                if (data === null) throw "invalid data format";
                if (ecclevel < 0 || ecclevel > 3) throw "invalid ECC level";
                if (ver < 0) {
                  for (ver = 1; ver <= 40; ++ver) {
                    if (data.length <= getmaxdatalen(ver, mode, ecclevel)) break;
                  }
                  if (ver > 40) throw "too large data for the Qr format";
                } else if (ver < 1 || ver > 40) {
                  throw "invalid Qr version! should be between 1 and 40";
                }
                if (mask != -1 && (mask < 0 || mask > 8)) throw "invalid mask";
                return generate(data, ver, mode, ecclevel, mask);
              }
              function buildCanvas(data, options) {
                var canvas = [];
                var background = options.background || "#fff";
                var foreground = options.foreground || "#000";
                var padding = options.padding || 0;
                var matrix = generateFrame(data, options);
                var n = matrix.length;
                var modSize = Math.floor(options.fit ? options.fit / n : 5);
                var size = n * modSize + modSize * padding * 2;
                var paddingXY = modSize * padding;
                canvas.push({
                  type: "rect",
                  x: 0,
                  y: 0,
                  w: size,
                  h: size,
                  lineWidth: 0,
                  color: background
                });
                for (var i2 = 0; i2 < n; ++i2) {
                  for (var j2 = 0; j2 < n; ++j2) {
                    if (matrix[i2][j2]) {
                      canvas.push({
                        type: "rect",
                        x: modSize * j2 + paddingXY,
                        y: modSize * i2 + paddingXY,
                        w: modSize,
                        h: modSize,
                        lineWidth: 0,
                        color: foreground
                      });
                    }
                  }
                }
                return {
                  canvas,
                  size
                };
              }
              function measure(node) {
                var cd = buildCanvas(node.qr, node);
                node._canvas = cd.canvas;
                node._width = node._height = node._minWidth = node._maxWidth = node._minHeight = node._maxHeight = cd.size;
                return node;
              }
              const qrEnc = {
                measure
              };
              ;
              class DocMeasure {
                constructor(pdfDocument, styleDictionary, defaultStyle, svgMeasure, tableLayouts2) {
                  this.pdfDocument = pdfDocument;
                  this.textInlines = new src_TextInlines(pdfDocument);
                  this.styleStack = new src_StyleContextStack(styleDictionary, defaultStyle);
                  this.svgMeasure = svgMeasure;
                  this.tableLayouts = tableLayouts2;
                  this.autoImageIndex = 1;
                }
                /**
                 * Measures all nodes and sets min/max-width properties required for the second
                 * layout-pass.
                 *
                 * @param {object} docStructure document-definition-object
                 * @returns {object} document-measurement-object
                 */
                measureDocument(docStructure) {
                  return this.measureNode(docStructure);
                }
                measureBlock(node) {
                  return this.measureNode(node);
                }
                measureNode(node) {
                  return this.styleStack.auto(node, () => {
                    node._margin = getNodeMargin(node, this.styleStack);
                    if (node.section) {
                      return extendMargins(this.measureSection(node));
                    } else if (node.columns) {
                      return extendMargins(this.measureColumns(node));
                    } else if (node.stack) {
                      return extendMargins(this.measureVerticalContainer(node));
                    } else if (node.ul) {
                      return extendMargins(this.measureUnorderedList(node));
                    } else if (node.ol) {
                      return extendMargins(this.measureOrderedList(node));
                    } else if (node.table) {
                      return extendMargins(this.measureTable(node));
                    } else if (node.text !== void 0) {
                      return extendMargins(this.measureLeaf(node));
                    } else if (node.toc) {
                      return extendMargins(this.measureToc(node));
                    } else if (node.image) {
                      return extendMargins(this.measureImage(node));
                    } else if (node.svg) {
                      return extendMargins(this.measureSVG(node));
                    } else if (node.canvas) {
                      return extendMargins(this.measureCanvas(node));
                    } else if (node.qr) {
                      return extendMargins(this.measureQr(node));
                    } else if (node.attachment) {
                      return extendMargins(this.measureAttachment(node));
                    } else {
                      throw new Error(`Unrecognized document structure: ${stringifyNode(node)}`);
                    }
                  });
                  function extendMargins(node2) {
                    let margin = node2._margin;
                    if (margin) {
                      node2._minWidth += margin[0] + margin[2];
                      node2._maxWidth += margin[0] + margin[2];
                    }
                    return node2;
                  }
                }
                measureImageWithDimensions(node, dimensions) {
                  if (node.fit) {
                    let factor = dimensions.width / dimensions.height > node.fit[0] / node.fit[1] ? node.fit[0] / dimensions.width : node.fit[1] / dimensions.height;
                    node._width = node._minWidth = node._maxWidth = dimensions.width * factor;
                    node._height = dimensions.height * factor;
                  } else if (node.cover) {
                    node._width = node._minWidth = node._maxWidth = node.cover.width;
                    node._height = node._minHeight = node._maxHeight = node.cover.height;
                  } else {
                    let ratio = dimensions.width / dimensions.height;
                    node._width = node._minWidth = node._maxWidth = node.width || (node.height ? node.height * ratio : dimensions.width);
                    node._height = node.height || (node.width ? node.width / ratio : dimensions.height);
                    if (isNumber(node.maxWidth) && node.maxWidth < node._width) {
                      node._width = node._minWidth = node._maxWidth = node.maxWidth;
                      node._height = node._width * dimensions.height / dimensions.width;
                    }
                    if (isNumber(node.maxHeight) && node.maxHeight < node._height) {
                      node._height = node.maxHeight;
                      node._width = node._minWidth = node._maxWidth = node._height * dimensions.width / dimensions.height;
                    }
                    if (isNumber(node.minWidth) && node.minWidth > node._width) {
                      node._width = node._minWidth = node._maxWidth = node.minWidth;
                      node._height = node._width * dimensions.height / dimensions.width;
                    }
                    if (isNumber(node.minHeight) && node.minHeight > node._height) {
                      node._height = node.minHeight;
                      node._width = node._minWidth = node._maxWidth = node._height * dimensions.width / dimensions.height;
                    }
                  }
                  node._alignment = this.styleStack.getProperty("alignment");
                }
                convertIfBase64Image(node) {
                  if (/^data:image\/(jpeg|jpg|png);base64,/.test(node.image)) {
                    let label = `$$pdfmake$$${this.autoImageIndex++}`;
                    this.pdfDocument.images[label] = node.image;
                    node.image = label;
                  }
                }
                measureImage(node) {
                  this.convertIfBase64Image(node);
                  let image = this.pdfDocument.provideImage(node.image);
                  let imageSize = {
                    width: image.width,
                    height: image.height
                  };
                  if (image.orientation > 4) {
                    imageSize = {
                      width: image.height,
                      height: image.width
                    };
                  }
                  this.measureImageWithDimensions(node, imageSize);
                  return node;
                }
                measureSVG(node) {
                  let dimensions = this.svgMeasure.measureSVG(node.svg);
                  this.measureImageWithDimensions(node, dimensions);
                  node.font = this.styleStack.getProperty("font");
                  if (!isNumber(node._width) && !isNumber(node._height)) {
                    throw new Error("SVG is missing defined width and height.");
                  } else if (!isNumber(node._width)) {
                    throw new Error("SVG is missing defined width.");
                  } else if (!isNumber(node._height)) {
                    throw new Error("SVG is missing defined height.");
                  }
                  node.svg = this.svgMeasure.writeDimensions(node.svg, {
                    width: node._width,
                    height: node._height
                  });
                  return node;
                }
                measureLeaf(node) {
                  if (node._textRef && node._textRef._textNodeRef.text) {
                    node.text = node._textRef._textNodeRef.text;
                  }
                  let styleStack = this.styleStack.clone();
                  styleStack.push(node);
                  let data = this.textInlines.buildInlines(node.text, styleStack);
                  node._inlines = data.items;
                  node._minWidth = data.minWidth;
                  node._maxWidth = data.maxWidth;
                  return node;
                }
                measureToc(node) {
                  if (node.toc.title) {
                    node.toc.title = this.measureNode(node.toc.title);
                  }
                  if (node.toc._items.length > 0) {
                    let body = [];
                    let textStyle = node.toc.textStyle || {};
                    let numberStyle = node.toc.numberStyle || textStyle;
                    let textMargin = node.toc.textMargin || [0, 0, 0, 0];
                    if (node.toc.sortBy === "title") {
                      node.toc._items.sort((a2, b2) => {
                        return a2._textNodeRef.text.localeCompare(b2._textNodeRef.text, node.toc.sortLocale);
                      });
                    }
                    for (let i2 = 0, l = node.toc._items.length; i2 < l; i2++) {
                      let item = node.toc._items[i2];
                      let lineStyle = item._textNodeRef.tocStyle || textStyle;
                      let lineMargin = item._textNodeRef.tocMargin || textMargin;
                      let lineNumberStyle = item._textNodeRef.tocNumberStyle || numberStyle;
                      let destination = getNodeId(item._nodeRef);
                      body.push([{
                        text: item._textNodeRef.text,
                        linkToDestination: destination,
                        alignment: "left",
                        style: lineStyle,
                        margin: lineMargin
                      }, {
                        text: "00000",
                        linkToDestination: destination,
                        alignment: "right",
                        _tocItemRef: item._nodeRef,
                        style: lineNumberStyle,
                        margin: [0, lineMargin[1], 0, lineMargin[3]]
                      }]);
                    }
                    node.toc._table = {
                      table: {
                        dontBreakRows: true,
                        widths: ["*", "auto"],
                        body
                      },
                      layout: "noBorders"
                    };
                    node.toc._table = this.measureNode(node.toc._table);
                  }
                  return node;
                }
                measureVerticalContainer(node) {
                  let items = node.stack;
                  node._minWidth = 0;
                  node._maxWidth = 0;
                  for (let i2 = 0, l = items.length; i2 < l; i2++) {
                    items[i2] = this.measureNode(items[i2]);
                    node._minWidth = Math.max(node._minWidth, items[i2]._minWidth);
                    node._maxWidth = Math.max(node._maxWidth, items[i2]._maxWidth);
                  }
                  return node;
                }
                gapSizeForList() {
                  return this.textInlines.sizeOfText("9. ", this.styleStack);
                }
                buildUnorderedMarker(item, styleStack, gapSize, type) {
                  function buildDisc(gapSize2, color2) {
                    let radius = gapSize2.fontSize / 6;
                    return {
                      canvas: [{
                        x: radius,
                        y: gapSize2.height / gapSize2.lineHeight + gapSize2.descender - gapSize2.fontSize / 3,
                        r1: radius,
                        r2: radius,
                        type: "ellipse",
                        color: color2
                      }]
                    };
                  }
                  function buildSquare(gapSize2, color2) {
                    let size = gapSize2.fontSize / 3;
                    return {
                      canvas: [{
                        x: 0,
                        y: gapSize2.height / gapSize2.lineHeight + gapSize2.descender - gapSize2.fontSize / 3 - size / 2,
                        h: size,
                        w: size,
                        type: "rect",
                        color: color2
                      }]
                    };
                  }
                  function buildCircle(gapSize2, color2) {
                    let radius = gapSize2.fontSize / 6;
                    return {
                      canvas: [{
                        x: radius,
                        y: gapSize2.height / gapSize2.lineHeight + gapSize2.descender - gapSize2.fontSize / 3,
                        r1: radius,
                        r2: radius,
                        type: "ellipse",
                        lineColor: color2
                      }]
                    };
                  }
                  let marker;
                  let color = src_StyleContextStack.getStyleProperty(item, styleStack, "markerColor", void 0) || styleStack.getProperty("color") || "black";
                  switch (type) {
                    case "circle":
                      marker = buildCircle(gapSize, color);
                      break;
                    case "square":
                      marker = buildSquare(gapSize, color);
                      break;
                    case "none":
                      marker = {};
                      break;
                    case "disc":
                    default:
                      marker = buildDisc(gapSize, color);
                      break;
                  }
                  marker._minWidth = marker._maxWidth = gapSize.width;
                  marker._minHeight = marker._maxHeight = gapSize.height;
                  return marker;
                }
                buildOrderedMarker(item, counter, styleStack, type, separator) {
                  function prepareAlpha(counter2) {
                    function toAlpha(num) {
                      return (num >= 26 ? toAlpha((num / 26 >> 0) - 1) : "") + "abcdefghijklmnopqrstuvwxyz"[num % 26 >> 0];
                    }
                    if (counter2 < 1) {
                      return counter2.toString();
                    }
                    return toAlpha(counter2 - 1);
                  }
                  function prepareRoman(counter2) {
                    if (counter2 < 1 || counter2 > 4999) {
                      return counter2.toString();
                    }
                    let num = counter2;
                    let lookup = {
                      M: 1e3,
                      CM: 900,
                      D: 500,
                      CD: 400,
                      C: 100,
                      XC: 90,
                      L: 50,
                      XL: 40,
                      X: 10,
                      IX: 9,
                      V: 5,
                      IV: 4,
                      I: 1
                    };
                    let roman = "";
                    for (let i2 in lookup) {
                      while (num >= lookup[i2]) {
                        roman += i2;
                        num -= lookup[i2];
                      }
                    }
                    return roman;
                  }
                  function prepareDecimal(counter2) {
                    return counter2.toString();
                  }
                  let counterText;
                  switch (type) {
                    case "none":
                      counterText = null;
                      break;
                    case "upper-alpha":
                      counterText = prepareAlpha(counter).toUpperCase();
                      break;
                    case "lower-alpha":
                      counterText = prepareAlpha(counter);
                      break;
                    case "upper-roman":
                      counterText = prepareRoman(counter);
                      break;
                    case "lower-roman":
                      counterText = prepareRoman(counter).toLowerCase();
                      break;
                    case "decimal":
                    default:
                      counterText = prepareDecimal(counter);
                      break;
                  }
                  if (counterText === null) {
                    return {};
                  }
                  if (separator) {
                    if (Array.isArray(separator)) {
                      if (separator[0]) {
                        counterText = separator[0] + counterText;
                      }
                      if (separator[1]) {
                        counterText += separator[1];
                      }
                      counterText += " ";
                    } else {
                      counterText += `${separator} `;
                    }
                  }
                  let markerColor = src_StyleContextStack.getStyleProperty(item, styleStack, "markerColor", void 0) || styleStack.getProperty("color") || "black";
                  let textArray = {
                    text: counterText,
                    color: markerColor
                  };
                  return {
                    _inlines: this.textInlines.buildInlines(textArray, styleStack).items
                  };
                }
                measureUnorderedList(node) {
                  let style = this.styleStack.clone();
                  let items = node.ul;
                  node.type = node.type || "disc";
                  node._gapSize = this.gapSizeForList();
                  node._minWidth = 0;
                  node._maxWidth = 0;
                  for (let i2 = 0, l = items.length; i2 < l; i2++) {
                    let item = items[i2] = this.measureNode(items[i2]);
                    if (!item.ol && !item.ul) {
                      item.listMarker = this.buildUnorderedMarker(item, style, node._gapSize, item.listType || node.type);
                    }
                    node._minWidth = Math.max(node._minWidth, items[i2]._minWidth + node._gapSize.width);
                    node._maxWidth = Math.max(node._maxWidth, items[i2]._maxWidth + node._gapSize.width);
                  }
                  return node;
                }
                measureOrderedList(node) {
                  let style = this.styleStack.clone();
                  let items = node.ol;
                  node.type = node.type || "decimal";
                  node.separator = node.separator || ".";
                  node.reversed = node.reversed || false;
                  if (!isNumber(node.start)) {
                    node.start = node.reversed ? items.length : 1;
                  }
                  node._gapSize = this.gapSizeForList();
                  node._minWidth = 0;
                  node._maxWidth = 0;
                  let counter = node.start;
                  for (let i2 = 0, l = items.length; i2 < l; i2++) {
                    let item = items[i2] = this.measureNode(items[i2]);
                    if (!item.ol && !item.ul) {
                      let counterValue = isNumber(item.counter) ? item.counter : counter;
                      item.listMarker = this.buildOrderedMarker(item, counterValue, style, item.listType || node.type, node.separator);
                      if (item.listMarker._inlines) {
                        node._gapSize.width = Math.max(node._gapSize.width, item.listMarker._inlines[0].width);
                      }
                      if (node.reversed) {
                        counter--;
                      } else {
                        counter++;
                      }
                    }
                    node._minWidth = Math.max(node._minWidth, items[i2]._minWidth);
                    node._maxWidth = Math.max(node._maxWidth, items[i2]._maxWidth);
                  }
                  node._minWidth += node._gapSize.width;
                  node._maxWidth += node._gapSize.width;
                  for (let i2 = 0, l = items.length; i2 < l; i2++) {
                    let item = items[i2];
                    if (!item.ol && !item.ul) {
                      item.listMarker._minWidth = item.listMarker._maxWidth = node._gapSize.width;
                    }
                  }
                  return node;
                }
                measureSection(node) {
                  node.section = this.measureNode(node.section);
                  return node;
                }
                measureColumns(node) {
                  let columns = node.columns;
                  node._gap = this.styleStack.getProperty("columnGap") || 0;
                  for (let i2 = 0, l = columns.length; i2 < l; i2++) {
                    columns[i2] = this.measureNode(columns[i2]);
                  }
                  let measures = columnCalculator.measureMinMax(columns);
                  let numGaps = columns.length > 0 ? columns.length - 1 : 0;
                  node._minWidth = measures.min + node._gap * numGaps;
                  node._maxWidth = measures.max + node._gap * numGaps;
                  return node;
                }
                measureTable(node) {
                  extendTableWidths(node);
                  node._layout = getLayout(this.tableLayouts);
                  node._offsets = getOffsets(node._layout);
                  let colSpans = [];
                  let col;
                  let row;
                  let cols;
                  let rows;
                  for (col = 0, cols = node.table.body[0].length; col < cols; col++) {
                    let c = node.table.widths[col];
                    c._minWidth = 0;
                    c._maxWidth = 0;
                    for (row = 0, rows = node.table.body.length; row < rows; row++) {
                      let rowData = node.table.body[row];
                      let data = rowData[col];
                      if (data === void 0) {
                        throw new Error(`Malformed table row, a cell is undefined.
Row index: ${row}
Column index: ${col}
Row data: ${stringifyNode(rowData)}`);
                      }
                      if (data === null) {
                        data = "";
                      }
                      if (!data._span) {
                        data = rowData[col] = this.styleStack.auto(data, measureCb(this, data));
                        if (data.colSpan && data.colSpan > 1) {
                          markSpans(rowData, col, data.colSpan);
                          colSpans.push({
                            col,
                            span: data.colSpan,
                            minWidth: data._minWidth,
                            maxWidth: data._maxWidth
                          });
                        } else {
                          c._minWidth = Math.max(c._minWidth, data._minWidth);
                          c._maxWidth = Math.max(c._maxWidth, data._maxWidth);
                        }
                      }
                      if (data.rowSpan && data.rowSpan > 1) {
                        markVSpans(node.table, row, col, data.rowSpan);
                      }
                    }
                  }
                  extendWidthsForColSpans();
                  let measures = columnCalculator.measureMinMax(node.table.widths);
                  node._minWidth = measures.min + node._offsets.total;
                  node._maxWidth = measures.max + node._offsets.total;
                  return node;
                  function measureCb(_this, data) {
                    return () => {
                      if (isObject(data)) {
                        data.fillColor = _this.styleStack.getProperty("fillColor");
                        data.fillOpacity = _this.styleStack.getProperty("fillOpacity");
                      }
                      return _this.measureNode(data);
                    };
                  }
                  function getLayout(tableLayouts2) {
                    let layout = node.layout;
                    if (isString(layout)) {
                      layout = tableLayouts2[layout];
                    }
                    return pack(defaultTableLayout, layout);
                  }
                  function getOffsets(layout) {
                    let offsets = [];
                    let totalOffset = 0;
                    let prevRightPadding = 0;
                    for (let i2 = 0, l = node.table.widths.length; i2 < l; i2++) {
                      let lOffset = prevRightPadding + layout.vLineWidth(i2, node) + layout.paddingLeft(i2, node);
                      offsets.push(lOffset);
                      totalOffset += lOffset;
                      prevRightPadding = layout.paddingRight(i2, node);
                    }
                    totalOffset += prevRightPadding + layout.vLineWidth(node.table.widths.length, node);
                    return {
                      total: totalOffset,
                      offsets
                    };
                  }
                  function extendWidthsForColSpans() {
                    let q;
                    let j2;
                    for (let i2 = 0, l = colSpans.length; i2 < l; i2++) {
                      let span = colSpans[i2];
                      let currentMinMax = getMinMax(span.col, span.span, node._offsets);
                      let minDifference = span.minWidth - currentMinMax.minWidth;
                      let maxDifference = span.maxWidth - currentMinMax.maxWidth;
                      if (minDifference > 0) {
                        q = minDifference / span.span;
                        for (j2 = 0; j2 < span.span; j2++) {
                          node.table.widths[span.col + j2]._minWidth += q;
                        }
                      }
                      if (maxDifference > 0) {
                        q = maxDifference / span.span;
                        for (j2 = 0; j2 < span.span; j2++) {
                          node.table.widths[span.col + j2]._maxWidth += q;
                        }
                      }
                    }
                  }
                  function getMinMax(col2, span, offsets) {
                    let result = {
                      minWidth: 0,
                      maxWidth: 0
                    };
                    for (let i2 = 0; i2 < span; i2++) {
                      result.minWidth += node.table.widths[col2 + i2]._minWidth + (i2 ? offsets.offsets[col2 + i2] : 0);
                      result.maxWidth += node.table.widths[col2 + i2]._maxWidth + (i2 ? offsets.offsets[col2 + i2] : 0);
                    }
                    return result;
                  }
                  function markSpans(rowData, col2, span) {
                    for (let i2 = 1; i2 < span; i2++) {
                      rowData[col2 + i2] = {
                        _span: true,
                        _minWidth: 0,
                        _maxWidth: 0,
                        rowSpan: rowData[col2].rowSpan
                      };
                    }
                  }
                  function markVSpans(table, row2, col2, span) {
                    for (let i2 = 1; i2 < span; i2++) {
                      table.body[row2 + i2][col2] = {
                        _span: true,
                        _minWidth: 0,
                        _maxWidth: 0,
                        fillColor: table.body[row2][col2].fillColor,
                        fillOpacity: table.body[row2][col2].fillOpacity
                      };
                    }
                  }
                  function extendTableWidths(node2) {
                    if (!node2.table.widths) {
                      node2.table.widths = "auto";
                    }
                    if (isString(node2.table.widths)) {
                      node2.table.widths = [node2.table.widths];
                      while (node2.table.widths.length < node2.table.body[0].length) {
                        node2.table.widths.push(node2.table.widths[node2.table.widths.length - 1]);
                      }
                    }
                    for (let i2 = 0, l = node2.table.widths.length; i2 < l; i2++) {
                      let w = node2.table.widths[i2];
                      if (isNumber(w) || isString(w)) {
                        node2.table.widths[i2] = {
                          width: w
                        };
                      }
                    }
                  }
                }
                measureCanvas(node) {
                  let w = 0;
                  let h = 0;
                  for (let i2 = 0, l = node.canvas.length; i2 < l; i2++) {
                    let vector = node.canvas[i2];
                    switch (vector.type) {
                      case "ellipse":
                        w = Math.max(w, vector.x + vector.r1);
                        h = Math.max(h, vector.y + vector.r2);
                        break;
                      case "rect":
                        w = Math.max(w, vector.x + vector.w);
                        h = Math.max(h, vector.y + vector.h);
                        break;
                      case "line":
                        w = Math.max(w, vector.x1, vector.x2);
                        h = Math.max(h, vector.y1, vector.y2);
                        break;
                      case "polyline":
                        for (let i22 = 0, l2 = vector.points.length; i22 < l2; i22++) {
                          w = Math.max(w, vector.points[i22].x);
                          h = Math.max(h, vector.points[i22].y);
                        }
                        break;
                    }
                  }
                  node._minWidth = node._maxWidth = w;
                  node._minHeight = node._maxHeight = h;
                  node._alignment = this.styleStack.getProperty("alignment");
                  return node;
                }
                measureQr(node) {
                  node = qrEnc.measure(node);
                  node._alignment = this.styleStack.getProperty("alignment");
                  return node;
                }
                measureAttachment(node) {
                  node._width = node.width || 7;
                  node._height = node.height || 18;
                  return node;
                }
              }
              const src_DocMeasure = DocMeasure;
              var events = __webpack_require__2(4785);
              ;
              class DocumentContext extends events.EventEmitter {
                constructor() {
                  super();
                  this.pages = [];
                  this.pageMargins = void 0;
                  this.x = void 0;
                  this.availableWidth = void 0;
                  this.availableHeight = void 0;
                  this.page = -1;
                  this.snapshots = [];
                  this.backgroundLength = [];
                }
                beginColumnGroup(marginXTopParent, bottomByPage) {
                  if (bottomByPage === void 0) {
                    bottomByPage = {};
                  }
                  this.snapshots.push({
                    x: this.x,
                    y: this.y,
                    availableHeight: this.availableHeight,
                    availableWidth: this.availableWidth,
                    page: this.page,
                    bottomByPage: bottomByPage ? bottomByPage : {},
                    bottomMost: {
                      x: this.x,
                      y: this.y,
                      availableHeight: this.availableHeight,
                      availableWidth: this.availableWidth,
                      page: this.page
                    },
                    lastColumnWidth: this.lastColumnWidth
                  });
                  this.lastColumnWidth = 0;
                  if (marginXTopParent) {
                    this.marginXTopParent = marginXTopParent;
                  }
                }
                updateBottomByPage() {
                  const lastSnapshot = this.snapshots[this.snapshots.length - 1];
                  const lastPage = this.page;
                  let previousBottom = -Number.MIN_VALUE;
                  if (lastSnapshot.bottomByPage[lastPage]) {
                    previousBottom = lastSnapshot.bottomByPage[lastPage];
                  }
                  lastSnapshot.bottomByPage[lastPage] = Math.max(previousBottom, this.y);
                }
                resetMarginXTopParent() {
                  this.marginXTopParent = null;
                }
                beginColumn(width, offset, endingCell) {
                  let saved = this.snapshots[this.snapshots.length - 1];
                  this.calculateBottomMost(saved, endingCell);
                  this.page = saved.page;
                  this.x = this.x + this.lastColumnWidth + (offset || 0);
                  this.y = saved.y;
                  this.availableWidth = width;
                  this.availableHeight = saved.availableHeight;
                  this.lastColumnWidth = width;
                }
                calculateBottomMost(destContext, endingCell) {
                  if (endingCell) {
                    this.saveContextInEndingCell(endingCell);
                  } else {
                    destContext.bottomMost = bottomMostContext(this, destContext.bottomMost);
                  }
                }
                markEnding(endingCell, originalXOffset, discountY) {
                  this.page = endingCell._columnEndingContext.page;
                  this.x = endingCell._columnEndingContext.x + originalXOffset;
                  this.y = endingCell._columnEndingContext.y - discountY;
                  this.availableWidth = endingCell._columnEndingContext.availableWidth;
                  this.availableHeight = endingCell._columnEndingContext.availableHeight;
                  this.lastColumnWidth = endingCell._columnEndingContext.lastColumnWidth;
                }
                saveContextInEndingCell(endingCell) {
                  endingCell._columnEndingContext = {
                    page: this.page,
                    x: this.x,
                    y: this.y,
                    availableHeight: this.availableHeight,
                    availableWidth: this.availableWidth,
                    lastColumnWidth: this.lastColumnWidth
                  };
                }
                completeColumnGroup(height, endingCell) {
                  let saved = this.snapshots.pop();
                  this.calculateBottomMost(saved, endingCell);
                  this.x = saved.x;
                  let y = saved.bottomMost.y;
                  if (height) {
                    if (saved.page === saved.bottomMost.page) {
                      if (saved.y + height > y) {
                        y = saved.y + height;
                      }
                    } else {
                      y += height;
                    }
                  }
                  this.y = y;
                  this.page = saved.bottomMost.page;
                  this.availableWidth = saved.availableWidth;
                  this.availableHeight = saved.bottomMost.availableHeight;
                  if (height) {
                    this.availableHeight -= y - saved.bottomMost.y;
                  }
                  this.lastColumnWidth = saved.lastColumnWidth;
                  return saved.bottomByPage;
                }
                addMargin(left, right) {
                  this.x += left;
                  this.availableWidth -= left + (right || 0);
                }
                moveDown(offset) {
                  this.y += offset;
                  this.availableHeight -= offset;
                  return this.availableHeight > 0;
                }
                initializePage() {
                  this.y = this.pageMargins.top;
                  this.availableHeight = this.getCurrentPage().pageSize.height - this.pageMargins.top - this.pageMargins.bottom;
                  const {
                    pageCtx,
                    isSnapshot
                  } = this.pageSnapshot();
                  pageCtx.availableWidth = this.getCurrentPage().pageSize.width - this.pageMargins.left - this.pageMargins.right;
                  if (isSnapshot && this.marginXTopParent) {
                    pageCtx.availableWidth -= this.marginXTopParent[0];
                    pageCtx.availableWidth -= this.marginXTopParent[1];
                  }
                }
                pageSnapshot() {
                  if (this.snapshots[0]) {
                    return {
                      pageCtx: this.snapshots[0],
                      isSnapshot: true
                    };
                  } else {
                    return {
                      pageCtx: this,
                      isSnapshot: false
                    };
                  }
                }
                moveTo(x, y) {
                  if (x !== void 0 && x !== null) {
                    this.x = x;
                    this.availableWidth = this.getCurrentPage().pageSize.width - this.x - this.pageMargins.right;
                  }
                  if (y !== void 0 && y !== null) {
                    this.y = y;
                    this.availableHeight = this.getCurrentPage().pageSize.height - this.y - this.pageMargins.bottom;
                  }
                }
                moveToRelative(x, y) {
                  if (x !== void 0 && x !== null) {
                    this.x = this.x + x;
                  }
                  if (y !== void 0 && y !== null) {
                    this.y = this.y + y;
                  }
                }
                beginDetachedBlock() {
                  this.snapshots.push({
                    x: this.x,
                    y: this.y,
                    availableHeight: this.availableHeight,
                    availableWidth: this.availableWidth,
                    page: this.page,
                    lastColumnWidth: this.lastColumnWidth
                  });
                }
                endDetachedBlock() {
                  let saved = this.snapshots.pop();
                  this.x = saved.x;
                  this.y = saved.y;
                  this.availableWidth = saved.availableWidth;
                  this.availableHeight = saved.availableHeight;
                  this.page = saved.page;
                  this.lastColumnWidth = saved.lastColumnWidth;
                }
                moveToNextPage(pageOrientation2) {
                  let nextPageIndex = this.page + 1;
                  let prevPage = this.page;
                  let prevY = this.y;
                  if (this.snapshots.length > 0) {
                    let lastSnapshot = this.snapshots[this.snapshots.length - 1];
                    if (lastSnapshot.bottomMost && lastSnapshot.bottomMost.y) {
                      prevY = Math.max(this.y, lastSnapshot.bottomMost.y);
                    }
                  }
                  let createNewPage = nextPageIndex >= this.pages.length;
                  if (createNewPage) {
                    let currentAvailableWidth = this.availableWidth;
                    let currentPageOrientation = this.getCurrentPage().pageSize.orientation;
                    let pageSize = getPageSize(this.getCurrentPage(), pageOrientation2);
                    this.addPage(pageSize, null, this.getCurrentPage().customProperties);
                    if (currentPageOrientation === pageSize.orientation) {
                      this.availableWidth = currentAvailableWidth;
                    }
                  } else {
                    this.page = nextPageIndex;
                    this.initializePage();
                  }
                  return {
                    newPageCreated: createNewPage,
                    prevPage,
                    prevY,
                    y: this.y
                  };
                }
                addPage(pageSize, pageMargin, customProperties) {
                  if (pageMargin === void 0) {
                    pageMargin = null;
                  }
                  if (customProperties === void 0) {
                    customProperties = {};
                  }
                  if (pageMargin !== null) {
                    this.pageMargins = pageMargin;
                    this.x = pageMargin.left;
                    this.availableWidth = pageSize.width - pageMargin.left - pageMargin.right;
                  }
                  let page = {
                    items: [],
                    pageSize,
                    pageMargins: this.pageMargins,
                    customProperties
                  };
                  this.pages.push(page);
                  this.backgroundLength.push(0);
                  this.page = this.pages.length - 1;
                  this.initializePage();
                  this.emit("pageAdded", page);
                  return page;
                }
                getCurrentPage() {
                  if (this.page < 0 || this.page >= this.pages.length) {
                    return null;
                  }
                  return this.pages[this.page];
                }
                getCurrentPosition() {
                  let pageSize = this.getCurrentPage().pageSize;
                  let innerHeight = pageSize.height - this.pageMargins.top - this.pageMargins.bottom;
                  let innerWidth = pageSize.width - this.pageMargins.left - this.pageMargins.right;
                  return {
                    pageNumber: this.page + 1,
                    pageOrientation: pageSize.orientation,
                    pageInnerHeight: innerHeight,
                    pageInnerWidth: innerWidth,
                    left: this.x,
                    top: this.y,
                    verticalRatio: (this.y - this.pageMargins.top) / innerHeight,
                    horizontalRatio: (this.x - this.pageMargins.left) / innerWidth
                  };
                }
              }
              function pageOrientation(pageOrientationString, currentPageOrientation) {
                if (pageOrientationString === void 0) {
                  return currentPageOrientation;
                } else if (isString(pageOrientationString) && pageOrientationString.toLowerCase() === "landscape") {
                  return "landscape";
                } else {
                  return "portrait";
                }
              }
              const getPageSize = (currentPage, newPageOrientation) => {
                newPageOrientation = pageOrientation(newPageOrientation, currentPage.pageSize.orientation);
                if (newPageOrientation !== currentPage.pageSize.orientation) {
                  return {
                    orientation: newPageOrientation,
                    width: currentPage.pageSize.height,
                    height: currentPage.pageSize.width
                  };
                } else {
                  return {
                    orientation: currentPage.pageSize.orientation,
                    width: currentPage.pageSize.width,
                    height: currentPage.pageSize.height
                  };
                }
              };
              function bottomMostContext(c1, c2) {
                let r;
                if (c1.page > c2.page) {
                  r = c1;
                } else if (c2.page > c1.page) {
                  r = c2;
                } else {
                  r = c1.y > c2.y ? c1 : c2;
                }
                return {
                  page: r.page,
                  x: r.x,
                  y: r.y,
                  availableHeight: r.availableHeight,
                  availableWidth: r.availableWidth
                };
              }
              const src_DocumentContext = DocumentContext;
              ;
              class ElementWriter extends events.EventEmitter {
                /**
                 * @param {DocumentContext} context
                 */
                constructor(context) {
                  super();
                  this._context = context;
                  this.contextStack = [];
                }
                /**
                 * @returns {DocumentContext}
                 */
                context() {
                  return this._context;
                }
                addLine(line, dontUpdateContextPosition, index) {
                  let height = line.getHeight();
                  let context = this.context();
                  let page = context.getCurrentPage();
                  let position = this.getCurrentPositionOnPage();
                  if (context.availableHeight < height || !page) {
                    return false;
                  }
                  line.x = context.x + (line.x || 0);
                  line.y = context.y + (line.y || 0);
                  this.alignLine(line);
                  addPageItem(page, {
                    type: "line",
                    item: line
                  }, index);
                  this.emit("lineAdded", line);
                  if (!dontUpdateContextPosition) {
                    context.moveDown(height);
                  }
                  return position;
                }
                alignLine(line) {
                  let width = this.context().availableWidth;
                  let lineWidth = line.getWidth();
                  let alignment = line.inlines && line.inlines.length > 0 && line.inlines[0].alignment;
                  let offset = 0;
                  switch (alignment) {
                    case "right":
                      offset = width - lineWidth;
                      break;
                    case "center":
                      offset = (width - lineWidth) / 2;
                      break;
                  }
                  if (offset) {
                    line.x = (line.x || 0) + offset;
                  }
                  if (alignment === "justify" && !line.newLineForced && !line.lastLineInParagraph && line.inlines.length > 1) {
                    let additionalSpacing = (width - lineWidth) / (line.inlines.length - 1);
                    for (let i2 = 1, l = line.inlines.length; i2 < l; i2++) {
                      offset = i2 * additionalSpacing;
                      line.inlines[i2].x += offset;
                      line.inlines[i2].justifyShift = additionalSpacing;
                    }
                  }
                }
                addImage(image, index) {
                  let context = this.context();
                  let page = context.getCurrentPage();
                  let position = this.getCurrentPositionOnPage();
                  if (!page || image.absolutePosition === void 0 && context.availableHeight < image._height && page.items.length > 0) {
                    return false;
                  }
                  if (image._x === void 0) {
                    image._x = image.x || 0;
                  }
                  image.x = context.x + image._x;
                  image.y = context.y;
                  this.alignImage(image);
                  addPageItem(page, {
                    type: "image",
                    item: image
                  }, index);
                  context.moveDown(image._height);
                  return position;
                }
                addCanvas(node, index) {
                  let context = this.context();
                  let page = context.getCurrentPage();
                  let positions = [];
                  let height = node._minHeight;
                  if (!page || node.absolutePosition === void 0 && context.availableHeight < height) {
                    return false;
                  }
                  this.alignCanvas(node);
                  node.canvas.forEach(function(vector) {
                    let position = this.addVector(vector, false, false, index);
                    positions.push(position);
                    if (index !== void 0) {
                      index++;
                    }
                  }, this);
                  context.moveDown(height);
                  return positions;
                }
                addSVG(image, index) {
                  let context = this.context();
                  let page = context.getCurrentPage();
                  let position = this.getCurrentPositionOnPage();
                  if (!page || image.absolutePosition === void 0 && context.availableHeight < image._height && page.items.length > 0) {
                    return false;
                  }
                  if (image._x === void 0) {
                    image._x = image.x || 0;
                  }
                  image.x = context.x + image._x;
                  image.y = context.y;
                  this.alignImage(image);
                  addPageItem(page, {
                    type: "svg",
                    item: image
                  }, index);
                  context.moveDown(image._height);
                  return position;
                }
                addQr(qr, index) {
                  let context = this.context();
                  let page = context.getCurrentPage();
                  let position = this.getCurrentPositionOnPage();
                  if (!page || qr.absolutePosition === void 0 && context.availableHeight < qr._height) {
                    return false;
                  }
                  if (qr._x === void 0) {
                    qr._x = qr.x || 0;
                  }
                  qr.x = context.x + qr._x;
                  qr.y = context.y;
                  this.alignImage(qr);
                  for (let i2 = 0, l = qr._canvas.length; i2 < l; i2++) {
                    let vector = qr._canvas[i2];
                    vector.x += qr.x;
                    vector.y += qr.y;
                    this.addVector(vector, true, true, index);
                  }
                  context.moveDown(qr._height);
                  return position;
                }
                addAttachment(attachment, index) {
                  let context = this.context();
                  let page = context.getCurrentPage();
                  let position = this.getCurrentPositionOnPage();
                  if (!page || attachment.absolutePosition === void 0 && context.availableHeight < attachment._height && page.items.length > 0) {
                    return false;
                  }
                  if (attachment._x === void 0) {
                    attachment._x = attachment.x || 0;
                  }
                  attachment.x = context.x + attachment._x;
                  attachment.y = context.y;
                  addPageItem(page, {
                    type: "attachment",
                    item: attachment
                  }, index);
                  context.moveDown(attachment._height);
                  return position;
                }
                alignImage(image) {
                  let width = this.context().availableWidth;
                  let imageWidth = image._minWidth;
                  let offset = 0;
                  switch (image._alignment) {
                    case "right":
                      offset = width - imageWidth;
                      break;
                    case "center":
                      offset = (width - imageWidth) / 2;
                      break;
                  }
                  if (offset) {
                    image.x = (image.x || 0) + offset;
                  }
                }
                alignCanvas(node) {
                  let width = this.context().availableWidth;
                  let canvasWidth = node._minWidth;
                  let offset = 0;
                  switch (node._alignment) {
                    case "right":
                      offset = width - canvasWidth;
                      break;
                    case "center":
                      offset = (width - canvasWidth) / 2;
                      break;
                  }
                  if (offset) {
                    node.canvas.forEach((vector) => {
                      offsetVector(vector, offset, 0);
                    });
                  }
                }
                addVector(vector, ignoreContextX, ignoreContextY, index, forcePage) {
                  let context = this.context();
                  let page = context.getCurrentPage();
                  if (isNumber(forcePage)) {
                    page = context.pages[forcePage];
                  }
                  let position = this.getCurrentPositionOnPage();
                  if (page) {
                    offsetVector(vector, ignoreContextX ? 0 : context.x, ignoreContextY ? 0 : context.y);
                    addPageItem(page, {
                      type: "vector",
                      item: vector
                    }, index);
                    return position;
                  }
                }
                beginClip(width, height) {
                  let ctx = this.context();
                  let page = ctx.getCurrentPage();
                  page.items.push({
                    type: "beginClip",
                    item: {
                      x: ctx.x,
                      y: ctx.y,
                      width,
                      height
                    }
                  });
                  return true;
                }
                endClip() {
                  let ctx = this.context();
                  let page = ctx.getCurrentPage();
                  page.items.push({
                    type: "endClip"
                  });
                  return true;
                }
                addFragment(block, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition) {
                  let ctx = this.context();
                  let page = ctx.getCurrentPage();
                  if (!useBlockXOffset && block.height > ctx.availableHeight) {
                    return false;
                  }
                  block.items.forEach((item) => {
                    switch (item.type) {
                      case "line":
                        var l = item.item.clone();
                        if (l._node) {
                          l._node.positions[0].pageNumber = ctx.page + 1;
                        }
                        l.x = (l.x || 0) + (useBlockXOffset ? block.xOffset || 0 : ctx.x);
                        l.y = (l.y || 0) + (useBlockYOffset ? block.yOffset || 0 : ctx.y);
                        page.items.push({
                          type: "line",
                          item: l
                        });
                        break;
                      case "vector":
                        var v2 = pack(item.item);
                        offsetVector(v2, useBlockXOffset ? block.xOffset || 0 : ctx.x, useBlockYOffset ? block.yOffset || 0 : ctx.y);
                        if (v2._isFillColorFromUnbreakable) {
                          delete v2._isFillColorFromUnbreakable;
                          const endOfBackgroundItemsIndex = ctx.backgroundLength[ctx.page];
                          page.items.splice(endOfBackgroundItemsIndex, 0, {
                            type: "vector",
                            item: v2
                          });
                        } else {
                          page.items.push({
                            type: "vector",
                            item: v2
                          });
                        }
                        break;
                      case "image":
                      case "svg":
                        var img = pack(item.item);
                        img.x = (img.x || 0) + (useBlockXOffset ? block.xOffset || 0 : ctx.x);
                        img.y = (img.y || 0) + (useBlockYOffset ? block.yOffset || 0 : ctx.y);
                        page.items.push({
                          type: item.type,
                          item: img
                        });
                        break;
                    }
                  });
                  if (!dontUpdateContextPosition) {
                    ctx.moveDown(block.height);
                  }
                  return true;
                }
                /**
                 * Pushes the provided context onto the stack or creates a new one
                 *
                 * pushContext(context) - pushes the provided context and makes it current
                 * pushContext(width, height) - creates and pushes a new context with the specified width and height
                 * pushContext() - creates a new context for unbreakable blocks (with current availableWidth and full-page-height)
                 *
                 * @param {DocumentContext|number} contextOrWidth
                 * @param {number} height
                 */
                pushContext(contextOrWidth, height) {
                  if (contextOrWidth === void 0) {
                    height = this.context().getCurrentPage().height - this.context().pageMargins.top - this.context().pageMargins.bottom;
                    contextOrWidth = this.context().availableWidth;
                  }
                  if (isNumber(contextOrWidth)) {
                    let width = contextOrWidth;
                    contextOrWidth = new src_DocumentContext();
                    contextOrWidth.addPage({
                      width,
                      height
                    }, {
                      left: 0,
                      right: 0,
                      top: 0,
                      bottom: 0
                    });
                  }
                  this.contextStack.push(this.context());
                  this._context = contextOrWidth;
                }
                popContext() {
                  this._context = this.contextStack.pop();
                }
                getCurrentPositionOnPage() {
                  return (this.contextStack[0] || this.context()).getCurrentPosition();
                }
              }
              function addPageItem(page, item, index) {
                if (index === null || index === void 0 || index < 0 || index > page.items.length) {
                  page.items.push(item);
                } else {
                  page.items.splice(index, 0, item);
                }
              }
              const src_ElementWriter = ElementWriter;
              ;
              const standardPageSizes = {
                "4A0": [4767.87, 6740.79],
                "2A0": [3370.39, 4767.87],
                A0: [2383.94, 3370.39],
                A1: [1683.78, 2383.94],
                A2: [1190.55, 1683.78],
                A3: [841.89, 1190.55],
                A4: [595.28, 841.89],
                A5: [419.53, 595.28],
                A6: [297.64, 419.53],
                A7: [209.76, 297.64],
                A8: [147.4, 209.76],
                A9: [104.88, 147.4],
                A10: [73.7, 104.88],
                B0: [2834.65, 4008.19],
                B1: [2004.09, 2834.65],
                B2: [1417.32, 2004.09],
                B3: [1000.63, 1417.32],
                B4: [708.66, 1000.63],
                B5: [498.9, 708.66],
                B6: [354.33, 498.9],
                B7: [249.45, 354.33],
                B8: [175.75, 249.45],
                B9: [124.72, 175.75],
                B10: [87.87, 124.72],
                C0: [2599.37, 3676.54],
                C1: [1836.85, 2599.37],
                C2: [1298.27, 1836.85],
                C3: [918.43, 1298.27],
                C4: [649.13, 918.43],
                C5: [459.21, 649.13],
                C6: [323.15, 459.21],
                C7: [229.61, 323.15],
                C8: [161.57, 229.61],
                C9: [113.39, 161.57],
                C10: [79.37, 113.39],
                RA0: [2437.8, 3458.27],
                RA1: [1729.13, 2437.8],
                RA2: [1218.9, 1729.13],
                RA3: [864.57, 1218.9],
                RA4: [609.45, 864.57],
                SRA0: [2551.18, 3628.35],
                SRA1: [1814.17, 2551.18],
                SRA2: [1275.59, 1814.17],
                SRA3: [907.09, 1275.59],
                SRA4: [637.8, 907.09],
                EXECUTIVE: [521.86, 756],
                FOLIO: [612, 936],
                LEGAL: [612, 1008],
                LETTER: [612, 792],
                TABLOID: [792, 1224]
              };
              ;
              function normalizePageSize(pageSize, pageOrientation2) {
                function isNeedSwapPageSizes(pageOrientation3) {
                  if (isString(pageOrientation3)) {
                    pageOrientation3 = pageOrientation3.toLowerCase();
                    return pageOrientation3 === "portrait" && size.width > size.height || pageOrientation3 === "landscape" && size.width < size.height;
                  }
                  return false;
                }
                function pageSizeToWidthAndHeight(pageSize2) {
                  if (isString(pageSize2)) {
                    let size2 = standardPageSizes[pageSize2.toUpperCase()];
                    if (!size2) {
                      throw new Error(`Page size ${pageSize2} not recognized`);
                    }
                    return {
                      width: size2[0],
                      height: size2[1]
                    };
                  }
                  return pageSize2;
                }
                if (pageSize && pageSize.height === "auto") {
                  pageSize.height = Infinity;
                }
                let size = pageSizeToWidthAndHeight(pageSize || "A4");
                if (isNeedSwapPageSizes(pageOrientation2)) {
                  size = {
                    width: size.height,
                    height: size.width
                  };
                }
                size.orientation = size.width > size.height ? "landscape" : "portrait";
                return size;
              }
              function normalizePageMargin(margin) {
                if (isNumber(margin)) {
                  margin = {
                    left: margin,
                    right: margin,
                    top: margin,
                    bottom: margin
                  };
                } else if (Array.isArray(margin)) {
                  if (margin.length === 2) {
                    margin = {
                      left: margin[0],
                      top: margin[1],
                      right: margin[0],
                      bottom: margin[1]
                    };
                  } else if (margin.length === 4) {
                    margin = {
                      left: margin[0],
                      top: margin[1],
                      right: margin[2],
                      bottom: margin[3]
                    };
                  } else {
                    throw new Error("Invalid pageMargins definition");
                  }
                }
                return margin;
              }
              ;
              class PageElementWriter extends src_ElementWriter {
                /**
                 * @param {DocumentContext} context
                 */
                constructor(context) {
                  super(context);
                  this.transactionLevel = 0;
                  this.repeatables = [];
                }
                addLine(line, dontUpdateContextPosition, index) {
                  return this._fitOnPage(() => super.addLine(line, dontUpdateContextPosition, index));
                }
                addImage(image, index) {
                  return this._fitOnPage(() => super.addImage(image, index));
                }
                addCanvas(image, index) {
                  return this._fitOnPage(() => super.addCanvas(image, index));
                }
                addSVG(image, index) {
                  return this._fitOnPage(() => super.addSVG(image, index));
                }
                addQr(qr, index) {
                  return this._fitOnPage(() => super.addQr(qr, index));
                }
                addAttachment(attachment, index) {
                  return this._fitOnPage(() => super.addAttachment(attachment, index));
                }
                addVector(vector, ignoreContextX, ignoreContextY, index, forcePage) {
                  return super.addVector(vector, ignoreContextX, ignoreContextY, index, forcePage);
                }
                beginClip(width, height) {
                  return super.beginClip(width, height);
                }
                endClip() {
                  return super.endClip();
                }
                addFragment(fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition) {
                  return this._fitOnPage(() => super.addFragment(fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition));
                }
                moveToNextPage(pageOrientation2) {
                  let nextPage = this.context().moveToNextPage(pageOrientation2);
                  this.repeatables.forEach(function(rep) {
                    if (rep.insertedOnPages[this.context().page] === void 0) {
                      rep.insertedOnPages[this.context().page] = true;
                      this.addFragment(rep, true);
                    } else {
                      this.context().moveDown(rep.height);
                    }
                  }, this);
                  this.emit("pageChanged", {
                    prevPage: nextPage.prevPage,
                    prevY: nextPage.prevY,
                    y: this.context().y
                  });
                }
                addPage(pageSize, pageOrientation2, pageMargin, customProperties) {
                  if (customProperties === void 0) {
                    customProperties = {};
                  }
                  let prevPage = this.page;
                  let prevY = this.y;
                  this.context().addPage(normalizePageSize(pageSize, pageOrientation2), normalizePageMargin(pageMargin), customProperties);
                  this.emit("pageChanged", {
                    prevPage,
                    prevY,
                    y: this.context().y
                  });
                }
                beginUnbreakableBlock(width, height) {
                  if (this.transactionLevel++ === 0) {
                    this.originalX = this.context().x;
                    this.pushContext(width, height);
                  }
                }
                commitUnbreakableBlock(forcedX, forcedY) {
                  if (--this.transactionLevel === 0) {
                    let unbreakableContext = this.context();
                    this.popContext();
                    let nbPages = unbreakableContext.pages.length;
                    if (nbPages > 0) {
                      let fragment = unbreakableContext.pages[0];
                      fragment.xOffset = forcedX;
                      fragment.yOffset = forcedY;
                      if (nbPages > 1) {
                        if (forcedX !== void 0 || forcedY !== void 0) {
                          fragment.height = unbreakableContext.getCurrentPage().pageSize.height - unbreakableContext.pageMargins.top - unbreakableContext.pageMargins.bottom;
                        } else {
                          fragment.height = this.context().getCurrentPage().pageSize.height - this.context().pageMargins.top - this.context().pageMargins.bottom;
                          for (let i2 = 0, l = this.repeatables.length; i2 < l; i2++) {
                            fragment.height -= this.repeatables[i2].height;
                          }
                        }
                      } else {
                        fragment.height = unbreakableContext.y;
                      }
                      if (forcedX !== void 0 || forcedY !== void 0) {
                        super.addFragment(fragment, true, true, true);
                      } else {
                        this.addFragment(fragment);
                      }
                    }
                  }
                }
                currentBlockToRepeatable() {
                  let unbreakableContext = this.context();
                  let rep = {
                    items: []
                  };
                  unbreakableContext.pages[0].items.forEach((item) => {
                    rep.items.push(item);
                  });
                  rep.xOffset = this.originalX;
                  rep.height = unbreakableContext.y;
                  rep.insertedOnPages = [];
                  return rep;
                }
                pushToRepeatables(rep) {
                  this.repeatables.push(rep);
                }
                popFromRepeatables() {
                  this.repeatables.pop();
                }
                _fitOnPage(addFct) {
                  let position = addFct();
                  if (!position) {
                    this.moveToNextPage();
                    position = addFct();
                  }
                  return position;
                }
              }
              const src_PageElementWriter = PageElementWriter;
              ;
              class TableProcessor {
                constructor(tableNode) {
                  this.tableNode = tableNode;
                }
                beginTable(writer) {
                  const getTableInnerContentWidth = () => {
                    let width = 0;
                    tableNode.table.widths.forEach((w) => {
                      width += w._calcWidth;
                    });
                    return width;
                  };
                  const prepareRowSpanData = () => {
                    let rsd = [];
                    let x = 0;
                    let lastWidth = 0;
                    rsd.push({
                      left: 0,
                      rowSpan: 0
                    });
                    for (let i2 = 0, l = this.tableNode.table.body[0].length; i2 < l; i2++) {
                      let paddings = this.layout.paddingLeft(i2, this.tableNode) + this.layout.paddingRight(i2, this.tableNode);
                      let lBorder = this.layout.vLineWidth(i2, this.tableNode);
                      lastWidth = paddings + lBorder + this.tableNode.table.widths[i2]._calcWidth;
                      rsd[rsd.length - 1].width = lastWidth;
                      x += lastWidth;
                      rsd.push({
                        left: x,
                        rowSpan: 0,
                        width: 0
                      });
                    }
                    return rsd;
                  };
                  const prepareCellBorders = (body) => {
                    for (let rowIndex = 0; rowIndex < body.length; rowIndex++) {
                      let row = body[rowIndex];
                      for (let colIndex = 0; colIndex < row.length; colIndex++) {
                        let cell = row[colIndex];
                        if (cell.border) {
                          let rowSpan = cell.rowSpan || 1;
                          let colSpan = cell.colSpan || 1;
                          for (let rowOffset = 0; rowOffset < rowSpan; rowOffset++) {
                            if (cell.border[0] !== void 0 && rowOffset > 0) {
                              setBorder(rowIndex + rowOffset, colIndex, 0, cell.border[0]);
                            }
                            if (cell.border[2] !== void 0) {
                              setBorder(rowIndex + rowOffset, colIndex + colSpan - 1, 2, cell.border[2]);
                            }
                          }
                          for (let colOffset = 0; colOffset < colSpan; colOffset++) {
                            if (cell.border[1] !== void 0 && colOffset > 0) {
                              setBorder(rowIndex, colIndex + colOffset, 1, cell.border[1]);
                            }
                            if (cell.border[3] !== void 0) {
                              setBorder(rowIndex + rowSpan - 1, colIndex + colOffset, 3, cell.border[3]);
                            }
                          }
                        }
                      }
                    }
                    function setBorder(rowIndex, colIndex, borderIndex, borderValue) {
                      let cell = body[rowIndex][colIndex];
                      cell.border = cell.border || {};
                      cell.border[borderIndex] = borderValue;
                    }
                  };
                  let tableNode;
                  let availableWidth;
                  tableNode = this.tableNode;
                  this.offsets = tableNode._offsets;
                  this.layout = tableNode._layout;
                  availableWidth = writer.context().availableWidth - this.offsets.total;
                  columnCalculator.buildColumnWidths(tableNode.table.widths, availableWidth, this.offsets.total, tableNode);
                  this.tableWidth = tableNode._offsets.total + getTableInnerContentWidth();
                  this.rowSpanData = prepareRowSpanData();
                  this.cleanUpRepeatables = false;
                  this.headerRows = 0;
                  this.rowsWithoutPageBreak = 0;
                  const headerRows = tableNode.table.headerRows;
                  if (isPositiveInteger(headerRows)) {
                    this.headerRows = headerRows;
                    if (this.headerRows > tableNode.table.body.length) {
                      throw new Error(`Too few rows in the table. Property headerRows requires at least ${this.headerRows}, contains only ${tableNode.table.body.length}`);
                    }
                    this.rowsWithoutPageBreak = this.headerRows;
                    const keepWithHeaderRows = tableNode.table.keepWithHeaderRows;
                    if (isPositiveInteger(keepWithHeaderRows)) {
                      this.rowsWithoutPageBreak += keepWithHeaderRows;
                    }
                  }
                  this.dontBreakRows = tableNode.table.dontBreakRows || false;
                  if (this.rowsWithoutPageBreak || this.dontBreakRows) {
                    writer.beginUnbreakableBlock();
                    this.drawHorizontalLine(0, writer);
                    if (this.rowsWithoutPageBreak && this.dontBreakRows) {
                      writer.beginUnbreakableBlock();
                    }
                  }
                  prepareCellBorders(this.tableNode.table.body);
                }
                onRowBreak(rowIndex, writer) {
                  return () => {
                    let offset = this.rowPaddingTop + (!this.headerRows ? this.topLineWidth : 0);
                    writer.context().availableHeight -= this.reservedAtBottom;
                    writer.context().moveDown(offset);
                  };
                }
                beginRow(rowIndex, writer) {
                  this.topLineWidth = this.layout.hLineWidth(rowIndex, this.tableNode);
                  this.rowPaddingTop = this.layout.paddingTop(rowIndex, this.tableNode);
                  this.bottomLineWidth = this.layout.hLineWidth(rowIndex + 1, this.tableNode);
                  this.rowPaddingBottom = this.layout.paddingBottom(rowIndex, this.tableNode);
                  this.rowCallback = this.onRowBreak(rowIndex, writer);
                  writer.addListener("pageChanged", this.rowCallback);
                  if (rowIndex == 0 && !this.dontBreakRows && !this.rowsWithoutPageBreak) {
                    this._tableTopBorderY = writer.context().y;
                    writer.context().moveDown(this.topLineWidth);
                  }
                  if (this.dontBreakRows && rowIndex > 0) {
                    writer.beginUnbreakableBlock();
                  }
                  this.rowTopY = writer.context().y;
                  this.reservedAtBottom = this.bottomLineWidth + this.rowPaddingBottom;
                  writer.context().availableHeight -= this.reservedAtBottom;
                  writer.context().moveDown(this.rowPaddingTop);
                }
                drawHorizontalLine(lineIndex, writer, overrideY, moveDown, forcePage) {
                  if (moveDown === void 0) {
                    moveDown = true;
                  }
                  let lineWidth = this.layout.hLineWidth(lineIndex, this.tableNode);
                  if (lineWidth) {
                    let style = this.layout.hLineStyle(lineIndex, this.tableNode);
                    let dash;
                    if (style && style.dash) {
                      dash = style.dash;
                    }
                    let offset = lineWidth / 2;
                    let currentLine = null;
                    let body = this.tableNode.table.body;
                    let cellAbove;
                    let currentCell;
                    let rowCellAbove;
                    for (let i2 = 0, l = this.rowSpanData.length; i2 < l; i2++) {
                      let data = this.rowSpanData[i2];
                      let shouldDrawLine = !data.rowSpan;
                      let borderColor = null;
                      if (shouldDrawLine && i2 < l - 1) {
                        var topBorder = false, bottomBorder = false, rowBottomBorder = false;
                        if (lineIndex > 0) {
                          cellAbove = body[lineIndex - 1][i2];
                          bottomBorder = cellAbove.border ? cellAbove.border[3] : this.layout.defaultBorder;
                          if (bottomBorder && cellAbove.borderColor) {
                            borderColor = cellAbove.borderColor[3];
                          }
                        }
                        if (lineIndex < body.length) {
                          currentCell = body[lineIndex][i2];
                          topBorder = currentCell.border ? currentCell.border[1] : this.layout.defaultBorder;
                          if (topBorder && borderColor == null && currentCell.borderColor) {
                            borderColor = currentCell.borderColor[1];
                          }
                        }
                        shouldDrawLine = topBorder || bottomBorder;
                      }
                      if (cellAbove && cellAbove._rowSpanCurrentOffset) {
                        rowCellAbove = body[lineIndex - 1 - cellAbove._rowSpanCurrentOffset][i2];
                        rowBottomBorder = rowCellAbove && rowCellAbove.border ? rowCellAbove.border[3] : this.layout.defaultBorder;
                        if (rowBottomBorder && rowCellAbove && rowCellAbove.borderColor) {
                          borderColor = rowCellAbove.borderColor[3];
                        }
                      }
                      if (borderColor == null) {
                        borderColor = typeof this.layout.hLineColor === "function" ? this.layout.hLineColor(lineIndex, this.tableNode, i2) : this.layout.hLineColor;
                      }
                      if (!currentLine && shouldDrawLine) {
                        currentLine = {
                          left: data.left,
                          width: 0
                        };
                      }
                      if (shouldDrawLine) {
                        let colSpanIndex = 0;
                        if (rowCellAbove && rowCellAbove.colSpan && rowBottomBorder) {
                          while (rowCellAbove.colSpan > colSpanIndex) {
                            currentLine.width += this.rowSpanData[i2 + colSpanIndex++].width || 0;
                          }
                          i2 += colSpanIndex - 1;
                        } else if (cellAbove && cellAbove.colSpan && bottomBorder) {
                          while (cellAbove.colSpan > colSpanIndex) {
                            currentLine.width += this.rowSpanData[i2 + colSpanIndex++].width || 0;
                          }
                          i2 += colSpanIndex - 1;
                        } else if (currentCell && currentCell.colSpan && topBorder) {
                          while (currentCell.colSpan > colSpanIndex) {
                            currentLine.width += this.rowSpanData[i2 + colSpanIndex++].width || 0;
                          }
                          i2 += colSpanIndex - 1;
                        } else {
                          currentLine.width += this.rowSpanData[i2].width || 0;
                        }
                      }
                      let y = (overrideY || 0) + offset;
                      if (shouldDrawLine) {
                        if (currentLine && currentLine.width) {
                          writer.addVector({
                            type: "line",
                            x1: currentLine.left,
                            x2: currentLine.left + currentLine.width,
                            y1: y,
                            y2: y,
                            lineWidth,
                            dash,
                            lineColor: borderColor
                          }, false, isNumber(overrideY), null, forcePage);
                          currentLine = null;
                          borderColor = null;
                          cellAbove = null;
                          currentCell = null;
                          rowCellAbove = null;
                        }
                      }
                    }
                    if (moveDown) {
                      writer.context().moveDown(lineWidth);
                    }
                  }
                }
                drawVerticalLine(x, y0, y1, vLineColIndex, writer, vLineRowIndex, beforeVLineColIndex) {
                  let width = this.layout.vLineWidth(vLineColIndex, this.tableNode);
                  if (width === 0) {
                    return;
                  }
                  let style = this.layout.vLineStyle(vLineColIndex, this.tableNode);
                  let dash;
                  if (style && style.dash) {
                    dash = style.dash;
                  }
                  let body = this.tableNode.table.body;
                  let cellBefore;
                  let currentCell;
                  let borderColor;
                  if (vLineColIndex > 0) {
                    cellBefore = body[vLineRowIndex][beforeVLineColIndex];
                    if (cellBefore && cellBefore.borderColor) {
                      if (cellBefore.border ? cellBefore.border[2] : this.layout.defaultBorder) {
                        borderColor = cellBefore.borderColor[2];
                      }
                    }
                  }
                  if (borderColor == null && vLineColIndex < body.length) {
                    currentCell = body[vLineRowIndex][vLineColIndex];
                    if (currentCell && currentCell.borderColor) {
                      if (currentCell.border ? currentCell.border[0] : this.layout.defaultBorder) {
                        borderColor = currentCell.borderColor[0];
                      }
                    }
                  }
                  if (borderColor == null && cellBefore && cellBefore._rowSpanCurrentOffset) {
                    let rowCellBeforeAbove = body[vLineRowIndex - cellBefore._rowSpanCurrentOffset][beforeVLineColIndex];
                    if (rowCellBeforeAbove.borderColor) {
                      if (rowCellBeforeAbove.border ? rowCellBeforeAbove.border[2] : this.layout.defaultBorder) {
                        borderColor = rowCellBeforeAbove.borderColor[2];
                      }
                    }
                  }
                  if (borderColor == null && currentCell && currentCell._rowSpanCurrentOffset) {
                    let rowCurrentCellAbove = body[vLineRowIndex - currentCell._rowSpanCurrentOffset][vLineColIndex];
                    if (rowCurrentCellAbove.borderColor) {
                      if (rowCurrentCellAbove.border ? rowCurrentCellAbove.border[2] : this.layout.defaultBorder) {
                        borderColor = rowCurrentCellAbove.borderColor[2];
                      }
                    }
                  }
                  if (borderColor == null) {
                    borderColor = typeof this.layout.vLineColor === "function" ? this.layout.vLineColor(vLineColIndex, this.tableNode, vLineRowIndex) : this.layout.vLineColor;
                  }
                  writer.addVector({
                    type: "line",
                    x1: x + width / 2,
                    x2: x + width / 2,
                    y1: y0,
                    y2: y1,
                    lineWidth: width,
                    dash,
                    lineColor: borderColor
                  }, false, true);
                  cellBefore = null;
                  currentCell = null;
                  borderColor = null;
                }
                endTable(writer) {
                  if (this.cleanUpRepeatables) {
                    writer.popFromRepeatables();
                  }
                }
                endRow(rowIndex, writer, pageBreaks) {
                  const getLineXs = () => {
                    let result = [];
                    let cols = 0;
                    for (let i2 = 0, l = this.tableNode.table.body[rowIndex].length; i2 < l; i2++) {
                      if (!cols) {
                        result.push({
                          x: this.rowSpanData[i2].left,
                          index: i2
                        });
                        let item = this.tableNode.table.body[rowIndex][i2];
                        cols = item._colSpan || item.colSpan || 0;
                      }
                      if (cols > 0) {
                        cols--;
                      }
                    }
                    result.push({
                      x: this.rowSpanData[this.rowSpanData.length - 1].left,
                      index: this.rowSpanData.length - 1
                    });
                    return result;
                  };
                  writer.removeListener("pageChanged", this.rowCallback);
                  writer.context().moveDown(this.layout.paddingBottom(rowIndex, this.tableNode));
                  writer.context().availableHeight += this.reservedAtBottom;
                  let endingPage = writer.context().page;
                  let endingY = writer.context().y;
                  let xs = getLineXs();
                  let ys = [];
                  let hasBreaks = pageBreaks && pageBreaks.length > 0;
                  let body = this.tableNode.table.body;
                  ys.push({
                    y0: this.rowTopY,
                    page: hasBreaks ? pageBreaks[0].prevPage : endingPage
                  });
                  if (hasBreaks) {
                    for (let i2 = 0, l = pageBreaks.length; i2 < l; i2++) {
                      let pageBreak = pageBreaks[i2];
                      ys[ys.length - 1].y1 = pageBreak.prevY;
                      ys.push({
                        y0: pageBreak.y,
                        page: pageBreak.prevPage + 1
                      });
                    }
                  }
                  ys[ys.length - 1].y1 = endingY;
                  let skipOrphanePadding = ys[0].y1 - ys[0].y0 === this.rowPaddingTop;
                  if (rowIndex === 0 && !skipOrphanePadding && !this.rowsWithoutPageBreak && !this.dontBreakRows) {
                    let pageTableStartedAt = null;
                    if (pageBreaks && pageBreaks.length > 0) {
                      pageTableStartedAt = pageBreaks[0].prevPage;
                    }
                    this.drawHorizontalLine(0, writer, this._tableTopBorderY, false, pageTableStartedAt);
                  }
                  for (let yi = skipOrphanePadding ? 1 : 0, yl = ys.length; yi < yl; yi++) {
                    let willBreak = yi < ys.length - 1;
                    let rowBreakWithoutHeader = yi > 0 && !this.headerRows;
                    let hzLineOffset = rowBreakWithoutHeader ? 0 : this.topLineWidth;
                    let y1 = ys[yi].y0;
                    let y2 = ys[yi].y1;
                    if (willBreak) {
                      y2 = y2 + this.rowPaddingBottom;
                    }
                    if (writer.context().page != ys[yi].page) {
                      writer.context().page = ys[yi].page;
                      this.reservedAtBottom = 0;
                    }
                    if (willBreak && this.layout.hLineWhenBroken !== false) {
                      this.drawHorizontalLine(rowIndex + 1, writer, y2);
                    }
                    if (rowBreakWithoutHeader && this.layout.hLineWhenBroken !== false) {
                      this.drawHorizontalLine(rowIndex, writer, y1);
                    }
                    for (let i2 = 0, l = xs.length; i2 < l; i2++) {
                      let leftCellBorder = false;
                      let rightCellBorder = false;
                      let colIndex = xs[i2].index;
                      if (colIndex < body[rowIndex].length) {
                        let cell = body[rowIndex][colIndex];
                        leftCellBorder = cell.border ? cell.border[0] : this.layout.defaultBorder;
                        rightCellBorder = cell.border ? cell.border[2] : this.layout.defaultBorder;
                      }
                      if (colIndex > 0 && !leftCellBorder) {
                        let cell = body[rowIndex][colIndex - 1];
                        leftCellBorder = cell.border ? cell.border[2] : this.layout.defaultBorder;
                      }
                      if (colIndex + 1 < body[rowIndex].length && !rightCellBorder) {
                        let cell = body[rowIndex][colIndex + 1];
                        rightCellBorder = cell.border ? cell.border[0] : this.layout.defaultBorder;
                      }
                      if (leftCellBorder) {
                        this.drawVerticalLine(xs[i2].x, y1 - hzLineOffset, y2 + this.bottomLineWidth, xs[i2].index, writer, rowIndex, xs[i2 - 1] ? xs[i2 - 1].index : null);
                      }
                      if (i2 < l - 1) {
                        let fillColor = body[rowIndex][colIndex].fillColor;
                        let fillOpacity = body[rowIndex][colIndex].fillOpacity;
                        if (!fillColor) {
                          fillColor = typeof this.layout.fillColor === "function" ? this.layout.fillColor(rowIndex, this.tableNode, colIndex) : this.layout.fillColor;
                        }
                        if (!isNumber(fillOpacity)) {
                          fillOpacity = typeof this.layout.fillOpacity === "function" ? this.layout.fillOpacity(rowIndex, this.tableNode, colIndex) : this.layout.fillOpacity;
                        }
                        var overlayPattern = body[rowIndex][colIndex].overlayPattern;
                        var overlayOpacity = body[rowIndex][colIndex].overlayOpacity;
                        if (fillColor || overlayPattern) {
                          let widthLeftBorder = leftCellBorder ? this.layout.vLineWidth(colIndex, this.tableNode) : 0;
                          let widthRightBorder;
                          if ((colIndex === 0 || colIndex + 1 == body[rowIndex].length) && !rightCellBorder) {
                            widthRightBorder = this.layout.vLineWidth(colIndex + 1, this.tableNode);
                          } else if (rightCellBorder) {
                            widthRightBorder = this.layout.vLineWidth(colIndex + 1, this.tableNode) / 2;
                          } else {
                            widthRightBorder = 0;
                          }
                          let x1f = this.dontBreakRows ? xs[i2].x + widthLeftBorder : xs[i2].x + widthLeftBorder / 2;
                          let y1f = this.dontBreakRows ? y1 : y1 - hzLineOffset / 2;
                          let x2f = xs[i2 + 1].x + widthRightBorder;
                          let y2f = this.dontBreakRows ? y2 + this.bottomLineWidth : y2 + this.bottomLineWidth / 2;
                          var bgWidth = x2f - x1f;
                          var bgHeight = y2f - y1f;
                          if (fillColor) {
                            writer.addVector({
                              type: "rect",
                              x: x1f,
                              y: y1f,
                              w: bgWidth,
                              h: bgHeight,
                              lineWidth: 0,
                              color: fillColor,
                              fillOpacity,
                              // mark if we are in an unbreakable block
                              _isFillColorFromUnbreakable: !!writer.transactionLevel
                            }, false, true, writer.context().backgroundLength[writer.context().page]);
                          }
                          if (overlayPattern) {
                            writer.addVector({
                              type: "rect",
                              x: x1f,
                              y: y1f,
                              w: bgWidth,
                              h: bgHeight,
                              lineWidth: 0,
                              color: overlayPattern,
                              fillOpacity: overlayOpacity
                            }, false, true);
                          }
                        }
                      }
                    }
                  }
                  writer.context().page = endingPage;
                  writer.context().y = endingY;
                  let row = this.tableNode.table.body[rowIndex];
                  for (let i2 = 0, l = row.length; i2 < l; i2++) {
                    if (row[i2].rowSpan) {
                      this.rowSpanData[i2].rowSpan = row[i2].rowSpan;
                      if (row[i2].colSpan && row[i2].colSpan > 1) {
                        for (let j2 = 1; j2 < row[i2].rowSpan; j2++) {
                          this.tableNode.table.body[rowIndex + j2][i2]._colSpan = row[i2].colSpan;
                        }
                      }
                      if (row[i2].rowSpan && row[i2].rowSpan > 1) {
                        for (let j2 = 1; j2 < row[i2].rowSpan; j2++) {
                          this.tableNode.table.body[rowIndex + j2][i2]._rowSpanCurrentOffset = j2;
                        }
                      }
                    }
                    if (this.rowSpanData[i2].rowSpan > 0) {
                      this.rowSpanData[i2].rowSpan--;
                    }
                  }
                  this.drawHorizontalLine(rowIndex + 1, writer);
                  if (this.headerRows && rowIndex === this.headerRows - 1) {
                    this.headerRepeatable = writer.currentBlockToRepeatable();
                  }
                  if (this.dontBreakRows) {
                    const pageChangedCallback = () => {
                      if (rowIndex > 0 && !this.headerRows && this.layout.hLineWhenBroken !== false) {
                        this.drawHorizontalLine(rowIndex, writer);
                      }
                    };
                    writer.addListener("pageChanged", pageChangedCallback);
                    writer.commitUnbreakableBlock();
                    writer.removeListener("pageChanged", pageChangedCallback);
                  }
                  if (this.headerRepeatable && (rowIndex === this.rowsWithoutPageBreak - 1 || rowIndex === this.tableNode.table.body.length - 1)) {
                    writer.commitUnbreakableBlock();
                    writer.pushToRepeatables(this.headerRepeatable);
                    this.cleanUpRepeatables = true;
                    this.headerRepeatable = null;
                  }
                }
              }
              const src_TableProcessor = TableProcessor;
              ;
              class Line {
                /**
                 * @param {number} maxWidth Maximum width this line can have
                 */
                constructor(maxWidth) {
                  this.maxWidth = maxWidth;
                  this.leadingCut = 0;
                  this.trailingCut = 0;
                  this.inlineWidths = 0;
                  this.inlines = [];
                }
                /**
                 * @param {object} inline
                 */
                addInline(inline) {
                  if (this.inlines.length === 0) {
                    this.leadingCut = inline.leadingCut || 0;
                  }
                  this.trailingCut = inline.trailingCut || 0;
                  inline.x = this.inlineWidths - this.leadingCut;
                  this.inlines.push(inline);
                  this.inlineWidths += inline.width;
                  if (inline.lineEnd) {
                    this.newLineForced = true;
                  }
                }
                /**
                 * @returns {number}
                 */
                getHeight() {
                  let max = 0;
                  this.inlines.forEach((item) => {
                    max = Math.max(max, item.height || 0);
                  });
                  return max;
                }
                /**
                 * @returns {number}
                 */
                getAscenderHeight() {
                  let y = 0;
                  this.inlines.forEach((inline) => {
                    y = Math.max(y, inline.font.ascender / 1e3 * inline.fontSize);
                  });
                  return y;
                }
                /**
                 * @returns {number}
                 */
                getWidth() {
                  return this.inlineWidths - this.leadingCut - this.trailingCut;
                }
                /**
                 * @returns {number}
                 */
                getAvailableWidth() {
                  return this.maxWidth - this.getWidth();
                }
                /**
                 * @param {object} inline
                 * @param {Array} nextInlines
                 * @returns {boolean}
                 */
                hasEnoughSpaceForInline(inline, nextInlines) {
                  if (nextInlines === void 0) {
                    nextInlines = [];
                  }
                  if (this.inlines.length === 0) {
                    return true;
                  }
                  if (this.newLineForced) {
                    return false;
                  }
                  let inlineWidth = inline.width;
                  let inlineTrailingCut = inline.trailingCut || 0;
                  if (inline.noNewLine) {
                    for (let i2 = 0, l = nextInlines.length; i2 < l; i2++) {
                      let nextInline = nextInlines[i2];
                      inlineWidth += nextInline.width;
                      inlineTrailingCut += nextInline.trailingCut || 0;
                      if (!nextInline.noNewLine) {
                        break;
                      }
                    }
                  }
                  return this.inlineWidths + inlineWidth - this.leadingCut - inlineTrailingCut <= this.maxWidth;
                }
                clone() {
                  let result = new Line(this.maxWidth);
                  for (let key in this) {
                    if (this.hasOwnProperty(key)) {
                      result[key] = this[key];
                    }
                  }
                  return result;
                }
              }
              const src_Line = Line;
              ;
              function addAll(target, otherArray) {
                otherArray.forEach((item) => {
                  target.push(item);
                });
              }
              class LayoutBuilder {
                /**
                 * @param {object} pageSize - an object defining page width and height
                 * @param {object} pageMargins - an object defining top, left, right and bottom margins
                 * @param {object} svgMeasure
                 */
                constructor(pageSize, pageMargins, svgMeasure) {
                  this.pageSize = pageSize;
                  this.pageMargins = pageMargins;
                  this.svgMeasure = svgMeasure;
                  this.tableLayouts = {};
                  this.nestedLevel = 0;
                }
                registerTableLayouts(tableLayouts2) {
                  this.tableLayouts = pack(this.tableLayouts, tableLayouts2);
                }
                /**
                 * Executes layout engine on document-definition-object and creates an array of pages
                 * containing positioned Blocks, Lines and inlines
                 *
                 * @param {object} docStructure document-definition-object
                 * @param {object} pdfDocument pdfkit document
                 * @param {object} styleDictionary dictionary with style definitions
                 * @param {object} defaultStyle default style definition
                 * @param {object} background
                 * @param {object} header
                 * @param {object} footer
                 * @param {object} watermark
                 * @param {object} pageBreakBeforeFct
                 * @returns {Array} an array of pages
                 */
                layoutDocument(docStructure, pdfDocument, styleDictionary, defaultStyle, background, header, footer, watermark, pageBreakBeforeFct) {
                  function addPageBreaksIfNecessary(linearNodeList, pages) {
                    if (typeof pageBreakBeforeFct !== "function") {
                      return false;
                    }
                    const hasRenderableContent = (node) => {
                      if (!node || node.positions.length === 0) {
                        return false;
                      }
                      if (node.text === "" && !node.listMarker) {
                        return false;
                      }
                      return true;
                    };
                    linearNodeList = linearNodeList.filter(hasRenderableContent);
                    linearNodeList.forEach((node) => {
                      let nodeInfo = {};
                      ["id", "text", "ul", "ol", "table", "image", "qr", "canvas", "svg", "columns", "headlineLevel", "style", "pageBreak", "pageOrientation", "width", "height"].forEach((key) => {
                        if (node[key] !== void 0) {
                          nodeInfo[key] = node[key];
                        }
                      });
                      nodeInfo.startPosition = node.positions[0];
                      nodeInfo.pageNumbers = Array.from(new Set(node.positions.map((node2) => node2.pageNumber)));
                      nodeInfo.pages = pages.length;
                      nodeInfo.stack = Array.isArray(node.stack);
                      node.nodeInfo = nodeInfo;
                    });
                    for (let index = 0; index < linearNodeList.length; index++) {
                      let node = linearNodeList[index];
                      if (node.pageBreak !== "before" && !node.pageBreakCalculated) {
                        node.pageBreakCalculated = true;
                        let pageNumber = node.nodeInfo.pageNumbers[0];
                        if (pageBreakBeforeFct(node.nodeInfo, {
                          getFollowingNodesOnPage: () => {
                            let followingNodesOnPage = [];
                            for (let ii = index + 1, l = linearNodeList.length; ii < l; ii++) {
                              if (linearNodeList[ii].nodeInfo.pageNumbers.indexOf(pageNumber) > -1) {
                                followingNodesOnPage.push(linearNodeList[ii].nodeInfo);
                              }
                            }
                            return followingNodesOnPage;
                          },
                          getNodesOnNextPage: () => {
                            let nodesOnNextPage = [];
                            for (let ii = index + 1, l = linearNodeList.length; ii < l; ii++) {
                              if (linearNodeList[ii].nodeInfo.pageNumbers.indexOf(pageNumber + 1) > -1) {
                                nodesOnNextPage.push(linearNodeList[ii].nodeInfo);
                              }
                            }
                            return nodesOnNextPage;
                          },
                          getPreviousNodesOnPage: () => {
                            let previousNodesOnPage = [];
                            for (let ii = 0; ii < index; ii++) {
                              if (linearNodeList[ii].nodeInfo.pageNumbers.indexOf(pageNumber) > -1) {
                                previousNodesOnPage.push(linearNodeList[ii].nodeInfo);
                              }
                            }
                            return previousNodesOnPage;
                          }
                        })) {
                          node.pageBreak = "before";
                          return true;
                        }
                      }
                    }
                    return false;
                  }
                  this.docPreprocessor = new src_DocPreprocessor();
                  this.docMeasure = new src_DocMeasure(pdfDocument, styleDictionary, defaultStyle, this.svgMeasure, this.tableLayouts);
                  function resetXYs(result2) {
                    result2.linearNodeList.forEach((node) => {
                      node.resetXY();
                    });
                  }
                  let result = this.tryLayoutDocument(docStructure, pdfDocument, styleDictionary, defaultStyle, background, header, footer, watermark);
                  while (addPageBreaksIfNecessary(result.linearNodeList, result.pages)) {
                    resetXYs(result);
                    result = this.tryLayoutDocument(docStructure, pdfDocument, styleDictionary, defaultStyle, background, header, footer, watermark);
                  }
                  return result.pages;
                }
                tryLayoutDocument(docStructure, pdfDocument, styleDictionary, defaultStyle, background, header, footer, watermark) {
                  const isNecessaryAddFirstPage = (docStructure2) => {
                    if (docStructure2.stack && docStructure2.stack.length > 0 && docStructure2.stack[0].section) {
                      return false;
                    } else if (docStructure2.section) {
                      return false;
                    }
                    return true;
                  };
                  this.linearNodeList = [];
                  docStructure = this.docPreprocessor.preprocessDocument(docStructure);
                  docStructure = this.docMeasure.measureDocument(docStructure);
                  this.writer = new src_PageElementWriter(new src_DocumentContext());
                  this.writer.context().addListener("pageAdded", (page) => {
                    let backgroundGetter = background;
                    if (page.customProperties["background"] || page.customProperties["background"] === null) {
                      backgroundGetter = page.customProperties["background"];
                    }
                    this.addBackground(backgroundGetter);
                  });
                  if (isNecessaryAddFirstPage(docStructure)) {
                    this.writer.addPage(this.pageSize, null, this.pageMargins);
                  }
                  this.processNode(docStructure);
                  this.addHeadersAndFooters(header, footer);
                  this.addWatermark(watermark, pdfDocument, defaultStyle);
                  return {
                    pages: this.writer.context().pages,
                    linearNodeList: this.linearNodeList
                  };
                }
                addBackground(background) {
                  let backgroundGetter = typeof background === "function" ? background : () => background;
                  let context = this.writer.context();
                  let pageSize = context.getCurrentPage().pageSize;
                  let pageBackground = backgroundGetter(context.page + 1, pageSize);
                  if (pageBackground) {
                    this.writer.beginUnbreakableBlock(pageSize.width, pageSize.height);
                    pageBackground = this.docPreprocessor.preprocessBlock(pageBackground);
                    this.processNode(this.docMeasure.measureBlock(pageBackground));
                    this.writer.commitUnbreakableBlock(0, 0);
                    context.backgroundLength[context.page] += pageBackground.positions.length;
                  }
                }
                addDynamicRepeatable(nodeGetter, sizeFunction, customPropertyName) {
                  let pages = this.writer.context().pages;
                  for (let pageIndex = 0, l = pages.length; pageIndex < l; pageIndex++) {
                    this.writer.context().page = pageIndex;
                    let customProperties = this.writer.context().getCurrentPage().customProperties;
                    let pageNodeGetter = nodeGetter;
                    if (customProperties[customPropertyName] || customProperties[customPropertyName] === null) {
                      pageNodeGetter = customProperties[customPropertyName];
                    }
                    if (typeof pageNodeGetter === "undefined" || pageNodeGetter === null) {
                      continue;
                    }
                    let node = pageNodeGetter(pageIndex + 1, l, this.writer.context().pages[pageIndex].pageSize);
                    if (node) {
                      let sizes = sizeFunction(this.writer.context().getCurrentPage().pageSize, this.writer.context().getCurrentPage().pageMargins);
                      this.writer.beginUnbreakableBlock(sizes.width, sizes.height);
                      node = this.docPreprocessor.preprocessBlock(node);
                      this.processNode(this.docMeasure.measureBlock(node));
                      this.writer.commitUnbreakableBlock(sizes.x, sizes.y);
                    }
                  }
                }
                addHeadersAndFooters(header, footer) {
                  const headerSizeFct = (pageSize, pageMargins) => ({
                    x: 0,
                    y: 0,
                    width: pageSize.width,
                    height: pageMargins.top
                  });
                  const footerSizeFct = (pageSize, pageMargins) => ({
                    x: 0,
                    y: pageSize.height - pageMargins.bottom,
                    width: pageSize.width,
                    height: pageMargins.bottom
                  });
                  this.addDynamicRepeatable(header, headerSizeFct, "header");
                  this.addDynamicRepeatable(footer, footerSizeFct, "footer");
                }
                addWatermark(watermark, pdfDocument, defaultStyle) {
                  let pages = this.writer.context().pages;
                  for (let i2 = 0, l = pages.length; i2 < l; i2++) {
                    let pageWatermark = watermark;
                    if (pages[i2].customProperties["watermark"] || pages[i2].customProperties["watermark"] === null) {
                      pageWatermark = pages[i2].customProperties["watermark"];
                    }
                    if (pageWatermark === void 0 || pageWatermark === null) {
                      continue;
                    }
                    if (isString(pageWatermark)) {
                      pageWatermark = {
                        "text": pageWatermark
                      };
                    }
                    if (!pageWatermark.text) {
                      continue;
                    }
                    pages[i2].watermark = getWatermarkObject({
                      ...pageWatermark
                    }, pages[i2].pageSize, pdfDocument, defaultStyle);
                  }
                  function getWatermarkObject(watermark2, pageSize, pdfDocument2, defaultStyle2) {
                    watermark2.font = watermark2.font || defaultStyle2.font || "Roboto";
                    watermark2.fontSize = watermark2.fontSize || "auto";
                    watermark2.color = watermark2.color || "black";
                    watermark2.opacity = isNumber(watermark2.opacity) ? watermark2.opacity : 0.6;
                    watermark2.bold = watermark2.bold || false;
                    watermark2.italics = watermark2.italics || false;
                    watermark2.angle = isValue(watermark2.angle) ? watermark2.angle : null;
                    if (watermark2.angle === null) {
                      watermark2.angle = Math.atan2(pageSize.height, pageSize.width) * -180 / Math.PI;
                    }
                    if (watermark2.fontSize === "auto") {
                      watermark2.fontSize = getWatermarkFontSize(pageSize, watermark2, pdfDocument2);
                    }
                    let watermarkObject = {
                      text: watermark2.text,
                      font: pdfDocument2.provideFont(watermark2.font, watermark2.bold, watermark2.italics),
                      fontSize: watermark2.fontSize,
                      color: watermark2.color,
                      opacity: watermark2.opacity,
                      angle: watermark2.angle
                    };
                    watermarkObject._size = getWatermarkSize(watermark2, pdfDocument2);
                    return watermarkObject;
                  }
                  function getWatermarkSize(watermark2, pdfDocument2) {
                    let textInlines = new src_TextInlines(pdfDocument2);
                    let styleContextStack = new src_StyleContextStack(null, {
                      font: watermark2.font,
                      bold: watermark2.bold,
                      italics: watermark2.italics
                    });
                    styleContextStack.push({
                      fontSize: watermark2.fontSize
                    });
                    let size = textInlines.sizeOfText(watermark2.text, styleContextStack);
                    let rotatedSize = textInlines.sizeOfRotatedText(watermark2.text, watermark2.angle, styleContextStack);
                    return {
                      size,
                      rotatedSize
                    };
                  }
                  function getWatermarkFontSize(pageSize, watermark2, pdfDocument2) {
                    let textInlines = new src_TextInlines(pdfDocument2);
                    let styleContextStack = new src_StyleContextStack(null, {
                      font: watermark2.font,
                      bold: watermark2.bold,
                      italics: watermark2.italics
                    });
                    let rotatedSize;
                    let a2 = 0;
                    let b2 = 1e3;
                    let c = (a2 + b2) / 2;
                    while (Math.abs(a2 - b2) > 1) {
                      styleContextStack.push({
                        fontSize: c
                      });
                      rotatedSize = textInlines.sizeOfRotatedText(watermark2.text, watermark2.angle, styleContextStack);
                      if (rotatedSize.width > pageSize.width) {
                        b2 = c;
                        c = (a2 + b2) / 2;
                      } else if (rotatedSize.width < pageSize.width) {
                        if (rotatedSize.height > pageSize.height) {
                          b2 = c;
                          c = (a2 + b2) / 2;
                        } else {
                          a2 = c;
                          c = (a2 + b2) / 2;
                        }
                      }
                      styleContextStack.pop();
                    }
                    return c;
                  }
                }
                processNode(node) {
                  const applyMargins = (callback) => {
                    let margin = node._margin;
                    if (node.pageBreak === "before") {
                      this.writer.moveToNextPage(node.pageOrientation);
                    } else if (node.pageBreak === "beforeOdd") {
                      this.writer.moveToNextPage(node.pageOrientation);
                      if ((this.writer.context().page + 1) % 2 === 1) {
                        this.writer.moveToNextPage(node.pageOrientation);
                      }
                    } else if (node.pageBreak === "beforeEven") {
                      this.writer.moveToNextPage(node.pageOrientation);
                      if ((this.writer.context().page + 1) % 2 === 0) {
                        this.writer.moveToNextPage(node.pageOrientation);
                      }
                    }
                    const isDetachedBlock = node.relativePosition || node.absolutePosition;
                    if (margin && !isDetachedBlock) {
                      const availableHeight = this.writer.context().availableHeight;
                      if (availableHeight - margin[1] < 0) {
                        this.writer.context().moveDown(availableHeight);
                        this.writer.moveToNextPage(node.pageOrientation);
                      } else {
                        this.writer.context().moveDown(margin[1]);
                      }
                      this.writer.context().addMargin(margin[0], margin[2]);
                    }
                    callback();
                    if (margin && !isDetachedBlock) {
                      const availableHeight = this.writer.context().availableHeight;
                      if (availableHeight - margin[3] < 0) {
                        this.writer.context().moveDown(availableHeight);
                        this.writer.moveToNextPage(node.pageOrientation);
                      } else {
                        this.writer.context().moveDown(margin[3]);
                      }
                      this.writer.context().addMargin(-margin[0], -margin[2]);
                    }
                    if (node.pageBreak === "after") {
                      this.writer.moveToNextPage(node.pageOrientation);
                    } else if (node.pageBreak === "afterOdd") {
                      this.writer.moveToNextPage(node.pageOrientation);
                      if ((this.writer.context().page + 1) % 2 === 1) {
                        this.writer.moveToNextPage(node.pageOrientation);
                      }
                    } else if (node.pageBreak === "afterEven") {
                      this.writer.moveToNextPage(node.pageOrientation);
                      if ((this.writer.context().page + 1) % 2 === 0) {
                        this.writer.moveToNextPage(node.pageOrientation);
                      }
                    }
                  };
                  this.linearNodeList.push(node);
                  decorateNode(node);
                  applyMargins(() => {
                    let unbreakable = node.unbreakable;
                    if (unbreakable) {
                      this.writer.beginUnbreakableBlock();
                    }
                    let absPosition = node.absolutePosition;
                    if (absPosition) {
                      this.writer.context().beginDetachedBlock();
                      this.writer.context().moveTo(absPosition.x || 0, absPosition.y || 0);
                    }
                    let relPosition = node.relativePosition;
                    if (relPosition) {
                      this.writer.context().beginDetachedBlock();
                      this.writer.context().moveToRelative(relPosition.x || 0, relPosition.y || 0);
                    }
                    if (node.stack) {
                      this.processVerticalContainer(node);
                    } else if (node.section) {
                      this.processSection(node);
                    } else if (node.columns) {
                      this.processColumns(node);
                    } else if (node.ul) {
                      this.processList(false, node);
                    } else if (node.ol) {
                      this.processList(true, node);
                    } else if (node.table) {
                      this.processTable(node);
                    } else if (node.text !== void 0) {
                      this.processLeaf(node);
                    } else if (node.toc) {
                      this.processToc(node);
                    } else if (node.image) {
                      this.processImage(node);
                    } else if (node.svg) {
                      this.processSVG(node);
                    } else if (node.canvas) {
                      this.processCanvas(node);
                    } else if (node.qr) {
                      this.processQr(node);
                    } else if (node.attachment) {
                      this.processAttachment(node);
                    } else if (!node._span) {
                      throw new Error(`Unrecognized document structure: ${stringifyNode(node)}`);
                    }
                    if (absPosition || relPosition) {
                      this.writer.context().endDetachedBlock();
                    }
                    if (unbreakable) {
                      this.writer.commitUnbreakableBlock();
                    }
                  });
                }
                // vertical container
                processVerticalContainer(node) {
                  node.stack.forEach((item) => {
                    this.processNode(item);
                    addAll(node.positions, item.positions);
                  }, this);
                }
                // section
                processSection(sectionNode) {
                  let page = this.writer.context().getCurrentPage();
                  if (!page || page && page.items.length) {
                    if (sectionNode.pageSize === "inherit") {
                      sectionNode.pageSize = page ? {
                        width: page.pageSize.width,
                        height: page.pageSize.height
                      } : void 0;
                    }
                    if (sectionNode.pageOrientation === "inherit") {
                      sectionNode.pageOrientation = page ? page.pageSize.orientation : void 0;
                    }
                    if (sectionNode.pageMargins === "inherit") {
                      sectionNode.pageMargins = page ? page.pageMargins : void 0;
                    }
                    if (sectionNode.header === "inherit") {
                      sectionNode.header = page ? page.customProperties.header : void 0;
                    }
                    if (sectionNode.footer === "inherit") {
                      sectionNode.footer = page ? page.customProperties.footer : void 0;
                    }
                    if (sectionNode.background === "inherit") {
                      sectionNode.background = page ? page.customProperties.background : void 0;
                    }
                    if (sectionNode.watermark === "inherit") {
                      sectionNode.watermark = page ? page.customProperties.watermark : void 0;
                    }
                    if (sectionNode.header && typeof sectionNode.header !== "function" && sectionNode.header !== null) {
                      sectionNode.header = convertToDynamicContent(sectionNode.header);
                    }
                    if (sectionNode.footer && typeof sectionNode.footer !== "function" && sectionNode.footer !== null) {
                      sectionNode.footer = convertToDynamicContent(sectionNode.footer);
                    }
                    let customProperties = {};
                    if (typeof sectionNode.header !== "undefined") {
                      customProperties.header = sectionNode.header;
                    }
                    if (typeof sectionNode.footer !== "undefined") {
                      customProperties.footer = sectionNode.footer;
                    }
                    if (typeof sectionNode.background !== "undefined") {
                      customProperties.background = sectionNode.background;
                    }
                    if (typeof sectionNode.watermark !== "undefined") {
                      customProperties.watermark = sectionNode.watermark;
                    }
                    this.writer.addPage(sectionNode.pageSize || this.pageSize, sectionNode.pageOrientation, sectionNode.pageMargins || this.pageMargins, customProperties);
                  }
                  this.processNode(sectionNode.section);
                }
                // columns
                processColumns(columnNode) {
                  this.nestedLevel++;
                  let columns = columnNode.columns;
                  let availableWidth = this.writer.context().availableWidth;
                  let gaps = gapArray(columnNode._gap);
                  if (gaps) {
                    availableWidth -= (gaps.length - 1) * columnNode._gap;
                  }
                  columnCalculator.buildColumnWidths(columns, availableWidth);
                  let result = this.processRow({
                    marginX: columnNode._margin ? [columnNode._margin[0], columnNode._margin[2]] : [0, 0],
                    cells: columns,
                    widths: columns,
                    gaps
                  });
                  addAll(columnNode.positions, result.positions);
                  this.nestedLevel--;
                  if (this.nestedLevel === 0) {
                    this.writer.context().resetMarginXTopParent();
                  }
                  function gapArray(gap) {
                    if (!gap) {
                      return null;
                    }
                    let gaps2 = [];
                    gaps2.push(0);
                    for (let i2 = columns.length - 1; i2 > 0; i2--) {
                      gaps2.push(gap);
                    }
                    return gaps2;
                  }
                }
                /**
                * Searches for a cell in the same row that starts a rowspan and is positioned immediately before the current cell.
                * Alternatively, it finds a cell where the colspan initiating the rowspan extends to the cell just before the current one.
                *
                * @param {Array<object>} arr - An array representing cells in a row.
                * @param {number} i - The index of the current cell to search backward from.
                * @returns {object|null} The starting cell of the rowspan if found; otherwise, `null`.
                */
                _findStartingRowSpanCell(arr, i2) {
                  let requiredColspan = 1;
                  for (let index = i2 - 1; index >= 0; index--) {
                    if (!arr[index]._span) {
                      if (arr[index].rowSpan > 1 && (arr[index].colSpan || 1) === requiredColspan) {
                        return arr[index];
                      } else {
                        return null;
                      }
                    }
                    requiredColspan++;
                  }
                  return null;
                }
                /**
                * Retrieves a page break description for a specified page from a list of page breaks.
                *
                * @param {Array<object>} pageBreaks - An array of page break descriptions, each containing `prevPage` properties.
                * @param {number} page - The page number to find the associated page break for.
                * @returns {object|undefined} The page break description object for the specified page if found; otherwise, `undefined`.
                */
                _getPageBreak(pageBreaks, page) {
                  return pageBreaks.find((desc) => desc.prevPage === page);
                }
                _getPageBreakListBySpan(tableNode, page, rowIndex) {
                  if (!tableNode || !tableNode._breaksBySpan) {
                    return null;
                  }
                  const breaksList = tableNode._breaksBySpan.filter((desc) => desc.prevPage === page && rowIndex <= desc.rowIndexOfSpanEnd);
                  let y = Number.MAX_VALUE, prevY = Number.MIN_VALUE;
                  breaksList.forEach((b2) => {
                    prevY = Math.max(b2.prevY, prevY);
                    y = Math.min(b2.y, y);
                  });
                  return {
                    prevPage: page,
                    prevY,
                    y
                  };
                }
                _findSameRowPageBreakByRowSpanData(breaksBySpan, page, rowIndex) {
                  if (!breaksBySpan) {
                    return null;
                  }
                  return breaksBySpan.find((desc) => desc.prevPage === page && rowIndex === desc.rowIndexOfSpanEnd);
                }
                _updatePageBreaksData(pageBreaks, tableNode, rowIndex) {
                  Object.keys(tableNode._bottomByPage).forEach((p) => {
                    const page = Number(p);
                    const pageBreak = this._getPageBreak(pageBreaks, page);
                    if (pageBreak) {
                      pageBreak.prevY = Math.max(pageBreak.prevY, tableNode._bottomByPage[page]);
                    }
                    if (tableNode._breaksBySpan && tableNode._breaksBySpan.length > 0) {
                      const breaksBySpanList = tableNode._breaksBySpan.filter((pb) => pb.prevPage === page && rowIndex <= pb.rowIndexOfSpanEnd);
                      if (breaksBySpanList && breaksBySpanList.length > 0) {
                        breaksBySpanList.forEach((b2) => {
                          b2.prevY = Math.max(b2.prevY, tableNode._bottomByPage[page]);
                        });
                      }
                    }
                  });
                }
                /**
                * Resolves the Y-coordinates for a target object by comparing two break points.
                *
                * @param {object} break1 - The first break point with `prevY` and `y` properties.
                * @param {object} break2 - The second break point with `prevY` and `y` properties.
                * @param {object} target - The target object to be updated with resolved Y-coordinates.
                * @property {number} target.prevY - Updated to the maximum `prevY` value between `break1` and `break2`.
                * @property {number} target.y - Updated to the minimum `y` value between `break1` and `break2`.
                */
                _resolveBreakY(break1, break2, target) {
                  target.prevY = Math.max(break1.prevY, break2.prevY);
                  target.y = Math.min(break1.y, break2.y);
                }
                _storePageBreakData(data, startsRowSpan, pageBreaks, tableNode) {
                  if (!startsRowSpan) {
                    let pageDesc = this._getPageBreak(pageBreaks, data.prevPage);
                    let pageDescBySpan = this._getPageBreakListBySpan(tableNode, data.prevPage, data.rowIndex);
                    if (!pageDesc) {
                      pageDesc = {
                        ...data
                      };
                      pageBreaks.push(pageDesc);
                    }
                    if (pageDescBySpan) {
                      this._resolveBreakY(pageDesc, pageDescBySpan, pageDesc);
                    }
                    this._resolveBreakY(pageDesc, data, pageDesc);
                  } else {
                    const breaksBySpan = tableNode && tableNode._breaksBySpan || null;
                    let pageDescBySpan = this._findSameRowPageBreakByRowSpanData(breaksBySpan, data.prevPage, data.rowIndex);
                    if (!pageDescBySpan) {
                      pageDescBySpan = {
                        ...data,
                        rowIndexOfSpanEnd: data.rowIndex + data.rowSpan - 1
                      };
                      if (!tableNode._breaksBySpan) {
                        tableNode._breaksBySpan = [];
                      }
                      tableNode._breaksBySpan.push(pageDescBySpan);
                    }
                    pageDescBySpan.prevY = Math.max(pageDescBySpan.prevY, data.prevY);
                    pageDescBySpan.y = Math.min(pageDescBySpan.y, data.y);
                    let pageDesc = this._getPageBreak(pageBreaks, data.prevPage);
                    if (pageDesc) {
                      this._resolveBreakY(pageDesc, pageDescBySpan, pageDesc);
                    }
                  }
                }
                /**
                * Calculates the left offset for a column based on the specified gap values.
                *
                * @param {number} i - The index of the column for which the offset is being calculated.
                * @param {Array<number>} gaps - An array of gap values for each column.
                * @returns {number} The left offset for the column. Returns `gaps[i]` if it exists, otherwise `0`.
                */
                _colLeftOffset(i2, gaps) {
                  if (gaps && gaps.length > i2) {
                    return gaps[i2];
                  }
                  return 0;
                }
                /**
                * Retrieves the ending cell for a row span in case it exists in a specified table column.
                *
                * @param {Array<Array<object>>} tableBody - The table body, represented as a 2D array of cell objects.
                * @param {number} rowIndex - The index of the starting row for the row span.
                * @param {object} column - The column object containing row span information.
                * @param {number} columnIndex - The index of the column within the row.
                * @returns {object|null} The cell at the end of the row span if it exists; otherwise, `null`.
                * @throws {Error} If the row span extends beyond the total row count.
                */
                _getRowSpanEndingCell(tableBody, rowIndex, column, columnIndex) {
                  if (column.rowSpan && column.rowSpan > 1) {
                    let endingRow = rowIndex + column.rowSpan - 1;
                    if (endingRow >= tableBody.length) {
                      throw new Error(`Row span for column ${columnIndex} (with indexes starting from 0) exceeded row count`);
                    }
                    return tableBody[endingRow][columnIndex];
                  }
                  return null;
                }
                processRow(_ref) {
                  let {
                    marginX = [0, 0],
                    dontBreakRows = false,
                    rowsWithoutPageBreak = 0,
                    cells,
                    widths,
                    gaps,
                    tableNode,
                    tableBody,
                    rowIndex,
                    height
                  } = _ref;
                  const isUnbreakableRow = dontBreakRows || rowIndex <= rowsWithoutPageBreak - 1;
                  let pageBreaks = [];
                  let pageBreaksByRowSpan = [];
                  let positions = [];
                  let willBreakByHeight = false;
                  widths = widths || cells;
                  if (!isUnbreakableRow && height > this.writer.context().availableHeight) {
                    willBreakByHeight = true;
                  }
                  const marginXParent = this.nestedLevel === 1 ? marginX : null;
                  const _bottomByPage = tableNode ? tableNode._bottomByPage : null;
                  this.writer.context().beginColumnGroup(marginXParent, _bottomByPage);
                  for (let i2 = 0, l = cells.length; i2 < l; i2++) {
                    let cell = cells[i2];
                    const storePageBreakClosure = (data) => {
                      const startsRowSpan = cell.rowSpan && cell.rowSpan > 1;
                      if (startsRowSpan) {
                        data.rowSpan = cell.rowSpan;
                      }
                      data.rowIndex = rowIndex;
                      this._storePageBreakData(data, startsRowSpan, pageBreaks, tableNode);
                    };
                    this.writer.addListener("pageChanged", storePageBreakClosure);
                    let width = widths[i2]._calcWidth;
                    let leftOffset = this._colLeftOffset(i2, gaps);
                    let startingSpanCell = this._findStartingRowSpanCell(cells, i2);
                    if (cell.colSpan && cell.colSpan > 1) {
                      for (let j2 = 1; j2 < cell.colSpan; j2++) {
                        width += widths[++i2]._calcWidth + gaps[i2];
                      }
                    }
                    const rowSpanEndingCell = this._getRowSpanEndingCell(tableBody, rowIndex, cell, i2);
                    if (rowSpanEndingCell) {
                      cell._endingCell = rowSpanEndingCell;
                      cell._endingCell._startingRowSpanY = cell._startingRowSpanY;
                    }
                    let endOfRowSpanCell = null;
                    if (startingSpanCell && startingSpanCell._endingCell) {
                      endOfRowSpanCell = startingSpanCell._endingCell;
                      if (this.writer.transactionLevel > 0) {
                        endOfRowSpanCell._isUnbreakableContext = true;
                        endOfRowSpanCell._originalXOffset = this.writer.originalX;
                      }
                    }
                    this.writer.context().beginColumn(width, leftOffset, endOfRowSpanCell);
                    if (!cell._span) {
                      this.processNode(cell);
                      this.writer.context().updateBottomByPage();
                      addAll(positions, cell.positions);
                    } else if (cell._columnEndingContext) {
                      let discountY = 0;
                      if (dontBreakRows) {
                        const ctxBeforeRowSpanLastRow = this.writer.contextStack[this.writer.contextStack.length - 1];
                        discountY = ctxBeforeRowSpanLastRow.y - cell._startingRowSpanY;
                      }
                      let originalXOffset = 0;
                      if (cell._isUnbreakableContext && !this.writer.transactionLevel) {
                        originalXOffset = cell._originalXOffset;
                      }
                      this.writer.context().markEnding(cell, originalXOffset, discountY);
                    }
                    this.writer.removeListener("pageChanged", storePageBreakClosure);
                  }
                  let endingSpanCell = null;
                  const lastColumn = cells.length > 0 ? cells[cells.length - 1] : null;
                  if (lastColumn) {
                    if (lastColumn._endingCell) {
                      endingSpanCell = lastColumn._endingCell;
                    } else if (lastColumn._span === true) {
                      const startingSpanCell = this._findStartingRowSpanCell(cells, cells.length);
                      if (startingSpanCell) {
                        endingSpanCell = startingSpanCell._endingCell;
                        if (this.writer.transactionLevel > 0) {
                          endingSpanCell._isUnbreakableContext = true;
                          endingSpanCell._originalXOffset = this.writer.originalX;
                        }
                      }
                    }
                  }
                  if (willBreakByHeight && !isUnbreakableRow && pageBreaks.length === 0) {
                    this.writer.context().moveDown(this.writer.context().availableHeight);
                    this.writer.moveToNextPage();
                  }
                  const bottomByPage = this.writer.context().completeColumnGroup(height, endingSpanCell);
                  if (tableNode) {
                    tableNode._bottomByPage = bottomByPage;
                    this._updatePageBreaksData(pageBreaks, tableNode, rowIndex);
                  }
                  return {
                    pageBreaksBySpan: pageBreaksByRowSpan,
                    pageBreaks,
                    positions
                  };
                }
                // lists
                processList(orderedList, node) {
                  const addMarkerToFirstLeaf = (line) => {
                    if (nextMarker) {
                      let marker = nextMarker;
                      nextMarker = null;
                      if (marker.canvas) {
                        let vector = marker.canvas[0];
                        offsetVector(vector, -marker._minWidth, 0);
                        this.writer.addVector(vector);
                      } else if (marker._inlines) {
                        let markerLine = new src_Line(this.pageSize.width);
                        markerLine.addInline(marker._inlines[0]);
                        markerLine.x = -marker._minWidth;
                        markerLine.y = line.getAscenderHeight() - markerLine.getAscenderHeight();
                        this.writer.addLine(markerLine, true);
                      }
                    }
                  };
                  let items = orderedList ? node.ol : node.ul;
                  let gapSize = node._gapSize;
                  this.writer.context().addMargin(gapSize.width);
                  let nextMarker;
                  this.writer.addListener("lineAdded", addMarkerToFirstLeaf);
                  items.forEach((item) => {
                    nextMarker = item.listMarker;
                    this.processNode(item);
                    addAll(node.positions, item.positions);
                  });
                  this.writer.removeListener("lineAdded", addMarkerToFirstLeaf);
                  this.writer.context().addMargin(-gapSize.width);
                }
                // tables
                processTable(tableNode) {
                  this.nestedLevel++;
                  let processor = new src_TableProcessor(tableNode);
                  processor.beginTable(this.writer);
                  let rowHeights = tableNode.table.heights;
                  for (let i2 = 0, l = tableNode.table.body.length; i2 < l; i2++) {
                    if (processor.dontBreakRows) {
                      tableNode.table.body[i2].forEach((cell) => {
                        if (cell.rowSpan && cell.rowSpan > 1) {
                          cell._startingRowSpanY = this.writer.context().y;
                        }
                      });
                    }
                    processor.beginRow(i2, this.writer);
                    let height;
                    if (typeof rowHeights === "function") {
                      height = rowHeights(i2);
                    } else if (Array.isArray(rowHeights)) {
                      height = rowHeights[i2];
                    } else {
                      height = rowHeights;
                    }
                    if (height === "auto") {
                      height = void 0;
                    }
                    const pageBeforeProcessing = this.writer.context().page;
                    let result = this.processRow({
                      marginX: tableNode._margin ? [tableNode._margin[0], tableNode._margin[2]] : [0, 0],
                      dontBreakRows: processor.dontBreakRows,
                      rowsWithoutPageBreak: processor.rowsWithoutPageBreak,
                      cells: tableNode.table.body[i2],
                      widths: tableNode.table.widths,
                      gaps: tableNode._offsets.offsets,
                      tableBody: tableNode.table.body,
                      tableNode,
                      rowIndex: i2,
                      height
                    });
                    addAll(tableNode.positions, result.positions);
                    if (!result.pageBreaks || result.pageBreaks.length === 0) {
                      const breaksBySpan = tableNode && tableNode._breaksBySpan || null;
                      const breakBySpanData = this._findSameRowPageBreakByRowSpanData(breaksBySpan, pageBeforeProcessing, i2);
                      if (breakBySpanData) {
                        const finalBreakBySpanData = this._getPageBreakListBySpan(tableNode, breakBySpanData.prevPage, i2);
                        result.pageBreaks.push(finalBreakBySpanData);
                      }
                    }
                    processor.endRow(i2, this.writer, result.pageBreaks);
                  }
                  processor.endTable(this.writer);
                  this.nestedLevel--;
                  if (this.nestedLevel === 0) {
                    this.writer.context().resetMarginXTopParent();
                  }
                }
                // leafs (texts)
                processLeaf(node) {
                  let line = this.buildNextLine(node);
                  if (line && (node.tocItem || node.id)) {
                    line._node = node;
                  }
                  let currentHeight = line ? line.getHeight() : 0;
                  let maxHeight = node.maxHeight || -1;
                  if (line) {
                    let nodeId = getNodeId(node);
                    if (nodeId) {
                      line.id = nodeId;
                    }
                  }
                  if (node._tocItemRef) {
                    line._pageNodeRef = node._tocItemRef;
                  }
                  if (node._pageRef) {
                    line._pageNodeRef = node._pageRef._nodeRef;
                  }
                  if (line && line.inlines && Array.isArray(line.inlines)) {
                    for (let i2 = 0, l = line.inlines.length; i2 < l; i2++) {
                      if (line.inlines[i2]._tocItemRef) {
                        line.inlines[i2]._pageNodeRef = line.inlines[i2]._tocItemRef;
                      }
                      if (line.inlines[i2]._pageRef) {
                        line.inlines[i2]._pageNodeRef = line.inlines[i2]._pageRef._nodeRef;
                      }
                    }
                  }
                  while (line && (maxHeight === -1 || currentHeight < maxHeight)) {
                    let positions = this.writer.addLine(line);
                    node.positions.push(positions);
                    line = this.buildNextLine(node);
                    if (line) {
                      currentHeight += line.getHeight();
                    }
                  }
                }
                processToc(node) {
                  if (!node.toc._table && node.toc.hideEmpty === true) {
                    return;
                  }
                  if (node.toc.title) {
                    this.processNode(node.toc.title);
                  }
                  if (node.toc._table) {
                    this.processNode(node.toc._table);
                  }
                }
                buildNextLine(textNode) {
                  function cloneInline(inline) {
                    let newInline = inline.constructor();
                    for (let key in inline) {
                      newInline[key] = inline[key];
                    }
                    return newInline;
                  }
                  function findMaxFitLength(text, maxWidth, measureFn) {
                    let low = 1;
                    let high = text.length;
                    let bestFit = 1;
                    while (low <= high) {
                      const mid = Math.floor((low + high) / 2);
                      const part = text.substring(0, mid);
                      const width = measureFn(part);
                      if (width <= maxWidth) {
                        bestFit = mid;
                        low = mid + 1;
                      } else {
                        high = mid - 1;
                      }
                    }
                    return bestFit;
                  }
                  if (!textNode._inlines || textNode._inlines.length === 0) {
                    return null;
                  }
                  let line = new src_Line(this.writer.context().availableWidth);
                  const textInlines = new src_TextInlines(null);
                  let isForceContinue = false;
                  while (textNode._inlines && textNode._inlines.length > 0 && (line.hasEnoughSpaceForInline(textNode._inlines[0], textNode._inlines.slice(1)) || isForceContinue)) {
                    let isHardWrap = false;
                    let inline = textNode._inlines.shift();
                    isForceContinue = false;
                    if (!inline.noWrap && inline.text.length > 1 && inline.width > line.getAvailableWidth()) {
                      let maxChars = findMaxFitLength(inline.text, line.getAvailableWidth(), (txt) => textInlines.widthOfText(txt, inline));
                      if (maxChars < inline.text.length) {
                        let newInline = cloneInline(inline);
                        newInline.text = inline.text.substr(maxChars);
                        inline.text = inline.text.substr(0, maxChars);
                        newInline.width = textInlines.widthOfText(newInline.text, newInline);
                        inline.width = textInlines.widthOfText(inline.text, inline);
                        textNode._inlines.unshift(newInline);
                        isHardWrap = true;
                      }
                    }
                    line.addInline(inline);
                    isForceContinue = inline.noNewLine && !isHardWrap;
                  }
                  line.lastLineInParagraph = textNode._inlines.length === 0;
                  return line;
                }
                // images
                processImage(node) {
                  let position = this.writer.addImage(node);
                  node.positions.push(position);
                }
                processCanvas(node) {
                  let positions = this.writer.addCanvas(node);
                  addAll(node.positions, positions);
                }
                processSVG(node) {
                  let position = this.writer.addSVG(node);
                  node.positions.push(position);
                }
                processQr(node) {
                  let position = this.writer.addQr(node);
                  node.positions.push(position);
                }
                processAttachment(node) {
                  let position = this.writer.addAttachment(node);
                  node.positions.push(position);
                }
              }
              function decorateNode(node) {
                let x = node.x;
                let y = node.y;
                node.positions = [];
                if (Array.isArray(node.canvas)) {
                  node.canvas.forEach((vector) => {
                    let x2 = vector.x;
                    let y2 = vector.y;
                    let x1 = vector.x1;
                    let y1 = vector.y1;
                    let x22 = vector.x2;
                    let y22 = vector.y2;
                    vector.resetXY = () => {
                      vector.x = x2;
                      vector.y = y2;
                      vector.x1 = x1;
                      vector.y1 = y1;
                      vector.x2 = x22;
                      vector.y2 = y22;
                    };
                  });
                }
                node.resetXY = () => {
                  node.x = x;
                  node.y = y;
                  if (Array.isArray(node.canvas)) {
                    node.canvas.forEach((vector) => {
                      vector.resetXY();
                    });
                  }
                };
              }
              const src_LayoutBuilder = LayoutBuilder;
              var xmldoc = __webpack_require__2(7507);
              ;
              const stripUnits = (textVal) => {
                let n = parseFloat(textVal);
                if (typeof n !== "number" || isNaN(n)) {
                  return void 0;
                }
                return n;
              };
              const parseSVG = (svgString) => {
                let doc;
                try {
                  doc = new xmldoc.XmlDocument(svgString);
                } catch (err) {
                  throw new Error("Invalid svg document (" + err + ")");
                }
                if (doc.name !== "svg") {
                  throw new Error("Invalid svg document (expected <svg>)");
                }
                return doc;
              };
              class SVGMeasure {
                constructor() {
                }
                measureSVG(svg) {
                  let width, height, viewBox;
                  if (isString(svg)) {
                    let doc = parseSVG(svg);
                    width = doc.attr.width;
                    height = doc.attr.height;
                    viewBox = doc.attr.viewBox;
                  } else if (typeof SVGElement !== "undefined" && svg instanceof SVGElement && typeof getComputedStyle === "function") {
                    width = svg.getAttribute("width");
                    height = svg.getAttribute("height");
                    viewBox = svg.getAttribute("viewBox");
                  } else {
                    throw new Error("Invalid SVG document");
                  }
                  let docWidth = stripUnits(width);
                  let docHeight = stripUnits(height);
                  if ((docWidth === void 0 || docHeight === void 0) && typeof viewBox === "string") {
                    let viewBoxParts = viewBox.split(/[,\s]+/);
                    if (viewBoxParts.length !== 4) {
                      throw new Error("Unexpected svg viewBox format, should have 4 entries but found: '" + viewBox + "'");
                    }
                    if (docWidth === void 0) {
                      docWidth = stripUnits(viewBoxParts[2]);
                    }
                    if (docHeight === void 0) {
                      docHeight = stripUnits(viewBoxParts[3]);
                    }
                  }
                  return {
                    width: docWidth,
                    height: docHeight
                  };
                }
                writeDimensions(svg, dimensions) {
                  if (isString(svg)) {
                    let doc = parseSVG(svg);
                    if (typeof doc.attr.viewBox !== "string") {
                      doc.attr.viewBox = `0 0 ${stripUnits(doc.attr.width)} ${stripUnits(doc.attr.height)}`;
                    }
                    doc.attr.width = "" + dimensions.width;
                    doc.attr.height = "" + dimensions.height;
                    return doc.toString();
                  }
                  if (!svg.hasAttribute("viewBox")) {
                    svg.setAttribute("viewBox", `0 0 ${stripUnits(svg.getAttribute("width"))} ${stripUnits(svg.getAttribute("height"))}`);
                  }
                  svg.setAttribute("width", "" + dimensions.width);
                  svg.setAttribute("height", "" + dimensions.height);
                  return svg;
                }
              }
              const src_SVGMeasure = SVGMeasure;
              ;
              const groupDecorations = (line) => {
                let groups = [];
                let currentGroup = null;
                for (let i2 = 0, l = line.inlines.length; i2 < l; i2++) {
                  let inline = line.inlines[i2];
                  let decoration = inline.decoration;
                  if (!decoration) {
                    currentGroup = null;
                    continue;
                  }
                  if (!Array.isArray(decoration)) {
                    decoration = [decoration];
                  }
                  let color = inline.decorationColor || inline.color || "black";
                  let style = inline.decorationStyle || "solid";
                  let thickness = isNumber(inline.decorationThickness) ? inline.decorationThickness : null;
                  for (let ii = 0, ll = decoration.length; ii < ll; ii++) {
                    let decorationItem = decoration[ii];
                    if (!currentGroup || decorationItem !== currentGroup.decoration || style !== currentGroup.decorationStyle || color !== currentGroup.decorationColor) {
                      currentGroup = {
                        line,
                        decoration: decorationItem,
                        decorationColor: color,
                        decorationStyle: style,
                        decorationThickness: thickness,
                        inlines: [inline]
                      };
                      groups.push(currentGroup);
                    } else {
                      currentGroup.inlines.push(inline);
                    }
                  }
                }
                return groups;
              };
              class TextDecorator {
                constructor(pdfDocument) {
                  this.pdfDocument = pdfDocument;
                }
                drawBackground(line, x, y) {
                  let height = line.getHeight();
                  for (let i2 = 0, l = line.inlines.length; i2 < l; i2++) {
                    let inline = line.inlines[i2];
                    if (!inline.background) {
                      continue;
                    }
                    let color = inline.background;
                    let patternColor = this.pdfDocument.providePattern(inline.background);
                    if (patternColor !== null) {
                      color = patternColor;
                    }
                    let justifyShift = inline.justifyShift || 0;
                    this.pdfDocument.fillColor(color).rect(x + inline.x - justifyShift, y, inline.width + justifyShift, height).fill();
                  }
                }
                drawDecorations(line, x, y) {
                  let groups = groupDecorations(line);
                  for (let i2 = 0, l = groups.length; i2 < l; i2++) {
                    this._drawDecoration(groups[i2], x, y);
                  }
                }
                _drawDecoration(group, x, y) {
                  const maxInline = () => {
                    let max = 0;
                    for (let i2 = 0, l = group.inlines.length; i2 < l; i2++) {
                      let inline = group.inlines[i2];
                      max = inline.fontSize > max ? i2 : max;
                    }
                    return group.inlines[max];
                  };
                  const width = () => {
                    let sum = 0;
                    for (let i2 = 0, l = group.inlines.length; i2 < l; i2++) {
                      let justifyShift = group.inlines[i2].justifyShift || 0;
                      sum += group.inlines[i2].width + justifyShift;
                    }
                    return sum;
                  };
                  let firstInline = group.inlines[0];
                  let biggerInline = maxInline();
                  let totalWidth = width();
                  let lineAscent = group.line.getAscenderHeight();
                  let ascent = biggerInline.font.ascender / 1e3 * biggerInline.fontSize;
                  let height = biggerInline.height;
                  let descent = height - ascent;
                  let lw = isNumber(group.decorationThickness) ? group.decorationThickness : 0.5 + Math.floor(Math.max(biggerInline.fontSize - 8, 0) / 2) * 0.12;
                  switch (group.decoration) {
                    case "underline":
                      y += lineAscent + descent * 0.45;
                      break;
                    case "overline":
                      y += lineAscent - ascent * 0.85;
                      break;
                    case "lineThrough":
                      y += lineAscent - ascent * 0.25;
                      break;
                    default:
                      throw new Error(`Unknown decoration : ${group.decoration}`);
                  }
                  if (group.inlines[0].sup) {
                    y -= group.inlines[0].fontSize * 0.75;
                  }
                  if (group.inlines[0].sub) {
                    y += group.inlines[0].fontSize * 0.35;
                  }
                  this.pdfDocument.save();
                  if (group.decorationStyle === "double") {
                    let gap = Math.max(0.5, lw, biggerInline.fontSize * 0.15);
                    this.pdfDocument.fillColor(group.decorationColor).rect(x + firstInline.x, y - lw / 2, totalWidth, lw / 2).fill().rect(x + firstInline.x, y + gap - lw / 2, totalWidth, lw / 2).fill();
                  } else if (group.decorationStyle === "dashed") {
                    let nbDashes = Math.ceil(totalWidth / (3.96 + 2.84));
                    let rdx = x + firstInline.x;
                    this.pdfDocument.rect(rdx, y, totalWidth, lw).clip();
                    this.pdfDocument.fillColor(group.decorationColor);
                    for (let i2 = 0; i2 < nbDashes; i2++) {
                      this.pdfDocument.rect(rdx, y - lw / 2, 3.96, lw).fill();
                      rdx += 3.96 + 2.84;
                    }
                  } else if (group.decorationStyle === "dotted") {
                    let nbDots = Math.ceil(totalWidth / (lw * 3));
                    let rx = x + firstInline.x;
                    this.pdfDocument.rect(rx, y, totalWidth, lw).clip();
                    this.pdfDocument.fillColor(group.decorationColor);
                    for (let i2 = 0; i2 < nbDots; i2++) {
                      this.pdfDocument.rect(rx, y - lw / 2, lw, lw).fill();
                      rx += lw * 3;
                    }
                  } else if (group.decorationStyle === "wavy") {
                    let sh = 0.7, sv = 1;
                    let nbWaves = Math.ceil(totalWidth / (sh * 2)) + 1;
                    let rwx = x + firstInline.x - 1;
                    this.pdfDocument.rect(x + firstInline.x, y - sv, totalWidth, y + sv).clip();
                    this.pdfDocument.lineWidth(lw / 3);
                    this.pdfDocument.moveTo(rwx, y);
                    for (let i2 = 0; i2 < nbWaves; i2++) {
                      this.pdfDocument.bezierCurveTo(rwx + sh, y - sv, rwx + sh * 2, y - sv, rwx + sh * 3, y).bezierCurveTo(rwx + sh * 4, y + sv, rwx + sh * 5, y + sv, rwx + sh * 6, y);
                      rwx += sh * 6;
                    }
                    this.pdfDocument.stroke(group.decorationColor);
                  } else {
                    this.pdfDocument.fillColor(group.decorationColor).rect(x + firstInline.x, y - lw / 2, totalWidth, lw).fill();
                  }
                  this.pdfDocument.restore();
                }
              }
              const src_TextDecorator = TextDecorator;
              var svg_to_pdfkit = __webpack_require__2(6582);
              ;
              const findFont = (fonts, requiredFonts, defaultFont) => {
                for (let i2 = 0; i2 < requiredFonts.length; i2++) {
                  let requiredFont = requiredFonts[i2].toLowerCase();
                  for (let font in fonts) {
                    if (font.toLowerCase() === requiredFont) {
                      return font;
                    }
                  }
                }
                return defaultFont;
              };
              const offsetText = (y, inline) => {
                let newY = y;
                if (inline.sup) {
                  newY -= inline.fontSize * 0.75;
                }
                if (inline.sub) {
                  newY += inline.fontSize * 0.35;
                }
                return newY;
              };
              class Renderer {
                constructor(pdfDocument, progressCallback) {
                  this.pdfDocument = pdfDocument;
                  this.progressCallback = progressCallback;
                }
                renderPages(pages) {
                  this.pdfDocument._pdfMakePages = pages;
                  let totalItems = 0;
                  if (this.progressCallback) {
                    pages.forEach((page) => {
                      totalItems += page.items.length;
                    });
                  }
                  let renderedItems = 0;
                  for (let i2 = 0; i2 < pages.length; i2++) {
                    this.pdfDocument.addPage({
                      size: [pages[i2].pageSize.width, pages[i2].pageSize.height]
                    });
                    let page = pages[i2];
                    for (let ii = 0, il = page.items.length; ii < il; ii++) {
                      let item = page.items[ii];
                      switch (item.type) {
                        case "vector":
                          this.renderVector(item.item);
                          break;
                        case "line":
                          this.renderLine(item.item, item.item.x, item.item.y);
                          break;
                        case "image":
                          this.renderImage(item.item);
                          break;
                        case "svg":
                          this.renderSVG(item.item);
                          break;
                        case "attachment":
                          this.renderAttachment(item.item);
                          break;
                        case "beginClip":
                          this.beginClip(item.item);
                          break;
                        case "endClip":
                          this.endClip();
                          break;
                      }
                      renderedItems++;
                      if (this.progressCallback) {
                        this.progressCallback(renderedItems / totalItems);
                      }
                    }
                    if (page.watermark) {
                      this.renderWatermark(page);
                    }
                  }
                }
                renderLine(line, x, y) {
                  function preparePageNodeRefLine(_pageNodeRef, inline) {
                    let newWidth;
                    let diffWidth;
                    let textInlines = new src_TextInlines(null);
                    if (_pageNodeRef.positions === void 0) {
                      throw new Error("Page reference id not found");
                    }
                    let pageNumber = _pageNodeRef.positions[0].pageNumber.toString();
                    inline.text = pageNumber;
                    newWidth = textInlines.widthOfText(inline.text, inline);
                    diffWidth = inline.width - newWidth;
                    inline.width = newWidth;
                    switch (inline.alignment) {
                      case "right":
                        inline.x += diffWidth;
                        break;
                      case "center":
                        inline.x += diffWidth / 2;
                        break;
                    }
                  }
                  if (line._pageNodeRef) {
                    preparePageNodeRefLine(line._pageNodeRef, line.inlines[0]);
                  }
                  x = x || 0;
                  y = y || 0;
                  let lineHeight = line.getHeight();
                  let ascenderHeight = line.getAscenderHeight();
                  let descent = lineHeight - ascenderHeight;
                  const textDecorator = new src_TextDecorator(this.pdfDocument);
                  textDecorator.drawBackground(line, x, y);
                  for (let i2 = 0, l = line.inlines.length; i2 < l; i2++) {
                    let inline = line.inlines[i2];
                    let shiftToBaseline = lineHeight - inline.font.ascender / 1e3 * inline.fontSize - descent;
                    if (inline._pageNodeRef) {
                      preparePageNodeRefLine(inline._pageNodeRef, inline);
                    }
                    let options = {
                      lineBreak: false,
                      textWidth: inline.width,
                      characterSpacing: inline.characterSpacing,
                      wordCount: 1,
                      link: inline.link
                    };
                    if (inline.linkToDestination) {
                      options.goTo = inline.linkToDestination;
                    }
                    if (line.id && i2 === 0) {
                      options.destination = line.id;
                    }
                    if (inline.fontFeatures) {
                      options.features = inline.fontFeatures;
                    }
                    let opacity = isNumber(inline.opacity) ? inline.opacity : 1;
                    this.pdfDocument.opacity(opacity);
                    this.pdfDocument.fill(inline.color || "black");
                    this.pdfDocument._font = inline.font;
                    this.pdfDocument.fontSize(inline.fontSize);
                    let shiftedY = offsetText(y + shiftToBaseline, inline);
                    this.pdfDocument.text(inline.text, x + inline.x, shiftedY, options);
                    if (inline.linkToPage) {
                      this.pdfDocument.ref({
                        Type: "Action",
                        S: "GoTo",
                        D: [inline.linkToPage, 0, 0]
                      }).end();
                      this.pdfDocument.annotate(x + inline.x, shiftedY, inline.width, inline.height, {
                        Subtype: "Link",
                        Dest: [inline.linkToPage - 1, "XYZ", null, null, null]
                      });
                    }
                  }
                  textDecorator.drawDecorations(line, x, y);
                }
                renderVector(vector) {
                  this.pdfDocument.lineWidth(vector.lineWidth || 1);
                  if (vector.dash) {
                    this.pdfDocument.dash(vector.dash.length, {
                      space: vector.dash.space || vector.dash.length,
                      phase: vector.dash.phase || 0
                    });
                  } else {
                    this.pdfDocument.undash();
                  }
                  this.pdfDocument.lineJoin(vector.lineJoin || "miter");
                  this.pdfDocument.lineCap(vector.lineCap || "butt");
                  let gradient = null;
                  switch (vector.type) {
                    case "ellipse":
                      this.pdfDocument.ellipse(vector.x, vector.y, vector.r1, vector.r2);
                      if (vector.linearGradient) {
                        gradient = this.pdfDocument.linearGradient(vector.x - vector.r1, vector.y, vector.x + vector.r1, vector.y);
                      }
                      break;
                    case "rect":
                      if (vector.r) {
                        this.pdfDocument.roundedRect(vector.x, vector.y, vector.w, vector.h, vector.r);
                      } else {
                        this.pdfDocument.rect(vector.x, vector.y, vector.w, vector.h);
                      }
                      if (vector.linearGradient) {
                        gradient = this.pdfDocument.linearGradient(vector.x, vector.y, vector.x + vector.w, vector.y);
                      }
                      break;
                    case "line":
                      this.pdfDocument.moveTo(vector.x1, vector.y1);
                      this.pdfDocument.lineTo(vector.x2, vector.y2);
                      break;
                    case "polyline":
                      if (vector.points.length === 0) {
                        break;
                      }
                      this.pdfDocument.moveTo(vector.points[0].x, vector.points[0].y);
                      for (let i2 = 1, l = vector.points.length; i2 < l; i2++) {
                        this.pdfDocument.lineTo(vector.points[i2].x, vector.points[i2].y);
                      }
                      if (vector.points.length > 1) {
                        let p1 = vector.points[0];
                        let pn = vector.points[vector.points.length - 1];
                        if (vector.closePath || p1.x === pn.x && p1.y === pn.y) {
                          this.pdfDocument.closePath();
                        }
                      }
                      break;
                    case "path":
                      this.pdfDocument.path(vector.d);
                      break;
                  }
                  if (vector.linearGradient && gradient) {
                    let step = 1 / (vector.linearGradient.length - 1);
                    for (let i2 = 0; i2 < vector.linearGradient.length; i2++) {
                      gradient.stop(i2 * step, vector.linearGradient[i2]);
                    }
                    vector.color = gradient;
                  }
                  let patternColor = this.pdfDocument.providePattern(vector.color);
                  if (patternColor !== null) {
                    vector.color = patternColor;
                  }
                  let fillOpacity = isNumber(vector.fillOpacity) ? vector.fillOpacity : 1;
                  let strokeOpacity = isNumber(vector.strokeOpacity) ? vector.strokeOpacity : 1;
                  if (vector.color && vector.lineColor) {
                    this.pdfDocument.fillColor(vector.color, fillOpacity);
                    this.pdfDocument.strokeColor(vector.lineColor, strokeOpacity);
                    this.pdfDocument.fillAndStroke();
                  } else if (vector.color) {
                    this.pdfDocument.fillColor(vector.color, fillOpacity);
                    this.pdfDocument.fill();
                  } else {
                    this.pdfDocument.strokeColor(vector.lineColor || "black", strokeOpacity);
                    this.pdfDocument.stroke();
                  }
                }
                renderImage(image) {
                  let opacity = isNumber(image.opacity) ? image.opacity : 1;
                  this.pdfDocument.opacity(opacity);
                  if (image.cover) {
                    const align = image.cover.align || "center";
                    const valign = image.cover.valign || "center";
                    const width = image.cover.width ? image.cover.width : image.width;
                    const height = image.cover.height ? image.cover.height : image.height;
                    this.pdfDocument.save();
                    this.pdfDocument.rect(image.x, image.y, width, height).clip();
                    this.pdfDocument.image(image.image, image.x, image.y, {
                      cover: [width, height],
                      align,
                      valign
                    });
                    this.pdfDocument.restore();
                  } else {
                    this.pdfDocument.image(image.image, image.x, image.y, {
                      width: image._width,
                      height: image._height
                    });
                  }
                  if (image.link) {
                    this.pdfDocument.link(image.x, image.y, image._width, image._height, image.link);
                  }
                  if (image.linkToPage) {
                    this.pdfDocument.ref({
                      Type: "Action",
                      S: "GoTo",
                      D: [image.linkToPage, 0, 0]
                    }).end();
                    this.pdfDocument.annotate(image.x, image.y, image._width, image._height, {
                      Subtype: "Link",
                      Dest: [image.linkToPage - 1, "XYZ", null, null, null]
                    });
                  }
                  if (image.linkToDestination) {
                    this.pdfDocument.goTo(image.x, image.y, image._width, image._height, image.linkToDestination);
                  }
                  if (image.linkToFile) {
                    const attachment = this.pdfDocument.provideAttachment(image.linkToFile);
                    this.pdfDocument.fileAnnotation(
                      image.x,
                      image.y,
                      image._width,
                      image._height,
                      attachment,
                      // add empty rectangle as file annotation appearance with the same size as the rendered image
                      {
                        AP: {
                          N: {
                            Type: "XObject",
                            Subtype: "Form",
                            FormType: 1,
                            BBox: [image.x, image.y, image._width, image._height]
                          }
                        }
                      }
                    );
                  }
                }
                renderSVG(svg) {
                  let options = {
                    width: svg._width,
                    height: svg._height,
                    assumePt: true,
                    useCSS: !isString(svg.svg),
                    ...svg.options
                  };
                  options.fontCallback = (family, bold, italic) => {
                    let fontsFamily = family.split(",").map((f) => f.trim().replace(/('|")/g, ""));
                    let font = findFont(this.pdfDocument.fonts, fontsFamily, svg.font || "Roboto");
                    let fontFile = this.pdfDocument.getFontFile(font, bold, italic);
                    if (fontFile === null) {
                      let type = this.pdfDocument.getFontType(bold, italic);
                      throw new Error(`Font '${font}' in style '${type}' is not defined in the font section of the document definition.`);
                    }
                    return fontFile;
                  };
                  (0, svg_to_pdfkit.A)(this.pdfDocument, svg.svg, svg.x, svg.y, options);
                  if (svg.link) {
                    this.pdfDocument.link(svg.x, svg.y, svg._width, svg._height, svg.link);
                  }
                  if (svg.linkToPage) {
                    this.pdfDocument.ref({
                      Type: "Action",
                      S: "GoTo",
                      D: [svg.linkToPage, 0, 0]
                    }).end();
                    this.pdfDocument.annotate(svg.x, svg.y, svg._width, svg._height, {
                      Subtype: "Link",
                      Dest: [svg.linkToPage - 1, "XYZ", null, null, null]
                    });
                  }
                  if (svg.linkToDestination) {
                    this.pdfDocument.goTo(svg.x, svg.y, svg._width, svg._height, svg.linkToDestination);
                  }
                }
                renderAttachment(attachment) {
                  const file = this.pdfDocument.provideAttachment(attachment.attachment);
                  const options = {};
                  if (attachment.icon) {
                    options.Name = attachment.icon;
                  }
                  this.pdfDocument.fileAnnotation(attachment.x, attachment.y, attachment._width, attachment._height, file, options);
                }
                beginClip(rect) {
                  this.pdfDocument.save();
                  this.pdfDocument.addContent(`${rect.x} ${rect.y} ${rect.width} ${rect.height} re`);
                  this.pdfDocument.clip();
                }
                endClip() {
                  this.pdfDocument.restore();
                }
                renderWatermark(page) {
                  let watermark = page.watermark;
                  this.pdfDocument.fill(watermark.color);
                  this.pdfDocument.opacity(watermark.opacity);
                  this.pdfDocument.save();
                  this.pdfDocument.rotate(watermark.angle, {
                    origin: [this.pdfDocument.page.width / 2, this.pdfDocument.page.height / 2]
                  });
                  let x = this.pdfDocument.page.width / 2 - watermark._size.size.width / 2;
                  let y = this.pdfDocument.page.height / 2 - watermark._size.size.height / 2;
                  this.pdfDocument._font = watermark.font;
                  this.pdfDocument.fontSize(watermark.fontSize);
                  this.pdfDocument.text(watermark.text, x, y, {
                    lineBreak: false
                  });
                  this.pdfDocument.restore();
                }
              }
              const src_Renderer = Renderer;
              ;
              class PdfPrinter {
                /**
                 * @param {object} fontDescriptors font definition dictionary
                 * @param {object} virtualfs
                 * @param {object} urlResolver
                 */
                constructor(fontDescriptors, virtualfs, urlResolver) {
                  if (virtualfs === void 0) {
                    virtualfs = null;
                  }
                  if (urlResolver === void 0) {
                    urlResolver = null;
                  }
                  this.fontDescriptors = fontDescriptors;
                  this.virtualfs = virtualfs;
                  this.urlResolver = urlResolver;
                }
                /**
                 * Executes layout engine for the specified document and renders it into a pdfkit document
                 * ready to be saved.
                 *
                 * @param {object} docDefinition
                 * @param {object} options
                 * @returns {Promise<PDFDocument>} resolved promise return a pdfkit document
                 */
                async createPdfKitDocument(docDefinition, options) {
                  if (options === void 0) {
                    options = {};
                  }
                  await this.resolveUrls(docDefinition);
                  docDefinition.version = docDefinition.version || "1.3";
                  docDefinition.subset = docDefinition.subset || void 0;
                  docDefinition.tagged = typeof docDefinition.tagged === "boolean" ? docDefinition.tagged : false;
                  docDefinition.displayTitle = typeof docDefinition.displayTitle === "boolean" ? docDefinition.displayTitle : false;
                  docDefinition.compress = typeof docDefinition.compress === "boolean" ? docDefinition.compress : true;
                  docDefinition.images = docDefinition.images || {};
                  docDefinition.attachments = docDefinition.attachments || {};
                  docDefinition.pageMargins = isValue(docDefinition.pageMargins) ? docDefinition.pageMargins : 40;
                  docDefinition.patterns = docDefinition.patterns || {};
                  if (docDefinition.header && typeof docDefinition.header !== "function") {
                    docDefinition.header = convertToDynamicContent(docDefinition.header);
                  }
                  if (docDefinition.footer && typeof docDefinition.footer !== "function") {
                    docDefinition.footer = convertToDynamicContent(docDefinition.footer);
                  }
                  let pageSize = normalizePageSize(docDefinition.pageSize, docDefinition.pageOrientation);
                  let pdfOptions = {
                    size: [pageSize.width, pageSize.height],
                    pdfVersion: docDefinition.version,
                    subset: docDefinition.subset,
                    tagged: docDefinition.tagged,
                    displayTitle: docDefinition.displayTitle,
                    compress: docDefinition.compress,
                    userPassword: docDefinition.userPassword,
                    ownerPassword: docDefinition.ownerPassword,
                    permissions: docDefinition.permissions,
                    lang: docDefinition.language,
                    fontLayoutCache: typeof options.fontLayoutCache === "boolean" ? options.fontLayoutCache : true,
                    bufferPages: options.bufferPages || false,
                    autoFirstPage: false,
                    info: createMetadata(docDefinition),
                    font: null
                  };
                  this.pdfKitDoc = new src_PDFDocument(this.fontDescriptors, docDefinition.images, docDefinition.patterns, docDefinition.attachments, pdfOptions, this.virtualfs);
                  embedFiles(docDefinition, this.pdfKitDoc);
                  const builder = new src_LayoutBuilder(pageSize, normalizePageMargin(docDefinition.pageMargins), new src_SVGMeasure());
                  builder.registerTableLayouts(tableLayouts);
                  if (options.tableLayouts) {
                    builder.registerTableLayouts(options.tableLayouts);
                  }
                  let pages = builder.layoutDocument(docDefinition.content, this.pdfKitDoc, docDefinition.styles || {}, docDefinition.defaultStyle || {
                    fontSize: 12,
                    font: "Roboto"
                  }, docDefinition.background, docDefinition.header, docDefinition.footer, docDefinition.watermark, docDefinition.pageBreakBefore);
                  let maxNumberPages = docDefinition.maxPagesNumber || -1;
                  if (isNumber(maxNumberPages) && maxNumberPages > -1) {
                    pages = pages.slice(0, maxNumberPages);
                  }
                  pages.forEach((page) => {
                    if (page.pageSize.height === Infinity) {
                      page.pageSize.height = calculatePageHeight(page, page.pageMargins);
                    }
                  });
                  const renderer = new src_Renderer(this.pdfKitDoc, options.progressCallback);
                  renderer.renderPages(pages);
                  return this.pdfKitDoc;
                }
                /**
                 * @param {object} docDefinition
                 * @returns {Promise}
                 */
                async resolveUrls(docDefinition) {
                  const getExtendedUrl = (url) => {
                    if (typeof url === "object") {
                      return {
                        url: url.url,
                        headers: url.headers
                      };
                    }
                    return {
                      url,
                      headers: {}
                    };
                  };
                  if (this.urlResolver === null) {
                    return;
                  }
                  for (let font in this.fontDescriptors) {
                    if (this.fontDescriptors.hasOwnProperty(font)) {
                      if (this.fontDescriptors[font].normal) {
                        if (Array.isArray(this.fontDescriptors[font].normal)) {
                          let url = getExtendedUrl(this.fontDescriptors[font].normal[0]);
                          this.urlResolver.resolve(url.url, url.headers);
                          this.fontDescriptors[font].normal[0] = url.url;
                        } else {
                          let url = getExtendedUrl(this.fontDescriptors[font].normal);
                          this.urlResolver.resolve(url.url, url.headers);
                          this.fontDescriptors[font].normal = url.url;
                        }
                      }
                      if (this.fontDescriptors[font].bold) {
                        if (Array.isArray(this.fontDescriptors[font].bold)) {
                          let url = getExtendedUrl(this.fontDescriptors[font].bold[0]);
                          this.urlResolver.resolve(url.url, url.headers);
                          this.fontDescriptors[font].bold[0] = url.url;
                        } else {
                          let url = getExtendedUrl(this.fontDescriptors[font].bold);
                          this.urlResolver.resolve(url.url, url.headers);
                          this.fontDescriptors[font].bold = url.url;
                        }
                      }
                      if (this.fontDescriptors[font].italics) {
                        if (Array.isArray(this.fontDescriptors[font].italics)) {
                          let url = getExtendedUrl(this.fontDescriptors[font].italics[0]);
                          this.urlResolver.resolve(url.url, url.headers);
                          this.fontDescriptors[font].italics[0] = url.url;
                        } else {
                          let url = getExtendedUrl(this.fontDescriptors[font].italics);
                          this.urlResolver.resolve(url.url, url.headers);
                          this.fontDescriptors[font].italics = url.url;
                        }
                      }
                      if (this.fontDescriptors[font].bolditalics) {
                        if (Array.isArray(this.fontDescriptors[font].bolditalics)) {
                          let url = getExtendedUrl(this.fontDescriptors[font].bolditalics[0]);
                          this.urlResolver.resolve(url.url, url.headers);
                          this.fontDescriptors[font].bolditalics[0] = url.url;
                        } else {
                          let url = getExtendedUrl(this.fontDescriptors[font].bolditalics);
                          this.urlResolver.resolve(url.url, url.headers);
                          this.fontDescriptors[font].bolditalics = url.url;
                        }
                      }
                    }
                  }
                  if (docDefinition.images) {
                    for (let image in docDefinition.images) {
                      if (docDefinition.images.hasOwnProperty(image)) {
                        let url = getExtendedUrl(docDefinition.images[image]);
                        this.urlResolver.resolve(url.url, url.headers);
                        docDefinition.images[image] = url.url;
                      }
                    }
                  }
                  if (docDefinition.attachments) {
                    for (let attachment in docDefinition.attachments) {
                      if (docDefinition.attachments.hasOwnProperty(attachment) && docDefinition.attachments[attachment].src) {
                        let url = getExtendedUrl(docDefinition.attachments[attachment].src);
                        this.urlResolver.resolve(url.url, url.headers);
                        docDefinition.attachments[attachment].src = url.url;
                      }
                    }
                  }
                  if (docDefinition.files) {
                    for (let file in docDefinition.files) {
                      if (docDefinition.files.hasOwnProperty(file) && docDefinition.files[file].src) {
                        let url = getExtendedUrl(docDefinition.files[file].src);
                        this.urlResolver.resolve(url.url, url.headers);
                        docDefinition.files[file].src = url.url;
                      }
                    }
                  }
                  await this.urlResolver.resolved();
                }
              }
              function createMetadata(docDefinition) {
                function standardizePropertyKey(key) {
                  let standardProperties = ["Title", "Author", "Subject", "Keywords", "Creator", "Producer", "CreationDate", "ModDate", "Trapped"];
                  let standardizedKey = key.charAt(0).toUpperCase() + key.slice(1);
                  if (standardProperties.includes(standardizedKey)) {
                    return standardizedKey;
                  }
                  return key.replace(/\s+/g, "");
                }
                let info = {
                  Producer: "pdfmake",
                  Creator: "pdfmake"
                };
                if (docDefinition.info) {
                  for (let key in docDefinition.info) {
                    let value = docDefinition.info[key];
                    if (value) {
                      key = standardizePropertyKey(key);
                      info[key] = value;
                    }
                  }
                }
                return info;
              }
              function embedFiles(docDefinition, pdfKitDoc) {
                if (docDefinition.files) {
                  for (const key in docDefinition.files) {
                    const file = docDefinition.files[key];
                    if (!file.src) return;
                    if (pdfKitDoc.virtualfs && pdfKitDoc.virtualfs.existsSync(file.src)) {
                      file.src = pdfKitDoc.virtualfs.readFileSync(file.src);
                    }
                    file.name = file.name || key;
                    pdfKitDoc.file(file.src, file);
                  }
                }
              }
              function calculatePageHeight(page, margins) {
                function getItemHeight(item) {
                  if (typeof item.item.getHeight === "function") {
                    return item.item.getHeight();
                  } else if (item.item._height) {
                    return item.item._height;
                  } else if (item.type === "vector") {
                    if (typeof item.item.y1 !== "undefined") {
                      return item.item.y1 > item.item.y2 ? item.item.y1 : item.item.y2;
                    } else {
                      return item.item.h;
                    }
                  } else {
                    return 0;
                  }
                }
                function getBottomPosition(item) {
                  let top = item.item.y || 0;
                  let height2 = getItemHeight(item);
                  return top + height2;
                }
                let fixedMargins = normalizePageMargin(margins || 40);
                let height = fixedMargins.top;
                page.items.forEach((item) => {
                  let bottomPosition = getBottomPosition(item);
                  if (bottomPosition > height) {
                    height = bottomPosition;
                  }
                });
                height += fixedMargins.bottom;
                return height;
              }
              const Printer = PdfPrinter;
              var virtual_fs = __webpack_require__2(6811);
              ;
              class pdfmake {
                constructor() {
                  this.virtualfs = virtual_fs["default"];
                  this.urlResolver = null;
                }
                /**
                 * @param {object} docDefinition
                 * @param {?object} options
                 * @returns {object}
                 */
                createPdf(docDefinition, options) {
                  if (options === void 0) {
                    options = {};
                  }
                  if (!isObject(docDefinition)) {
                    throw new Error("Parameter 'docDefinition' has an invalid type. Object expected.");
                  }
                  if (!isObject(options)) {
                    throw new Error("Parameter 'options' has an invalid type. Object expected.");
                  }
                  options.progressCallback = this.progressCallback;
                  options.tableLayouts = this.tableLayouts;
                  let printer = new Printer(this.fonts, this.virtualfs, this.urlResolver());
                  const pdfDocumentPromise = printer.createPdfKitDocument(docDefinition, options);
                  return this._transformToDocument(pdfDocumentPromise);
                }
                setProgressCallback(callback) {
                  this.progressCallback = callback;
                }
                addTableLayouts(tableLayouts2) {
                  this.tableLayouts = pack(this.tableLayouts, tableLayouts2);
                }
                setTableLayouts(tableLayouts2) {
                  this.tableLayouts = tableLayouts2;
                }
                clearTableLayouts() {
                  this.tableLayouts = {};
                }
                addFonts(fonts) {
                  this.fonts = pack(this.fonts, fonts);
                }
                setFonts(fonts) {
                  this.fonts = fonts;
                }
                clearFonts() {
                  this.fonts = {};
                }
                _transformToDocument(doc) {
                  return doc;
                }
              }
              const base = pdfmake;
              ;
              var OutputDocument_Buffer = __webpack_require__2(783)["Buffer"];
              class OutputDocument {
                /**
                 * @param {Promise<object>} pdfDocumentPromise
                 */
                constructor(pdfDocumentPromise) {
                  this.bufferSize = 1073741824;
                  this.pdfDocumentPromise = pdfDocumentPromise;
                  this.bufferPromise = null;
                }
                /**
                 * @returns {Promise<object>}
                 */
                getStream() {
                  return this.pdfDocumentPromise;
                }
                /**
                 * @returns {Promise<Buffer>}
                 */
                getBuffer() {
                  const getBufferInternal = async () => {
                    const stream = await this.getStream();
                    return new Promise((resolve) => {
                      let chunks = [];
                      stream.on("readable", () => {
                        let chunk;
                        while ((chunk = stream.read(this.bufferSize)) !== null) {
                          chunks.push(chunk);
                        }
                      });
                      stream.on("end", () => {
                        resolve(OutputDocument_Buffer.concat(chunks));
                      });
                      stream.end();
                    });
                  };
                  if (this.bufferPromise === null) {
                    this.bufferPromise = getBufferInternal();
                  }
                  return this.bufferPromise;
                }
                /**
                 * @returns {Promise<string>}
                 */
                async getBase64() {
                  const buffer = await this.getBuffer();
                  return buffer.toString("base64");
                }
                /**
                 * @returns {Promise<string>}
                 */
                async getDataUrl() {
                  const data = await this.getBase64();
                  return "data:application/pdf;base64," + data;
                }
              }
              const src_OutputDocument = OutputDocument;
              var FileSaver_min = __webpack_require__2(7992);
              ;
              const openWindow = () => {
                let win = window.open("", "_blank");
                if (win === null) {
                  throw new Error("Open PDF in new window blocked by browser");
                }
                return win;
              };
              class OutputDocumentBrowser extends src_OutputDocument {
                /**
                 * @returns {Promise<Blob>}
                 */
                async getBlob() {
                  const buffer = await this.getBuffer();
                  return new Blob([buffer], {
                    type: "application/pdf"
                  });
                }
                /**
                 * @param {string} filename
                 * @returns {Promise}
                 */
                async download(filename) {
                  if (filename === void 0) {
                    filename = "file.pdf";
                  }
                  const blob = await this.getBlob();
                  (0, FileSaver_min.saveAs)(blob, filename);
                }
                /**
                 * @param {Window} win
                 * @returns {Promise}
                 */
                async open(win) {
                  if (win === void 0) {
                    win = null;
                  }
                  if (!win) {
                    win = openWindow();
                  }
                  const blob = await this.getBlob();
                  try {
                    let urlCreator = window.URL || window.webkitURL;
                    let pdfUrl = urlCreator.createObjectURL(blob);
                    win.location.href = pdfUrl;
                  } catch (e) {
                    win.close();
                    throw e;
                  }
                }
                /**
                 * @param {Window} win
                 * @returns {Promise}
                 */
                async print(win) {
                  if (win === void 0) {
                    win = null;
                  }
                  const stream = await this.getStream();
                  stream.setOpenActionAsPrint();
                  await this.open(win);
                }
              }
              const browser_extensions_OutputDocumentBrowser = OutputDocumentBrowser;
              ;
              async function fetchUrl(url, headers) {
                if (headers === void 0) {
                  headers = {};
                }
                try {
                  const response = await fetch(url, {
                    headers
                  });
                  if (!response.ok) {
                    throw new Error(`Failed to fetch (status code: ${response.status}, url: "${url}")`);
                  }
                  return await response.arrayBuffer();
                } catch (error) {
                  throw new Error(`Network request failed (url: "${url}", error: ${error.message})`);
                }
              }
              class URLResolver {
                constructor(fs) {
                  this.fs = fs;
                  this.resolving = {};
                }
                resolve(url, headers) {
                  if (headers === void 0) {
                    headers = {};
                  }
                  const resolveUrlInternal = async () => {
                    if (url.toLowerCase().startsWith("https://") || url.toLowerCase().startsWith("http://")) {
                      if (this.fs.existsSync(url)) {
                        return;
                      }
                      const buffer = await fetchUrl(url, headers);
                      this.fs.writeFileSync(url, buffer);
                    }
                  };
                  if (!this.resolving[url]) {
                    this.resolving[url] = resolveUrlInternal();
                  }
                  return this.resolving[url];
                }
                resolved() {
                  return Promise.all(Object.values(this.resolving));
                }
              }
              const src_URLResolver = URLResolver;
              var virtual_fs_cjs = __webpack_require__2(2416);
              var virtual_fs_cjs_default = __webpack_require__2.n(virtual_fs_cjs);
              var configurator = __webpack_require__2(890);
              var configurator_default = __webpack_require__2.n(configurator);
              ;
              configurator_default()({
                useNative: ["Promise"]
              });
              let defaultClientFonts = {
                Roboto: {
                  normal: "Roboto-Regular.ttf",
                  bold: "Roboto-Medium.ttf",
                  italics: "Roboto-Italic.ttf",
                  bolditalics: "Roboto-MediumItalic.ttf"
                }
              };
              class browser_extensions_pdfmake extends base {
                constructor() {
                  super();
                  this.urlResolver = () => new src_URLResolver(this.virtualfs);
                  this.fonts = defaultClientFonts;
                }
                addFontContainer(fontContainer) {
                  this.addVirtualFileSystem(fontContainer.vfs);
                  this.addFonts(fontContainer.fonts);
                }
                addVirtualFileSystem(vfs) {
                  for (let key in vfs) {
                    if (vfs.hasOwnProperty(key)) {
                      let data;
                      let encoding;
                      if (typeof vfs[key] === "object") {
                        data = vfs[key].data;
                        encoding = vfs[key].encoding || "base64";
                      } else {
                        data = vfs[key];
                        encoding = "base64";
                      }
                      virtual_fs_cjs_default().writeFileSync(key, data, encoding);
                    }
                  }
                }
                _transformToDocument(doc) {
                  return new browser_extensions_OutputDocumentBrowser(doc);
                }
              }
              const browser_extensions = new browser_extensions_pdfmake();
            },
            /***/
            7139(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var globalThis2 = __webpack_require__2(7756);
              var isCallable = __webpack_require__2(8681);
              var aFunction = function(argument) {
                return isCallable(argument) ? argument : void 0;
              };
              module2.exports = function(namespace, method) {
                return arguments.length < 2 ? aFunction(globalThis2[namespace]) : globalThis2[namespace] && globalThis2[namespace][method];
              };
            },
            /***/
            7187(__unused_webpack_module, exports2, __webpack_require__2) {
              var process = __webpack_require__2(9964);
              var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
                var keys = Object.keys(obj);
                var descriptors = {};
                for (var i = 0; i < keys.length; i++) {
                  descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
                }
                return descriptors;
              };
              var formatRegExp = /%[sdj%]/g;
              exports2.format = function(f) {
                if (!isString(f)) {
                  var objects = [];
                  for (var i = 0; i < arguments.length; i++) {
                    objects.push(inspect(arguments[i]));
                  }
                  return objects.join(" ");
                }
                var i = 1;
                var args = arguments;
                var len = args.length;
                var str = String(f).replace(formatRegExp, function(x2) {
                  if (x2 === "%%") return "%";
                  if (i >= len) return x2;
                  switch (x2) {
                    case "%s":
                      return String(args[i++]);
                    case "%d":
                      return Number(args[i++]);
                    case "%j":
                      try {
                        return JSON.stringify(args[i++]);
                      } catch (_) {
                        return "[Circular]";
                      }
                    default:
                      return x2;
                  }
                });
                for (var x = args[i]; i < len; x = args[++i]) {
                  if (isNull(x) || !isObject(x)) {
                    str += " " + x;
                  } else {
                    str += " " + inspect(x);
                  }
                }
                return str;
              };
              exports2.deprecate = function(fn, msg) {
                if (typeof process !== "undefined" && process.noDeprecation === true) {
                  return fn;
                }
                if (typeof process === "undefined") {
                  return function() {
                    return exports2.deprecate(fn, msg).apply(this, arguments);
                  };
                }
                var warned = false;
                function deprecated() {
                  if (!warned) {
                    if (process.throwDeprecation) {
                      throw new Error(msg);
                    } else if (process.traceDeprecation) {
                      console.trace(msg);
                    } else {
                      console.error(msg);
                    }
                    warned = true;
                  }
                  return fn.apply(this, arguments);
                }
                return deprecated;
              };
              var debugs = {};
              var debugEnvRegex = /^$/;
              if (process.env.NODE_DEBUG) {
                var debugEnv = process.env.NODE_DEBUG;
                debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
                debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
              }
              exports2.debuglog = function(set) {
                set = set.toUpperCase();
                if (!debugs[set]) {
                  if (debugEnvRegex.test(set)) {
                    var pid = process.pid;
                    debugs[set] = function() {
                      var msg = exports2.format.apply(exports2, arguments);
                      console.error("%s %d: %s", set, pid, msg);
                    };
                  } else {
                    debugs[set] = function() {
                    };
                  }
                }
                return debugs[set];
              };
              function inspect(obj, opts) {
                var ctx = {
                  seen: [],
                  stylize: stylizeNoColor
                };
                if (arguments.length >= 3) ctx.depth = arguments[2];
                if (arguments.length >= 4) ctx.colors = arguments[3];
                if (isBoolean(opts)) {
                  ctx.showHidden = opts;
                } else if (opts) {
                  exports2._extend(ctx, opts);
                }
                if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                if (isUndefined(ctx.depth)) ctx.depth = 2;
                if (isUndefined(ctx.colors)) ctx.colors = false;
                if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                if (ctx.colors) ctx.stylize = stylizeWithColor;
                return formatValue(ctx, obj, ctx.depth);
              }
              exports2.inspect = inspect;
              inspect.colors = {
                "bold": [1, 22],
                "italic": [3, 23],
                "underline": [4, 24],
                "inverse": [7, 27],
                "white": [37, 39],
                "grey": [90, 39],
                "black": [30, 39],
                "blue": [34, 39],
                "cyan": [36, 39],
                "green": [32, 39],
                "magenta": [35, 39],
                "red": [31, 39],
                "yellow": [33, 39]
              };
              inspect.styles = {
                "special": "cyan",
                "number": "yellow",
                "boolean": "yellow",
                "undefined": "grey",
                "null": "bold",
                "string": "green",
                "date": "magenta",
                // "name": intentionally not styling
                "regexp": "red"
              };
              function stylizeWithColor(str, styleType) {
                var style = inspect.styles[styleType];
                if (style) {
                  return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
                } else {
                  return str;
                }
              }
              function stylizeNoColor(str, styleType) {
                return str;
              }
              function arrayToHash(array) {
                var hash = {};
                array.forEach(function(val, idx) {
                  hash[val] = true;
                });
                return hash;
              }
              function formatValue(ctx, value, recurseTimes) {
                if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
                value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
                !(value.constructor && value.constructor.prototype === value)) {
                  var ret = value.inspect(recurseTimes, ctx);
                  if (!isString(ret)) {
                    ret = formatValue(ctx, ret, recurseTimes);
                  }
                  return ret;
                }
                var primitive = formatPrimitive(ctx, value);
                if (primitive) {
                  return primitive;
                }
                var keys = Object.keys(value);
                var visibleKeys = arrayToHash(keys);
                if (ctx.showHidden) {
                  keys = Object.getOwnPropertyNames(value);
                }
                if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                  return formatError(value);
                }
                if (keys.length === 0) {
                  if (isFunction(value)) {
                    var name = value.name ? ": " + value.name : "";
                    return ctx.stylize("[Function" + name + "]", "special");
                  }
                  if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                  }
                  if (isDate(value)) {
                    return ctx.stylize(Date.prototype.toString.call(value), "date");
                  }
                  if (isError(value)) {
                    return formatError(value);
                  }
                }
                var base = "", array = false, braces = ["{", "}"];
                if (isArray(value)) {
                  array = true;
                  braces = ["[", "]"];
                }
                if (isFunction(value)) {
                  var n = value.name ? ": " + value.name : "";
                  base = " [Function" + n + "]";
                }
                if (isRegExp(value)) {
                  base = " " + RegExp.prototype.toString.call(value);
                }
                if (isDate(value)) {
                  base = " " + Date.prototype.toUTCString.call(value);
                }
                if (isError(value)) {
                  base = " " + formatError(value);
                }
                if (keys.length === 0 && (!array || value.length == 0)) {
                  return braces[0] + base + braces[1];
                }
                if (recurseTimes < 0) {
                  if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                  } else {
                    return ctx.stylize("[Object]", "special");
                  }
                }
                ctx.seen.push(value);
                var output;
                if (array) {
                  output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                } else {
                  output = keys.map(function(key) {
                    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                  });
                }
                ctx.seen.pop();
                return reduceToSingleString(output, base, braces);
              }
              function formatPrimitive(ctx, value) {
                if (isUndefined(value))
                  return ctx.stylize("undefined", "undefined");
                if (isString(value)) {
                  var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                  return ctx.stylize(simple, "string");
                }
                if (isNumber(value))
                  return ctx.stylize("" + value, "number");
                if (isBoolean(value))
                  return ctx.stylize("" + value, "boolean");
                if (isNull(value))
                  return ctx.stylize("null", "null");
              }
              function formatError(value) {
                return "[" + Error.prototype.toString.call(value) + "]";
              }
              function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                var output = [];
                for (var i = 0, l = value.length; i < l; ++i) {
                  if (hasOwnProperty(value, String(i))) {
                    output.push(formatProperty(
                      ctx,
                      value,
                      recurseTimes,
                      visibleKeys,
                      String(i),
                      true
                    ));
                  } else {
                    output.push("");
                  }
                }
                keys.forEach(function(key) {
                  if (!key.match(/^\d+$/)) {
                    output.push(formatProperty(
                      ctx,
                      value,
                      recurseTimes,
                      visibleKeys,
                      key,
                      true
                    ));
                  }
                });
                return output;
              }
              function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                var name, str, desc;
                desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
                if (desc.get) {
                  if (desc.set) {
                    str = ctx.stylize("[Getter/Setter]", "special");
                  } else {
                    str = ctx.stylize("[Getter]", "special");
                  }
                } else {
                  if (desc.set) {
                    str = ctx.stylize("[Setter]", "special");
                  }
                }
                if (!hasOwnProperty(visibleKeys, key)) {
                  name = "[" + key + "]";
                }
                if (!str) {
                  if (ctx.seen.indexOf(desc.value) < 0) {
                    if (isNull(recurseTimes)) {
                      str = formatValue(ctx, desc.value, null);
                    } else {
                      str = formatValue(ctx, desc.value, recurseTimes - 1);
                    }
                    if (str.indexOf("\n") > -1) {
                      if (array) {
                        str = str.split("\n").map(function(line) {
                          return "  " + line;
                        }).join("\n").slice(2);
                      } else {
                        str = "\n" + str.split("\n").map(function(line) {
                          return "   " + line;
                        }).join("\n");
                      }
                    }
                  } else {
                    str = ctx.stylize("[Circular]", "special");
                  }
                }
                if (isUndefined(name)) {
                  if (array && key.match(/^\d+$/)) {
                    return str;
                  }
                  name = JSON.stringify("" + key);
                  if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                    name = name.slice(1, -1);
                    name = ctx.stylize(name, "name");
                  } else {
                    name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                    name = ctx.stylize(name, "string");
                  }
                }
                return name + ": " + str;
              }
              function reduceToSingleString(output, base, braces) {
                var numLinesEst = 0;
                var length = output.reduce(function(prev, cur) {
                  numLinesEst++;
                  if (cur.indexOf("\n") >= 0) numLinesEst++;
                  return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
                }, 0);
                if (length > 60) {
                  return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
                }
                return braces[0] + base + " " + output.join(", ") + " " + braces[1];
              }
              exports2.types = __webpack_require__2(9490);
              function isArray(ar) {
                return Array.isArray(ar);
              }
              exports2.isArray = isArray;
              function isBoolean(arg) {
                return typeof arg === "boolean";
              }
              exports2.isBoolean = isBoolean;
              function isNull(arg) {
                return arg === null;
              }
              exports2.isNull = isNull;
              function isNullOrUndefined(arg) {
                return arg == null;
              }
              exports2.isNullOrUndefined = isNullOrUndefined;
              function isNumber(arg) {
                return typeof arg === "number";
              }
              exports2.isNumber = isNumber;
              function isString(arg) {
                return typeof arg === "string";
              }
              exports2.isString = isString;
              function isSymbol(arg) {
                return typeof arg === "symbol";
              }
              exports2.isSymbol = isSymbol;
              function isUndefined(arg) {
                return arg === void 0;
              }
              exports2.isUndefined = isUndefined;
              function isRegExp(re) {
                return isObject(re) && objectToString(re) === "[object RegExp]";
              }
              exports2.isRegExp = isRegExp;
              exports2.types.isRegExp = isRegExp;
              function isObject(arg) {
                return typeof arg === "object" && arg !== null;
              }
              exports2.isObject = isObject;
              function isDate(d) {
                return isObject(d) && objectToString(d) === "[object Date]";
              }
              exports2.isDate = isDate;
              exports2.types.isDate = isDate;
              function isError(e) {
                return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
              }
              exports2.isError = isError;
              exports2.types.isNativeError = isError;
              function isFunction(arg) {
                return typeof arg === "function";
              }
              exports2.isFunction = isFunction;
              function isPrimitive(arg) {
                return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
                typeof arg === "undefined";
              }
              exports2.isPrimitive = isPrimitive;
              exports2.isBuffer = __webpack_require__2(1201);
              function objectToString(o) {
                return Object.prototype.toString.call(o);
              }
              function pad(n) {
                return n < 10 ? "0" + n.toString(10) : n.toString(10);
              }
              var months = [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec"
              ];
              function timestamp() {
                var d = /* @__PURE__ */ new Date();
                var time = [
                  pad(d.getHours()),
                  pad(d.getMinutes()),
                  pad(d.getSeconds())
                ].join(":");
                return [d.getDate(), months[d.getMonth()], time].join(" ");
              }
              exports2.log = function() {
                console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
              };
              exports2.inherits = __webpack_require__2(9784);
              exports2._extend = function(origin, add) {
                if (!add || !isObject(add)) return origin;
                var keys = Object.keys(add);
                var i = keys.length;
                while (i--) {
                  origin[keys[i]] = add[keys[i]];
                }
                return origin;
              };
              function hasOwnProperty(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
              }
              var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
              exports2.promisify = function promisify(original) {
                if (typeof original !== "function")
                  throw new TypeError('The "original" argument must be of type Function');
                if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                  var fn = original[kCustomPromisifiedSymbol];
                  if (typeof fn !== "function") {
                    throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                  }
                  Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                    value: fn,
                    enumerable: false,
                    writable: false,
                    configurable: true
                  });
                  return fn;
                }
                function fn() {
                  var promiseResolve, promiseReject;
                  var promise = new Promise(function(resolve, reject) {
                    promiseResolve = resolve;
                    promiseReject = reject;
                  });
                  var args = [];
                  for (var i = 0; i < arguments.length; i++) {
                    args.push(arguments[i]);
                  }
                  args.push(function(err, value) {
                    if (err) {
                      promiseReject(err);
                    } else {
                      promiseResolve(value);
                    }
                  });
                  try {
                    original.apply(this, args);
                  } catch (err) {
                    promiseReject(err);
                  }
                  return promise;
                }
                Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
                if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                  value: fn,
                  enumerable: false,
                  writable: false,
                  configurable: true
                });
                return Object.defineProperties(
                  fn,
                  getOwnPropertyDescriptors(original)
                );
              };
              exports2.promisify.custom = kCustomPromisifiedSymbol;
              function callbackifyOnRejected(reason, cb) {
                if (!reason) {
                  var newReason = new Error("Promise was rejected with a falsy value");
                  newReason.reason = reason;
                  reason = newReason;
                }
                return cb(reason);
              }
              function callbackify(original) {
                if (typeof original !== "function") {
                  throw new TypeError('The "original" argument must be of type Function');
                }
                function callbackified() {
                  var args = [];
                  for (var i = 0; i < arguments.length; i++) {
                    args.push(arguments[i]);
                  }
                  var maybeCb = args.pop();
                  if (typeof maybeCb !== "function") {
                    throw new TypeError("The last argument must be of type Function");
                  }
                  var self2 = this;
                  var cb = function() {
                    return maybeCb.apply(self2, arguments);
                  };
                  original.apply(this, args).then(
                    function(ret) {
                      process.nextTick(cb.bind(null, null, ret));
                    },
                    function(rej) {
                      process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                    }
                  );
                }
                Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
                Object.defineProperties(
                  callbackified,
                  getOwnPropertyDescriptors(original)
                );
                return callbackified;
              }
              exports2.callbackify = callbackify;
            },
            /***/
            7199() {
            },
            /***/
            7222(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var isPossiblePrototype = __webpack_require__2(2657);
              var $String = String;
              var $TypeError = TypeError;
              module2.exports = function(argument) {
                if (isPossiblePrototype(argument)) return argument;
                throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
              };
            },
            /***/
            7309(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var globalThis2 = __webpack_require__2(7756);
              var defineProperty = Object.defineProperty;
              module2.exports = function(key, value) {
                try {
                  defineProperty(globalThis2, key, { value, configurable: true, writable: true });
                } catch (error) {
                  globalThis2[key] = value;
                }
                return value;
              };
            },
            /***/
            7331(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(321), __webpack_require__2(8865));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function() {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var Base = C_lib.Base;
                  var WordArray = C_lib.WordArray;
                  var C_algo = C.algo;
                  var SHA256 = C_algo.SHA256;
                  var HMAC = C_algo.HMAC;
                  var PBKDF2 = C_algo.PBKDF2 = Base.extend({
                    /**
                     * Configuration options.
                     *
                     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
                     * @property {Hasher} hasher The hasher to use. Default: SHA256
                     * @property {number} iterations The number of iterations to perform. Default: 250000
                     */
                    cfg: Base.extend({
                      keySize: 128 / 32,
                      hasher: SHA256,
                      iterations: 25e4
                    }),
                    /**
                     * Initializes a newly created key derivation function.
                     *
                     * @param {Object} cfg (Optional) The configuration options to use for the derivation.
                     *
                     * @example
                     *
                     *     var kdf = CryptoJS.algo.PBKDF2.create();
                     *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
                     *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
                     */
                    init: function(cfg) {
                      this.cfg = this.cfg.extend(cfg);
                    },
                    /**
                     * Computes the Password-Based Key Derivation Function 2.
                     *
                     * @param {WordArray|string} password The password.
                     * @param {WordArray|string} salt A salt.
                     *
                     * @return {WordArray} The derived key.
                     *
                     * @example
                     *
                     *     var key = kdf.compute(password, salt);
                     */
                    compute: function(password, salt) {
                      var cfg = this.cfg;
                      var hmac = HMAC.create(cfg.hasher, password);
                      var derivedKey = WordArray.create();
                      var blockIndex = WordArray.create([1]);
                      var derivedKeyWords = derivedKey.words;
                      var blockIndexWords = blockIndex.words;
                      var keySize = cfg.keySize;
                      var iterations = cfg.iterations;
                      while (derivedKeyWords.length < keySize) {
                        var block = hmac.update(salt).finalize(blockIndex);
                        hmac.reset();
                        var blockWords = block.words;
                        var blockWordsLength = blockWords.length;
                        var intermediate = block;
                        for (var i = 1; i < iterations; i++) {
                          intermediate = hmac.finalize(intermediate);
                          hmac.reset();
                          var intermediateWords = intermediate.words;
                          for (var j = 0; j < blockWordsLength; j++) {
                            blockWords[j] ^= intermediateWords[j];
                          }
                        }
                        derivedKey.concat(block);
                        blockIndexWords[0]++;
                      }
                      derivedKey.sigBytes = keySize * 4;
                      return derivedKey;
                    }
                  });
                  C.PBKDF2 = function(password, salt, cfg) {
                    return PBKDF2.create(cfg).compute(password, salt);
                  };
                })();
                return CryptoJS.PBKDF2;
              });
            },
            /***/
            7383(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var UA = __webpack_require__2(8115);
              module2.exports = /MSIE|Trident/.test(UA);
            },
            /***/
            7385(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var process = __webpack_require__2(9964);
              function destroy(err, cb) {
                var _this = this;
                var readableDestroyed = this._readableState && this._readableState.destroyed;
                var writableDestroyed = this._writableState && this._writableState.destroyed;
                if (readableDestroyed || writableDestroyed) {
                  if (cb) {
                    cb(err);
                  } else if (err) {
                    if (!this._writableState) {
                      process.nextTick(emitErrorNT, this, err);
                    } else if (!this._writableState.errorEmitted) {
                      this._writableState.errorEmitted = true;
                      process.nextTick(emitErrorNT, this, err);
                    }
                  }
                  return this;
                }
                if (this._readableState) {
                  this._readableState.destroyed = true;
                }
                if (this._writableState) {
                  this._writableState.destroyed = true;
                }
                this._destroy(err || null, function(err2) {
                  if (!cb && err2) {
                    if (!_this._writableState) {
                      process.nextTick(emitErrorAndCloseNT, _this, err2);
                    } else if (!_this._writableState.errorEmitted) {
                      _this._writableState.errorEmitted = true;
                      process.nextTick(emitErrorAndCloseNT, _this, err2);
                    } else {
                      process.nextTick(emitCloseNT, _this);
                    }
                  } else if (cb) {
                    process.nextTick(emitCloseNT, _this);
                    cb(err2);
                  } else {
                    process.nextTick(emitCloseNT, _this);
                  }
                });
                return this;
              }
              function emitErrorAndCloseNT(self2, err) {
                emitErrorNT(self2, err);
                emitCloseNT(self2);
              }
              function emitCloseNT(self2) {
                if (self2._writableState && !self2._writableState.emitClose) return;
                if (self2._readableState && !self2._readableState.emitClose) return;
                self2.emit("close");
              }
              function undestroy() {
                if (this._readableState) {
                  this._readableState.destroyed = false;
                  this._readableState.reading = false;
                  this._readableState.ended = false;
                  this._readableState.endEmitted = false;
                }
                if (this._writableState) {
                  this._writableState.destroyed = false;
                  this._writableState.ended = false;
                  this._writableState.ending = false;
                  this._writableState.finalCalled = false;
                  this._writableState.prefinished = false;
                  this._writableState.finished = false;
                  this._writableState.errorEmitted = false;
                }
              }
              function emitErrorNT(self2, err) {
                self2.emit("error", err);
              }
              function errorOrDestroy(stream, err) {
                var rState = stream._readableState;
                var wState = stream._writableState;
                if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
                else stream.emit("error", err);
              }
              module2.exports = {
                destroy,
                undestroy,
                errorOrDestroy
              };
            },
            /***/
            7450(module2) {
              "use strict";
              module2.exports = Math.floor;
            },
            /***/
            7468(module2) {
              "use strict";
              function ZStream() {
                this.input = null;
                this.next_in = 0;
                this.avail_in = 0;
                this.total_in = 0;
                this.output = null;
                this.next_out = 0;
                this.avail_out = 0;
                this.total_out = 0;
                this.msg = "";
                this.state = null;
                this.data_type = 2;
                this.adler = 0;
              }
              module2.exports = ZStream;
            },
            /***/
            7493(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function() {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var WordArray = C_lib.WordArray;
                  var C_enc = C.enc;
                  var Base64url = C_enc.Base64url = {
                    /**
                     * Converts a word array to a Base64url string.
                     *
                     * @param {WordArray} wordArray The word array.
                     *
                     * @param {boolean} urlSafe Whether to use url safe
                     *
                     * @return {string} The Base64url string.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
                     */
                    stringify: function(wordArray, urlSafe) {
                      if (urlSafe === void 0) {
                        urlSafe = true;
                      }
                      var words = wordArray.words;
                      var sigBytes = wordArray.sigBytes;
                      var map = urlSafe ? this._safe_map : this._map;
                      wordArray.clamp();
                      var base64Chars = [];
                      for (var i = 0; i < sigBytes; i += 3) {
                        var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                        var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
                        var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
                        var triplet = byte1 << 16 | byte2 << 8 | byte3;
                        for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                          base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
                        }
                      }
                      var paddingChar = map.charAt(64);
                      if (paddingChar) {
                        while (base64Chars.length % 4) {
                          base64Chars.push(paddingChar);
                        }
                      }
                      return base64Chars.join("");
                    },
                    /**
                     * Converts a Base64url string to a word array.
                     *
                     * @param {string} base64Str The Base64url string.
                     *
                     * @param {boolean} urlSafe Whether to use url safe
                     *
                     * @return {WordArray} The word array.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
                     */
                    parse: function(base64Str, urlSafe) {
                      if (urlSafe === void 0) {
                        urlSafe = true;
                      }
                      var base64StrLength = base64Str.length;
                      var map = urlSafe ? this._safe_map : this._map;
                      var reverseMap = this._reverseMap;
                      if (!reverseMap) {
                        reverseMap = this._reverseMap = [];
                        for (var j = 0; j < map.length; j++) {
                          reverseMap[map.charCodeAt(j)] = j;
                        }
                      }
                      var paddingChar = map.charAt(64);
                      if (paddingChar) {
                        var paddingIndex = base64Str.indexOf(paddingChar);
                        if (paddingIndex !== -1) {
                          base64StrLength = paddingIndex;
                        }
                      }
                      return parseLoop(base64Str, base64StrLength, reverseMap);
                    },
                    _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                    _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
                  };
                  function parseLoop(base64Str, base64StrLength, reverseMap) {
                    var words = [];
                    var nBytes = 0;
                    for (var i = 0; i < base64StrLength; i++) {
                      if (i % 4) {
                        var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
                        var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
                        var bitsCombined = bits1 | bits2;
                        words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                        nBytes++;
                      }
                    }
                    return WordArray.create(words, nBytes);
                  }
                })();
                return CryptoJS.enc.Base64url;
              });
            },
            /***/
            7507(__unused_webpack_module, exports2, __webpack_require__2) {
              "use strict";
              var __importDefault = this && this.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : { "default": mod };
              };
              Object.defineProperty(exports2, "__esModule", { value: true });
              exports2.XmlDocument = exports2.XmlElement = exports2.XmlCommentNode = exports2.XmlCDataNode = exports2.XmlTextNode = void 0;
              const sax_1 = __importDefault(__webpack_require__2(1733));
              class XmlTextNode {
                /**
                 * Creates a new text node
                 * @param text The text content
                 */
                constructor(text) {
                  this.text = text;
                  this.type = "text";
                }
                /**
                 * Converts the text node to a string
                 * @param options Formatting options
                 * @returns String representation of the text node
                 */
                toString(options) {
                  return formatText(escapeXML(this.text), options);
                }
                /**
                 * Converts the text node to a string with indentation
                 * @param indent The indentation to use
                 * @param options Formatting options
                 * @returns String representation of the text node with indentation
                 */
                toStringWithIndent(indent, options) {
                  return indent + this.toString(options);
                }
              }
              exports2.XmlTextNode = XmlTextNode;
              class XmlCDataNode {
                /**
                 * Creates a new CDATA node
                 * @param cdata The CDATA content
                 */
                constructor(cdata) {
                  this.cdata = cdata;
                  this.type = "cdata";
                }
                /**
                 * Converts the CDATA node to a string
                 * @param options Formatting options
                 * @returns String representation of the CDATA node
                 */
                toString(options) {
                  return `<![CDATA[${formatText(this.cdata, options)}]]>`;
                }
                /**
                 * Converts the CDATA node to a string with indentation
                 * @param indent The indentation to use
                 * @param options Formatting options
                 * @returns String representation of the CDATA node with indentation
                 */
                toStringWithIndent(indent, options) {
                  return indent + this.toString(options);
                }
              }
              exports2.XmlCDataNode = XmlCDataNode;
              class XmlCommentNode {
                /**
                 * Creates a new comment node
                 * @param comment The comment content
                 */
                constructor(comment) {
                  this.comment = comment;
                  this.type = "comment";
                }
                /**
                 * Converts the comment node to a string
                 * @param options Formatting options
                 * @returns String representation of the comment node
                 */
                toString(options) {
                  return `<!--${formatText(escapeXML(this.comment), options)}-->`;
                }
                /**
                 * Converts the comment node to a string with indentation
                 * @param indent The indentation to use
                 * @param options Formatting options
                 * @returns String representation of the comment node with indentation
                 */
                toStringWithIndent(indent, options) {
                  return indent + this.toString(options);
                }
              }
              exports2.XmlCommentNode = XmlCommentNode;
              class XmlElement {
                /**
                 * Creates a new XML element
                 * @param tag The tag name and attributes
                 * @param parser Optional SAX parser instance with position information
                 */
                constructor(tag, parser) {
                  this.type = "element";
                  if (!parser && delegates.length) {
                    var delegate = delegates[delegates.length - 1];
                    if ("parser" in delegate) {
                      parser = delegate.parser;
                    }
                  }
                  this.name = tag.name;
                  this.attr = tag.attributes;
                  this.val = "";
                  this.children = [];
                  this.firstChild = null;
                  this.lastChild = null;
                  this.line = parser ? parser.line : null;
                  this.column = parser ? parser.column : null;
                  this.position = parser ? parser.position : null;
                  this.startTagPosition = parser ? parser.startTagPosition : null;
                }
                /**
                 * Adds a child node to this element
                 * @param child The child node to add
                 */
                _addChild(child) {
                  this.children.push(child);
                  if (!this.firstChild)
                    this.firstChild = child;
                  this.lastChild = child;
                }
                _opentag(tag) {
                  const child = new XmlElement(tag);
                  this._addChild(child);
                  delegates.unshift(child);
                }
                _closetag() {
                  delegates.shift();
                }
                _text(text) {
                  this.val += text;
                  this._addChild(new XmlTextNode(text));
                }
                _cdata(cdata) {
                  this.val += cdata;
                  this._addChild(new XmlCDataNode(cdata));
                }
                _comment(comment) {
                  this._addChild(new XmlCommentNode(comment));
                }
                _error(err) {
                  throw err;
                }
                /**
                 * Iterates through each child element of this node
                 * @param iterator Function to call for each child element
                 * @param context Optional context to use for the iterator function
                 */
                eachChild(iterator, context) {
                  for (let i = 0, l = this.children.length; i < l; i++) {
                    const child = this.children[i];
                    if (child.type === "element") {
                      if (iterator.call(context, child, i, this.children) === false)
                        return;
                    }
                  }
                }
                /**
                 * Finds the first child element with the given name
                 * @param name The name of the child element to find
                 * @returns The first matching child element, or undefined if not found
                 */
                childNamed(name) {
                  for (let i = 0, l = this.children.length; i < l; i++) {
                    const child = this.children[i];
                    if (child.type === "element" && child.name === name) {
                      return child;
                    }
                  }
                  return void 0;
                }
                /**
                 * Finds all child elements with the given name
                 * @param name The name of the child elements to find
                 * @returns Array of matching child elements
                 */
                childrenNamed(name) {
                  const matches = [];
                  for (let i = 0, l = this.children.length; i < l; i++) {
                    const child = this.children[i];
                    if (child.type === "element" && child.name === name) {
                      matches.push(child);
                    }
                  }
                  return matches;
                }
                /**
                 * Finds the first child element with the given attribute
                 * @param name The name of the attribute to find
                 * @param value Optional value the attribute should have
                 * @returns The first matching child element, or undefined if not found
                 */
                childWithAttribute(name, value) {
                  for (let i = 0, l = this.children.length; i < l; i++) {
                    const child = this.children[i];
                    if (child.type === "element" && (value !== void 0 && child.attr[name] === value || value === void 0 && child.attr[name])) {
                      return child;
                    }
                  }
                  return void 0;
                }
                /**
                 * Finds all descendant elements with the given name, searching recursively
                 * @param name The name of the descendant elements to find
                 * @returns Array of matching descendant elements
                 */
                descendantsNamed(name) {
                  const matches = [];
                  for (let i = 0, l = this.children.length; i < l; i++) {
                    const child = this.children[i];
                    if (child.type === "element") {
                      const element = child;
                      if (element.name === name)
                        matches.push(element);
                      matches.push(...element.descendantsNamed(name));
                    }
                  }
                  return matches;
                }
                /**
                 * Finds a descendant element using a dot-notation path
                 * @param path The path to the descendant, e.g. "author.name"
                 * @returns The matching descendant element, or undefined if not found
                 * @example
                 * // For XML: <book><author><name>John</name></author></book>
                 * bookNode.descendantWithPath("author.name") // returns the <name> element
                 */
                descendantWithPath(path) {
                  let descendant = this;
                  const components = path.split(".");
                  for (let i = 0, l = components.length; i < l; i++) {
                    if (descendant && descendant.type === "element") {
                      descendant = descendant.childNamed(components[i]);
                    } else {
                      return void 0;
                    }
                  }
                  return descendant;
                }
                /**
                 * Gets the value of a descendant element or attribute using a path
                 * @param path The path to the descendant or attribute, e.g. "author.name" or "author.name@id"
                 * @returns The value of the descendant or attribute, or undefined if not found
                 * @example
                 * // For XML: <book><author><name id="1">John</name></author></book>
                 * bookNode.valueWithPath("author.name")    // returns "John"
                 * bookNode.valueWithPath("author.name@id") // returns "1"
                 */
                valueWithPath(path) {
                  const components = path.split("@");
                  const descendant = this.descendantWithPath(components[0]);
                  if (descendant) {
                    return components.length > 1 ? descendant.attr[components[1]] : descendant.val;
                  } else {
                    return void 0;
                  }
                }
                /**
                 * Converts the element to a string representation
                 * @param options Formatting options
                 * @returns String representation of the element
                 */
                toString(options) {
                  return this.toStringWithIndent("", options);
                }
                /**
                 * Converts the element to a string with the specified indentation
                 * @param indent The indentation to use
                 * @param options Formatting options
                 * @returns String representation of the element with indentation
                 */
                toStringWithIndent(indent, options) {
                  let s = `${indent}<${this.name}`;
                  const linebreak = (options === null || options === void 0 ? void 0 : options.compressed) ? "" : "\n";
                  for (const name in this.attr) {
                    if (Object.prototype.hasOwnProperty.call(this.attr, name)) {
                      s += ` ${name}="${escapeXML(this.attr[name])}"`;
                    }
                  }
                  if (this.children.length === 1 && this.children[0].type !== "element") {
                    s += `>${this.children[0].toString(options)}</${this.name}>`;
                  } else if (this.children.length) {
                    s += `>${linebreak}`;
                    const childIndent = indent + ((options === null || options === void 0 ? void 0 : options.compressed) ? "" : "  ");
                    for (let i = 0, l = this.children.length; i < l; i++) {
                      s += `${this.children[i].toStringWithIndent(childIndent, options)}${linebreak}`;
                    }
                    s += `${indent}</${this.name}>`;
                  } else if (options === null || options === void 0 ? void 0 : options.html) {
                    const whiteList = [
                      "area",
                      "base",
                      "br",
                      "col",
                      "embed",
                      "frame",
                      "hr",
                      "img",
                      "input",
                      "keygen",
                      "link",
                      "menuitem",
                      "meta",
                      "param",
                      "source",
                      "track",
                      "wbr"
                    ];
                    if (whiteList.includes(this.name)) {
                      s += "/>";
                    } else {
                      s += `></${this.name}>`;
                    }
                  } else {
                    s += "/>";
                  }
                  return s;
                }
              }
              exports2.XmlElement = XmlElement;
              class XmlDocument extends XmlElement {
                /**
                 * Creates a new XML document from an XML string
                 * @param xml The XML string to parse
                 * @throws {Error} If the XML is empty or invalid
                 * @example
                 * ```ts
                 * import { XmlDocument } from 'xmldoc';
                 *
                 * const doc = new XmlDocument("<root><child>value</child></root>");
                 * console.log(doc.childNamed("child")?.val); // "value"
                 * ```
                 */
                constructor(xml) {
                  super({ name: "", attributes: {} });
                  xml = xml.toString().trim();
                  if (!xml) {
                    throw new Error("No XML to parse!");
                  }
                  this.doctype = "";
                  this.parser = sax_1.default.parser(true);
                  addParserEvents(this.parser);
                  delegates = [this];
                  try {
                    this.parser.write(xml);
                  } finally {
                    delete this.parser;
                  }
                }
                _opentag(tag) {
                  if (this.name === "") {
                    this.name = tag.name;
                    this.attr = tag.attributes;
                  } else {
                    super._opentag(tag);
                  }
                }
                _doctype(doctype) {
                  this.doctype += doctype;
                }
              }
              exports2.XmlDocument = XmlDocument;
              let delegates = [];
              function addParserEvents(parser) {
                parser.onopentag = (tag) => {
                  var _a;
                  return (_a = delegates[0]) === null || _a === void 0 ? void 0 : _a._opentag(tag);
                };
                parser.onclosetag = () => {
                  var _a;
                  return (_a = delegates[0]) === null || _a === void 0 ? void 0 : _a._closetag();
                };
                parser.ontext = (text) => {
                  var _a;
                  return (_a = delegates[0]) === null || _a === void 0 ? void 0 : _a._text(text);
                };
                parser.oncdata = (cdata) => {
                  var _a;
                  return (_a = delegates[0]) === null || _a === void 0 ? void 0 : _a._cdata(cdata);
                };
                parser.oncomment = (comment) => {
                  var _a;
                  return (_a = delegates[0]) === null || _a === void 0 ? void 0 : _a._comment(comment);
                };
                parser.ondoctype = (doctype) => {
                  const doc = delegates[0];
                  if (doc._doctype)
                    doc._doctype(doctype);
                };
                parser.onerror = (err) => {
                  var _a;
                  return (_a = delegates[0]) === null || _a === void 0 ? void 0 : _a._error(err);
                };
              }
              function escapeXML(value) {
                return value.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&apos;").replace(/"/g, "&quot;");
              }
              function formatText(text, options) {
                let finalText = text;
                if ((options === null || options === void 0 ? void 0 : options.trimmed) && text.length > 25) {
                  finalText = finalText.substring(0, 25).trim() + "";
                }
                if (!(options === null || options === void 0 ? void 0 : options.preserveWhitespace)) {
                  finalText = finalText.trim();
                }
                return finalText;
              }
              exports2["default"] = XmlDocument;
            },
            /***/
            7552(module2) {
              "use strict";
              module2.exports = Math.min;
            },
            /***/
            7571(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              __webpack_require__2(8376);
              __webpack_require__2(6401);
              __webpack_require__2(2017);
              const inflate = __webpack_require__2(3483);
              const {
                swap32LE
              } = __webpack_require__2(6016);
              const SHIFT_1 = 6 + 5;
              const SHIFT_2 = 5;
              const SHIFT_1_2 = SHIFT_1 - SHIFT_2;
              const OMITTED_BMP_INDEX_1_LENGTH = 65536 >> SHIFT_1;
              const INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
              const INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
              const INDEX_SHIFT = 2;
              const DATA_BLOCK_LENGTH = 1 << SHIFT_2;
              const DATA_MASK = DATA_BLOCK_LENGTH - 1;
              const LSCP_INDEX_2_OFFSET = 65536 >> SHIFT_2;
              const LSCP_INDEX_2_LENGTH = 1024 >> SHIFT_2;
              const INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
              const UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
              const UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
              const INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
              const DATA_GRANULARITY = 1 << INDEX_SHIFT;
              class UnicodeTrie {
                constructor(data) {
                  const isBuffer = typeof data.readUInt32BE === "function" && typeof data.slice === "function";
                  if (isBuffer || data instanceof Uint8Array) {
                    let uncompressedLength;
                    if (isBuffer) {
                      this.highStart = data.readUInt32LE(0);
                      this.errorValue = data.readUInt32LE(4);
                      uncompressedLength = data.readUInt32LE(8);
                      data = data.slice(12);
                    } else {
                      const view = new DataView(data.buffer);
                      this.highStart = view.getUint32(0, true);
                      this.errorValue = view.getUint32(4, true);
                      uncompressedLength = view.getUint32(8, true);
                      data = data.subarray(12);
                    }
                    data = inflate(data, new Uint8Array(uncompressedLength));
                    data = inflate(data, new Uint8Array(uncompressedLength));
                    swap32LE(data);
                    this.data = new Uint32Array(data.buffer);
                  } else {
                    ({
                      data: this.data,
                      highStart: this.highStart,
                      errorValue: this.errorValue
                    } = data);
                  }
                }
                get(codePoint) {
                  let index;
                  if (codePoint < 0 || codePoint > 1114111) {
                    return this.errorValue;
                  }
                  if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
                    index = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
                    return this.data[index];
                  }
                  if (codePoint <= 65535) {
                    index = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
                    return this.data[index];
                  }
                  if (codePoint < this.highStart) {
                    index = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
                    index = this.data[index + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
                    index = (index << INDEX_SHIFT) + (codePoint & DATA_MASK);
                    return this.data[index];
                  }
                  return this.data[this.data.length - DATA_GRANULARITY];
                }
              }
              module2.exports = UnicodeTrie;
            },
            /***/
            7596(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var implementation = __webpack_require__2(6521);
              var lacksProperEnumerationOrder = function() {
                if (!Object.assign) {
                  return false;
                }
                var str = "abcdefghijklmnopqrst";
                var letters = str.split("");
                var map = {};
                for (var i = 0; i < letters.length; ++i) {
                  map[letters[i]] = letters[i];
                }
                var obj = Object.assign({}, map);
                var actual = "";
                for (var k in obj) {
                  actual += k;
                }
                return str !== actual;
              };
              var assignHasPendingExceptions = function() {
                if (!Object.assign || !Object.preventExtensions) {
                  return false;
                }
                var thrower = Object.preventExtensions({ 1: 2 });
                try {
                  Object.assign(thrower, "xy");
                } catch (e) {
                  return thrower[1] === "y";
                }
                return false;
              };
              module2.exports = function getPolyfill() {
                if (!Object.assign) {
                  return implementation;
                }
                if (lacksProperEnumerationOrder()) {
                  return implementation;
                }
                if (assignHasPendingExceptions()) {
                  return implementation;
                }
                return Object.assign;
              };
            },
            /***/
            7657(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var DESCRIPTORS = __webpack_require__2(5144);
              var fails = __webpack_require__2(299);
              var createElement = __webpack_require__2(2283);
              module2.exports = !DESCRIPTORS && !fails(function() {
                return Object.defineProperty(createElement("div"), "a", {
                  get: function() {
                    return 7;
                  }
                }).a !== 7;
              });
            },
            /***/
            7695(module2) {
              "use strict";
              module2.exports = false;
            },
            /***/
            7696(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              module2 = __webpack_require__2.nmd(module2);
              var SVGtoPDF = function(doc, svg, x, y, options) {
                "use strict";
                const NamedColors = {
                  aliceblue: [240, 248, 255],
                  antiquewhite: [250, 235, 215],
                  aqua: [0, 255, 255],
                  aquamarine: [127, 255, 212],
                  azure: [240, 255, 255],
                  beige: [245, 245, 220],
                  bisque: [255, 228, 196],
                  black: [0, 0, 0],
                  blanchedalmond: [255, 235, 205],
                  blue: [0, 0, 255],
                  blueviolet: [138, 43, 226],
                  brown: [165, 42, 42],
                  burlywood: [222, 184, 135],
                  cadetblue: [95, 158, 160],
                  chartreuse: [127, 255, 0],
                  chocolate: [210, 105, 30],
                  coral: [255, 127, 80],
                  cornflowerblue: [100, 149, 237],
                  cornsilk: [255, 248, 220],
                  crimson: [220, 20, 60],
                  cyan: [0, 255, 255],
                  darkblue: [0, 0, 139],
                  darkcyan: [0, 139, 139],
                  darkgoldenrod: [184, 134, 11],
                  darkgray: [169, 169, 169],
                  darkgrey: [169, 169, 169],
                  darkgreen: [0, 100, 0],
                  darkkhaki: [189, 183, 107],
                  darkmagenta: [139, 0, 139],
                  darkolivegreen: [85, 107, 47],
                  darkorange: [255, 140, 0],
                  darkorchid: [153, 50, 204],
                  darkred: [139, 0, 0],
                  darksalmon: [233, 150, 122],
                  darkseagreen: [143, 188, 143],
                  darkslateblue: [72, 61, 139],
                  darkslategray: [47, 79, 79],
                  darkslategrey: [47, 79, 79],
                  darkturquoise: [0, 206, 209],
                  darkviolet: [148, 0, 211],
                  deeppink: [255, 20, 147],
                  deepskyblue: [0, 191, 255],
                  dimgray: [105, 105, 105],
                  dimgrey: [105, 105, 105],
                  dodgerblue: [30, 144, 255],
                  firebrick: [178, 34, 34],
                  floralwhite: [255, 250, 240],
                  forestgreen: [34, 139, 34],
                  fuchsia: [255, 0, 255],
                  gainsboro: [220, 220, 220],
                  ghostwhite: [248, 248, 255],
                  gold: [255, 215, 0],
                  goldenrod: [218, 165, 32],
                  gray: [128, 128, 128],
                  grey: [128, 128, 128],
                  green: [0, 128, 0],
                  greenyellow: [173, 255, 47],
                  honeydew: [240, 255, 240],
                  hotpink: [255, 105, 180],
                  indianred: [205, 92, 92],
                  indigo: [75, 0, 130],
                  ivory: [255, 255, 240],
                  khaki: [240, 230, 140],
                  lavender: [230, 230, 250],
                  lavenderblush: [255, 240, 245],
                  lawngreen: [124, 252, 0],
                  lemonchiffon: [255, 250, 205],
                  lightblue: [173, 216, 230],
                  lightcoral: [240, 128, 128],
                  lightcyan: [224, 255, 255],
                  lightgoldenrodyellow: [250, 250, 210],
                  lightgray: [211, 211, 211],
                  lightgrey: [211, 211, 211],
                  lightgreen: [144, 238, 144],
                  lightpink: [255, 182, 193],
                  lightsalmon: [255, 160, 122],
                  lightseagreen: [32, 178, 170],
                  lightskyblue: [135, 206, 250],
                  lightslategray: [119, 136, 153],
                  lightslategrey: [119, 136, 153],
                  lightsteelblue: [176, 196, 222],
                  lightyellow: [255, 255, 224],
                  lime: [0, 255, 0],
                  limegreen: [50, 205, 50],
                  linen: [250, 240, 230],
                  magenta: [255, 0, 255],
                  maroon: [128, 0, 0],
                  mediumaquamarine: [102, 205, 170],
                  mediumblue: [0, 0, 205],
                  mediumorchid: [186, 85, 211],
                  mediumpurple: [147, 112, 219],
                  mediumseagreen: [60, 179, 113],
                  mediumslateblue: [123, 104, 238],
                  mediumspringgreen: [0, 250, 154],
                  mediumturquoise: [72, 209, 204],
                  mediumvioletred: [199, 21, 133],
                  midnightblue: [25, 25, 112],
                  mintcream: [245, 255, 250],
                  mistyrose: [255, 228, 225],
                  moccasin: [255, 228, 181],
                  navajowhite: [255, 222, 173],
                  navy: [0, 0, 128],
                  oldlace: [253, 245, 230],
                  olive: [128, 128, 0],
                  olivedrab: [107, 142, 35],
                  orange: [255, 165, 0],
                  orangered: [255, 69, 0],
                  orchid: [218, 112, 214],
                  palegoldenrod: [238, 232, 170],
                  palegreen: [152, 251, 152],
                  paleturquoise: [175, 238, 238],
                  palevioletred: [219, 112, 147],
                  papayawhip: [255, 239, 213],
                  peachpuff: [255, 218, 185],
                  peru: [205, 133, 63],
                  pink: [255, 192, 203],
                  plum: [221, 160, 221],
                  powderblue: [176, 224, 230],
                  purple: [128, 0, 128],
                  rebeccapurple: [102, 51, 153],
                  red: [255, 0, 0],
                  rosybrown: [188, 143, 143],
                  royalblue: [65, 105, 225],
                  saddlebrown: [139, 69, 19],
                  salmon: [250, 128, 114],
                  sandybrown: [244, 164, 96],
                  seagreen: [46, 139, 87],
                  seashell: [255, 245, 238],
                  sienna: [160, 82, 45],
                  silver: [192, 192, 192],
                  skyblue: [135, 206, 235],
                  slateblue: [106, 90, 205],
                  slategray: [112, 128, 144],
                  slategrey: [112, 128, 144],
                  snow: [255, 250, 250],
                  springgreen: [0, 255, 127],
                  steelblue: [70, 130, 180],
                  tan: [210, 180, 140],
                  teal: [0, 128, 128],
                  thistle: [216, 191, 216],
                  tomato: [255, 99, 71],
                  turquoise: [64, 224, 208],
                  violet: [238, 130, 238],
                  wheat: [245, 222, 179],
                  white: [255, 255, 255],
                  whitesmoke: [245, 245, 245],
                  yellow: [255, 255, 0]
                };
                const DefaultColors = {
                  black: [NamedColors.black, 1],
                  white: [NamedColors.white, 1],
                  transparent: [NamedColors.black, 0]
                };
                const Entities = {
                  quot: 34,
                  amp: 38,
                  lt: 60,
                  gt: 62,
                  apos: 39,
                  OElig: 338,
                  oelig: 339,
                  Scaron: 352,
                  scaron: 353,
                  Yuml: 376,
                  circ: 710,
                  tilde: 732,
                  ensp: 8194,
                  emsp: 8195,
                  thinsp: 8201,
                  zwnj: 8204,
                  zwj: 8205,
                  lrm: 8206,
                  rlm: 8207,
                  ndash: 8211,
                  mdash: 8212,
                  lsquo: 8216,
                  rsquo: 8217,
                  sbquo: 8218,
                  ldquo: 8220,
                  rdquo: 8221,
                  bdquo: 8222,
                  dagger: 8224,
                  Dagger: 8225,
                  permil: 8240,
                  lsaquo: 8249,
                  rsaquo: 8250,
                  euro: 8364,
                  nbsp: 160,
                  iexcl: 161,
                  cent: 162,
                  pound: 163,
                  curren: 164,
                  yen: 165,
                  brvbar: 166,
                  sect: 167,
                  uml: 168,
                  copy: 169,
                  ordf: 170,
                  laquo: 171,
                  not: 172,
                  shy: 173,
                  reg: 174,
                  macr: 175,
                  deg: 176,
                  plusmn: 177,
                  sup2: 178,
                  sup3: 179,
                  acute: 180,
                  micro: 181,
                  para: 182,
                  middot: 183,
                  cedil: 184,
                  sup1: 185,
                  ordm: 186,
                  raquo: 187,
                  frac14: 188,
                  frac12: 189,
                  frac34: 190,
                  iquest: 191,
                  Agrave: 192,
                  Aacute: 193,
                  Acirc: 194,
                  Atilde: 195,
                  Auml: 196,
                  Aring: 197,
                  AElig: 198,
                  Ccedil: 199,
                  Egrave: 200,
                  Eacute: 201,
                  Ecirc: 202,
                  Euml: 203,
                  Igrave: 204,
                  Iacute: 205,
                  Icirc: 206,
                  Iuml: 207,
                  ETH: 208,
                  Ntilde: 209,
                  Ograve: 210,
                  Oacute: 211,
                  Ocirc: 212,
                  Otilde: 213,
                  Ouml: 214,
                  times: 215,
                  Oslash: 216,
                  Ugrave: 217,
                  Uacute: 218,
                  Ucirc: 219,
                  Uuml: 220,
                  Yacute: 221,
                  THORN: 222,
                  szlig: 223,
                  agrave: 224,
                  aacute: 225,
                  acirc: 226,
                  atilde: 227,
                  auml: 228,
                  aring: 229,
                  aelig: 230,
                  ccedil: 231,
                  egrave: 232,
                  eacute: 233,
                  ecirc: 234,
                  euml: 235,
                  igrave: 236,
                  iacute: 237,
                  icirc: 238,
                  iuml: 239,
                  eth: 240,
                  ntilde: 241,
                  ograve: 242,
                  oacute: 243,
                  ocirc: 244,
                  otilde: 245,
                  ouml: 246,
                  divide: 247,
                  oslash: 248,
                  ugrave: 249,
                  uacute: 250,
                  ucirc: 251,
                  uuml: 252,
                  yacute: 253,
                  thorn: 254,
                  yuml: 255,
                  fnof: 402,
                  Alpha: 913,
                  Beta: 914,
                  Gamma: 915,
                  Delta: 916,
                  Epsilon: 917,
                  Zeta: 918,
                  Eta: 919,
                  Theta: 920,
                  Iota: 921,
                  Kappa: 922,
                  Lambda: 923,
                  Mu: 924,
                  Nu: 925,
                  Xi: 926,
                  Omicron: 927,
                  Pi: 928,
                  Rho: 929,
                  Sigma: 931,
                  Tau: 932,
                  Upsilon: 933,
                  Phi: 934,
                  Chi: 935,
                  Psi: 936,
                  Omega: 937,
                  alpha: 945,
                  beta: 946,
                  gamma: 947,
                  delta: 948,
                  epsilon: 949,
                  zeta: 950,
                  eta: 951,
                  theta: 952,
                  iota: 953,
                  kappa: 954,
                  lambda: 955,
                  mu: 956,
                  nu: 957,
                  xi: 958,
                  omicron: 959,
                  pi: 960,
                  rho: 961,
                  sigmaf: 962,
                  sigma: 963,
                  tau: 964,
                  upsilon: 965,
                  phi: 966,
                  chi: 967,
                  psi: 968,
                  omega: 969,
                  thetasym: 977,
                  upsih: 978,
                  piv: 982,
                  bull: 8226,
                  hellip: 8230,
                  prime: 8242,
                  Prime: 8243,
                  oline: 8254,
                  frasl: 8260,
                  weierp: 8472,
                  image: 8465,
                  real: 8476,
                  trade: 8482,
                  alefsym: 8501,
                  larr: 8592,
                  uarr: 8593,
                  rarr: 8594,
                  darr: 8595,
                  harr: 8596,
                  crarr: 8629,
                  lArr: 8656,
                  uArr: 8657,
                  rArr: 8658,
                  dArr: 8659,
                  hArr: 8660,
                  forall: 8704,
                  part: 8706,
                  exist: 8707,
                  empty: 8709,
                  nabla: 8711,
                  isin: 8712,
                  notin: 8713,
                  ni: 8715,
                  prod: 8719,
                  sum: 8721,
                  minus: 8722,
                  lowast: 8727,
                  radic: 8730,
                  prop: 8733,
                  infin: 8734,
                  ang: 8736,
                  and: 8743,
                  or: 8744,
                  cap: 8745,
                  cup: 8746,
                  int: 8747,
                  there4: 8756,
                  sim: 8764,
                  cong: 8773,
                  asymp: 8776,
                  ne: 8800,
                  equiv: 8801,
                  le: 8804,
                  ge: 8805,
                  sub: 8834,
                  sup: 8835,
                  nsub: 8836,
                  sube: 8838,
                  supe: 8839,
                  oplus: 8853,
                  otimes: 8855,
                  perp: 8869,
                  sdot: 8901,
                  lceil: 8968,
                  rceil: 8969,
                  lfloor: 8970,
                  rfloor: 8971,
                  lang: 9001,
                  rang: 9002,
                  loz: 9674,
                  spades: 9824,
                  clubs: 9827,
                  hearts: 9829,
                  diams: 9830
                };
                const PathArguments = {
                  A: 7,
                  a: 7,
                  C: 6,
                  c: 6,
                  H: 1,
                  h: 1,
                  L: 2,
                  l: 2,
                  M: 2,
                  m: 2,
                  Q: 4,
                  q: 4,
                  S: 4,
                  s: 4,
                  T: 2,
                  t: 2,
                  V: 1,
                  v: 1,
                  Z: 0,
                  z: 0
                };
                const PathFlags = {
                  A3: true,
                  A4: true,
                  a3: true,
                  a4: true
                };
                const Properties = {
                  "color": {
                    inherit: true,
                    initial: void 0
                  },
                  "visibility": {
                    inherit: true,
                    initial: "visible",
                    values: {
                      "hidden": "hidden",
                      "collapse": "hidden",
                      "visible": "visible"
                    }
                  },
                  "fill": {
                    inherit: true,
                    initial: DefaultColors.black
                  },
                  "stroke": {
                    inherit: true,
                    initial: "none"
                  },
                  "stop-color": {
                    inherit: false,
                    initial: DefaultColors.black
                  },
                  "fill-opacity": {
                    inherit: true,
                    initial: 1
                  },
                  "stroke-opacity": {
                    inherit: true,
                    initial: 1
                  },
                  "stop-opacity": {
                    inherit: false,
                    initial: 1
                  },
                  "fill-rule": {
                    inherit: true,
                    initial: "nonzero",
                    values: {
                      "nonzero": "nonzero",
                      "evenodd": "evenodd"
                    }
                  },
                  "clip-rule": {
                    inherit: true,
                    initial: "nonzero",
                    values: {
                      "nonzero": "nonzero",
                      "evenodd": "evenodd"
                    }
                  },
                  "stroke-width": {
                    inherit: true,
                    initial: 1
                  },
                  "stroke-dasharray": {
                    inherit: true,
                    initial: []
                  },
                  "stroke-dashoffset": {
                    inherit: true,
                    initial: 0
                  },
                  "stroke-miterlimit": {
                    inherit: true,
                    initial: 4
                  },
                  "stroke-linejoin": {
                    inherit: true,
                    initial: "miter",
                    values: {
                      "miter": "miter",
                      "round": "round",
                      "bevel": "bevel"
                    }
                  },
                  "stroke-linecap": {
                    inherit: true,
                    initial: "butt",
                    values: {
                      "butt": "butt",
                      "round": "round",
                      "square": "square"
                    }
                  },
                  "font-size": {
                    inherit: true,
                    initial: 16,
                    values: {
                      "xx-small": 9,
                      "x-small": 10,
                      "small": 13,
                      "medium": 16,
                      "large": 18,
                      "x-large": 24,
                      "xx-large": 32
                    }
                  },
                  "font-family": {
                    inherit: true,
                    initial: "sans-serif"
                  },
                  "font-weight": {
                    inherit: true,
                    initial: "normal",
                    values: {
                      "600": "bold",
                      "700": "bold",
                      "800": "bold",
                      "900": "bold",
                      "bold": "bold",
                      "bolder": "bold",
                      "500": "normal",
                      "400": "normal",
                      "300": "normal",
                      "200": "normal",
                      "100": "normal",
                      "normal": "normal",
                      "lighter": "normal"
                    }
                  },
                  "font-style": {
                    inherit: true,
                    initial: "normal",
                    values: {
                      "italic": "italic",
                      "oblique": "italic",
                      "normal": "normal"
                    }
                  },
                  "text-anchor": {
                    inherit: true,
                    initial: "start",
                    values: {
                      "start": "start",
                      "middle": "middle",
                      "end": "end"
                    }
                  },
                  "direction": {
                    inherit: true,
                    initial: "ltr",
                    values: {
                      "ltr": "ltr",
                      "rtl": "rtl"
                    }
                  },
                  "dominant-baseline": {
                    inherit: true,
                    initial: "baseline",
                    values: {
                      "auto": "baseline",
                      "baseline": "baseline",
                      "before-edge": "before-edge",
                      "text-before-edge": "before-edge",
                      "middle": "middle",
                      "central": "central",
                      "after-edge": "after-edge",
                      "text-after-edge": "after-edge",
                      "ideographic": "ideographic",
                      "alphabetic": "alphabetic",
                      "hanging": "hanging",
                      "mathematical": "mathematical"
                    }
                  },
                  "alignment-baseline": {
                    inherit: false,
                    initial: void 0,
                    values: {
                      "auto": "baseline",
                      "baseline": "baseline",
                      "before-edge": "before-edge",
                      "text-before-edge": "before-edge",
                      "middle": "middle",
                      "central": "central",
                      "after-edge": "after-edge",
                      "text-after-edge": "after-edge",
                      "ideographic": "ideographic",
                      "alphabetic": "alphabetic",
                      "hanging": "hanging",
                      "mathematical": "mathematical"
                    }
                  },
                  "baseline-shift": {
                    inherit: true,
                    initial: "baseline",
                    values: {
                      "baseline": "baseline",
                      "sub": "sub",
                      "super": "super"
                    }
                  },
                  "word-spacing": {
                    inherit: true,
                    initial: 0,
                    values: {
                      normal: 0
                    }
                  },
                  "letter-spacing": {
                    inherit: true,
                    initial: 0,
                    values: {
                      normal: 0
                    }
                  },
                  "text-decoration": {
                    inherit: false,
                    initial: "none",
                    values: {
                      "none": "none",
                      "underline": "underline",
                      "overline": "overline",
                      "line-through": "line-through"
                    }
                  },
                  "xml:space": {
                    inherit: true,
                    initial: "default",
                    css: "white-space",
                    values: {
                      "preserve": "preserve",
                      "default": "default",
                      "pre": "preserve",
                      "pre-line": "preserve",
                      "pre-wrap": "preserve",
                      "nowrap": "default"
                    }
                  },
                  "marker-start": {
                    inherit: true,
                    initial: "none"
                  },
                  "marker-mid": {
                    inherit: true,
                    initial: "none"
                  },
                  "marker-end": {
                    inherit: true,
                    initial: "none"
                  },
                  "opacity": {
                    inherit: false,
                    initial: 1
                  },
                  "transform": {
                    inherit: false,
                    initial: [1, 0, 0, 1, 0, 0]
                  },
                  "display": {
                    inherit: false,
                    initial: "inline",
                    values: {
                      "none": "none",
                      "inline": "inline",
                      "block": "inline"
                    }
                  },
                  "clip-path": {
                    inherit: false,
                    initial: "none"
                  },
                  "mask": {
                    inherit: false,
                    initial: "none"
                  },
                  "overflow": {
                    inherit: false,
                    initial: "hidden",
                    values: {
                      "hidden": "hidden",
                      "scroll": "hidden",
                      "visible": "visible"
                    }
                  },
                  "vector-effect": {
                    inherit: true,
                    initial: "none",
                    values: {
                      "none": "none",
                      "non-scaling-stroke": "non-scaling-stroke"
                    }
                  }
                };
                function docBeginGroup(bbox) {
                  let group = new function PDFGroup() {
                  }();
                  group.name = "G" + (doc._groupCount = (doc._groupCount || 0) + 1);
                  group.resources = doc.ref();
                  group.xobj = doc.ref({
                    Type: "XObject",
                    Subtype: "Form",
                    FormType: 1,
                    BBox: bbox,
                    Group: {
                      S: "Transparency",
                      CS: "DeviceRGB",
                      I: true,
                      K: false
                    },
                    Resources: group.resources
                  });
                  group.xobj.write("");
                  group.savedMatrix = doc._ctm;
                  group.savedPage = doc.page;
                  groupStack.push(group);
                  doc._ctm = [1, 0, 0, 1, 0, 0];
                  doc.page = {
                    width: doc.page.width,
                    height: doc.page.height,
                    write: function(data) {
                      group.xobj.write(data);
                    },
                    fonts: {},
                    xobjects: {},
                    ext_gstates: {},
                    patterns: {}
                  };
                  return group;
                }
                function docEndGroup(group) {
                  if (group !== groupStack.pop()) {
                    throw "Group not matching";
                  }
                  if (Object.keys(doc.page.fonts).length) {
                    group.resources.data.Font = doc.page.fonts;
                  }
                  if (Object.keys(doc.page.xobjects).length) {
                    group.resources.data.XObject = doc.page.xobjects;
                  }
                  if (Object.keys(doc.page.ext_gstates).length) {
                    group.resources.data.ExtGState = doc.page.ext_gstates;
                  }
                  if (Object.keys(doc.page.patterns).length) {
                    group.resources.data.Pattern = doc.page.patterns;
                  }
                  group.resources.end();
                  group.xobj.end();
                  doc._ctm = group.savedMatrix;
                  doc.page = group.savedPage;
                }
                function docInsertGroup(group) {
                  doc.page.xobjects[group.name] = group.xobj;
                  doc.addContent("/" + group.name + " Do");
                }
                function docApplyMask(group, clip) {
                  let name = "M" + (doc._maskCount = (doc._maskCount || 0) + 1);
                  let gstate = doc.ref({
                    Type: "ExtGState",
                    CA: 1,
                    ca: 1,
                    BM: "Normal",
                    SMask: {
                      S: "Luminosity",
                      G: group.xobj,
                      BC: clip ? [0, 0, 0] : [1, 1, 1]
                    }
                  });
                  gstate.end();
                  doc.page.ext_gstates[name] = gstate;
                  doc.addContent("/" + name + " gs");
                }
                function docCreatePattern(group, dx, dy, matrix) {
                  let pattern = {
                    type: "PDFPattern",
                    group,
                    dx,
                    dy,
                    matrix: matrix || [1, 0, 0, 1, 0, 0]
                  };
                  return pattern;
                }
                function docUsePattern(pattern, stroke) {
                  let name = "P" + (doc._patternCount = (doc._patternCount || 0) + 1);
                  let ref = doc.ref({
                    Type: "Pattern",
                    PatternType: 1,
                    PaintType: 1,
                    TilingType: 2,
                    BBox: [0, 0, pattern.dx, pattern.dy],
                    XStep: pattern.dx,
                    YStep: pattern.dy,
                    Matrix: multiplyMatrix(doc._ctm, pattern.matrix),
                    Resources: {
                      ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
                      XObject: function() {
                        let temp = {};
                        temp[pattern.group.name] = pattern.group.xobj;
                        return temp;
                      }()
                    }
                  });
                  ref.write("/" + pattern.group.name + " Do");
                  ref.end();
                  doc.page.patterns[name] = ref;
                  if (stroke) {
                    doc.addContent("/Pattern CS");
                    doc.addContent("/" + name + " SCN");
                  } else {
                    doc.addContent("/Pattern cs");
                    doc.addContent("/" + name + " scn");
                  }
                }
                function docBeginText(font, size) {
                  if (!doc.page.fonts[font.id]) {
                    doc.page.fonts[font.id] = font.ref();
                  }
                  doc.addContent("BT").addContent("/" + font.id + " " + size + " Tf");
                }
                function docSetTextMatrix(a, b, c, d, e, f) {
                  doc.addContent(validateNumber(a) + " " + validateNumber(b) + " " + validateNumber(-c) + " " + validateNumber(-d) + " " + validateNumber(e) + " " + validateNumber(f) + " Tm");
                }
                function docSetTextMode(fill, stroke) {
                  let mode = fill && stroke ? 2 : stroke ? 1 : fill ? 0 : 3;
                  doc.addContent(mode + " Tr");
                }
                function docWriteGlyphs(positions, font) {
                  let commands = [];
                  let commandStr = "";
                  const skew = font.fauxItalic ? -0.25 : 0;
                  function addChar(char) {
                    commandStr += char.glyph;
                    if (char.kern === 0) return;
                    commands.push(`<${commandStr}> ${validateNumber(char.kern)}`);
                    commandStr = "";
                  }
                  ;
                  function flush() {
                    if (commandStr.length) {
                      commands.push(`<${commandStr}> 0`);
                      commandStr = "";
                    }
                    if (commands.length) {
                      doc.addContent(`[${commands.join(" ")}] TJ`);
                      commands = [];
                    }
                  }
                  ;
                  for (let i = 0; i < positions.length; i++) {
                    const pos = positions[i];
                    if (pos.hidden || isEqual(pos.width, 0)) {
                      flush();
                      continue;
                    }
                    if (pos.continuous) {
                      addChar(pos);
                      continue;
                    }
                    flush();
                    const cos = Math.cos(pos.rotate);
                    const sin = Math.sin(pos.rotate);
                    docSetTextMatrix(cos * pos.scale, sin * pos.scale, cos * skew - sin, sin * skew + cos, pos.x, pos.y);
                    addChar(pos);
                  }
                  ;
                  flush();
                }
                function docEndText() {
                  doc.addContent("ET");
                }
                function docFillColor(color) {
                  if (color[0].type === "PDFPattern") {
                    doc.fillOpacity(color[1]);
                    docUsePattern(color[0], false);
                  } else {
                    doc.fillColor(color[0], color[1]);
                  }
                }
                function docStrokeColor(color) {
                  if (color[0].type === "PDFPattern") {
                    doc.strokeOpacity(color[1]);
                    docUsePattern(color[0], true);
                  } else {
                    doc.strokeColor(color[0], color[1]);
                  }
                }
                function docApplyDash(dashArray, dashOffset) {
                  let index;
                  while ((index = dashArray.slice(1, -1).indexOf(0)) !== -1) {
                    let actualIndex = index + 1;
                    let replacementValue = dashArray[actualIndex - 1] + dashArray[actualIndex + 1];
                    dashArray = dashArray.slice(0, actualIndex - 1).concat([replacementValue]).concat(dashArray.slice(actualIndex + 2));
                  }
                  if (dashArray.length === 2) {
                    if (dashArray[0] === 0) {
                      doc.strokeOpacity(0);
                      return;
                    } else if (dashArray[1] === 0) {
                      dashArray = [];
                    }
                  } else {
                    if (dashArray[0] === 0) {
                      dashOffset -= dashArray[1];
                      dashArray[dashArray.length - 1] += dashArray[1];
                      dashArray = dashArray.slice(2);
                    }
                    if (dashArray[dashArray.length - 1] === 0) {
                      dashOffset += dashArray[dashArray.length - 2];
                      dashArray[0] += dashArray[dashArray.length - 2];
                      dashArray = dashArray.slice(0, -2);
                    }
                  }
                  let length = 0;
                  for (let i = 0; i < dashArray.length; i++) {
                    length += dashArray[i];
                  }
                  if (length > 0) {
                    while (dashOffset < 0) {
                      dashOffset += length;
                    }
                  }
                  doc.dash(dashArray, {
                    phase: dashOffset
                  });
                }
                function docInsertLink(x2, y2, w, h, url) {
                  let ref = doc.ref({
                    Type: "Annot",
                    Subtype: "Link",
                    Rect: [x2, y2, w, h],
                    Border: [0, 0, 0],
                    A: {
                      S: "URI",
                      URI: new String(url)
                    }
                  });
                  ref.end();
                  links.push(ref);
                }
                function parseXml(xml) {
                  let SvgNode = function(tag, type, value, error2) {
                    this.error = error2;
                    this.nodeName = tag;
                    this.nodeValue = value;
                    this.nodeType = type;
                    this.attributes = /* @__PURE__ */ Object.create(null);
                    this.childNodes = [];
                    this.parentNode = null;
                    this.id = "";
                    this.textContent = "";
                    this.classList = [];
                  };
                  SvgNode.prototype.getAttribute = function(attr) {
                    return this.attributes[attr] != null ? this.attributes[attr] : null;
                  };
                  SvgNode.prototype.getElementById = function(id) {
                    let result2 = null;
                    (function recursive2(node) {
                      if (result2) {
                        return;
                      }
                      if (node.nodeType === 1) {
                        if (node.id === id) {
                          result2 = node;
                        }
                        for (let i = 0; i < node.childNodes.length; i++) {
                          recursive2(node.childNodes[i]);
                        }
                      }
                    })(this);
                    return result2;
                  };
                  SvgNode.prototype.getElementsByTagName = function(tag) {
                    let result2 = [];
                    (function recursive2(node) {
                      if (node.nodeType === 1) {
                        if (node.nodeName === tag) {
                          result2.push(node);
                        }
                        for (let i = 0; i < node.childNodes.length; i++) {
                          recursive2(node.childNodes[i]);
                        }
                      }
                    })(this);
                    return result2;
                  };
                  let parser = new StringParser(xml.trim()), result, child, error = false;
                  let recursive = function() {
                    let temp, child2;
                    if (temp = parser.match(/^<([\w:.-]+)\s*/, true)) {
                      let node = new SvgNode(temp[1], 1, null, error);
                      while (temp = parser.match(/^([\w:.-]+)(?:\s*=\s*"([^"]*)"|\s*=\s*'([^']*)')?\s*/, true)) {
                        let attr = temp[1], value = decodeEntities(temp[2] || temp[3] || "");
                        if (!node.attributes[attr]) {
                          node.attributes[attr] = value;
                          if (attr === "id") {
                            node.id = value;
                          }
                          if (attr === "class") {
                            node.classList = value.split(" ");
                          }
                        } else {
                          warningCallback('parseXml: duplicate attribute "' + attr + '"');
                          error = true;
                        }
                      }
                      if (parser.match(/^>/)) {
                        while (child2 = recursive()) {
                          node.childNodes.push(child2);
                          child2.parentNode = node;
                          node.textContent += child2.nodeType === 3 || child2.nodeType === 4 ? child2.nodeValue : child2.textContent;
                        }
                        if (temp = parser.match(/^<\/([\w:.-]+)\s*>/, true)) {
                          if (temp[1] === node.nodeName) {
                            return node;
                          } else {
                            warningCallback('parseXml: tag not matching, opening "' + node.nodeName + '" & closing "' + temp[1] + '"');
                            error = true;
                            return node;
                          }
                        } else {
                          warningCallback('parseXml: tag not matching, opening "' + node.nodeName + '" & not closing');
                          error = true;
                          return node;
                        }
                      } else if (parser.match(/^\/>/)) {
                        return node;
                      } else {
                        warningCallback('parseXml: tag could not be parsed "' + node.nodeName + '"');
                        error = true;
                      }
                    } else if (temp = parser.match(/^<!--[\s\S]*?-->/)) {
                      return new SvgNode(null, 8, temp, error);
                    } else if (temp = parser.match(/^<\?[\s\S]*?\?>/)) {
                      return new SvgNode(null, 7, temp, error);
                    } else if (temp = parser.match(/^<!DOCTYPE\s*([\s\S]*?)>/)) {
                      return new SvgNode(null, 10, temp, error);
                    } else if (temp = parser.match(/^<!\[CDATA\[([\s\S]*?)\]\]>/, true)) {
                      return new SvgNode("#cdata-section", 4, temp[1], error);
                    } else if (temp = parser.match(/^([^<]+)/, true)) {
                      return new SvgNode("#text", 3, decodeEntities(temp[1]), error);
                    }
                  };
                  while (child = recursive()) {
                    if (child.nodeType === 1 && !result) {
                      result = child;
                    } else if (child.nodeType === 1 || child.nodeType === 3 && child.nodeValue.trim() !== "") {
                      warningCallback("parseXml: data after document end has been discarded");
                    }
                  }
                  if (parser.matchAll()) {
                    warningCallback("parseXml: parsing error");
                  }
                  return result;
                }
                ;
                function decodeEntities(str) {
                  return str.replace(/&(?:#([0-9]+)|#[xX]([0-9A-Fa-f]+)|([0-9A-Za-z]+));/g, function(mt, m0, m1, m2) {
                    if (m0) {
                      return String.fromCharCode(parseInt(m0, 10));
                    } else if (m1) {
                      return String.fromCharCode(parseInt(m1, 16));
                    } else if (m2 && Entities[m2]) {
                      return String.fromCharCode(Entities[m2]);
                    } else {
                      return mt;
                    }
                  });
                }
                function parseColor(raw) {
                  let temp, result;
                  raw = (raw || "").trim();
                  if (temp = NamedColors[raw]) {
                    result = [temp.slice(), 1];
                  } else if (temp = raw.match(/^cmyk\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9.]+)\s*\)$/i)) {
                    temp[1] = parseInt(temp[1]);
                    temp[2] = parseInt(temp[2]);
                    temp[3] = parseInt(temp[3]);
                    temp[4] = parseFloat(temp[4]);
                    if (temp[1] <= 100 && temp[2] <= 100 && temp[3] <= 100 && temp[4] <= 100) {
                      result = [temp.slice(1, 5), 1];
                    }
                  } else if (temp = raw.match(/^rgba\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9.]+)\s*\)$/i)) {
                    temp[1] = parseInt(temp[1]);
                    temp[2] = parseInt(temp[2]);
                    temp[3] = parseInt(temp[3]);
                    temp[4] = parseFloat(temp[4]);
                    if (temp[1] < 256 && temp[2] < 256 && temp[3] < 256 && temp[4] <= 1) {
                      result = [temp.slice(1, 4), temp[4]];
                    }
                  } else if (temp = raw.match(/^rgb\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)$/i)) {
                    temp[1] = parseInt(temp[1]);
                    temp[2] = parseInt(temp[2]);
                    temp[3] = parseInt(temp[3]);
                    if (temp[1] < 256 && temp[2] < 256 && temp[3] < 256) {
                      result = [temp.slice(1, 4), 1];
                    }
                  } else if (temp = raw.match(/^rgb\(\s*([0-9.]+)%\s*,\s*([0-9.]+)%\s*,\s*([0-9.]+)%\s*\)$/i)) {
                    temp[1] = 2.55 * parseFloat(temp[1]);
                    temp[2] = 2.55 * parseFloat(temp[2]);
                    temp[3] = 2.55 * parseFloat(temp[3]);
                    if (temp[1] < 256 && temp[2] < 256 && temp[3] < 256) {
                      result = [temp.slice(1, 4), 1];
                    }
                  } else if (temp = raw.match(/^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i)) {
                    result = [[parseInt(temp[1], 16), parseInt(temp[2], 16), parseInt(temp[3], 16)], 1];
                  } else if (temp = raw.match(/^#([0-9a-f])([0-9a-f])([0-9a-f])$/i)) {
                    result = [[17 * parseInt(temp[1], 16), 17 * parseInt(temp[2], 16), 17 * parseInt(temp[3], 16)], 1];
                  }
                  return colorCallback ? colorCallback(result, raw) : result;
                }
                function opacityToColor(color, opacity, isMask) {
                  let newColor = color[0].slice(), newOpacity = color[1] * opacity;
                  if (isMask) {
                    for (let i = 0; i < color.length; i++) {
                      newColor[i] *= newOpacity;
                    }
                    return [newColor, 1];
                  } else {
                    return [newColor, newOpacity];
                  }
                }
                function multiplyMatrix() {
                  function multiply(a, b) {
                    return [a[0] * b[0] + a[2] * b[1], a[1] * b[0] + a[3] * b[1], a[0] * b[2] + a[2] * b[3], a[1] * b[2] + a[3] * b[3], a[0] * b[4] + a[2] * b[5] + a[4], a[1] * b[4] + a[3] * b[5] + a[5]];
                  }
                  let result = arguments[0];
                  for (let i = 1; i < arguments.length; i++) {
                    result = multiply(result, arguments[i]);
                  }
                  return result;
                }
                function transformPoint(p, m) {
                  return [m[0] * p[0] + m[2] * p[1] + m[4], m[1] * p[0] + m[3] * p[1] + m[5]];
                }
                function getGlobalMatrix() {
                  let ctm = doc._ctm;
                  for (let i = groupStack.length - 1; i >= 0; i--) {
                    ctm = multiplyMatrix(groupStack[i].savedMatrix, ctm);
                  }
                  return ctm;
                }
                function getPageBBox() {
                  return new SvgShape().M(0, 0).L(doc.page.width, 0).L(doc.page.width, doc.page.height).L(0, doc.page.height).transform(inverseMatrix(getGlobalMatrix())).getBoundingBox();
                }
                function getPageScale() {
                  const bbox = getPageBBox();
                  const width = doc.page.width;
                  return width / bbox[2];
                }
                function inverseMatrix(m) {
                  let dt = m[0] * m[3] - m[1] * m[2];
                  return [m[3] / dt, -m[1] / dt, -m[2] / dt, m[0] / dt, (m[2] * m[5] - m[3] * m[4]) / dt, (m[1] * m[4] - m[0] * m[5]) / dt];
                }
                function validateMatrix(m) {
                  let m0 = validateNumber(m[0]), m1 = validateNumber(m[1]), m2 = validateNumber(m[2]), m3 = validateNumber(m[3]), m4 = validateNumber(m[4]), m5 = validateNumber(m[5]);
                  if (isNotEqual(m0 * m3 - m1 * m2, 0)) {
                    return [m0, m1, m2, m3, m4, m5];
                  }
                }
                function solveEquation(curve) {
                  let a = curve[2] || 0, b = curve[1] || 0, c = curve[0] || 0;
                  if (isEqual(a, 0) && isEqual(b, 0)) {
                    return [];
                  } else if (isEqual(a, 0)) {
                    return [-c / b];
                  } else {
                    let d = b * b - 4 * a * c;
                    if (isNotEqual(d, 0) && d > 0) {
                      return [(-b + Math.sqrt(d)) / (2 * a), (-b - Math.sqrt(d)) / (2 * a)];
                    } else if (isEqual(d, 0)) {
                      return [-b / (2 * a)];
                    } else {
                      return [];
                    }
                  }
                }
                function getCurveValue(t, curve) {
                  return (curve[0] || 0) + (curve[1] || 0) * t + (curve[2] || 0) * t * t + (curve[3] || 0) * t * t * t;
                }
                function isEqual(number, ref) {
                  return Math.abs(number - ref) < 1e-10;
                }
                function isNotEqual(number, ref) {
                  return Math.abs(number - ref) >= 1e-10;
                }
                function validateNumber(n) {
                  return n > -1e21 && n < 1e21 ? Math.round(n * 1e6) / 1e6 : 0;
                }
                function isArrayLike(v) {
                  return typeof v === "object" && v !== null && typeof v.length === "number";
                }
                function parseTranform(v) {
                  let parser = new StringParser((v || "").trim()), result = [1, 0, 0, 1, 0, 0], temp;
                  while (temp = parser.match(/^([A-Za-z]+)\s*[(]([^(]+)[)]/, true)) {
                    let func = temp[1], nums = [], parser2 = new StringParser(temp[2].trim()), temp2;
                    while (temp2 = parser2.matchNumber()) {
                      nums.push(Number(temp2));
                      parser2.matchSeparator();
                    }
                    if (func === "matrix" && nums.length === 6) {
                      result = multiplyMatrix(result, [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]]);
                    } else if (func === "translate" && nums.length === 2) {
                      result = multiplyMatrix(result, [1, 0, 0, 1, nums[0], nums[1]]);
                    } else if (func === "translate" && nums.length === 1) {
                      result = multiplyMatrix(result, [1, 0, 0, 1, nums[0], 0]);
                    } else if (func === "scale" && nums.length === 2) {
                      result = multiplyMatrix(result, [nums[0], 0, 0, nums[1], 0, 0]);
                    } else if (func === "scale" && nums.length === 1) {
                      result = multiplyMatrix(result, [nums[0], 0, 0, nums[0], 0, 0]);
                    } else if (func === "rotate" && nums.length === 3) {
                      let a = nums[0] * Math.PI / 180;
                      result = multiplyMatrix(result, [1, 0, 0, 1, nums[1], nums[2]], [Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0], [1, 0, 0, 1, -nums[1], -nums[2]]);
                    } else if (func === "rotate" && nums.length === 1) {
                      let a = nums[0] * Math.PI / 180;
                      result = multiplyMatrix(result, [Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
                    } else if (func === "skewX" && nums.length === 1) {
                      let a = nums[0] * Math.PI / 180;
                      result = multiplyMatrix(result, [1, 0, Math.tan(a), 1, 0, 0]);
                    } else if (func === "skewY" && nums.length === 1) {
                      let a = nums[0] * Math.PI / 180;
                      result = multiplyMatrix(result, [1, Math.tan(a), 0, 1, 0, 0]);
                    } else {
                      return;
                    }
                    parser.matchSeparator();
                  }
                  if (parser.matchAll()) {
                    return;
                  }
                  return result;
                }
                function parseAspectRatio(aspectRatio, availWidth, availHeight, elemWidth, elemHeight, initAlign) {
                  let temp = (aspectRatio || "").trim().match(/^(none)$|^x(Min|Mid|Max)Y(Min|Mid|Max)(?:\s+(meet|slice))?$/) || [], ratioType = temp[1] || temp[4] || "meet", xAlign = temp[2] || "Mid", yAlign = temp[3] || "Mid", scaleX = availWidth / elemWidth, scaleY = availHeight / elemHeight, dx = {
                    "Min": 0,
                    "Mid": 0.5,
                    "Max": 1
                  }[xAlign] - (initAlign || 0), dy = {
                    "Min": 0,
                    "Mid": 0.5,
                    "Max": 1
                  }[yAlign] - (initAlign || 0);
                  if (ratioType === "slice") {
                    scaleY = scaleX = Math.max(scaleX, scaleY);
                  } else if (ratioType === "meet") {
                    scaleY = scaleX = Math.min(scaleX, scaleY);
                  }
                  return [scaleX, 0, 0, scaleY, dx * (availWidth - elemWidth * scaleX), dy * (availHeight - elemHeight * scaleY)];
                }
                function parseStyleAttr(v) {
                  let result = /* @__PURE__ */ Object.create(null);
                  v = (v || "").trim().split(/;/);
                  for (let i = 0; i < v.length; i++) {
                    let key = (v[i].split(":")[0] || "").trim(), value = (v[i].split(":")[1] || "").trim();
                    if (key) {
                      result[key] = value;
                    }
                  }
                  if (result["marker"]) {
                    if (!result["marker-start"]) {
                      result["marker-start"] = result["marker"];
                    }
                    if (!result["marker-mid"]) {
                      result["marker-mid"] = result["marker"];
                    }
                    if (!result["marker-end"]) {
                      result["marker-end"] = result["marker"];
                    }
                  }
                  if (result["font"]) {
                    let fontFamily = null, fontSize = null, fontStyle = "normal", fontWeight = "normal", fontVariant = "normal";
                    let parts = result["font"].split(/\s+/);
                    for (let i = 0; i < parts.length; i++) {
                      switch (parts[i]) {
                        case "normal":
                          break;
                        case "italic":
                        case "oblique":
                          fontStyle = parts[i];
                          break;
                        case "small-caps":
                          fontVariant = parts[i];
                          break;
                        case "bold":
                        case "bolder":
                        case "lighter":
                        case "100":
                        case "200":
                        case "300":
                        case "400":
                        case "500":
                        case "600":
                        case "700":
                        case "800":
                        case "900":
                          fontWeight = parts[i];
                          break;
                        default:
                          if (!fontSize) {
                            fontSize = parts[i].split("/")[0];
                          } else {
                            if (!fontFamily) {
                              fontFamily = parts[i];
                            } else {
                              fontFamily += " " + parts[i];
                            }
                          }
                          break;
                      }
                    }
                    if (!result["font-style"]) {
                      result["font-style"] = fontStyle;
                    }
                    if (!result["font-variant"]) {
                      result["font-variant"] = fontVariant;
                    }
                    if (!result["font-weight"]) {
                      result["font-weight"] = fontWeight;
                    }
                    if (!result["font-size"]) {
                      result["font-size"] = fontSize;
                    }
                    if (!result["font-family"]) {
                      result["font-family"] = fontFamily;
                    }
                  }
                  return result;
                }
                function parseSelector(v) {
                  let parts = v.split(/(?=[.#])/g), ids = [], classes = [], tags = [], temp;
                  for (let i = 0; i < parts.length; i++) {
                    if (temp = parts[i].match(/^[#]([_A-Za-z0-9-]+)$/)) {
                      ids.push(temp[1]);
                    } else if (temp = parts[i].match(/^[.]([_A-Za-z0-9-]+)$/)) {
                      classes.push(temp[1]);
                    } else if (temp = parts[i].match(/^([_A-Za-z0-9-]+)$/)) {
                      tags.push(temp[1]);
                    } else if (parts[i] !== "*") {
                      return;
                    }
                  }
                  return {
                    tags,
                    ids,
                    classes,
                    specificity: ids.length * 1e4 + classes.length * 100 + tags.length
                  };
                }
                function parseStyleSheet(v) {
                  let parser = new StringParser(v.trim()), rules = [], rule;
                  while (rule = parser.match(/^\s*([^\{\}]*?)\s*\{([^\{\}]*?)\}/, true)) {
                    let selectors = rule[1].split(/\s*,\s*/g), css = parseStyleAttr(rule[2]);
                    for (let i = 0; i < selectors.length; i++) {
                      let selector = parseSelector(selectors[i]);
                      if (selector) {
                        rules.push({
                          selector,
                          css
                        });
                      }
                    }
                  }
                  return rules;
                }
                function matchesSelector(elem, selector) {
                  if (elem.nodeType !== 1) {
                    return false;
                  }
                  for (let i = 0; i < selector.tags.length; i++) {
                    if (selector.tags[i] !== elem.nodeName) {
                      return false;
                    }
                  }
                  for (let i = 0; i < selector.ids.length; i++) {
                    if (selector.ids[i] !== elem.id) {
                      return false;
                    }
                  }
                  for (let i = 0; i < selector.classes.length; i++) {
                    if (elem.classList.indexOf(selector.classes[i]) === -1) {
                      return false;
                    }
                  }
                  return true;
                }
                function getStyle(elem) {
                  let result = /* @__PURE__ */ Object.create(null);
                  let specificities = /* @__PURE__ */ Object.create(null);
                  for (let i = 0; i < styleRules.length; i++) {
                    let rule = styleRules[i];
                    if (matchesSelector(elem, rule.selector)) {
                      for (let key in rule.css) {
                        if (!(specificities[key] > rule.selector.specificity)) {
                          result[key] = rule.css[key];
                          specificities[key] = rule.selector.specificity;
                        }
                      }
                    }
                  }
                  return result;
                }
                function combineArrays(array1, array2) {
                  return array1.concat(array2.slice(array1.length));
                }
                function getAscent(font, size) {
                  return Math.max(font.ascender, (font.bbox[3] || font.bbox.maxY) * (font.scale || 1)) * size / 1e3;
                }
                function getDescent(font, size) {
                  return Math.min(font.descender, (font.bbox[1] || font.bbox.minY) * (font.scale || 1)) * size / 1e3;
                }
                function getXHeight(font, size) {
                  return (font.xHeight || 0.5 * (font.ascender - font.descender)) * size / 1e3;
                }
                function getBaseline(font, size, baseline, shift) {
                  let dy1, dy2;
                  switch (baseline) {
                    case "middle":
                      dy1 = 0.5 * getXHeight(font, size);
                      break;
                    case "central":
                      dy1 = 0.5 * (getDescent(font, size) + getAscent(font, size));
                      break;
                    case "after-edge":
                    case "text-after-edge":
                      dy1 = getDescent(font, size);
                      break;
                    case "alphabetic":
                    case "auto":
                    case "baseline":
                      dy1 = 0;
                      break;
                    case "mathematical":
                      dy1 = 0.5 * getAscent(font, size);
                      break;
                    case "hanging":
                      dy1 = 0.8 * getAscent(font, size);
                      break;
                    case "before-edge":
                    case "text-before-edge":
                      dy1 = getAscent(font, size);
                      break;
                    default:
                      dy1 = 0;
                      break;
                  }
                  switch (shift) {
                    case "baseline":
                      dy2 = 0;
                      break;
                    case "super":
                      dy2 = 0.6 * size;
                      break;
                    case "sub":
                      dy2 = -0.6 * size;
                      break;
                    default:
                      dy2 = shift;
                      break;
                  }
                  return dy1 - dy2;
                }
                function getTextPos(font, size, text) {
                  let encoded = font.encode("" + text), hex = encoded[0], pos = encoded[1], data = [];
                  for (let i = 0; i < hex.length; i++) {
                    let unicode = font.unicode ? font.unicode[parseInt(hex[i], 16)] : [text.charCodeAt(i)];
                    data.push({
                      glyph: hex[i],
                      unicode,
                      kern: pos[i].advanceWidth - pos[i].xAdvance,
                      width: pos[i].advanceWidth * size / 1e3,
                      xOffset: pos[i].xOffset * size / 1e3,
                      yOffset: pos[i].yOffset * size / 1e3,
                      xAdvance: pos[i].xAdvance * size / 1e3,
                      yAdvance: pos[i].yAdvance * size / 1e3
                    });
                  }
                  return data;
                }
                function createSVGElement(obj, inherits) {
                  switch (obj.nodeName) {
                    case "use":
                      return new SvgElemUse(obj, inherits);
                    case "symbol":
                      return new SvgElemSymbol(obj, inherits);
                    case "g":
                      return new SvgElemGroup(obj, inherits);
                    case "a":
                      return new SvgElemLink(obj, inherits);
                    case "svg":
                      return new SvgElemSvg(obj, inherits);
                    case "image":
                      return new SVGElemImage(obj, inherits);
                    case "rect":
                      return new SvgElemRect(obj, inherits);
                    case "circle":
                      return new SvgElemCircle(obj, inherits);
                    case "ellipse":
                      return new SvgElemEllipse(obj, inherits);
                    case "line":
                      return new SvgElemLine(obj, inherits);
                    case "polyline":
                      return new SvgElemPolyline(obj, inherits);
                    case "polygon":
                      return new SvgElemPolygon(obj, inherits);
                    case "path":
                      return new SvgElemPath(obj, inherits);
                    case "text":
                      return new SvgElemText(obj, inherits);
                    case "tspan":
                      return new SvgElemTspan(obj, inherits);
                    case "textPath":
                      return new SvgElemTextPath(obj, inherits);
                    case "#text":
                    case "#cdata-section":
                      return new SvgElemTextNode(obj, inherits);
                    default:
                      return new SvgElem(obj, inherits);
                  }
                }
                var StringParser = function(str) {
                  this.match = function(exp, all) {
                    let temp = str.match(exp);
                    if (!temp || temp.index !== 0) {
                      return;
                    }
                    str = str.substring(temp[0].length);
                    return all ? temp : temp[0];
                  };
                  this.matchSeparator = function() {
                    return this.match(/^(?:\s*,\s*|\s*|)/);
                  };
                  this.matchSpace = function() {
                    return this.match(/^(?:\s*)/);
                  };
                  this.matchLengthUnit = function() {
                    return this.match(/^(?:px|pt|cm|mm|in|pc|em|ex|%|)/);
                  };
                  this.matchNumber = function() {
                    return this.match(/^(?:[-+]?(?:[0-9]+[.][0-9]+|[0-9]+[.]|[.][0-9]+|[0-9]+)(?:[eE][-+]?[0-9]+)?)/);
                  };
                  this.matchAll = function() {
                    return this.match(/^[\s\S]+/);
                  };
                };
                var BezierSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
                  let divisions = 6 * precision;
                  let equationX = [p1x, -3 * p1x + 3 * c1x, 3 * p1x - 6 * c1x + 3 * c2x, -p1x + 3 * c1x - 3 * c2x + p2x];
                  let equationY = [p1y, -3 * p1y + 3 * c1y, 3 * p1y - 6 * c1y + 3 * c2y, -p1y + 3 * c1y - 3 * c2y + p2y];
                  let derivativeX = [-3 * p1x + 3 * c1x, 6 * p1x - 12 * c1x + 6 * c2x, -3 * p1x + 9 * c1x - 9 * c2x + 3 * p2x];
                  let derivativeY = [-3 * p1y + 3 * c1y, 6 * p1y - 12 * c1y + 6 * c2y, -3 * p1y + 9 * c1y - 9 * c2y + 3 * p2y];
                  let lengthMap = [0];
                  for (let i = 1; i <= divisions; i++) {
                    let t = (i - 0.5) / divisions;
                    let dx = getCurveValue(t, derivativeX) / divisions, dy = getCurveValue(t, derivativeY) / divisions, l = Math.sqrt(dx * dx + dy * dy);
                    lengthMap[i] = lengthMap[i - 1] + l;
                  }
                  this.totalLength = lengthMap[divisions];
                  this.startPoint = [p1x, p1y, isEqual(p1x, c1x) && isEqual(p1y, c1y) ? Math.atan2(c2y - c1y, c2x - c1x) : Math.atan2(c1y - p1y, c1x - p1x)];
                  this.endPoint = [p2x, p2y, isEqual(c2x, p2x) && isEqual(c2y, p2y) ? Math.atan2(c2y - c1y, c2x - c1x) : Math.atan2(p2y - c2y, p2x - c2x)];
                  this.getBoundingBox = function() {
                    let temp;
                    let minX = getCurveValue(0, equationX), minY = getCurveValue(0, equationY), maxX = getCurveValue(1, equationX), maxY = getCurveValue(1, equationY);
                    if (minX > maxX) {
                      temp = maxX;
                      maxX = minX;
                      minX = temp;
                    }
                    if (minY > maxY) {
                      temp = maxY;
                      maxY = minY;
                      minY = temp;
                    }
                    let rootsX = solveEquation(derivativeX);
                    for (let i = 0; i < rootsX.length; i++) {
                      if (rootsX[i] >= 0 && rootsX[i] <= 1) {
                        let x2 = getCurveValue(rootsX[i], equationX);
                        if (x2 < minX) {
                          minX = x2;
                        }
                        if (x2 > maxX) {
                          maxX = x2;
                        }
                      }
                    }
                    let rootsY = solveEquation(derivativeY);
                    for (let i = 0; i < rootsY.length; i++) {
                      if (rootsY[i] >= 0 && rootsY[i] <= 1) {
                        let y2 = getCurveValue(rootsY[i], equationY);
                        if (y2 < minY) {
                          minY = y2;
                        }
                        if (y2 > maxY) {
                          maxY = y2;
                        }
                      }
                    }
                    return [minX, minY, maxX, maxY];
                  };
                  this.getPointAtLength = function(l) {
                    if (isEqual(l, 0)) {
                      return this.startPoint;
                    }
                    if (isEqual(l, this.totalLength)) {
                      return this.endPoint;
                    }
                    if (l < 0 || l > this.totalLength) {
                      return;
                    }
                    for (let i = 1; i <= divisions; i++) {
                      let l1 = lengthMap[i - 1], l2 = lengthMap[i];
                      if (l1 <= l && l <= l2) {
                        let t = (i - (l2 - l) / (l2 - l1)) / divisions, x2 = getCurveValue(t, equationX), y2 = getCurveValue(t, equationY), dx = getCurveValue(t, derivativeX), dy = getCurveValue(t, derivativeY);
                        return [x2, y2, Math.atan2(dy, dx)];
                      }
                    }
                  };
                };
                var LineSegment = function(p1x, p1y, p2x, p2y) {
                  this.totalLength = Math.sqrt((p2x - p1x) * (p2x - p1x) + (p2y - p1y) * (p2y - p1y));
                  this.startPoint = [p1x, p1y, Math.atan2(p2y - p1y, p2x - p1x)];
                  this.endPoint = [p2x, p2y, Math.atan2(p2y - p1y, p2x - p1x)];
                  this.getBoundingBox = function() {
                    return [Math.min(this.startPoint[0], this.endPoint[0]), Math.min(this.startPoint[1], this.endPoint[1]), Math.max(this.startPoint[0], this.endPoint[0]), Math.max(this.startPoint[1], this.endPoint[1])];
                  };
                  this.getPointAtLength = function(l) {
                    if (l >= 0 && l <= this.totalLength) {
                      let r = l / this.totalLength || 0, x2 = this.startPoint[0] + r * (this.endPoint[0] - this.startPoint[0]), y2 = this.startPoint[1] + r * (this.endPoint[1] - this.startPoint[1]);
                      return [x2, y2, this.startPoint[2]];
                    }
                  };
                };
                var SvgShape = function() {
                  this.pathCommands = [];
                  this.pathSegments = [];
                  this.startPoint = null;
                  this.endPoint = null;
                  this.totalLength = 0;
                  let startX = 0, startY = 0, currX = 0, currY = 0, lastCom, lastCtrlX, lastCtrlY;
                  this.move = function(x2, y2) {
                    startX = currX = x2;
                    startY = currY = y2;
                    return null;
                  };
                  this.line = function(x2, y2) {
                    let segment = new LineSegment(currX, currY, x2, y2);
                    currX = x2;
                    currY = y2;
                    return segment;
                  };
                  this.curve = function(c1x, c1y, c2x, c2y, x2, y2) {
                    let segment = new BezierSegment(currX, currY, c1x, c1y, c2x, c2y, x2, y2);
                    currX = x2;
                    currY = y2;
                    return segment;
                  };
                  this.close = function() {
                    let segment = new LineSegment(currX, currY, startX, startY);
                    currX = startX;
                    currY = startY;
                    return segment;
                  };
                  this.addCommand = function(data) {
                    this.pathCommands.push(data);
                    let segment = this[data[0]].apply(this, data.slice(3));
                    if (segment) {
                      segment.hasStart = data[1];
                      segment.hasEnd = data[2];
                      this.startPoint = this.startPoint || segment.startPoint;
                      this.endPoint = segment.endPoint;
                      this.pathSegments.push(segment);
                      this.totalLength += segment.totalLength;
                    }
                  };
                  this.M = function(x2, y2) {
                    this.addCommand(["move", true, true, x2, y2]);
                    lastCom = "M";
                    return this;
                  };
                  this.m = function(x2, y2) {
                    return this.M(currX + x2, currY + y2);
                  };
                  this.Z = this.z = function() {
                    this.addCommand(["close", true, true]);
                    lastCom = "Z";
                    return this;
                  };
                  this.L = function(x2, y2) {
                    this.addCommand(["line", true, true, x2, y2]);
                    lastCom = "L";
                    return this;
                  };
                  this.l = function(x2, y2) {
                    return this.L(currX + x2, currY + y2);
                  };
                  this.H = function(x2) {
                    return this.L(x2, currY);
                  };
                  this.h = function(x2) {
                    return this.L(currX + x2, currY);
                  };
                  this.V = function(y2) {
                    return this.L(currX, y2);
                  };
                  this.v = function(y2) {
                    return this.L(currX, currY + y2);
                  };
                  this.C = function(c1x, c1y, c2x, c2y, x2, y2) {
                    this.addCommand(["curve", true, true, c1x, c1y, c2x, c2y, x2, y2]);
                    lastCom = "C";
                    lastCtrlX = c2x;
                    lastCtrlY = c2y;
                    return this;
                  };
                  this.c = function(c1x, c1y, c2x, c2y, x2, y2) {
                    return this.C(currX + c1x, currY + c1y, currX + c2x, currY + c2y, currX + x2, currY + y2);
                  };
                  this.S = function(c1x, c1y, x2, y2) {
                    return this.C(currX + (lastCom === "C" ? currX - lastCtrlX : 0), currY + (lastCom === "C" ? currY - lastCtrlY : 0), c1x, c1y, x2, y2);
                  };
                  this.s = function(c1x, c1y, x2, y2) {
                    return this.C(currX + (lastCom === "C" ? currX - lastCtrlX : 0), currY + (lastCom === "C" ? currY - lastCtrlY : 0), currX + c1x, currY + c1y, currX + x2, currY + y2);
                  };
                  this.Q = function(cx, cy, x2, y2) {
                    let c1x = currX + 2 / 3 * (cx - currX), c1y = currY + 2 / 3 * (cy - currY), c2x = x2 + 2 / 3 * (cx - x2), c2y = y2 + 2 / 3 * (cy - y2);
                    this.addCommand(["curve", true, true, c1x, c1y, c2x, c2y, x2, y2]);
                    lastCom = "Q";
                    lastCtrlX = cx;
                    lastCtrlY = cy;
                    return this;
                  };
                  this.q = function(c1x, c1y, x2, y2) {
                    return this.Q(currX + c1x, currY + c1y, currX + x2, currY + y2);
                  };
                  this.T = function(x2, y2) {
                    return this.Q(currX + (lastCom === "Q" ? currX - lastCtrlX : 0), currY + (lastCom === "Q" ? currY - lastCtrlY : 0), x2, y2);
                  };
                  this.t = function(x2, y2) {
                    return this.Q(currX + (lastCom === "Q" ? currX - lastCtrlX : 0), currY + (lastCom === "Q" ? currY - lastCtrlY : 0), currX + x2, currY + y2);
                  };
                  this.A = function(rx, ry, fi, fa, fs, x2, y2) {
                    if (isEqual(rx, 0) || isEqual(ry, 0)) {
                      this.addCommand(["line", true, true, x2, y2]);
                    } else {
                      fi = fi * (Math.PI / 180);
                      rx = Math.abs(rx);
                      ry = Math.abs(ry);
                      fa = 1 * !!fa;
                      fs = 1 * !!fs;
                      let x1 = Math.cos(fi) * (currX - x2) / 2 + Math.sin(fi) * (currY - y2) / 2, y1 = Math.cos(fi) * (currY - y2) / 2 - Math.sin(fi) * (currX - x2) / 2, lambda = x1 * x1 / (rx * rx) + y1 * y1 / (ry * ry);
                      if (lambda > 1) {
                        rx *= Math.sqrt(lambda);
                        ry *= Math.sqrt(lambda);
                      }
                      let r = Math.sqrt(Math.max(0, rx * rx * ry * ry - rx * rx * y1 * y1 - ry * ry * x1 * x1) / (rx * rx * y1 * y1 + ry * ry * x1 * x1)), x22 = (fa === fs ? -1 : 1) * r * rx * y1 / ry, y22 = (fa === fs ? 1 : -1) * r * ry * x1 / rx;
                      let cx = Math.cos(fi) * x22 - Math.sin(fi) * y22 + (currX + x2) / 2, cy = Math.sin(fi) * x22 + Math.cos(fi) * y22 + (currY + y2) / 2, th1 = Math.atan2((y1 - y22) / ry, (x1 - x22) / rx), th2 = Math.atan2((-y1 - y22) / ry, (-x1 - x22) / rx);
                      if (fs === 0 && th2 - th1 > 0) {
                        th2 -= 2 * Math.PI;
                      } else if (fs === 1 && th2 - th1 < 0) {
                        th2 += 2 * Math.PI;
                      }
                      let segms = Math.ceil(Math.abs(th2 - th1) / (Math.PI / precision));
                      for (let i = 0; i < segms; i++) {
                        let th3 = th1 + i * (th2 - th1) / segms, th4 = th1 + (i + 1) * (th2 - th1) / segms, t = 4 / 3 * Math.tan((th4 - th3) / 4);
                        let c1x = cx + Math.cos(fi) * rx * (Math.cos(th3) - t * Math.sin(th3)) - Math.sin(fi) * ry * (Math.sin(th3) + t * Math.cos(th3)), c1y = cy + Math.sin(fi) * rx * (Math.cos(th3) - t * Math.sin(th3)) + Math.cos(fi) * ry * (Math.sin(th3) + t * Math.cos(th3)), c2x = cx + Math.cos(fi) * rx * (Math.cos(th4) + t * Math.sin(th4)) - Math.sin(fi) * ry * (Math.sin(th4) - t * Math.cos(th4)), c2y = cy + Math.sin(fi) * rx * (Math.cos(th4) + t * Math.sin(th4)) + Math.cos(fi) * ry * (Math.sin(th4) - t * Math.cos(th4)), endX = cx + Math.cos(fi) * rx * Math.cos(th4) - Math.sin(fi) * ry * Math.sin(th4), endY = cy + Math.sin(fi) * rx * Math.cos(th4) + Math.cos(fi) * ry * Math.sin(th4);
                        this.addCommand(["curve", i === 0, i === segms - 1, c1x, c1y, c2x, c2y, endX, endY]);
                      }
                    }
                    lastCom = "A";
                    return this;
                  };
                  this.a = function(rx, ry, fi, fa, fs, x2, y2) {
                    return this.A(rx, ry, fi, fa, fs, currX + x2, currY + y2);
                  };
                  this.path = function(d) {
                    let command, value, temp, parser = new StringParser((d || "").trim());
                    while (command = parser.match(/^[astvzqmhlcASTVZQMHLC]/)) {
                      parser.matchSeparator();
                      let values = [];
                      while (value = PathFlags[command + values.length] ? parser.match(/^[01]/) : parser.matchNumber()) {
                        parser.matchSeparator();
                        if (values.length === PathArguments[command]) {
                          this[command].apply(this, values);
                          values = [];
                          if (command === "M") {
                            command = "L";
                          } else if (command === "m") {
                            command = "l";
                          }
                        }
                        values.push(Number(value));
                      }
                      if (values.length === PathArguments[command]) {
                        this[command].apply(this, values);
                      } else {
                        warningCallback("SvgPath: command " + command + " with " + values.length + " numbers");
                        return;
                      }
                    }
                    if (temp = parser.matchAll()) {
                      warningCallback("SvgPath: unexpected string " + temp);
                    }
                    return this;
                  };
                  this.getBoundingBox = function() {
                    let bbox = [Infinity, Infinity, -Infinity, -Infinity];
                    function addBounds(bbox1) {
                      if (bbox1[0] < bbox[0]) {
                        bbox[0] = bbox1[0];
                      }
                      if (bbox1[2] > bbox[2]) {
                        bbox[2] = bbox1[2];
                      }
                      if (bbox1[1] < bbox[1]) {
                        bbox[1] = bbox1[1];
                      }
                      if (bbox1[3] > bbox[3]) {
                        bbox[3] = bbox1[3];
                      }
                    }
                    for (let i = 0; i < this.pathSegments.length; i++) {
                      addBounds(this.pathSegments[i].getBoundingBox());
                    }
                    if (bbox[0] === Infinity) {
                      bbox[0] = 0;
                    }
                    if (bbox[1] === Infinity) {
                      bbox[1] = 0;
                    }
                    if (bbox[2] === -Infinity) {
                      bbox[2] = 0;
                    }
                    if (bbox[3] === -Infinity) {
                      bbox[3] = 0;
                    }
                    return bbox;
                  };
                  this.getPointAtLength = function(l) {
                    if (l >= 0 && l <= this.totalLength) {
                      let temp;
                      for (let i = 0; i < this.pathSegments.length; i++) {
                        if (temp = this.pathSegments[i].getPointAtLength(l)) {
                          return temp;
                        }
                        l -= this.pathSegments[i].totalLength;
                      }
                      return this.endPoint;
                    }
                  };
                  this.transform = function(m) {
                    this.pathSegments = [];
                    this.startPoint = null;
                    this.endPoint = null;
                    this.totalLength = 0;
                    for (let i = 0; i < this.pathCommands.length; i++) {
                      let data = this.pathCommands.shift();
                      for (let j = 3; j < data.length; j += 2) {
                        let p = transformPoint([data[j], data[j + 1]], m);
                        data[j] = p[0];
                        data[j + 1] = p[1];
                      }
                      this.addCommand(data);
                    }
                    return this;
                  };
                  this.mergeShape = function(shape) {
                    for (let i = 0; i < shape.pathCommands.length; i++) {
                      this.addCommand(shape.pathCommands[i].slice());
                    }
                    return this;
                  };
                  this.clone = function() {
                    return new SvgShape().mergeShape(this);
                  };
                  this.insertInDocument = function() {
                    for (let i = 0; i < this.pathCommands.length; i++) {
                      let command = this.pathCommands[i][0], values = this.pathCommands[i].slice(3);
                      switch (command) {
                        case "move":
                          doc.moveTo(values[0], values[1]);
                          break;
                        case "line":
                          doc.lineTo(values[0], values[1]);
                          break;
                        case "curve":
                          doc.bezierCurveTo(values[0], values[1], values[2], values[3], values[4], values[5]);
                          break;
                        case "close":
                          doc.closePath();
                          break;
                      }
                    }
                  };
                  this.getSubPaths = function() {
                    let subPaths = [], shape = new SvgShape();
                    for (let i = 0; i < this.pathCommands.length; i++) {
                      let data = this.pathCommands[i], command = this.pathCommands[i][0];
                      if (command === "move" && i !== 0) {
                        subPaths.push(shape);
                        shape = new SvgShape();
                      }
                      shape.addCommand(data);
                    }
                    subPaths.push(shape);
                    return subPaths;
                  };
                  this.getMarkers = function() {
                    let markers = [], subPaths = this.getSubPaths();
                    for (let i = 0; i < subPaths.length; i++) {
                      let subPath = subPaths[i], subPathMarkers = [];
                      for (let j = 0; j < subPath.pathSegments.length; j++) {
                        let segment = subPath.pathSegments[j];
                        if (isNotEqual(segment.totalLength, 0) || j === 0 || j === subPath.pathSegments.length - 1) {
                          if (segment.hasStart) {
                            let startMarker = segment.getPointAtLength(0), prevEndMarker = subPathMarkers.pop();
                            if (prevEndMarker) {
                              startMarker[2] = 0.5 * (prevEndMarker[2] + startMarker[2]);
                            }
                            subPathMarkers.push(startMarker);
                          }
                          if (segment.hasEnd) {
                            let endMarker = segment.getPointAtLength(segment.totalLength);
                            subPathMarkers.push(endMarker);
                          }
                        }
                      }
                      markers = markers.concat(subPathMarkers);
                    }
                    return markers;
                  };
                };
                var SvgElem = function(obj, inherits) {
                  let styleCache = /* @__PURE__ */ Object.create(null);
                  let childrenCache = null;
                  this.name = obj.nodeName;
                  this.isOuterElement = obj === svg || !obj.parentNode;
                  this.inherits = inherits || (!this.isOuterElement ? createSVGElement(obj.parentNode, null) : null);
                  this.stack = this.inherits ? this.inherits.stack.concat(obj) : [obj];
                  this.style = parseStyleAttr(typeof obj.getAttribute === "function" && obj.getAttribute("style"));
                  this.css = useCSS ? getComputedStyle(obj) : getStyle(obj);
                  this.allowedChildren = [];
                  this.attr = function(key) {
                    if (typeof obj.getAttribute === "function") {
                      return obj.getAttribute(key);
                    }
                  };
                  this.resolveUrl = function(value) {
                    let temp = (value || "").match(/^\s*(?:url\("(.*)#(.*)"\)|url\('(.*)#(.*)'\)|url\((.*)#(.*)\)|(.*)#(.*))\s*$/) || [];
                    let file = temp[1] || temp[3] || temp[5] || temp[7], id = temp[2] || temp[4] || temp[6] || temp[8];
                    if (id) {
                      if (!file) {
                        let svgObj = svg.getElementById(id);
                        if (svgObj) {
                          if (this.stack.indexOf(svgObj) === -1) {
                            return svgObj;
                          } else {
                            warningCallback('SVGtoPDF: loop of circular references for id "' + id + '"');
                            return;
                          }
                        }
                      }
                      if (documentCallback) {
                        let svgs = documentCache[file];
                        if (!svgs) {
                          svgs = documentCallback(file);
                          if (!isArrayLike(svgs)) {
                            svgs = [svgs];
                          }
                          for (let i = 0; i < svgs.length; i++) {
                            if (typeof svgs[i] === "string") {
                              svgs[i] = parseXml(svgs[i]);
                            }
                          }
                          documentCache[file] = svgs;
                        }
                        for (let i = 0; i < svgs.length; i++) {
                          let svgObj = svgs[i].getElementById(id);
                          if (svgObj) {
                            if (this.stack.indexOf(svgObj) === -1) {
                              return svgObj;
                            } else {
                              warningCallback('SVGtoPDF: loop of circular references for id "' + file + "#" + id + '"');
                              return;
                            }
                          }
                        }
                      }
                    }
                  };
                  this.computeUnits = function(value, unit, percent, isFontSize) {
                    if (unit === "%") {
                      return parseFloat(value) / 100 * (isFontSize || percent != null ? percent : this.getViewport());
                    } else if (unit === "ex" || unit === "em") {
                      return value * {
                        "em": 1,
                        "ex": 0.5
                      }[unit] * (isFontSize ? percent : this.get("font-size"));
                    } else {
                      return value * {
                        "": 1,
                        "px": 1,
                        "pt": 96 / 72,
                        "cm": 96 / 2.54,
                        "mm": 96 / 25.4,
                        "in": 96,
                        "pc": 96 / 6
                      }[unit];
                    }
                  };
                  this.computeLength = function(value, percent, initial, isFontSize) {
                    let parser = new StringParser((value || "").trim()), temp1, temp2;
                    if (typeof (temp1 = parser.matchNumber()) === "string" && typeof (temp2 = parser.matchLengthUnit()) === "string" && !parser.matchAll()) {
                      return this.computeUnits(temp1, temp2, percent, isFontSize);
                    }
                    return initial;
                  };
                  this.computeLengthList = function(value, percent, strict) {
                    let parser = new StringParser((value || "").trim()), result = [], temp1, temp2;
                    while (typeof (temp1 = parser.matchNumber()) === "string" && typeof (temp2 = parser.matchLengthUnit()) === "string") {
                      result.push(this.computeUnits(temp1, temp2, percent));
                      parser.matchSeparator();
                    }
                    if (strict && parser.matchAll()) {
                      return;
                    }
                    return result;
                  };
                  this.getLength = function(key, percent, initial) {
                    return this.computeLength(this.attr(key), percent, initial);
                  };
                  this.getLengthList = function(key, percent) {
                    return this.computeLengthList(this.attr(key), percent);
                  };
                  this.getUrl = function(key) {
                    return this.resolveUrl(this.attr(key));
                  };
                  this.getNumberList = function(key) {
                    let parser = new StringParser((this.attr(key) || "").trim()), result = [], temp;
                    while (temp = parser.matchNumber()) {
                      result.push(Number(temp));
                      parser.matchSeparator();
                    }
                    result.error = parser.matchAll();
                    return result;
                  };
                  this.getViewbox = function(key, initial) {
                    let viewBox = this.getNumberList(key);
                    if (viewBox.length === 4 && viewBox[2] >= 0 && viewBox[3] >= 0) {
                      return viewBox;
                    }
                    return initial;
                  };
                  this.getPercent = function(key, initial) {
                    let value = this.attr(key);
                    let parser = new StringParser((value || "").trim()), temp1, temp2;
                    let number = parser.matchNumber();
                    if (!number) {
                      return initial;
                    }
                    if (parser.match("%")) {
                      number *= 0.01;
                    }
                    if (parser.matchAll()) {
                      return initial;
                    }
                    return Math.max(0, Math.min(1, number));
                  };
                  this.chooseValue = function(args) {
                    for (let i = 0; i < arguments.length; i++) {
                      if (arguments[i] != null && arguments[i] === arguments[i]) {
                        return arguments[i];
                      }
                    }
                    return arguments[arguments.length - 1];
                  };
                  this.get = function(key) {
                    if (styleCache[key] !== void 0) {
                      return styleCache[key];
                    }
                    let keyInfo = Properties[key] || {}, value, result;
                    for (let i = 0; i < 3; i++) {
                      switch (i) {
                        case 0:
                          if (key !== "transform") {
                            value = this.css[keyInfo.css || key];
                          }
                          break;
                        case 1:
                          value = this.style[key];
                          break;
                        case 2:
                          value = this.attr(key);
                          break;
                      }
                      if (value === "inherit") {
                        result = this.inherits ? this.inherits.get(key) : keyInfo.initial;
                        if (result != null) {
                          return styleCache[key] = result;
                        }
                      }
                      if (keyInfo.values != null) {
                        result = keyInfo.values[value];
                        if (result != null) {
                          return styleCache[key] = result;
                        }
                      }
                      if (value != null) {
                        let parsed;
                        switch (key) {
                          case "font-size":
                            result = this.computeLength(value, this.inherits ? this.inherits.get(key) : keyInfo.initial, void 0, true);
                            break;
                          case "baseline-shift":
                            result = this.computeLength(value, this.get("font-size"));
                            break;
                          case "font-family":
                            result = value || void 0;
                            break;
                          case "opacity":
                          case "stroke-opacity":
                          case "fill-opacity":
                          case "stop-opacity":
                            parsed = parseFloat(value);
                            if (!isNaN(parsed)) {
                              result = Math.max(0, Math.min(1, parsed));
                            }
                            break;
                          case "transform":
                            result = parseTranform(value);
                            break;
                          case "stroke-dasharray":
                            if (value === "none") {
                              result = [];
                            } else if (parsed = this.computeLengthList(value, this.getViewport(), true)) {
                              let sum = 0, error = false;
                              for (let j = 0; j < parsed.length; j++) {
                                if (parsed[j] < 0) {
                                  error = true;
                                }
                                sum += parsed[j];
                              }
                              if (!error) {
                                if (parsed.length % 2 === 1) {
                                  parsed = parsed.concat(parsed);
                                }
                                result = sum === 0 ? [] : parsed;
                              }
                            }
                            break;
                          case "color":
                            if (value === "none" || value === "transparent") {
                              result = "none";
                            } else {
                              result = parseColor(value);
                            }
                            break;
                          case "fill":
                          case "stroke":
                            if (value === "none" || value === "transparent") {
                              result = "none";
                            } else if (value === "currentColor") {
                              result = this.get("color");
                            } else if (parsed = parseColor(value)) {
                              return parsed;
                            } else if (parsed = (value || "").split(" ")) {
                              let object = this.resolveUrl(parsed[0]), fallbackColor = parseColor(parsed[1]);
                              if (object == null) {
                                result = fallbackColor;
                              } else if (object.nodeName === "linearGradient" || object.nodeName === "radialGradient") {
                                result = new SvgElemGradient(object, null, fallbackColor);
                              } else if (object.nodeName === "pattern") {
                                result = new SvgElemPattern(object, null, fallbackColor);
                              } else {
                                result = fallbackColor;
                              }
                            }
                            break;
                          case "stop-color":
                            if (value === "none" || value === "transparent") {
                              result = "none";
                            } else if (value === "currentColor") {
                              result = this.get("color");
                            } else {
                              result = parseColor(value);
                            }
                            break;
                          case "marker-start":
                          case "marker-mid":
                          case "marker-end":
                          case "clip-path":
                          case "mask":
                            if (value === "none") {
                              result = "none";
                            } else {
                              result = this.resolveUrl(value);
                            }
                            break;
                          case "stroke-width":
                            parsed = this.computeLength(value, this.getViewport());
                            if (parsed != null && parsed >= 0) {
                              result = parsed;
                            }
                            break;
                          case "stroke-miterlimit":
                            parsed = parseFloat(value);
                            if (parsed != null && parsed >= 1) {
                              result = parsed;
                            }
                            break;
                          case "word-spacing":
                          case "letter-spacing":
                            result = this.computeLength(value, this.getViewport());
                            break;
                          case "stroke-dashoffset":
                            result = this.computeLength(value, this.getViewport());
                            break;
                        }
                        if (result != null) {
                          return styleCache[key] = result;
                        }
                      }
                    }
                    return styleCache[key] = keyInfo.inherit && this.inherits ? this.inherits.get(key) : keyInfo.initial;
                  };
                  this.getChildren = function() {
                    if (childrenCache != null) {
                      return childrenCache;
                    }
                    let children = [];
                    for (let i = 0; i < obj.childNodes.length; i++) {
                      let child = obj.childNodes[i];
                      if (!child.error && this.allowedChildren.indexOf(child.nodeName) !== -1) {
                        children.push(createSVGElement(child, this));
                      }
                    }
                    return childrenCache = children;
                  };
                  this.getParentVWidth = function() {
                    return this.inherits ? this.inherits.getVWidth() : viewportWidth;
                  };
                  this.getParentVHeight = function() {
                    return this.inherits ? this.inherits.getVHeight() : viewportHeight;
                  };
                  this.getParentViewport = function() {
                    return Math.sqrt(0.5 * this.getParentVWidth() * this.getParentVWidth() + 0.5 * this.getParentVHeight() * this.getParentVHeight());
                  };
                  this.getVWidth = function() {
                    return this.getParentVWidth();
                  };
                  this.getVHeight = function() {
                    return this.getParentVHeight();
                  };
                  this.getViewport = function() {
                    return Math.sqrt(0.5 * this.getVWidth() * this.getVWidth() + 0.5 * this.getVHeight() * this.getVHeight());
                  };
                  this.getBoundingBox = function() {
                    let shape = this.getBoundingShape();
                    return shape.getBoundingBox();
                  };
                };
                var SvgElemStylable = function(obj, inherits) {
                  SvgElem.call(this, obj, inherits);
                  this.transform = function() {
                    doc.transform.apply(doc, this.getTransformation());
                  };
                  this.clip = function() {
                    if (this.get("clip-path") !== "none") {
                      let clipPath = new SvgElemClipPath(this.get("clip-path"), null);
                      clipPath.useMask(clipPath.attr("clipPathUnits") === "objectBoundingBox" ? this.getBoundingBox() : null);
                      return true;
                    }
                  };
                  this.mask = function() {
                    if (this.get("mask") !== "none") {
                      let mask = new SvgElemMask(this.get("mask"), null);
                      mask.useMask(this.getBoundingBox());
                      return true;
                    }
                  };
                  this.getFill = function(isClip, isMask) {
                    let opacity = this.get("opacity"), fill = this.get("fill"), fillOpacity = this.get("fill-opacity");
                    if (isClip) {
                      return DefaultColors.white;
                    }
                    if (fill !== "none" && opacity && fillOpacity) {
                      if (fill instanceof SvgElemGradient || fill instanceof SvgElemPattern) {
                        return fill.getPaint(this.getBoundingBox(), fillOpacity * opacity, isClip, isMask);
                      }
                      return opacityToColor(fill, fillOpacity * opacity, isMask);
                    }
                  };
                  this.getStroke = function(isClip, isMask) {
                    let opacity = this.get("opacity"), stroke = this.get("stroke"), strokeOpacity = this.get("stroke-opacity");
                    if (isClip || isEqual(this.get("stroke-width"), 0)) {
                      return;
                    }
                    if (stroke !== "none" && opacity && strokeOpacity) {
                      if (stroke instanceof SvgElemGradient || stroke instanceof SvgElemPattern) {
                        return stroke.getPaint(this.getBoundingBox(), strokeOpacity * opacity, isClip, isMask);
                      }
                      return opacityToColor(stroke, strokeOpacity * opacity, isMask);
                    }
                  };
                };
                var SvgElemHasChildren = function(obj, inherits) {
                  SvgElemStylable.call(this, obj, inherits);
                  this.allowedChildren = ["use", "g", "a", "svg", "image", "rect", "circle", "ellipse", "line", "polyline", "polygon", "path", "text"];
                  this.getBoundingShape = function() {
                    let shape = new SvgShape(), children = this.getChildren();
                    for (let i = 0; i < children.length; i++) {
                      if (children[i].get("display") !== "none") {
                        if (typeof children[i].getBoundingShape === "function") {
                          let childShape = children[i].getBoundingShape().clone();
                          if (typeof children[i].getTransformation === "function") {
                            childShape.transform(children[i].getTransformation());
                          }
                          shape.mergeShape(childShape);
                        }
                      }
                    }
                    return shape;
                  };
                  this.drawChildren = function(isClip, isMask) {
                    let children = this.getChildren();
                    for (let i = 0; i < children.length; i++) {
                      if (children[i].get("display") !== "none") {
                        if (typeof children[i].drawInDocument === "function") {
                          children[i].drawInDocument(isClip, isMask);
                        }
                      }
                    }
                  };
                };
                var SvgElemContainer = function(obj, inherits) {
                  SvgElemHasChildren.call(this, obj, inherits);
                  this.drawContent = function(isClip, isMask) {
                    this.transform();
                    let clipped = this.clip(), masked = this.mask(), group;
                    if ((this.get("opacity") < 1 || clipped || masked) && !isClip) {
                      group = docBeginGroup(getPageBBox());
                    }
                    this.drawChildren(isClip, isMask);
                    if (group) {
                      docEndGroup(group);
                      doc.fillOpacity(this.get("opacity"));
                      docInsertGroup(group);
                    }
                  };
                };
                var SvgElemUse = function(obj, inherits) {
                  SvgElemContainer.call(this, obj, inherits);
                  let x2 = this.getLength("x", this.getVWidth(), 0), y2 = this.getLength("y", this.getVHeight(), 0), child = this.getUrl("href") || this.getUrl("xlink:href");
                  if (child) {
                    child = createSVGElement(child, this);
                  }
                  this.getChildren = function() {
                    return child ? [child] : [];
                  };
                  this.drawInDocument = function(isClip, isMask) {
                    doc.save();
                    this.drawContent(isClip, isMask);
                    doc.restore();
                  };
                  this.getTransformation = function() {
                    return multiplyMatrix(this.get("transform"), [1, 0, 0, 1, x2, y2]);
                  };
                };
                var SvgElemSymbol = function(obj, inherits) {
                  SvgElemContainer.call(this, obj, inherits);
                  let width = this.getLength("width", this.getParentVWidth(), this.getParentVWidth()), height = this.getLength("height", this.getParentVHeight(), this.getParentVHeight());
                  if (inherits instanceof SvgElemUse) {
                    width = inherits.getLength("width", inherits.getParentVWidth(), width);
                    height = inherits.getLength("height", inherits.getParentVHeight(), height);
                  }
                  let aspectRatio = (this.attr("preserveAspectRatio") || "").trim(), viewBox = this.getViewbox("viewBox", [0, 0, width, height]);
                  this.getVWidth = function() {
                    return viewBox[2];
                  };
                  this.getVHeight = function() {
                    return viewBox[3];
                  };
                  this.drawInDocument = function(isClip, isMask) {
                    doc.save();
                    this.drawContent(isClip, isMask);
                    doc.restore();
                  };
                  this.getTransformation = function() {
                    return multiplyMatrix(parseAspectRatio(aspectRatio, width, height, viewBox[2], viewBox[3]), [1, 0, 0, 1, -viewBox[0], -viewBox[1]]);
                  };
                };
                var SvgElemGroup = function(obj, inherits) {
                  SvgElemContainer.call(this, obj, inherits);
                  this.drawInDocument = function(isClip, isMask) {
                    doc.save();
                    if (this.link && !isClip && !isMask) {
                      this.addLink();
                    }
                    this.drawContent(isClip, isMask);
                    doc.restore();
                  };
                  this.getTransformation = function() {
                    return this.get("transform");
                  };
                };
                var SvgElemLink = function(obj, inherits) {
                  if (inherits && inherits.isText) {
                    SvgElemTspan.call(this, obj, inherits);
                    this.allowedChildren = ["textPath", "tspan", "#text", "#cdata-section", "a"];
                  } else {
                    SvgElemGroup.call(this, obj, inherits);
                  }
                  this.link = this.attr("href") || this.attr("xlink:href");
                  this.addLink = function() {
                    if (this.link.match(/^(?:[a-z][a-z0-9+.-]*:|\/\/)?/i) && this.getChildren().length) {
                      let bbox = this.getBoundingShape().transform(getGlobalMatrix()).getBoundingBox();
                      docInsertLink(bbox[0], bbox[1], bbox[2], bbox[3], this.link);
                    }
                  };
                };
                var SvgElemSvg = function(obj, inherits) {
                  SvgElemContainer.call(this, obj, inherits);
                  let width = this.getLength("width", this.getParentVWidth(), this.getParentVWidth()), height = this.getLength("height", this.getParentVHeight(), this.getParentVHeight()), x2 = this.getLength("x", this.getParentVWidth(), 0), y2 = this.getLength("y", this.getParentVHeight(), 0);
                  if (inherits instanceof SvgElemUse) {
                    width = inherits.getLength("width", inherits.getParentVWidth(), width);
                    height = inherits.getLength("height", inherits.getParentVHeight(), height);
                  }
                  let aspectRatio = this.attr("preserveAspectRatio"), viewBox = this.getViewbox("viewBox", [0, 0, width, height]);
                  if (this.isOuterElement && preserveAspectRatio) {
                    x2 = y2 = 0;
                    width = viewportWidth;
                    height = viewportHeight;
                    aspectRatio = preserveAspectRatio;
                  }
                  this.getVWidth = function() {
                    return viewBox[2];
                  };
                  this.getVHeight = function() {
                    return viewBox[3];
                  };
                  this.drawInDocument = function(isClip, isMask) {
                    doc.save();
                    if (this.get("overflow") === "hidden") {
                      new SvgShape().M(x2, y2).L(x2 + width, y2).L(x2 + width, y2 + height).L(x2, y2 + height).Z().transform(this.get("transform")).insertInDocument();
                      doc.clip();
                    }
                    this.drawContent(isClip, isMask);
                    doc.restore();
                  };
                  this.getTransformation = function() {
                    return multiplyMatrix(this.get("transform"), [1, 0, 0, 1, x2, y2], parseAspectRatio(aspectRatio, width, height, viewBox[2], viewBox[3]), [1, 0, 0, 1, -viewBox[0], -viewBox[1]]);
                  };
                };
                var SVGElemImage = function(obj, inherits) {
                  SvgElemStylable.call(this, obj, inherits);
                  let link = imageCallback(this.attr("href") || this.attr("xlink:href") || ""), x2 = this.getLength("x", this.getVWidth(), 0), y2 = this.getLength("y", this.getVHeight(), 0), width = this.getLength("width", this.getVWidth(), "auto"), height = this.getLength("height", this.getVHeight(), "auto"), image;
                  try {
                    image = doc.openImage(link);
                  } catch (e) {
                    warningCallback('SVGElemImage: failed to open image "' + link + '" in PDFKit');
                  }
                  if (image) {
                    if (width === "auto" && height !== "auto") {
                      width = height * image.width / image.height;
                    } else if (height === "auto" && width !== "auto") {
                      height = width * image.height / image.width;
                    } else if (width === "auto" && height === "auto") {
                      width = image.width;
                      height = image.height;
                    }
                  }
                  if (width === "auto" || width < 0) {
                    width = 0;
                  }
                  if (height === "auto" || height < 0) {
                    height = 0;
                  }
                  this.getTransformation = function() {
                    return this.get("transform");
                  };
                  this.getBoundingShape = function() {
                    return new SvgShape().M(x2, y2).L(x2 + width, y2).M(x2 + width, y2 + height).L(x2, y2 + height);
                  };
                  this.drawInDocument = function(isClip, isMask) {
                    if (this.get("visibility") === "hidden" || !image) {
                      return;
                    }
                    doc.save();
                    this.transform();
                    if (this.get("overflow") === "hidden") {
                      doc.rect(x2, y2, width, height).clip();
                    }
                    this.clip();
                    this.mask();
                    doc.translate(x2, y2);
                    doc.transform.apply(doc, parseAspectRatio(this.attr("preserveAspectRatio"), width, height, image ? image.width : width, image ? image.height : height));
                    if (!isClip) {
                      doc.fillOpacity(this.get("opacity"));
                      doc.image(image, 0, 0);
                    } else {
                      doc.rect(0, 0, image.width, image.height);
                      docFillColor(DefaultColors.white).fill();
                    }
                    doc.restore();
                  };
                };
                var SvgElemPattern = function(obj, inherits, fallback) {
                  SvgElemHasChildren.call(this, obj, inherits);
                  this.ref = (function() {
                    let ref = this.getUrl("href") || this.getUrl("xlink:href");
                    if (ref && ref.nodeName === obj.nodeName) {
                      return new SvgElemPattern(ref, inherits, fallback);
                    }
                  }).call(this);
                  let _attr = this.attr;
                  this.attr = function(key) {
                    let attr = _attr.call(this, key);
                    if (attr != null || key === "href" || key === "xlink:href") {
                      return attr;
                    }
                    return this.ref ? this.ref.attr(key) : null;
                  };
                  let _getChildren = this.getChildren;
                  this.getChildren = function() {
                    let children = _getChildren.call(this);
                    if (children.length > 0) {
                      return children;
                    }
                    return this.ref ? this.ref.getChildren() : [];
                  };
                  this.getPaint = function(bBox, gOpacity, isClip, isMask) {
                    let bBoxUnitsPattern = this.attr("patternUnits") !== "userSpaceOnUse", bBoxUnitsContent = this.attr("patternContentUnits") === "objectBoundingBox", x2 = this.getLength("x", bBoxUnitsPattern ? 1 : this.getParentVWidth(), 0), y2 = this.getLength("y", bBoxUnitsPattern ? 1 : this.getParentVHeight(), 0), width = this.getLength("width", bBoxUnitsPattern ? 1 : this.getParentVWidth(), 0), height = this.getLength("height", bBoxUnitsPattern ? 1 : this.getParentVHeight(), 0);
                    if (bBoxUnitsContent && !bBoxUnitsPattern) {
                      x2 = (x2 - bBox[0]) / (bBox[2] - bBox[0]) || 0;
                      y2 = (y2 - bBox[1]) / (bBox[3] - bBox[1]) || 0;
                      width = width / (bBox[2] - bBox[0]) || 0;
                      height = height / (bBox[3] - bBox[1]) || 0;
                    } else if (!bBoxUnitsContent && bBoxUnitsPattern) {
                      x2 = bBox[0] + x2 * (bBox[2] - bBox[0]);
                      y2 = bBox[1] + y2 * (bBox[3] - bBox[1]);
                      width = width * (bBox[2] - bBox[0]);
                      height = height * (bBox[3] - bBox[1]);
                    }
                    let viewBox = this.getViewbox("viewBox", [0, 0, width, height]), aspectRatio = (this.attr("preserveAspectRatio") || "").trim(), aspectRatioMatrix = multiplyMatrix(parseAspectRatio(aspectRatio, width, height, viewBox[2], viewBox[3], 0), [1, 0, 0, 1, -viewBox[0], -viewBox[1]]), matrix = parseTranform(this.attr("patternTransform"));
                    if (bBoxUnitsContent) {
                      matrix = multiplyMatrix([bBox[2] - bBox[0], 0, 0, bBox[3] - bBox[1], bBox[0], bBox[1]], matrix);
                    }
                    matrix = multiplyMatrix(matrix, [1, 0, 0, 1, x2, y2]);
                    if ((matrix = validateMatrix(matrix)) && (aspectRatioMatrix = validateMatrix(aspectRatioMatrix)) && (width = validateNumber(width)) && (height = validateNumber(height))) {
                      let group = docBeginGroup([0, 0, width, height]);
                      doc.transform.apply(doc, aspectRatioMatrix);
                      this.drawChildren(isClip, isMask);
                      docEndGroup(group);
                      return [docCreatePattern(group, width, height, matrix), gOpacity];
                    } else {
                      return fallback ? [fallback[0], fallback[1] * gOpacity] : void 0;
                    }
                  };
                  this.getVWidth = function() {
                    let bBoxUnitsPattern = this.attr("patternUnits") !== "userSpaceOnUse", width = this.getLength("width", bBoxUnitsPattern ? 1 : this.getParentVWidth(), 0);
                    return this.getViewbox("viewBox", [0, 0, width, 0])[2];
                  };
                  this.getVHeight = function() {
                    let bBoxUnitsPattern = this.attr("patternUnits") !== "userSpaceOnUse", height = this.getLength("height", bBoxUnitsPattern ? 1 : this.getParentVHeight(), 0);
                    return this.getViewbox("viewBox", [0, 0, 0, height])[3];
                  };
                };
                var SvgElemGradient = function(obj, inherits, fallback) {
                  SvgElem.call(this, obj, inherits);
                  this.allowedChildren = ["stop"];
                  this.ref = (function() {
                    let ref = this.getUrl("href") || this.getUrl("xlink:href");
                    if (ref && ref.nodeName === obj.nodeName) {
                      return new SvgElemGradient(ref, inherits, fallback);
                    }
                  }).call(this);
                  let _attr = this.attr;
                  this.attr = function(key) {
                    let attr = _attr.call(this, key);
                    if (attr != null || key === "href" || key === "xlink:href") {
                      return attr;
                    }
                    return this.ref ? this.ref.attr(key) : null;
                  };
                  let _getChildren = this.getChildren;
                  this.getChildren = function() {
                    let children = _getChildren.call(this);
                    if (children.length > 0) {
                      return children;
                    }
                    return this.ref ? this.ref.getChildren() : [];
                  };
                  this.getPaint = function(bBox, gOpacity, isClip, isMask) {
                    let children = this.getChildren();
                    if (children.length === 0) {
                      return;
                    }
                    if (children.length === 1) {
                      let child = children[0], stopColor = child.get("stop-color");
                      if (stopColor === "none") {
                        return;
                      }
                      return opacityToColor(stopColor, child.get("stop-opacity") * gOpacity, isMask);
                    }
                    let bBoxUnits = this.attr("gradientUnits") !== "userSpaceOnUse", matrix = parseTranform(this.attr("gradientTransform")), spread = this.attr("spreadMethod"), grad, x1, x2, y1, y2, r2, nAfter = 0, nBefore = 0, nTotal = 1;
                    if (bBoxUnits) {
                      matrix = multiplyMatrix([bBox[2] - bBox[0], 0, 0, bBox[3] - bBox[1], bBox[0], bBox[1]], matrix);
                    }
                    if (matrix = validateMatrix(matrix)) {
                      if (this.name === "linearGradient") {
                        x1 = this.getLength("x1", bBoxUnits ? 1 : this.getVWidth(), 0);
                        x2 = this.getLength("x2", bBoxUnits ? 1 : this.getVWidth(), bBoxUnits ? 1 : this.getVWidth());
                        y1 = this.getLength("y1", bBoxUnits ? 1 : this.getVHeight(), 0);
                        y2 = this.getLength("y2", bBoxUnits ? 1 : this.getVHeight(), 0);
                      } else {
                        x2 = this.getLength("cx", bBoxUnits ? 1 : this.getVWidth(), bBoxUnits ? 0.5 : 0.5 * this.getVWidth());
                        y2 = this.getLength("cy", bBoxUnits ? 1 : this.getVHeight(), bBoxUnits ? 0.5 : 0.5 * this.getVHeight());
                        r2 = this.getLength("r", bBoxUnits ? 1 : this.getViewport(), bBoxUnits ? 0.5 : 0.5 * this.getViewport());
                        x1 = this.getLength("fx", bBoxUnits ? 1 : this.getVWidth(), x2);
                        y1 = this.getLength("fy", bBoxUnits ? 1 : this.getVHeight(), y2);
                        if (r2 < 0) {
                          warningCallback("SvgElemGradient: negative r value");
                        }
                        let d = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), multiplier = 1;
                        if (d > r2) {
                          multiplier = r2 / d;
                          x1 = x2 + (x1 - x2) * multiplier;
                          y1 = y2 + (y1 - y2) * multiplier;
                        }
                        r2 = Math.max(r2, d * multiplier * (1 + 1e-6));
                      }
                      if (spread === "reflect" || spread === "repeat") {
                        let inv = inverseMatrix(matrix), corner1 = transformPoint([bBox[0], bBox[1]], inv), corner2 = transformPoint([bBox[2], bBox[1]], inv), corner3 = transformPoint([bBox[2], bBox[3]], inv), corner4 = transformPoint([bBox[0], bBox[3]], inv);
                        if (this.name === "linearGradient") {
                          nAfter = Math.max((corner1[0] - x2) * (x2 - x1) + (corner1[1] - y2) * (y2 - y1), (corner2[0] - x2) * (x2 - x1) + (corner2[1] - y2) * (y2 - y1), (corner3[0] - x2) * (x2 - x1) + (corner3[1] - y2) * (y2 - y1), (corner4[0] - x2) * (x2 - x1) + (corner4[1] - y2) * (y2 - y1)) / (Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                          nBefore = Math.max((corner1[0] - x1) * (x1 - x2) + (corner1[1] - y1) * (y1 - y2), (corner2[0] - x1) * (x1 - x2) + (corner2[1] - y1) * (y1 - y2), (corner3[0] - x1) * (x1 - x2) + (corner3[1] - y1) * (y1 - y2), (corner4[0] - x1) * (x1 - x2) + (corner4[1] - y1) * (y1 - y2)) / (Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                        } else {
                          nAfter = Math.sqrt(Math.max(Math.pow(corner1[0] - x2, 2) + Math.pow(corner1[1] - y2, 2), Math.pow(corner2[0] - x2, 2) + Math.pow(corner2[1] - y2, 2), Math.pow(corner3[0] - x2, 2) + Math.pow(corner3[1] - y2, 2), Math.pow(corner4[0] - x2, 2) + Math.pow(corner4[1] - y2, 2))) / r2 - 1;
                        }
                        nAfter = Math.ceil(nAfter + 0.5);
                        nBefore = Math.ceil(nBefore + 0.5);
                        nTotal = nBefore + 1 + nAfter;
                      }
                      if (this.name === "linearGradient") {
                        grad = doc.linearGradient(x1 - nBefore * (x2 - x1), y1 - nBefore * (y2 - y1), x2 + nAfter * (x2 - x1), y2 + nAfter * (y2 - y1));
                      } else {
                        grad = doc.radialGradient(x1, y1, 0, x2, y2, r2 + nAfter * r2);
                      }
                      for (let n = 0; n < nTotal; n++) {
                        let offset = 0, inOrder = spread !== "reflect" || (n - nBefore) % 2 === 0;
                        for (let i = 0; i < children.length; i++) {
                          let child = children[inOrder ? i : children.length - 1 - i], stopColor = child.get("stop-color");
                          if (stopColor === "none") {
                            stopColor = DefaultColors.transparent;
                          }
                          stopColor = opacityToColor(stopColor, child.get("stop-opacity") * gOpacity, isMask);
                          offset = Math.max(offset, inOrder ? child.getPercent("offset", 0) : 1 - child.getPercent("offset", 0));
                          if (i === 0 && stopColor[0].length === 4) {
                            grad._colorSpace = "DeviceCMYK";
                          }
                          if (i === 0 && offset > 0) {
                            grad.stop((n + 0) / nTotal, stopColor[0], stopColor[1]);
                          }
                          grad.stop((n + offset) / (nAfter + nBefore + 1), stopColor[0], stopColor[1]);
                          if (i === children.length - 1 && offset < 1) {
                            grad.stop((n + 1) / nTotal, stopColor[0], stopColor[1]);
                          }
                        }
                      }
                      grad.setTransform.apply(grad, matrix);
                      return [grad, 1];
                    } else {
                      return fallback ? [fallback[0], fallback[1] * gOpacity] : void 0;
                    }
                  };
                };
                var SvgElemBasicShape = function(obj, inherits) {
                  SvgElemStylable.call(this, obj, inherits);
                  this.dashScale = 1;
                  this.getBoundingShape = function() {
                    return this.shape;
                  };
                  this.getTransformation = function() {
                    return this.get("transform");
                  };
                  this.drawInDocument = function(isClip, isMask) {
                    if (this.get("visibility") === "hidden" || !this.shape) {
                      return;
                    }
                    doc.save();
                    if (this.get("vector-effect") === "non-scaling-stroke") {
                      this.shape.transform(this.getTransformation());
                    } else {
                      this.transform();
                    }
                    this.clip();
                    if (!isClip) {
                      let masked = this.mask(), group;
                      if (masked) {
                        group = docBeginGroup(getPageBBox());
                      }
                      let subPaths = this.shape.getSubPaths(), fill = this.getFill(isClip, isMask), stroke = this.getStroke(isClip, isMask), lineWidth = this.get("stroke-width"), lineCap = this.get("stroke-linecap");
                      if (this.get("vector-effect") === "non-scaling-stroke") {
                        lineWidth = lineWidth / getPageScale();
                      }
                      if (fill || stroke) {
                        if (fill) {
                          docFillColor(fill);
                        }
                        if (stroke) {
                          for (let j = 0; j < subPaths.length; j++) {
                            if (isEqual(subPaths[j].totalLength, 0)) {
                              if ((lineCap === "square" || lineCap === "round") && lineWidth > 0) {
                                if (subPaths[j].startPoint && subPaths[j].startPoint.length > 1) {
                                  let x2 = subPaths[j].startPoint[0], y2 = subPaths[j].startPoint[1];
                                  docFillColor(stroke);
                                  if (lineCap === "square") {
                                    doc.rect(x2 - 0.5 * lineWidth, y2 - 0.5 * lineWidth, lineWidth, lineWidth);
                                  } else if (lineCap === "round") {
                                    doc.circle(x2, y2, 0.5 * lineWidth);
                                  }
                                  doc.fill();
                                }
                              }
                            }
                          }
                          let dashArray = this.get("stroke-dasharray"), dashOffset = this.get("stroke-dashoffset");
                          if (isNotEqual(this.dashScale, 1)) {
                            for (let j = 0; j < dashArray.length; j++) {
                              dashArray[j] *= this.dashScale;
                            }
                            dashOffset *= this.dashScale;
                          }
                          docStrokeColor(stroke);
                          doc.lineWidth(lineWidth).miterLimit(this.get("stroke-miterlimit")).lineJoin(this.get("stroke-linejoin")).lineCap(lineCap);
                          docApplyDash(dashArray, dashOffset);
                        }
                        for (let j = 0; j < subPaths.length; j++) {
                          if (subPaths[j].totalLength > 0) {
                            subPaths[j].insertInDocument();
                          }
                        }
                        if (fill && stroke) {
                          doc.fillAndStroke(this.get("fill-rule"));
                        } else if (fill) {
                          doc.fill(this.get("fill-rule"));
                        } else if (stroke) {
                          doc.stroke();
                        }
                      }
                      let markerStart = this.get("marker-start"), markerMid = this.get("marker-mid"), markerEnd = this.get("marker-end");
                      if (markerStart !== "none" || markerMid !== "none" || markerEnd !== "none") {
                        let markersPos = this.shape.getMarkers();
                        if (markerStart !== "none" && markersPos.length > 0) {
                          let marker = new SvgElemMarker(markerStart, null);
                          marker.drawMarker(false, isMask, markersPos[0], lineWidth);
                        }
                        if (markerMid !== "none") {
                          for (let i = 1; i < markersPos.length - 1; i++) {
                            let marker = new SvgElemMarker(markerMid, null);
                            marker.drawMarker(false, isMask, markersPos[i], lineWidth);
                          }
                        }
                        if (markerEnd !== "none" && markersPos.length > 0) {
                          let marker = new SvgElemMarker(markerEnd, null);
                          marker.drawMarker(false, isMask, markersPos[markersPos.length - 1], lineWidth);
                        }
                      }
                      if (group) {
                        docEndGroup(group);
                        docInsertGroup(group);
                      }
                    } else {
                      this.shape.insertInDocument();
                      docFillColor(DefaultColors.white);
                      doc.fill(this.get("clip-rule"));
                    }
                    doc.restore();
                  };
                };
                var SvgElemRect = function(obj, inherits) {
                  SvgElemBasicShape.call(this, obj, inherits);
                  let x2 = this.getLength("x", this.getVWidth(), 0), y2 = this.getLength("y", this.getVHeight(), 0), w = this.getLength("width", this.getVWidth(), 0), h = this.getLength("height", this.getVHeight(), 0), rx = this.getLength("rx", this.getVWidth()), ry = this.getLength("ry", this.getVHeight());
                  if (rx === void 0 && ry === void 0) {
                    rx = ry = 0;
                  } else if (rx === void 0 && ry !== void 0) {
                    rx = ry;
                  } else if (rx !== void 0 && ry === void 0) {
                    ry = rx;
                  }
                  if (w > 0 && h > 0) {
                    if (rx && ry) {
                      rx = Math.min(rx, 0.5 * w);
                      ry = Math.min(ry, 0.5 * h);
                      this.shape = new SvgShape().M(x2 + rx, y2).L(x2 + w - rx, y2).A(rx, ry, 0, 0, 1, x2 + w, y2 + ry).L(x2 + w, y2 + h - ry).A(rx, ry, 0, 0, 1, x2 + w - rx, y2 + h).L(x2 + rx, y2 + h).A(rx, ry, 0, 0, 1, x2, y2 + h - ry).L(x2, y2 + ry).A(rx, ry, 0, 0, 1, x2 + rx, y2).Z();
                    } else {
                      this.shape = new SvgShape().M(x2, y2).L(x2 + w, y2).L(x2 + w, y2 + h).L(x2, y2 + h).Z();
                    }
                  } else {
                    this.shape = new SvgShape();
                  }
                };
                var SvgElemCircle = function(obj, inherits) {
                  SvgElemBasicShape.call(this, obj, inherits);
                  let cx = this.getLength("cx", this.getVWidth(), 0), cy = this.getLength("cy", this.getVHeight(), 0), r = this.getLength("r", this.getViewport(), 0);
                  if (r > 0) {
                    this.shape = new SvgShape().M(cx + r, cy).A(r, r, 0, 0, 1, cx - r, cy).A(r, r, 0, 0, 1, cx + r, cy).Z();
                  } else {
                    this.shape = new SvgShape();
                  }
                };
                var SvgElemEllipse = function(obj, inherits) {
                  SvgElemBasicShape.call(this, obj, inherits);
                  let cx = this.getLength("cx", this.getVWidth(), 0), cy = this.getLength("cy", this.getVHeight(), 0), rx = this.getLength("rx", this.getVWidth(), 0), ry = this.getLength("ry", this.getVHeight(), 0);
                  if (rx > 0 && ry > 0) {
                    this.shape = new SvgShape().M(cx + rx, cy).A(rx, ry, 0, 0, 1, cx - rx, cy).A(rx, ry, 0, 0, 1, cx + rx, cy).Z();
                  } else {
                    this.shape = new SvgShape();
                  }
                };
                var SvgElemLine = function(obj, inherits) {
                  SvgElemBasicShape.call(this, obj, inherits);
                  let x1 = this.getLength("x1", this.getVWidth(), 0), y1 = this.getLength("y1", this.getVHeight(), 0), x2 = this.getLength("x2", this.getVWidth(), 0), y2 = this.getLength("y2", this.getVHeight(), 0);
                  this.shape = new SvgShape().M(x1, y1).L(x2, y2);
                };
                var SvgElemPolyline = function(obj, inherits) {
                  SvgElemBasicShape.call(this, obj, inherits);
                  let points = this.getNumberList("points");
                  this.shape = new SvgShape();
                  for (let i = 0; i < points.length - 1; i += 2) {
                    if (i === 0) {
                      this.shape.M(points[i], points[i + 1]);
                    } else {
                      this.shape.L(points[i], points[i + 1]);
                    }
                  }
                  if (points.error) {
                    warningCallback("SvgElemPolygon: unexpected string " + points.error);
                  }
                  if (points.length % 2 === 1) {
                    warningCallback("SvgElemPolyline: uneven number of coordinates");
                  }
                };
                var SvgElemPolygon = function(obj, inherits) {
                  SvgElemBasicShape.call(this, obj, inherits);
                  let points = this.getNumberList("points");
                  this.shape = new SvgShape();
                  for (let i = 0; i < points.length - 1; i += 2) {
                    if (i === 0) {
                      this.shape.M(points[i], points[i + 1]);
                    } else {
                      this.shape.L(points[i], points[i + 1]);
                    }
                  }
                  this.shape.Z();
                  if (points.error) {
                    warningCallback("SvgElemPolygon: unexpected string " + points.error);
                  }
                  if (points.length % 2 === 1) {
                    warningCallback("SvgElemPolygon: uneven number of coordinates");
                  }
                };
                var SvgElemPath = function(obj, inherits) {
                  SvgElemBasicShape.call(this, obj, inherits);
                  this.shape = new SvgShape().path(this.attr("d"));
                  let pathLength = this.getLength("pathLength", this.getViewport());
                  this.pathLength = pathLength > 0 ? pathLength : void 0;
                  this.dashScale = this.pathLength !== void 0 ? this.shape.totalLength / this.pathLength : 1;
                };
                var SvgElemMarker = function(obj, inherits) {
                  SvgElemHasChildren.call(this, obj, inherits);
                  let width = this.getLength("markerWidth", this.getParentVWidth(), 3), height = this.getLength("markerHeight", this.getParentVHeight(), 3), viewBox = this.getViewbox("viewBox", [0, 0, width, height]);
                  this.getVWidth = function() {
                    return viewBox[2];
                  };
                  this.getVHeight = function() {
                    return viewBox[3];
                  };
                  this.drawMarker = function(isClip, isMask, posArray, strokeWidth) {
                    doc.save();
                    let orient = this.attr("orient"), units = this.attr("markerUnits"), rotate = orient === "auto" ? posArray[2] : (parseFloat(orient) || 0) * Math.PI / 180, scale = units === "userSpaceOnUse" ? 1 : strokeWidth;
                    doc.transform(Math.cos(rotate) * scale, Math.sin(rotate) * scale, -Math.sin(rotate) * scale, Math.cos(rotate) * scale, posArray[0], posArray[1]);
                    let refX = this.getLength("refX", this.getVWidth(), 0), refY = this.getLength("refY", this.getVHeight(), 0), aspectRatioMatrix = parseAspectRatio(this.attr("preserveAspectRatio"), width, height, viewBox[2], viewBox[3], 0.5);
                    if (this.get("overflow") === "hidden") {
                      doc.rect(aspectRatioMatrix[0] * (viewBox[0] + viewBox[2] / 2 - refX) - width / 2, aspectRatioMatrix[3] * (viewBox[1] + viewBox[3] / 2 - refY) - height / 2, width, height).clip();
                    }
                    doc.transform.apply(doc, aspectRatioMatrix);
                    doc.translate(-refX, -refY);
                    let group;
                    if (this.get("opacity") < 1 && !isClip) {
                      group = docBeginGroup(getPageBBox());
                    }
                    this.drawChildren(isClip, isMask);
                    if (group) {
                      docEndGroup(group);
                      doc.fillOpacity(this.get("opacity"));
                      docInsertGroup(group);
                    }
                    doc.restore();
                  };
                };
                var SvgElemClipPath = function(obj, inherits) {
                  SvgElemHasChildren.call(this, obj, inherits);
                  this.useMask = function(bBox) {
                    let group = docBeginGroup(getPageBBox());
                    doc.save();
                    doc.transform.apply(doc, this.get("transform"));
                    if (this.attr("clipPathUnits") === "objectBoundingBox") {
                      doc.transform(bBox[2] - bBox[0], 0, 0, bBox[3] - bBox[1], bBox[0], bBox[1]);
                    }
                    this.clip();
                    this.drawChildren(true, false);
                    doc.restore();
                    docEndGroup(group);
                    docApplyMask(group, true);
                  };
                };
                var SvgElemMask = function(obj, inherits) {
                  SvgElemHasChildren.call(this, obj, inherits);
                  this.useMask = function(bBox) {
                    let group = docBeginGroup(getPageBBox());
                    doc.save();
                    let x2, y2, w, h;
                    if (this.attr("maskUnits") === "userSpaceOnUse") {
                      x2 = this.getLength("x", this.getVWidth(), -0.1 * (bBox[2] - bBox[0]) + bBox[0]);
                      y2 = this.getLength("y", this.getVHeight(), -0.1 * (bBox[3] - bBox[1]) + bBox[1]);
                      w = this.getLength("width", this.getVWidth(), 1.2 * (bBox[2] - bBox[0]));
                      h = this.getLength("height", this.getVHeight(), 1.2 * (bBox[3] - bBox[1]));
                    } else {
                      x2 = this.getLength("x", this.getVWidth(), -0.1) * (bBox[2] - bBox[0]) + bBox[0];
                      y2 = this.getLength("y", this.getVHeight(), -0.1) * (bBox[3] - bBox[1]) + bBox[1];
                      w = this.getLength("width", this.getVWidth(), 1.2) * (bBox[2] - bBox[0]);
                      h = this.getLength("height", this.getVHeight(), 1.2) * (bBox[3] - bBox[1]);
                    }
                    if (this.attr("maskContentUnits") === "objectBoundingBox") {
                      doc.transform(bBox[2] - bBox[0], 0, 0, bBox[3] - bBox[1], bBox[0], bBox[1]);
                    }
                    this.clip();
                    this.drawChildren(false, true);
                    doc.restore();
                    docEndGroup(group);
                    docApplyMask(group, true);
                  };
                };
                var SvgElemTextContainer = function(obj, inherits) {
                  SvgElemStylable.call(this, obj, inherits);
                  this.allowedChildren = ["tspan", "#text", "#cdata-section", "a"];
                  this.isText = true;
                  this.getBoundingShape = function() {
                    let shape = new SvgShape();
                    for (let i = 0; i < this._pos.length; i++) {
                      let pos = this._pos[i];
                      if (!pos.hidden) {
                        let dx0 = pos.ascent * Math.sin(pos.rotate), dy0 = -pos.ascent * Math.cos(pos.rotate), dx1 = pos.descent * Math.sin(pos.rotate), dy1 = -pos.descent * Math.cos(pos.rotate), dx2 = pos.width * Math.cos(pos.rotate), dy2 = pos.width * Math.sin(pos.rotate);
                        shape.M(pos.x + dx0, pos.y + dy0).L(pos.x + dx0 + dx2, pos.y + dy0 + dy2).M(pos.x + dx1 + dx2, pos.y + dy1 + dy2).L(pos.x + dx1, pos.y + dy1);
                      }
                    }
                    return shape;
                  };
                  this.drawTextInDocument = function(isClip, isMask) {
                    if (this.link && !isClip && !isMask) {
                      this.addLink();
                    }
                    if (this.get("text-decoration") === "underline") {
                      this.decorate(0.05 * this._font.size, -0.075 * this._font.size, isClip, isMask);
                    }
                    if (this.get("text-decoration") === "overline") {
                      this.decorate(0.05 * this._font.size, getAscent(this._font.font, this._font.size) + 0.075 * this._font.size, isClip, isMask);
                    }
                    let fill = this.getFill(isClip, isMask), stroke = this.getStroke(isClip, isMask), strokeWidth = this.get("stroke-width");
                    if (this._font.fauxBold) {
                      if (!stroke) {
                        stroke = fill;
                        strokeWidth = this._font.size * 0.03;
                      } else {
                        strokeWidth += this._font.size * 0.03;
                      }
                    }
                    let children = this.getChildren();
                    for (let i = 0; i < children.length; i++) {
                      let childElem = children[i];
                      switch (childElem.name) {
                        case "tspan":
                        case "textPath":
                        case "a":
                          if (childElem.get("display") !== "none") {
                            childElem.drawTextInDocument(isClip, isMask);
                          }
                          break;
                        case "#text":
                        case "#cdata-section":
                          if (this.get("visibility") === "hidden") {
                            continue;
                          }
                          if (fill || stroke || isClip) {
                            if (fill) {
                              docFillColor(fill);
                            }
                            if (stroke && strokeWidth) {
                              docStrokeColor(stroke);
                              doc.lineWidth(strokeWidth).miterLimit(this.get("stroke-miterlimit")).lineJoin(this.get("stroke-linejoin")).lineCap(this.get("stroke-linecap"));
                              docApplyDash(this.get("stroke-dasharray"), this.get("stroke-dashoffset"));
                            }
                            docBeginText(this._font.font, this._font.size);
                            docSetTextMode(!!fill, !!stroke);
                            docWriteGlyphs(childElem._pos, this._font);
                            docEndText();
                          }
                          break;
                      }
                    }
                    if (this.get("text-decoration") === "line-through") {
                      this.decorate(0.05 * this._font.size, 0.5 * (getAscent(this._font.font, this._font.size) + getDescent(this._font.font, this._font.size)), isClip, isMask);
                    }
                  };
                  this.decorate = function(lineWidth, linePosition, isClip, isMask) {
                    let fill = this.getFill(isClip, isMask), stroke = this.getStroke(isClip, isMask);
                    if (fill) {
                      docFillColor(fill);
                    }
                    if (stroke) {
                      docStrokeColor(stroke);
                      doc.lineWidth(this.get("stroke-width")).miterLimit(this.get("stroke-miterlimit")).lineJoin(this.get("stroke-linejoin")).lineCap(this.get("stroke-linecap"));
                      docApplyDash(this.get("stroke-dasharray"), this.get("stroke-dashoffset"));
                    }
                    for (let j = 0, pos = this._pos; j < pos.length; j++) {
                      if (!pos[j].hidden && isNotEqual(pos[j].width, 0)) {
                        let dx0 = (linePosition + lineWidth / 2) * Math.sin(pos[j].rotate), dy0 = -(linePosition + lineWidth / 2) * Math.cos(pos[j].rotate), dx1 = (linePosition - lineWidth / 2) * Math.sin(pos[j].rotate), dy1 = -(linePosition - lineWidth / 2) * Math.cos(pos[j].rotate), dx2 = pos[j].width * Math.cos(pos[j].rotate), dy2 = pos[j].width * Math.sin(pos[j].rotate);
                        new SvgShape().M(pos[j].x + dx0, pos[j].y + dy0).L(pos[j].x + dx0 + dx2, pos[j].y + dy0 + dy2).L(pos[j].x + dx1 + dx2, pos[j].y + dy1 + dy2).L(pos[j].x + dx1, pos[j].y + dy1).Z().insertInDocument();
                        if (fill && stroke) {
                          doc.fillAndStroke();
                        } else if (fill) {
                          doc.fill();
                        } else if (stroke) {
                          doc.stroke();
                        }
                      }
                    }
                  };
                };
                var SvgElemTextNode = function(obj, inherits) {
                  this.name = obj.nodeName;
                  this.textContent = obj.nodeValue;
                };
                var SvgElemTspan = function(obj, inherits) {
                  SvgElemTextContainer.call(this, obj, inherits);
                };
                var SvgElemTextPath = function(obj, inherits) {
                  SvgElemTextContainer.call(this, obj, inherits);
                  let pathObject, pathLength, temp;
                  if ((temp = this.attr("path")) && temp.trim() !== "") {
                    let pathLength2 = this.getLength("pathLength", this.getViewport());
                    this.pathObject = new SvgShape().path(temp);
                    this.pathLength = pathLength2 > 0 ? pathLength2 : this.pathObject.totalLength;
                    this.pathScale = this.pathObject.totalLength / this.pathLength;
                  } else if ((temp = this.getUrl("href") || this.getUrl("xlink:href")) && temp.nodeName === "path") {
                    let pathElem = new SvgElemPath(temp, this);
                    this.pathObject = pathElem.shape.clone().transform(pathElem.get("transform"));
                    this.pathLength = this.chooseValue(pathElem.pathLength, this.pathObject.totalLength);
                    this.pathScale = this.pathObject.totalLength / this.pathLength;
                  }
                };
                var SvgElemText = function(obj, inherits) {
                  SvgElemTextContainer.call(this, obj, inherits);
                  this.allowedChildren = ["textPath", "tspan", "#text", "#cdata-section", "a"];
                  (function(textParentElem) {
                    let processedText = "", remainingText = obj.textContent, textPaths = [], currentChunk = [], currentAnchor, currentDirection, currentX = 0, currentY = 0;
                    function doAnchoring() {
                      if (currentChunk.length) {
                        let last = currentChunk[currentChunk.length - 1];
                        let first = currentChunk[0];
                        let width = last.x + last.width - first.x;
                        let anchordx = {
                          "startltr": 0,
                          "middleltr": 0.5,
                          "endltr": 1,
                          "startrtl": 1,
                          "middlertl": 0.5,
                          "endrtl": 0
                        }[currentAnchor + currentDirection] * width || 0;
                        for (let i = 0; i < currentChunk.length; i++) {
                          currentChunk[i].x -= anchordx;
                        }
                      }
                      currentChunk = [];
                    }
                    function adjustLength(pos, length, spacingAndGlyphs) {
                      let firstChar = pos[0], lastChar = pos[pos.length - 1], startX = firstChar.x, endX = lastChar.x + lastChar.width;
                      if (spacingAndGlyphs) {
                        let textScale = length / (endX - startX);
                        if (textScale > 0 && textScale < Infinity) {
                          for (let j = 0; j < pos.length; j++) {
                            pos[j].continuous = false;
                            pos[j].x = startX + textScale * (pos[j].x - startX);
                            pos[j].scale *= textScale;
                            pos[j].width *= textScale;
                          }
                        }
                      } else {
                        if (pos.length >= 2) {
                          let spaceDiff = (length - (endX - startX)) / (pos.length - 1);
                          for (let j = 0; j < pos.length; j++) {
                            pos[j].continuous = false;
                            pos[j].x += j * spaceDiff;
                          }
                        }
                      }
                      currentX += length - (endX - startX);
                    }
                    function recursive(currentElem, parentElem) {
                      currentElem._x = combineArrays(currentElem.getLengthList("x", currentElem.getVWidth()), parentElem ? parentElem._x.slice(parentElem._pos.length) : []);
                      currentElem._y = combineArrays(currentElem.getLengthList("y", currentElem.getVHeight()), parentElem ? parentElem._y.slice(parentElem._pos.length) : []);
                      currentElem._dx = combineArrays(currentElem.getLengthList("dx", currentElem.getVWidth()), parentElem ? parentElem._dx.slice(parentElem._pos.length) : []);
                      currentElem._dy = combineArrays(currentElem.getLengthList("dy", currentElem.getVHeight()), parentElem ? parentElem._dy.slice(parentElem._pos.length) : []);
                      currentElem._rot = combineArrays(currentElem.getNumberList("rotate"), parentElem ? parentElem._rot.slice(parentElem._pos.length) : []);
                      currentElem._defRot = currentElem.chooseValue(currentElem._rot[currentElem._rot.length - 1], parentElem && parentElem._defRot, 0);
                      if (currentElem.name === "textPath") {
                        currentElem._y = [];
                      }
                      let fontOptions = {
                        fauxItalic: false,
                        fauxBold: false
                      }, fontNameorLink = fontCallback(currentElem.get("font-family"), currentElem.get("font-weight") === "bold", currentElem.get("font-style") === "italic", fontOptions);
                      try {
                        doc.font(fontNameorLink);
                      } catch (e) {
                        warningCallback('SVGElemText: failed to open font "' + fontNameorLink + '" in PDFKit: ' + e.message);
                      }
                      currentElem._pos = [];
                      currentElem._index = 0;
                      currentElem._font = {
                        font: doc._font,
                        size: currentElem.get("font-size"),
                        fauxItalic: fontOptions.fauxItalic,
                        fauxBold: fontOptions.fauxBold
                      };
                      let textLength = currentElem.getLength("textLength", currentElem.getVWidth(), void 0), spacingAndGlyphs = currentElem.attr("lengthAdjust") === "spacingAndGlyphs", wordSpacing = currentElem.get("word-spacing"), letterSpacing = currentElem.get("letter-spacing"), textAnchor = currentElem.get("text-anchor"), textDirection = currentElem.get("direction"), isTextElem = currentElem.name === "text", baselineAttr = isTextElem ? currentElem.get("dominant-baseline") : currentElem.get("alignment-baseline") || currentElem.get("dominant-baseline"), baselineShiftAttr = isTextElem ? "baseline" : currentElem.get("baseline-shift"), baseline = getBaseline(currentElem._font.font, currentElem._font.size, baselineAttr, baselineShiftAttr);
                      if (currentElem.name === "textPath") {
                        doAnchoring();
                        currentX = currentY = 0;
                      }
                      let children = currentElem.getChildren();
                      for (let i = 0; i < children.length; i++) {
                        let childElem = children[i];
                        switch (childElem.name) {
                          case "tspan":
                          case "textPath":
                          case "a":
                            recursive(childElem, currentElem);
                            break;
                          case "#text":
                          case "#cdata-section":
                            let rawText = childElem.textContent, renderedText = rawText, words;
                            childElem._font = currentElem._font;
                            childElem._pos = [];
                            remainingText = remainingText.substring(rawText.length);
                            if (currentElem.get("xml:space") === "preserve") {
                              renderedText = renderedText.replace(/[\s]/g, " ");
                            } else {
                              renderedText = renderedText.replace(/[\s]+/g, " ");
                              if (processedText.match(/[\s]$|^$/)) {
                                renderedText = renderedText.replace(/^[\s]/, "");
                              }
                              if (remainingText.match(/^[\s]*$/)) {
                                renderedText = renderedText.replace(/[\s]$/, "");
                              }
                            }
                            processedText += rawText;
                            if (wordSpacing === 0) {
                              words = [renderedText];
                            } else {
                              words = renderedText.split(/(\s)/);
                            }
                            for (let w = 0; w < words.length; w++) {
                              let pos = getTextPos(currentElem._font.font, currentElem._font.size, words[w]);
                              for (let j = 0; j < pos.length; j++) {
                                let index = currentElem._index, xAttr = currentElem._x[index], yAttr = currentElem._y[index], dxAttr = currentElem._dx[index], dyAttr = currentElem._dy[index], rotAttr = currentElem._rot[index], continuous = !(w === 0 && j === 0);
                                if (letterSpacing !== 0) {
                                  continuous = false;
                                }
                                if (wordSpacing !== 0) {
                                  continuous = false;
                                }
                                if (xAttr !== void 0) {
                                  continuous = false;
                                  doAnchoring();
                                  currentX = xAttr;
                                }
                                if (yAttr !== void 0) {
                                  continuous = false;
                                  doAnchoring();
                                  currentY = yAttr;
                                }
                                if (dxAttr !== void 0) {
                                  continuous = false;
                                  currentX += dxAttr;
                                }
                                if (dyAttr !== void 0) {
                                  continuous = false;
                                  currentY += dyAttr;
                                }
                                if (rotAttr !== void 0 || currentElem._defRot !== 0) {
                                  continuous = false;
                                }
                                let position = {
                                  glyph: pos[j].glyph,
                                  rotate: Math.PI / 180 * currentElem.chooseValue(rotAttr, currentElem._defRot),
                                  x: currentX + pos[j].xOffset,
                                  kern: pos[j].kern,
                                  y: currentY + baseline + pos[j].yOffset,
                                  width: pos[j].width,
                                  ascent: getAscent(currentElem._font.font, currentElem._font.size),
                                  descent: getDescent(currentElem._font.font, currentElem._font.size),
                                  scale: 1,
                                  hidden: false,
                                  continuous
                                };
                                currentChunk.push(position);
                                childElem._pos.push(position);
                                currentElem._pos.push(position);
                                currentElem._index += pos[j].unicode.length;
                                if (currentChunk.length === 1) {
                                  currentAnchor = textAnchor;
                                  currentDirection = textDirection;
                                }
                                currentX += pos[j].xAdvance + letterSpacing;
                                currentY += pos[j].yAdvance;
                              }
                              if (words[w] === " ") {
                                currentX += wordSpacing;
                              }
                            }
                            break;
                          default:
                            remainingText = remainingText.substring(childElem.textContent.length);
                        }
                      }
                      if (textLength && currentElem._pos.length) {
                        adjustLength(currentElem._pos, textLength, spacingAndGlyphs);
                      }
                      if (currentElem.name === "textPath" || currentElem.name === "text") {
                        doAnchoring();
                      }
                      if (currentElem.name === "textPath") {
                        textPaths.push(currentElem);
                        let pathObject = currentElem.pathObject;
                        if (pathObject) {
                          currentX = pathObject.endPoint[0];
                          currentY = pathObject.endPoint[1];
                        }
                      }
                      if (parentElem) {
                        parentElem._pos = parentElem._pos.concat(currentElem._pos);
                        parentElem._index += currentElem._index;
                      }
                    }
                    function textOnPath(currentElem) {
                      let pathObject = currentElem.pathObject, pathLength = currentElem.pathLength, pathScale = currentElem.pathScale;
                      if (pathObject) {
                        let textOffset = currentElem.getLength("startOffset", pathLength, 0);
                        for (let j = 0; j < currentElem._pos.length; j++) {
                          let charMidX = textOffset + currentElem._pos[j].x + 0.5 * currentElem._pos[j].width;
                          if (charMidX > pathLength || charMidX < 0) {
                            currentElem._pos[j].hidden = true;
                          } else {
                            let pointOnPath = pathObject.getPointAtLength(charMidX * pathScale);
                            if (isNotEqual(pathScale, 1)) {
                              currentElem._pos[j].scale *= pathScale;
                              currentElem._pos[j].width *= pathScale;
                            }
                            currentElem._pos[j].x = pointOnPath[0] - 0.5 * currentElem._pos[j].width * Math.cos(pointOnPath[2]) - currentElem._pos[j].y * Math.sin(pointOnPath[2]);
                            currentElem._pos[j].y = pointOnPath[1] - 0.5 * currentElem._pos[j].width * Math.sin(pointOnPath[2]) + currentElem._pos[j].y * Math.cos(pointOnPath[2]);
                            currentElem._pos[j].rotate = pointOnPath[2] + currentElem._pos[j].rotate;
                            currentElem._pos[j].continuous = false;
                          }
                        }
                      } else {
                        for (let j = 0; j < currentElem._pos.length; j++) {
                          currentElem._pos[j].hidden = true;
                        }
                      }
                    }
                    recursive(textParentElem, null);
                    for (let i = 0; i < textPaths.length; i++) {
                      textOnPath(textPaths[i]);
                    }
                  })(this);
                  this.getTransformation = function() {
                    return this.get("transform");
                  };
                  this.drawInDocument = function(isClip, isMask) {
                    doc.save();
                    this.transform();
                    this.clip();
                    let masked = this.mask(), group;
                    if (masked) {
                      group = docBeginGroup(getPageBBox());
                    }
                    this.drawTextInDocument(isClip, isMask);
                    if (group) {
                      docEndGroup(group);
                      docInsertGroup(group);
                    }
                    doc.restore();
                  };
                };
                options = options || {};
                var pxToPt = options.assumePt ? 1 : 72 / 96, viewportWidth = (options.width || doc.page.width) / pxToPt, viewportHeight = (options.height || doc.page.height) / pxToPt, preserveAspectRatio = options.preserveAspectRatio || null, useCSS = options.useCSS && typeof SVGElement !== "undefined" && svg instanceof SVGElement && typeof getComputedStyle === "function", warningCallback = options.warningCallback, fontCallback = options.fontCallback, imageCallback = options.imageCallback, colorCallback = options.colorCallback, documentCallback = options.documentCallback, precision = Math.ceil(Math.max(1, options.precision)) || 3, groupStack = [], documentCache = {}, links = [], styleRules = [];
                if (typeof warningCallback !== "function") {
                  warningCallback = function(str) {
                    if (typeof console !== void 0 && typeof console.warn === "function") {
                      console.warn(str);
                    }
                  };
                }
                if (typeof fontCallback !== "function") {
                  fontCallback = function(family, bold, italic, fontOptions) {
                    if (bold && italic) {
                      if (doc._registeredFonts.hasOwnProperty(family + "-BoldItalic")) {
                        return family + "-BoldItalic";
                      } else if (doc._registeredFonts.hasOwnProperty(family + "-Italic")) {
                        fontOptions.fauxBold = true;
                        return family + "-Italic";
                      } else if (doc._registeredFonts.hasOwnProperty(family + "-Bold")) {
                        fontOptions.fauxItalic = true;
                        return family + "-Bold";
                      } else if (doc._registeredFonts.hasOwnProperty(family)) {
                        fontOptions.fauxBold = true;
                        fontOptions.fauxItalic = true;
                        return family;
                      }
                    }
                    if (bold && !italic) {
                      if (doc._registeredFonts.hasOwnProperty(family + "-Bold")) {
                        return family + "-Bold";
                      } else if (doc._registeredFonts.hasOwnProperty(family)) {
                        fontOptions.fauxBold = true;
                        return family;
                      }
                    }
                    if (!bold && italic) {
                      if (doc._registeredFonts.hasOwnProperty(family + "-Italic")) {
                        return family + "-Italic";
                      } else if (doc._registeredFonts.hasOwnProperty(family)) {
                        fontOptions.fauxItalic = true;
                        return family;
                      }
                    }
                    if (!bold && !italic) {
                      if (doc._registeredFonts.hasOwnProperty(family)) {
                        return family;
                      }
                    }
                    if (family.match(/(?:^|,)\s*serif\s*$/)) {
                      if (bold && italic) {
                        return "Times-BoldItalic";
                      }
                      if (bold && !italic) {
                        return "Times-Bold";
                      }
                      if (!bold && italic) {
                        return "Times-Italic";
                      }
                      if (!bold && !italic) {
                        return "Times-Roman";
                      }
                    } else if (family.match(/(?:^|,)\s*monospace\s*$/)) {
                      if (bold && italic) {
                        return "Courier-BoldOblique";
                      }
                      if (bold && !italic) {
                        return "Courier-Bold";
                      }
                      if (!bold && italic) {
                        return "Courier-Oblique";
                      }
                      if (!bold && !italic) {
                        return "Courier";
                      }
                    } else if (family.match(/(?:^|,)\s*sans-serif\s*$/) || true) {
                      if (bold && italic) {
                        return "Helvetica-BoldOblique";
                      }
                      if (bold && !italic) {
                        return "Helvetica-Bold";
                      }
                      if (!bold && italic) {
                        return "Helvetica-Oblique";
                      }
                      if (!bold && !italic) {
                        return "Helvetica";
                      }
                    }
                  };
                }
                if (typeof imageCallback !== "function") {
                  imageCallback = function(link) {
                    return link.replace(/\s+/g, "");
                  };
                }
                if (typeof colorCallback !== "function") {
                  colorCallback = null;
                } else {
                  for (let color in DefaultColors) {
                    let newColor = colorCallback(DefaultColors[color]);
                    DefaultColors[color][0] = newColor[0];
                    DefaultColors[color][1] = newColor[1];
                  }
                }
                if (typeof documentCallback !== "function") {
                  documentCallback = null;
                }
                if (typeof svg === "string") {
                  svg = parseXml(svg);
                }
                if (svg) {
                  let styles = svg.getElementsByTagName("style");
                  for (let i = 0; i < styles.length; i++) {
                    styleRules = styleRules.concat(parseStyleSheet(styles[i].textContent));
                  }
                  let elem = createSVGElement(svg, null);
                  if (typeof elem.drawInDocument === "function") {
                    if (options.useCSS && !useCSS) {
                      warningCallback("SVGtoPDF: useCSS option can only be used for SVG *elements* in compatible browsers");
                    }
                    let savedFillColor = doc._fillColor;
                    doc.save().translate(x || 0, y || 0).scale(pxToPt);
                    elem.drawInDocument();
                    for (let i = 0; i < links.length; i++) {
                      doc.page.annotations.push(links[i]);
                    }
                    doc.restore();
                    doc._fillColor = savedFillColor;
                  } else {
                    warningCallback("SVGtoPDF: this element can't be rendered directly: " + svg.nodeName);
                  }
                } else {
                  warningCallback("SVGtoPDF: the input does not look like a valid SVG");
                }
              };
              if (module2 && typeof module2.exports !== "undefined") {
                module2.exports = SVGtoPDF;
              }
            },
            /***/
            7705(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(2858));
                } else {
                }
              })(void 0, function(CryptoJS) {
                CryptoJS.pad.Iso10126 = {
                  pad: function(data, blockSize) {
                    var blockSizeBytes = blockSize * 4;
                    var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
                    data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
                  },
                  unpad: function(data) {
                    var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
                    data.sigBytes -= nPaddingBytes;
                  }
                };
                return CryptoJS.pad.Iso10126;
              });
            },
            /***/
            7723(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              module2.exports = PassThrough;
              var Transform = __webpack_require__2(8569);
              __webpack_require__2(9784)(PassThrough, Transform);
              function PassThrough(options) {
                if (!(this instanceof PassThrough)) return new PassThrough(options);
                Transform.call(this, options);
              }
              PassThrough.prototype._transform = function(chunk, encoding, cb) {
                cb(null, chunk);
              };
            },
            /***/
            7756(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var check = function(it) {
                return it && it.Math === Math && it;
              };
              module2.exports = // eslint-disable-next-line es/no-global-this -- safe
              check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
              check(typeof self == "object" && self) || check(typeof __webpack_require__2.g == "object" && __webpack_require__2.g) || check(typeof this == "object" && this) || // eslint-disable-next-line no-new-func -- fallback
              /* @__PURE__ */ function() {
                return this;
              }() || Function("return this")();
            },
            /***/
            7770(module2) {
              "use strict";
              module2.exports = SyntaxError;
            },
            /***/
            7801(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var process = __webpack_require__2(9964);
              function _typeof(o) {
                "@babel/helpers - typeof";
                return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
                  return typeof o2;
                } : function(o2) {
                  return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
                }, _typeof(o);
              }
              function _defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                }
              }
              function _createClass(Constructor, protoProps, staticProps) {
                if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                if (staticProps) _defineProperties(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", { writable: false });
                return Constructor;
              }
              function _toPropertyKey(arg) {
                var key = _toPrimitive(arg, "string");
                return _typeof(key) === "symbol" ? key : String(key);
              }
              function _toPrimitive(input, hint) {
                if (_typeof(input) !== "object" || input === null) return input;
                var prim = input[Symbol.toPrimitive];
                if (prim !== void 0) {
                  var res = prim.call(input, hint || "default");
                  if (_typeof(res) !== "object") return res;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return (hint === "string" ? String : Number)(input);
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var _require = __webpack_require__2(5403), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
              var AssertionError = __webpack_require__2(5416);
              var _require2 = __webpack_require__2(7187), inspect = _require2.inspect;
              var _require$types = __webpack_require__2(7187).types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
              var objectAssign = __webpack_require__2(7596)();
              var objectIs = __webpack_require__2(9636)();
              var RegExpPrototypeTest = __webpack_require__2(7913)("RegExp.prototype.test");
              var errorCache = /* @__PURE__ */ new Map();
              var isDeepEqual;
              var isDeepStrictEqual;
              var parseExpressionAt;
              var findNodeAround;
              var decoder;
              function lazyLoadComparison() {
                var comparison = __webpack_require__2(6781);
                isDeepEqual = comparison.isDeepEqual;
                isDeepStrictEqual = comparison.isDeepStrictEqual;
              }
              var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
              var meta = (
                /* unused pure expression or super */
                null
              );
              var escapeFn = function escapeFn2(str) {
                return meta[str.charCodeAt(0)];
              };
              var warned = false;
              var assert = module2.exports = ok;
              var NO_EXCEPTION_SENTINEL = {};
              function innerFail(obj) {
                if (obj.message instanceof Error) throw obj.message;
                throw new AssertionError(obj);
              }
              function fail(actual, expected, message, operator, stackStartFn) {
                var argsLen = arguments.length;
                var internalMessage;
                if (argsLen === 0) {
                  internalMessage = "Failed";
                } else if (argsLen === 1) {
                  message = actual;
                  actual = void 0;
                } else {
                  if (warned === false) {
                    warned = true;
                    var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
                    warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
                  }
                  if (argsLen === 2) operator = "!=";
                }
                if (message instanceof Error) throw message;
                var errArgs = {
                  actual,
                  expected,
                  operator: operator === void 0 ? "fail" : operator,
                  stackStartFn: stackStartFn || fail
                };
                if (message !== void 0) {
                  errArgs.message = message;
                }
                var err = new AssertionError(errArgs);
                if (internalMessage) {
                  err.message = internalMessage;
                  err.generatedMessage = true;
                }
                throw err;
              }
              assert.fail = fail;
              assert.AssertionError = AssertionError;
              function innerOk(fn, argLen, value, message) {
                if (!value) {
                  var generatedMessage = false;
                  if (argLen === 0) {
                    generatedMessage = true;
                    message = "No value argument passed to `assert.ok()`";
                  } else if (message instanceof Error) {
                    throw message;
                  }
                  var err = new AssertionError({
                    actual: value,
                    expected: true,
                    message,
                    operator: "==",
                    stackStartFn: fn
                  });
                  err.generatedMessage = generatedMessage;
                  throw err;
                }
              }
              function ok() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                innerOk.apply(void 0, [ok, args.length].concat(args));
              }
              assert.ok = ok;
              assert.equal = function equal(actual, expected, message) {
                if (arguments.length < 2) {
                  throw new ERR_MISSING_ARGS("actual", "expected");
                }
                if (actual != expected) {
                  innerFail({
                    actual,
                    expected,
                    message,
                    operator: "==",
                    stackStartFn: equal
                  });
                }
              };
              assert.notEqual = function notEqual(actual, expected, message) {
                if (arguments.length < 2) {
                  throw new ERR_MISSING_ARGS("actual", "expected");
                }
                if (actual == expected) {
                  innerFail({
                    actual,
                    expected,
                    message,
                    operator: "!=",
                    stackStartFn: notEqual
                  });
                }
              };
              assert.deepEqual = function deepEqual(actual, expected, message) {
                if (arguments.length < 2) {
                  throw new ERR_MISSING_ARGS("actual", "expected");
                }
                if (isDeepEqual === void 0) lazyLoadComparison();
                if (!isDeepEqual(actual, expected)) {
                  innerFail({
                    actual,
                    expected,
                    message,
                    operator: "deepEqual",
                    stackStartFn: deepEqual
                  });
                }
              };
              assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                if (arguments.length < 2) {
                  throw new ERR_MISSING_ARGS("actual", "expected");
                }
                if (isDeepEqual === void 0) lazyLoadComparison();
                if (isDeepEqual(actual, expected)) {
                  innerFail({
                    actual,
                    expected,
                    message,
                    operator: "notDeepEqual",
                    stackStartFn: notDeepEqual
                  });
                }
              };
              assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
                if (arguments.length < 2) {
                  throw new ERR_MISSING_ARGS("actual", "expected");
                }
                if (isDeepEqual === void 0) lazyLoadComparison();
                if (!isDeepStrictEqual(actual, expected)) {
                  innerFail({
                    actual,
                    expected,
                    message,
                    operator: "deepStrictEqual",
                    stackStartFn: deepStrictEqual
                  });
                }
              };
              assert.notDeepStrictEqual = notDeepStrictEqual;
              function notDeepStrictEqual(actual, expected, message) {
                if (arguments.length < 2) {
                  throw new ERR_MISSING_ARGS("actual", "expected");
                }
                if (isDeepEqual === void 0) lazyLoadComparison();
                if (isDeepStrictEqual(actual, expected)) {
                  innerFail({
                    actual,
                    expected,
                    message,
                    operator: "notDeepStrictEqual",
                    stackStartFn: notDeepStrictEqual
                  });
                }
              }
              assert.strictEqual = function strictEqual(actual, expected, message) {
                if (arguments.length < 2) {
                  throw new ERR_MISSING_ARGS("actual", "expected");
                }
                if (!objectIs(actual, expected)) {
                  innerFail({
                    actual,
                    expected,
                    message,
                    operator: "strictEqual",
                    stackStartFn: strictEqual
                  });
                }
              };
              assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                if (arguments.length < 2) {
                  throw new ERR_MISSING_ARGS("actual", "expected");
                }
                if (objectIs(actual, expected)) {
                  innerFail({
                    actual,
                    expected,
                    message,
                    operator: "notStrictEqual",
                    stackStartFn: notStrictEqual
                  });
                }
              };
              var Comparison = _createClass(function Comparison2(obj, keys, actual) {
                var _this = this;
                _classCallCheck(this, Comparison2);
                keys.forEach(function(key) {
                  if (key in obj) {
                    if (actual !== void 0 && typeof actual[key] === "string" && isRegExp(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) {
                      _this[key] = actual[key];
                    } else {
                      _this[key] = obj[key];
                    }
                  }
                });
              });
              function compareExceptionKey(actual, expected, key, message, keys, fn) {
                if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
                  if (!message) {
                    var a = new Comparison(actual, keys);
                    var b = new Comparison(expected, keys, actual);
                    var err = new AssertionError({
                      actual: a,
                      expected: b,
                      operator: "deepStrictEqual",
                      stackStartFn: fn
                    });
                    err.actual = actual;
                    err.expected = expected;
                    err.operator = fn.name;
                    throw err;
                  }
                  innerFail({
                    actual,
                    expected,
                    message,
                    operator: fn.name,
                    stackStartFn: fn
                  });
                }
              }
              function expectedException(actual, expected, msg, fn) {
                if (typeof expected !== "function") {
                  if (isRegExp(expected)) return RegExpPrototypeTest(expected, actual);
                  if (arguments.length === 2) {
                    throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
                  }
                  if (_typeof(actual) !== "object" || actual === null) {
                    var err = new AssertionError({
                      actual,
                      expected,
                      message: msg,
                      operator: "deepStrictEqual",
                      stackStartFn: fn
                    });
                    err.operator = fn.name;
                    throw err;
                  }
                  var keys = Object.keys(expected);
                  if (expected instanceof Error) {
                    keys.push("name", "message");
                  } else if (keys.length === 0) {
                    throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
                  }
                  if (isDeepEqual === void 0) lazyLoadComparison();
                  keys.forEach(function(key) {
                    if (typeof actual[key] === "string" && isRegExp(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) {
                      return;
                    }
                    compareExceptionKey(actual, expected, key, msg, keys, fn);
                  });
                  return true;
                }
                if (expected.prototype !== void 0 && actual instanceof expected) {
                  return true;
                }
                if (Error.isPrototypeOf(expected)) {
                  return false;
                }
                return expected.call({}, actual) === true;
              }
              function getActual(fn) {
                if (typeof fn !== "function") {
                  throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
                }
                try {
                  fn();
                } catch (e) {
                  return e;
                }
                return NO_EXCEPTION_SENTINEL;
              }
              function checkIsPromise(obj) {
                return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
              }
              function waitForActual(promiseFn) {
                return Promise.resolve().then(function() {
                  var resultPromise;
                  if (typeof promiseFn === "function") {
                    resultPromise = promiseFn();
                    if (!checkIsPromise(resultPromise)) {
                      throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
                    }
                  } else if (checkIsPromise(promiseFn)) {
                    resultPromise = promiseFn;
                  } else {
                    throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
                  }
                  return Promise.resolve().then(function() {
                    return resultPromise;
                  }).then(function() {
                    return NO_EXCEPTION_SENTINEL;
                  }).catch(function(e) {
                    return e;
                  });
                });
              }
              function expectsError(stackStartFn, actual, error, message) {
                if (typeof error === "string") {
                  if (arguments.length === 4) {
                    throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
                  }
                  if (_typeof(actual) === "object" && actual !== null) {
                    if (actual.message === error) {
                      throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
                    }
                  } else if (actual === error) {
                    throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
                  }
                  message = error;
                  error = void 0;
                } else if (error != null && _typeof(error) !== "object" && typeof error !== "function") {
                  throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
                }
                if (actual === NO_EXCEPTION_SENTINEL) {
                  var details = "";
                  if (error && error.name) {
                    details += " (".concat(error.name, ")");
                  }
                  details += message ? ": ".concat(message) : ".";
                  var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
                  innerFail({
                    actual: void 0,
                    expected: error,
                    operator: stackStartFn.name,
                    message: "Missing expected ".concat(fnType).concat(details),
                    stackStartFn
                  });
                }
                if (error && !expectedException(actual, error, message, stackStartFn)) {
                  throw actual;
                }
              }
              function expectsNoError(stackStartFn, actual, error, message) {
                if (actual === NO_EXCEPTION_SENTINEL) return;
                if (typeof error === "string") {
                  message = error;
                  error = void 0;
                }
                if (!error || expectedException(actual, error)) {
                  var details = message ? ": ".concat(message) : ".";
                  var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
                  innerFail({
                    actual,
                    expected: error,
                    operator: stackStartFn.name,
                    message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
                    stackStartFn
                  });
                }
                throw actual;
              }
              assert.throws = function throws(promiseFn) {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
              };
              assert.rejects = function rejects(promiseFn) {
                for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
                  args[_key3 - 1] = arguments[_key3];
                }
                return waitForActual(promiseFn).then(function(result) {
                  return expectsError.apply(void 0, [rejects, result].concat(args));
                });
              };
              assert.doesNotThrow = function doesNotThrow(fn) {
                for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
                  args[_key4 - 1] = arguments[_key4];
                }
                expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
              };
              assert.doesNotReject = function doesNotReject(fn) {
                for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
                  args[_key5 - 1] = arguments[_key5];
                }
                return waitForActual(fn).then(function(result) {
                  return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
                });
              };
              assert.ifError = function ifError(err) {
                if (err !== null && err !== void 0) {
                  var message = "ifError got unwanted exception: ";
                  if (_typeof(err) === "object" && typeof err.message === "string") {
                    if (err.message.length === 0 && err.constructor) {
                      message += err.constructor.name;
                    } else {
                      message += err.message;
                    }
                  } else {
                    message += inspect(err);
                  }
                  var newErr = new AssertionError({
                    actual: err,
                    expected: null,
                    operator: "ifError",
                    message,
                    stackStartFn: ifError
                  });
                  var origStack = err.stack;
                  if (typeof origStack === "string") {
                    var tmp2 = origStack.split("\n");
                    tmp2.shift();
                    var tmp1 = newErr.stack.split("\n");
                    for (var i = 0; i < tmp2.length; i++) {
                      var pos = tmp1.indexOf(tmp2[i]);
                      if (pos !== -1) {
                        tmp1 = tmp1.slice(0, pos);
                        break;
                      }
                    }
                    newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
                  }
                  throw newErr;
                }
              };
              function internalMatch(string, regexp, message, fn, fnName) {
                if (!isRegExp(regexp)) {
                  throw new ERR_INVALID_ARG_TYPE("regexp", "RegExp", regexp);
                }
                var match = fnName === "match";
                if (typeof string !== "string" || RegExpPrototypeTest(regexp, string) !== match) {
                  if (message instanceof Error) {
                    throw message;
                  }
                  var generatedMessage = !message;
                  message = message || (typeof string !== "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect(string), ")") : (match ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(inspect(regexp), ". Input:\n\n").concat(inspect(string), "\n"));
                  var err = new AssertionError({
                    actual: string,
                    expected: regexp,
                    message,
                    operator: fnName,
                    stackStartFn: fn
                  });
                  err.generatedMessage = generatedMessage;
                  throw err;
                }
              }
              assert.match = function match(string, regexp, message) {
                internalMatch(string, regexp, message, match, "match");
              };
              assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
                internalMatch(string, regexp, message, doesNotMatch, "doesNotMatch");
              };
              function strict() {
                for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
                  args[_key6] = arguments[_key6];
                }
                innerOk.apply(void 0, [strict, args.length].concat(args));
              }
              assert.strict = objectAssign(strict, assert, {
                equal: assert.strictEqual,
                deepEqual: assert.deepStrictEqual,
                notEqual: assert.notStrictEqual,
                notDeepEqual: assert.notDeepStrictEqual
              });
              assert.strict.strict = assert.strict;
            },
            /***/
            7802(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var bind = __webpack_require__2(5049);
              var $apply = __webpack_require__2(3036);
              var $call = __webpack_require__2(78);
              var $reflectApply = __webpack_require__2(1909);
              module2.exports = $reflectApply || bind.call($call, $apply);
            },
            /***/
            7866(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var toIntegerOrInfinity = __webpack_require__2(2119);
              var $RangeError = RangeError;
              module2.exports = function(it) {
                var result = toIntegerOrInfinity(it);
                if (result < 0) throw new $RangeError("The argument can't be less than 0");
                return result;
              };
            },
            /***/
            7900(module2) {
              "use strict";
              module2.exports = ReferenceError;
            },
            /***/
            7906(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var hasToStringTag = __webpack_require__2(6626)();
              var callBound = __webpack_require__2(2774);
              var $toString = callBound("Object.prototype.toString");
              var isStandardArguments = function isArguments(value) {
                if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
                  return false;
                }
                return $toString(value) === "[object Arguments]";
              };
              var isLegacyArguments = function isArguments(value) {
                if (isStandardArguments(value)) {
                  return true;
                }
                return value !== null && typeof value === "object" && "length" in value && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && "callee" in value && $toString(value.callee) === "[object Function]";
              };
              var supportsStandardArguments = function() {
                return isStandardArguments(arguments);
              }();
              isStandardArguments.isLegacyArguments = isLegacyArguments;
              module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
            },
            /***/
            7913(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var GetIntrinsic = __webpack_require__2(8651);
              var callBind = __webpack_require__2(6601);
              var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
              module2.exports = function callBoundIntrinsic(name, allowMissing) {
                var intrinsic = GetIntrinsic(name, !!allowMissing);
                if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
                  return callBind(intrinsic);
                }
                return intrinsic;
              };
            },
            /***/
            7920(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var wellKnownSymbol = __webpack_require__2(8663);
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              var test = {};
              test[TO_STRING_TAG] = "z";
              module2.exports = String(test) === "[object z]";
            },
            /***/
            7984(__unused_webpack_module, exports2, __webpack_require__2) {
              var BrotliDictionary = __webpack_require__2(614);
              var kIdentity = 0;
              var kOmitLast1 = 1;
              var kOmitLast2 = 2;
              var kOmitLast3 = 3;
              var kOmitLast4 = 4;
              var kOmitLast5 = 5;
              var kOmitLast6 = 6;
              var kOmitLast7 = 7;
              var kOmitLast8 = 8;
              var kOmitLast9 = 9;
              var kUppercaseFirst = 10;
              var kUppercaseAll = 11;
              var kOmitFirst1 = 12;
              var kOmitFirst2 = 13;
              var kOmitFirst3 = 14;
              var kOmitFirst4 = 15;
              var kOmitFirst5 = 16;
              var kOmitFirst6 = 17;
              var kOmitFirst7 = 18;
              var kOmitFirst8 = 19;
              var kOmitFirst9 = 20;
              function Transform(prefix, transform, suffix) {
                this.prefix = new Uint8Array(prefix.length);
                this.transform = transform;
                this.suffix = new Uint8Array(suffix.length);
                for (var i = 0; i < prefix.length; i++)
                  this.prefix[i] = prefix.charCodeAt(i);
                for (var i = 0; i < suffix.length; i++)
                  this.suffix[i] = suffix.charCodeAt(i);
              }
              var kTransforms = [
                new Transform("", kIdentity, ""),
                new Transform("", kIdentity, " "),
                new Transform(" ", kIdentity, " "),
                new Transform("", kOmitFirst1, ""),
                new Transform("", kUppercaseFirst, " "),
                new Transform("", kIdentity, " the "),
                new Transform(" ", kIdentity, ""),
                new Transform("s ", kIdentity, " "),
                new Transform("", kIdentity, " of "),
                new Transform("", kUppercaseFirst, ""),
                new Transform("", kIdentity, " and "),
                new Transform("", kOmitFirst2, ""),
                new Transform("", kOmitLast1, ""),
                new Transform(", ", kIdentity, " "),
                new Transform("", kIdentity, ", "),
                new Transform(" ", kUppercaseFirst, " "),
                new Transform("", kIdentity, " in "),
                new Transform("", kIdentity, " to "),
                new Transform("e ", kIdentity, " "),
                new Transform("", kIdentity, '"'),
                new Transform("", kIdentity, "."),
                new Transform("", kIdentity, '">'),
                new Transform("", kIdentity, "\n"),
                new Transform("", kOmitLast3, ""),
                new Transform("", kIdentity, "]"),
                new Transform("", kIdentity, " for "),
                new Transform("", kOmitFirst3, ""),
                new Transform("", kOmitLast2, ""),
                new Transform("", kIdentity, " a "),
                new Transform("", kIdentity, " that "),
                new Transform(" ", kUppercaseFirst, ""),
                new Transform("", kIdentity, ". "),
                new Transform(".", kIdentity, ""),
                new Transform(" ", kIdentity, ", "),
                new Transform("", kOmitFirst4, ""),
                new Transform("", kIdentity, " with "),
                new Transform("", kIdentity, "'"),
                new Transform("", kIdentity, " from "),
                new Transform("", kIdentity, " by "),
                new Transform("", kOmitFirst5, ""),
                new Transform("", kOmitFirst6, ""),
                new Transform(" the ", kIdentity, ""),
                new Transform("", kOmitLast4, ""),
                new Transform("", kIdentity, ". The "),
                new Transform("", kUppercaseAll, ""),
                new Transform("", kIdentity, " on "),
                new Transform("", kIdentity, " as "),
                new Transform("", kIdentity, " is "),
                new Transform("", kOmitLast7, ""),
                new Transform("", kOmitLast1, "ing "),
                new Transform("", kIdentity, "\n	"),
                new Transform("", kIdentity, ":"),
                new Transform(" ", kIdentity, ". "),
                new Transform("", kIdentity, "ed "),
                new Transform("", kOmitFirst9, ""),
                new Transform("", kOmitFirst7, ""),
                new Transform("", kOmitLast6, ""),
                new Transform("", kIdentity, "("),
                new Transform("", kUppercaseFirst, ", "),
                new Transform("", kOmitLast8, ""),
                new Transform("", kIdentity, " at "),
                new Transform("", kIdentity, "ly "),
                new Transform(" the ", kIdentity, " of "),
                new Transform("", kOmitLast5, ""),
                new Transform("", kOmitLast9, ""),
                new Transform(" ", kUppercaseFirst, ", "),
                new Transform("", kUppercaseFirst, '"'),
                new Transform(".", kIdentity, "("),
                new Transform("", kUppercaseAll, " "),
                new Transform("", kUppercaseFirst, '">'),
                new Transform("", kIdentity, '="'),
                new Transform(" ", kIdentity, "."),
                new Transform(".com/", kIdentity, ""),
                new Transform(" the ", kIdentity, " of the "),
                new Transform("", kUppercaseFirst, "'"),
                new Transform("", kIdentity, ". This "),
                new Transform("", kIdentity, ","),
                new Transform(".", kIdentity, " "),
                new Transform("", kUppercaseFirst, "("),
                new Transform("", kUppercaseFirst, "."),
                new Transform("", kIdentity, " not "),
                new Transform(" ", kIdentity, '="'),
                new Transform("", kIdentity, "er "),
                new Transform(" ", kUppercaseAll, " "),
                new Transform("", kIdentity, "al "),
                new Transform(" ", kUppercaseAll, ""),
                new Transform("", kIdentity, "='"),
                new Transform("", kUppercaseAll, '"'),
                new Transform("", kUppercaseFirst, ". "),
                new Transform(" ", kIdentity, "("),
                new Transform("", kIdentity, "ful "),
                new Transform(" ", kUppercaseFirst, ". "),
                new Transform("", kIdentity, "ive "),
                new Transform("", kIdentity, "less "),
                new Transform("", kUppercaseAll, "'"),
                new Transform("", kIdentity, "est "),
                new Transform(" ", kUppercaseFirst, "."),
                new Transform("", kUppercaseAll, '">'),
                new Transform(" ", kIdentity, "='"),
                new Transform("", kUppercaseFirst, ","),
                new Transform("", kIdentity, "ize "),
                new Transform("", kUppercaseAll, "."),
                new Transform("", kIdentity, ""),
                new Transform(" ", kIdentity, ","),
                new Transform("", kUppercaseFirst, '="'),
                new Transform("", kUppercaseAll, '="'),
                new Transform("", kIdentity, "ous "),
                new Transform("", kUppercaseAll, ", "),
                new Transform("", kUppercaseFirst, "='"),
                new Transform(" ", kUppercaseFirst, ","),
                new Transform(" ", kUppercaseAll, '="'),
                new Transform(" ", kUppercaseAll, ", "),
                new Transform("", kUppercaseAll, ","),
                new Transform("", kUppercaseAll, "("),
                new Transform("", kUppercaseAll, ". "),
                new Transform(" ", kUppercaseAll, "."),
                new Transform("", kUppercaseAll, "='"),
                new Transform(" ", kUppercaseAll, ". "),
                new Transform(" ", kUppercaseFirst, '="'),
                new Transform(" ", kUppercaseAll, "='"),
                new Transform(" ", kUppercaseFirst, "='")
              ];
              exports2.kTransforms = kTransforms;
              exports2.kNumTransforms = kTransforms.length;
              function ToUpperCase(p, i) {
                if (p[i] < 192) {
                  if (p[i] >= 97 && p[i] <= 122) {
                    p[i] ^= 32;
                  }
                  return 1;
                }
                if (p[i] < 224) {
                  p[i + 1] ^= 32;
                  return 2;
                }
                p[i + 2] ^= 5;
                return 3;
              }
              exports2.transformDictionaryWord = function(dst, idx, word, len, transform) {
                var prefix = kTransforms[transform].prefix;
                var suffix = kTransforms[transform].suffix;
                var t = kTransforms[transform].transform;
                var skip = t < kOmitFirst1 ? 0 : t - (kOmitFirst1 - 1);
                var i = 0;
                var start_idx = idx;
                var uppercase;
                if (skip > len) {
                  skip = len;
                }
                var prefix_pos = 0;
                while (prefix_pos < prefix.length) {
                  dst[idx++] = prefix[prefix_pos++];
                }
                word += skip;
                len -= skip;
                if (t <= kOmitLast9) {
                  len -= t;
                }
                for (i = 0; i < len; i++) {
                  dst[idx++] = BrotliDictionary.dictionary[word + i];
                }
                uppercase = idx - len;
                if (t === kUppercaseFirst) {
                  ToUpperCase(dst, uppercase);
                } else if (t === kUppercaseAll) {
                  while (len > 0) {
                    var step = ToUpperCase(dst, uppercase);
                    uppercase += step;
                    len -= step;
                  }
                }
                var suffix_pos = 0;
                while (suffix_pos < suffix.length) {
                  dst[idx++] = suffix[suffix_pos++];
                }
                return idx - start_idx;
              };
            },
            /***/
            7992(module2, exports2, __webpack_require__2) {
              var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
              (function(a, b) {
                if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = b, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                else {
                }
              })(this, function() {
                "use strict";
                function b(a2, b2) {
                  return "undefined" == typeof b2 ? b2 = { autoBom: false } : "object" != typeof b2 && (console.warn("Deprecated: Expected third argument to be a object"), b2 = { autoBom: !b2 }), b2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type) ? new Blob(["\uFEFF", a2], { type: a2.type }) : a2;
                }
                function c(a2, b2, c2) {
                  var d2 = new XMLHttpRequest();
                  d2.open("GET", a2), d2.responseType = "blob", d2.onload = function() {
                    g(d2.response, b2, c2);
                  }, d2.onerror = function() {
                    console.error("could not download file");
                  }, d2.send();
                }
                function d(a2) {
                  var b2 = new XMLHttpRequest();
                  b2.open("HEAD", a2, false);
                  try {
                    b2.send();
                  } catch (a3) {
                  }
                  return 200 <= b2.status && 299 >= b2.status;
                }
                function e(a2) {
                  try {
                    a2.dispatchEvent(new MouseEvent("click"));
                  } catch (c2) {
                    var b2 = document.createEvent("MouseEvents");
                    b2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a2.dispatchEvent(b2);
                  }
                }
                var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof __webpack_require__2.g && __webpack_require__2.g.global === __webpack_require__2.g ? __webpack_require__2.g : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || ("object" != typeof window || window !== f ? function() {
                } : typeof HTMLAnchorElement !== "undefined" && "download" in HTMLAnchorElement.prototype && !a ? function(b2, g2, h) {
                  var i = f.URL || f.webkitURL, j = document.createElement("a");
                  g2 = g2 || b2.name || "download", j.download = g2, j.rel = "noopener", "string" == typeof b2 ? (j.href = b2, j.origin === location.origin ? e(j) : d(j.href) ? c(b2, g2, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b2), setTimeout(function() {
                    i.revokeObjectURL(j.href);
                  }, 4e4), setTimeout(function() {
                    e(j);
                  }, 0));
                } : "msSaveOrOpenBlob" in navigator ? function(f2, g2, h) {
                  if (g2 = g2 || f2.name || "download", "string" != typeof f2) navigator.msSaveOrOpenBlob(b(f2, h), g2);
                  else if (d(f2)) c(f2, g2, h);
                  else {
                    var i = document.createElement("a");
                    i.href = f2, i.target = "_blank", setTimeout(function() {
                      e(i);
                    });
                  }
                } : function(b2, d2, e2, g2) {
                  if (g2 = g2 || open("", "_blank"), g2 && (g2.document.title = g2.document.body.innerText = "downloading..."), "string" == typeof b2) return c(b2, d2, e2);
                  var h = "application/octet-stream" === b2.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
                  if ((j || h && i || a) && "undefined" != typeof FileReader) {
                    var k = new FileReader();
                    k.onloadend = function() {
                      var a2 = k.result;
                      a2 = j ? a2 : a2.replace(/^data:[^;]*;/, "data:attachment/file;"), g2 ? g2.location.href = a2 : location = a2, g2 = null;
                    }, k.readAsDataURL(b2);
                  } else {
                    var l = f.URL || f.webkitURL, m = l.createObjectURL(b2);
                    g2 ? g2.location = m : location.href = m, g2 = null, setTimeout(function() {
                      l.revokeObjectURL(m);
                    }, 4e4);
                  }
                });
                f.saveAs = g.saveAs = g, module2.exports = g;
              });
            },
            /***/
            8109(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var $gOPD = __webpack_require__2(5567);
              if ($gOPD) {
                try {
                  $gOPD([], "length");
                } catch (e) {
                  $gOPD = null;
                }
              }
              module2.exports = $gOPD;
            },
            /***/
            8115(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var globalThis2 = __webpack_require__2(7756);
              var navigator2 = globalThis2.navigator;
              var userAgent = navigator2 && navigator2.userAgent;
              module2.exports = userAgent ? String(userAgent) : "";
            },
            /***/
            8130(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var ERR_INVALID_OPT_VALUE = __webpack_require__2(3797).F.ERR_INVALID_OPT_VALUE;
              function highWaterMarkFrom(options, isDuplex, duplexKey) {
                return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
              }
              function getHighWaterMark(state, options, duplexKey, isDuplex) {
                var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
                if (hwm != null) {
                  if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
                    var name = isDuplex ? duplexKey : "highWaterMark";
                    throw new ERR_INVALID_OPT_VALUE(name, hwm);
                  }
                  return Math.floor(hwm);
                }
                return state.objectMode ? 16 : 16 * 1024;
              }
              module2.exports = {
                getHighWaterMark
              };
            },
            /***/
            8197(__unused_webpack_module, exports2) {
              function BrotliInput(buffer) {
                this.buffer = buffer;
                this.pos = 0;
              }
              BrotliInput.prototype.read = function(buf, i, count) {
                if (this.pos + count > this.buffer.length) {
                  count = this.buffer.length - this.pos;
                }
                for (var p = 0; p < count; p++)
                  buf[i + p] = this.buffer[this.pos + p];
                this.pos += count;
                return count;
              };
              exports2.z = BrotliInput;
              function BrotliOutput(buf) {
                this.buffer = buf;
                this.pos = 0;
              }
              BrotliOutput.prototype.write = function(buf, count) {
                if (this.pos + count > this.buffer.length)
                  throw new Error("Output buffer is not large enough");
                this.buffer.set(buf.subarray(0, count), this.pos);
                this.pos += count;
                return count;
              };
              exports2.y = BrotliOutput;
            },
            /***/
            8261(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var process = __webpack_require__2(9964);
              module2.exports = Readable;
              var Duplex;
              Readable.ReadableState = ReadableState;
              var EE = __webpack_require__2(4785).EventEmitter;
              var EElistenerCount = function EElistenerCount2(emitter, type) {
                return emitter.listeners(type).length;
              };
              var Stream = __webpack_require__2(9018);
              var Buffer = __webpack_require__2(783).Buffer;
              var OurUint8Array = (typeof __webpack_require__2.g !== "undefined" ? __webpack_require__2.g : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
              };
              function _uint8ArrayToBuffer(chunk) {
                return Buffer.from(chunk);
              }
              function _isUint8Array(obj) {
                return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
              }
              var debugUtil = __webpack_require__2(7199);
              var debug;
              if (debugUtil && debugUtil.debuglog) {
                debug = debugUtil.debuglog("stream");
              } else {
                debug = function debug2() {
                };
              }
              var BufferList = __webpack_require__2(182);
              var destroyImpl = __webpack_require__2(7385);
              var _require = __webpack_require__2(8130), getHighWaterMark = _require.getHighWaterMark;
              var _require$codes = __webpack_require__2(3797).F, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
              var StringDecoder;
              var createReadableStreamAsyncIterator;
              var from;
              __webpack_require__2(9784)(Readable, Stream);
              var errorOrDestroy = destroyImpl.errorOrDestroy;
              var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
              function prependListener(emitter, event, fn) {
                if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
                if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
                else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
                else emitter._events[event] = [fn, emitter._events[event]];
              }
              function ReadableState(options, stream, isDuplex) {
                Duplex = Duplex || __webpack_require__2(4903);
                options = options || {};
                if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
                this.objectMode = !!options.objectMode;
                if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
                this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
                this.buffer = new BufferList();
                this.length = 0;
                this.pipes = null;
                this.pipesCount = 0;
                this.flowing = null;
                this.ended = false;
                this.endEmitted = false;
                this.reading = false;
                this.sync = true;
                this.needReadable = false;
                this.emittedReadable = false;
                this.readableListening = false;
                this.resumeScheduled = false;
                this.paused = true;
                this.emitClose = options.emitClose !== false;
                this.autoDestroy = !!options.autoDestroy;
                this.destroyed = false;
                this.defaultEncoding = options.defaultEncoding || "utf8";
                this.awaitDrain = 0;
                this.readingMore = false;
                this.decoder = null;
                this.encoding = null;
                if (options.encoding) {
                  if (!StringDecoder) StringDecoder = __webpack_require__2(3143).I;
                  this.decoder = new StringDecoder(options.encoding);
                  this.encoding = options.encoding;
                }
              }
              function Readable(options) {
                Duplex = Duplex || __webpack_require__2(4903);
                if (!(this instanceof Readable)) return new Readable(options);
                var isDuplex = this instanceof Duplex;
                this._readableState = new ReadableState(options, this, isDuplex);
                this.readable = true;
                if (options) {
                  if (typeof options.read === "function") this._read = options.read;
                  if (typeof options.destroy === "function") this._destroy = options.destroy;
                }
                Stream.call(this);
              }
              Object.defineProperty(Readable.prototype, "destroyed", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  if (this._readableState === void 0) {
                    return false;
                  }
                  return this._readableState.destroyed;
                },
                set: function set(value) {
                  if (!this._readableState) {
                    return;
                  }
                  this._readableState.destroyed = value;
                }
              });
              Readable.prototype.destroy = destroyImpl.destroy;
              Readable.prototype._undestroy = destroyImpl.undestroy;
              Readable.prototype._destroy = function(err, cb) {
                cb(err);
              };
              Readable.prototype.push = function(chunk, encoding) {
                var state = this._readableState;
                var skipChunkCheck;
                if (!state.objectMode) {
                  if (typeof chunk === "string") {
                    encoding = encoding || state.defaultEncoding;
                    if (encoding !== state.encoding) {
                      chunk = Buffer.from(chunk, encoding);
                      encoding = "";
                    }
                    skipChunkCheck = true;
                  }
                } else {
                  skipChunkCheck = true;
                }
                return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
              };
              Readable.prototype.unshift = function(chunk) {
                return readableAddChunk(this, chunk, null, true, false);
              };
              function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
                debug("readableAddChunk", chunk);
                var state = stream._readableState;
                if (chunk === null) {
                  state.reading = false;
                  onEofChunk(stream, state);
                } else {
                  var er;
                  if (!skipChunkCheck) er = chunkInvalid(state, chunk);
                  if (er) {
                    errorOrDestroy(stream, er);
                  } else if (state.objectMode || chunk && chunk.length > 0) {
                    if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                      chunk = _uint8ArrayToBuffer(chunk);
                    }
                    if (addToFront) {
                      if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                      else addChunk(stream, state, chunk, true);
                    } else if (state.ended) {
                      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
                    } else if (state.destroyed) {
                      return false;
                    } else {
                      state.reading = false;
                      if (state.decoder && !encoding) {
                        chunk = state.decoder.write(chunk);
                        if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                        else maybeReadMore(stream, state);
                      } else {
                        addChunk(stream, state, chunk, false);
                      }
                    }
                  } else if (!addToFront) {
                    state.reading = false;
                    maybeReadMore(stream, state);
                  }
                }
                return !state.ended && (state.length < state.highWaterMark || state.length === 0);
              }
              function addChunk(stream, state, chunk, addToFront) {
                if (state.flowing && state.length === 0 && !state.sync) {
                  state.awaitDrain = 0;
                  stream.emit("data", chunk);
                } else {
                  state.length += state.objectMode ? 1 : chunk.length;
                  if (addToFront) state.buffer.unshift(chunk);
                  else state.buffer.push(chunk);
                  if (state.needReadable) emitReadable(stream);
                }
                maybeReadMore(stream, state);
              }
              function chunkInvalid(state, chunk) {
                var er;
                if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
                  er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
                }
                return er;
              }
              Readable.prototype.isPaused = function() {
                return this._readableState.flowing === false;
              };
              Readable.prototype.setEncoding = function(enc) {
                if (!StringDecoder) StringDecoder = __webpack_require__2(3143).I;
                var decoder = new StringDecoder(enc);
                this._readableState.decoder = decoder;
                this._readableState.encoding = this._readableState.decoder.encoding;
                var p = this._readableState.buffer.head;
                var content = "";
                while (p !== null) {
                  content += decoder.write(p.data);
                  p = p.next;
                }
                this._readableState.buffer.clear();
                if (content !== "") this._readableState.buffer.push(content);
                this._readableState.length = content.length;
                return this;
              };
              var MAX_HWM = 1073741824;
              function computeNewHighWaterMark(n) {
                if (n >= MAX_HWM) {
                  n = MAX_HWM;
                } else {
                  n--;
                  n |= n >>> 1;
                  n |= n >>> 2;
                  n |= n >>> 4;
                  n |= n >>> 8;
                  n |= n >>> 16;
                  n++;
                }
                return n;
              }
              function howMuchToRead(n, state) {
                if (n <= 0 || state.length === 0 && state.ended) return 0;
                if (state.objectMode) return 1;
                if (n !== n) {
                  if (state.flowing && state.length) return state.buffer.head.data.length;
                  else return state.length;
                }
                if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
                if (n <= state.length) return n;
                if (!state.ended) {
                  state.needReadable = true;
                  return 0;
                }
                return state.length;
              }
              Readable.prototype.read = function(n) {
                debug("read", n);
                n = parseInt(n, 10);
                var state = this._readableState;
                var nOrig = n;
                if (n !== 0) state.emittedReadable = false;
                if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
                  debug("read: emitReadable", state.length, state.ended);
                  if (state.length === 0 && state.ended) endReadable(this);
                  else emitReadable(this);
                  return null;
                }
                n = howMuchToRead(n, state);
                if (n === 0 && state.ended) {
                  if (state.length === 0) endReadable(this);
                  return null;
                }
                var doRead = state.needReadable;
                debug("need readable", doRead);
                if (state.length === 0 || state.length - n < state.highWaterMark) {
                  doRead = true;
                  debug("length less than watermark", doRead);
                }
                if (state.ended || state.reading) {
                  doRead = false;
                  debug("reading or ended", doRead);
                } else if (doRead) {
                  debug("do read");
                  state.reading = true;
                  state.sync = true;
                  if (state.length === 0) state.needReadable = true;
                  this._read(state.highWaterMark);
                  state.sync = false;
                  if (!state.reading) n = howMuchToRead(nOrig, state);
                }
                var ret;
                if (n > 0) ret = fromList(n, state);
                else ret = null;
                if (ret === null) {
                  state.needReadable = state.length <= state.highWaterMark;
                  n = 0;
                } else {
                  state.length -= n;
                  state.awaitDrain = 0;
                }
                if (state.length === 0) {
                  if (!state.ended) state.needReadable = true;
                  if (nOrig !== n && state.ended) endReadable(this);
                }
                if (ret !== null) this.emit("data", ret);
                return ret;
              };
              function onEofChunk(stream, state) {
                debug("onEofChunk");
                if (state.ended) return;
                if (state.decoder) {
                  var chunk = state.decoder.end();
                  if (chunk && chunk.length) {
                    state.buffer.push(chunk);
                    state.length += state.objectMode ? 1 : chunk.length;
                  }
                }
                state.ended = true;
                if (state.sync) {
                  emitReadable(stream);
                } else {
                  state.needReadable = false;
                  if (!state.emittedReadable) {
                    state.emittedReadable = true;
                    emitReadable_(stream);
                  }
                }
              }
              function emitReadable(stream) {
                var state = stream._readableState;
                debug("emitReadable", state.needReadable, state.emittedReadable);
                state.needReadable = false;
                if (!state.emittedReadable) {
                  debug("emitReadable", state.flowing);
                  state.emittedReadable = true;
                  process.nextTick(emitReadable_, stream);
                }
              }
              function emitReadable_(stream) {
                var state = stream._readableState;
                debug("emitReadable_", state.destroyed, state.length, state.ended);
                if (!state.destroyed && (state.length || state.ended)) {
                  stream.emit("readable");
                  state.emittedReadable = false;
                }
                state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
                flow(stream);
              }
              function maybeReadMore(stream, state) {
                if (!state.readingMore) {
                  state.readingMore = true;
                  process.nextTick(maybeReadMore_, stream, state);
                }
              }
              function maybeReadMore_(stream, state) {
                while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
                  var len = state.length;
                  debug("maybeReadMore read 0");
                  stream.read(0);
                  if (len === state.length)
                    break;
                }
                state.readingMore = false;
              }
              Readable.prototype._read = function(n) {
                errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
              };
              Readable.prototype.pipe = function(dest, pipeOpts) {
                var src = this;
                var state = this._readableState;
                switch (state.pipesCount) {
                  case 0:
                    state.pipes = dest;
                    break;
                  case 1:
                    state.pipes = [state.pipes, dest];
                    break;
                  default:
                    state.pipes.push(dest);
                    break;
                }
                state.pipesCount += 1;
                debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
                var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
                var endFn = doEnd ? onend : unpipe;
                if (state.endEmitted) process.nextTick(endFn);
                else src.once("end", endFn);
                dest.on("unpipe", onunpipe);
                function onunpipe(readable, unpipeInfo) {
                  debug("onunpipe");
                  if (readable === src) {
                    if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                      unpipeInfo.hasUnpiped = true;
                      cleanup();
                    }
                  }
                }
                function onend() {
                  debug("onend");
                  dest.end();
                }
                var ondrain = pipeOnDrain(src);
                dest.on("drain", ondrain);
                var cleanedUp = false;
                function cleanup() {
                  debug("cleanup");
                  dest.removeListener("close", onclose);
                  dest.removeListener("finish", onfinish);
                  dest.removeListener("drain", ondrain);
                  dest.removeListener("error", onerror);
                  dest.removeListener("unpipe", onunpipe);
                  src.removeListener("end", onend);
                  src.removeListener("end", unpipe);
                  src.removeListener("data", ondata);
                  cleanedUp = true;
                  if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
                }
                src.on("data", ondata);
                function ondata(chunk) {
                  debug("ondata");
                  var ret = dest.write(chunk);
                  debug("dest.write", ret);
                  if (ret === false) {
                    if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                      debug("false write response, pause", state.awaitDrain);
                      state.awaitDrain++;
                    }
                    src.pause();
                  }
                }
                function onerror(er) {
                  debug("onerror", er);
                  unpipe();
                  dest.removeListener("error", onerror);
                  if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
                }
                prependListener(dest, "error", onerror);
                function onclose() {
                  dest.removeListener("finish", onfinish);
                  unpipe();
                }
                dest.once("close", onclose);
                function onfinish() {
                  debug("onfinish");
                  dest.removeListener("close", onclose);
                  unpipe();
                }
                dest.once("finish", onfinish);
                function unpipe() {
                  debug("unpipe");
                  src.unpipe(dest);
                }
                dest.emit("pipe", src);
                if (!state.flowing) {
                  debug("pipe resume");
                  src.resume();
                }
                return dest;
              };
              function pipeOnDrain(src) {
                return function pipeOnDrainFunctionResult() {
                  var state = src._readableState;
                  debug("pipeOnDrain", state.awaitDrain);
                  if (state.awaitDrain) state.awaitDrain--;
                  if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                    state.flowing = true;
                    flow(src);
                  }
                };
              }
              Readable.prototype.unpipe = function(dest) {
                var state = this._readableState;
                var unpipeInfo = {
                  hasUnpiped: false
                };
                if (state.pipesCount === 0) return this;
                if (state.pipesCount === 1) {
                  if (dest && dest !== state.pipes) return this;
                  if (!dest) dest = state.pipes;
                  state.pipes = null;
                  state.pipesCount = 0;
                  state.flowing = false;
                  if (dest) dest.emit("unpipe", this, unpipeInfo);
                  return this;
                }
                if (!dest) {
                  var dests = state.pipes;
                  var len = state.pipesCount;
                  state.pipes = null;
                  state.pipesCount = 0;
                  state.flowing = false;
                  for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
                    hasUnpiped: false
                  });
                  return this;
                }
                var index = indexOf(state.pipes, dest);
                if (index === -1) return this;
                state.pipes.splice(index, 1);
                state.pipesCount -= 1;
                if (state.pipesCount === 1) state.pipes = state.pipes[0];
                dest.emit("unpipe", this, unpipeInfo);
                return this;
              };
              Readable.prototype.on = function(ev, fn) {
                var res = Stream.prototype.on.call(this, ev, fn);
                var state = this._readableState;
                if (ev === "data") {
                  state.readableListening = this.listenerCount("readable") > 0;
                  if (state.flowing !== false) this.resume();
                } else if (ev === "readable") {
                  if (!state.endEmitted && !state.readableListening) {
                    state.readableListening = state.needReadable = true;
                    state.flowing = false;
                    state.emittedReadable = false;
                    debug("on readable", state.length, state.reading);
                    if (state.length) {
                      emitReadable(this);
                    } else if (!state.reading) {
                      process.nextTick(nReadingNextTick, this);
                    }
                  }
                }
                return res;
              };
              Readable.prototype.addListener = Readable.prototype.on;
              Readable.prototype.removeListener = function(ev, fn) {
                var res = Stream.prototype.removeListener.call(this, ev, fn);
                if (ev === "readable") {
                  process.nextTick(updateReadableListening, this);
                }
                return res;
              };
              Readable.prototype.removeAllListeners = function(ev) {
                var res = Stream.prototype.removeAllListeners.apply(this, arguments);
                if (ev === "readable" || ev === void 0) {
                  process.nextTick(updateReadableListening, this);
                }
                return res;
              };
              function updateReadableListening(self2) {
                var state = self2._readableState;
                state.readableListening = self2.listenerCount("readable") > 0;
                if (state.resumeScheduled && !state.paused) {
                  state.flowing = true;
                } else if (self2.listenerCount("data") > 0) {
                  self2.resume();
                }
              }
              function nReadingNextTick(self2) {
                debug("readable nexttick read 0");
                self2.read(0);
              }
              Readable.prototype.resume = function() {
                var state = this._readableState;
                if (!state.flowing) {
                  debug("resume");
                  state.flowing = !state.readableListening;
                  resume(this, state);
                }
                state.paused = false;
                return this;
              };
              function resume(stream, state) {
                if (!state.resumeScheduled) {
                  state.resumeScheduled = true;
                  process.nextTick(resume_, stream, state);
                }
              }
              function resume_(stream, state) {
                debug("resume", state.reading);
                if (!state.reading) {
                  stream.read(0);
                }
                state.resumeScheduled = false;
                stream.emit("resume");
                flow(stream);
                if (state.flowing && !state.reading) stream.read(0);
              }
              Readable.prototype.pause = function() {
                debug("call pause flowing=%j", this._readableState.flowing);
                if (this._readableState.flowing !== false) {
                  debug("pause");
                  this._readableState.flowing = false;
                  this.emit("pause");
                }
                this._readableState.paused = true;
                return this;
              };
              function flow(stream) {
                var state = stream._readableState;
                debug("flow", state.flowing);
                while (state.flowing && stream.read() !== null) ;
              }
              Readable.prototype.wrap = function(stream) {
                var _this = this;
                var state = this._readableState;
                var paused = false;
                stream.on("end", function() {
                  debug("wrapped end");
                  if (state.decoder && !state.ended) {
                    var chunk = state.decoder.end();
                    if (chunk && chunk.length) _this.push(chunk);
                  }
                  _this.push(null);
                });
                stream.on("data", function(chunk) {
                  debug("wrapped data");
                  if (state.decoder) chunk = state.decoder.write(chunk);
                  if (state.objectMode && (chunk === null || chunk === void 0)) return;
                  else if (!state.objectMode && (!chunk || !chunk.length)) return;
                  var ret = _this.push(chunk);
                  if (!ret) {
                    paused = true;
                    stream.pause();
                  }
                });
                for (var i in stream) {
                  if (this[i] === void 0 && typeof stream[i] === "function") {
                    this[i] = /* @__PURE__ */ function methodWrap(method) {
                      return function methodWrapReturnFunction() {
                        return stream[method].apply(stream, arguments);
                      };
                    }(i);
                  }
                }
                for (var n = 0; n < kProxyEvents.length; n++) {
                  stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
                }
                this._read = function(n2) {
                  debug("wrapped _read", n2);
                  if (paused) {
                    paused = false;
                    stream.resume();
                  }
                };
                return this;
              };
              if (typeof Symbol === "function") {
                Readable.prototype[Symbol.asyncIterator] = function() {
                  if (createReadableStreamAsyncIterator === void 0) {
                    createReadableStreamAsyncIterator = __webpack_require__2(9676);
                  }
                  return createReadableStreamAsyncIterator(this);
                };
              }
              Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._readableState.highWaterMark;
                }
              });
              Object.defineProperty(Readable.prototype, "readableBuffer", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._readableState && this._readableState.buffer;
                }
              });
              Object.defineProperty(Readable.prototype, "readableFlowing", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._readableState.flowing;
                },
                set: function set(state) {
                  if (this._readableState) {
                    this._readableState.flowing = state;
                  }
                }
              });
              Readable._fromList = fromList;
              Object.defineProperty(Readable.prototype, "readableLength", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._readableState.length;
                }
              });
              function fromList(n, state) {
                if (state.length === 0) return null;
                var ret;
                if (state.objectMode) ret = state.buffer.shift();
                else if (!n || n >= state.length) {
                  if (state.decoder) ret = state.buffer.join("");
                  else if (state.buffer.length === 1) ret = state.buffer.first();
                  else ret = state.buffer.concat(state.length);
                  state.buffer.clear();
                } else {
                  ret = state.buffer.consume(n, state.decoder);
                }
                return ret;
              }
              function endReadable(stream) {
                var state = stream._readableState;
                debug("endReadable", state.endEmitted);
                if (!state.endEmitted) {
                  state.ended = true;
                  process.nextTick(endReadableNT, state, stream);
                }
              }
              function endReadableNT(state, stream) {
                debug("endReadableNT", state.endEmitted, state.length);
                if (!state.endEmitted && state.length === 0) {
                  state.endEmitted = true;
                  stream.readable = false;
                  stream.emit("end");
                  if (state.autoDestroy) {
                    var wState = stream._writableState;
                    if (!wState || wState.autoDestroy && wState.finished) {
                      stream.destroy();
                    }
                  }
                }
              }
              if (typeof Symbol === "function") {
                Readable.from = function(iterable, opts) {
                  if (from === void 0) {
                    from = __webpack_require__2(378);
                  }
                  return from(Readable, iterable, opts);
                };
              }
              function indexOf(xs, x) {
                for (var i = 0, l = xs.length; i < l; i++) {
                  if (xs[i] === x) return i;
                }
                return -1;
              }
            },
            /***/
            8264(module2) {
              "use strict";
              module2.exports = function(bitmap, value) {
                return {
                  enumerable: !(bitmap & 1),
                  configurable: !(bitmap & 2),
                  writable: !(bitmap & 4),
                  value
                };
              };
            },
            /***/
            8266(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var toIntegerOrInfinity = __webpack_require__2(2119);
              var min = Math.min;
              module2.exports = function(argument) {
                var len = toIntegerOrInfinity(argument);
                return len > 0 ? min(len, 9007199254740991) : 0;
              };
            },
            /***/
            8300(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var NATIVE_SYMBOL = __webpack_require__2(4483);
              module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
            },
            /***/
            8358(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(2858));
                } else {
                }
              })(void 0, function(CryptoJS) {
                CryptoJS.mode.ECB = function() {
                  var ECB = CryptoJS.lib.BlockCipherMode.extend();
                  ECB.Encryptor = ECB.extend({
                    processBlock: function(words, offset) {
                      this._cipher.encryptBlock(words, offset);
                    }
                  });
                  ECB.Decryptor = ECB.extend({
                    processBlock: function(words, offset) {
                      this._cipher.decryptBlock(words, offset);
                    }
                  });
                  return ECB;
                }();
                return CryptoJS.mode.ECB;
              });
            },
            /***/
            8376(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var ArrayBufferViewCore = __webpack_require__2(4074);
              var $fill = __webpack_require__2(3161);
              var toBigInt = __webpack_require__2(3018);
              var classof = __webpack_require__2(9391);
              var call = __webpack_require__2(8993);
              var uncurryThis = __webpack_require__2(1212);
              var fails = __webpack_require__2(299);
              var aTypedArray = ArrayBufferViewCore.aTypedArray;
              var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
              var slice = uncurryThis("".slice);
              var CONVERSION_BUG = fails(function() {
                var count = 0;
                new Int8Array(2).fill({ valueOf: function() {
                  return count++;
                } });
                return count !== 1;
              });
              exportTypedArrayMethod("fill", function fill(value) {
                var length = arguments.length;
                aTypedArray(this);
                var actualValue = slice(classof(this), 0, 3) === "Big" ? toBigInt(value) : +value;
                return call($fill, this, actualValue, length > 1 ? arguments[1] : void 0, length > 2 ? arguments[2] : void 0);
              }, CONVERSION_BUG);
            },
            /***/
            8395(__unused_webpack_module, exports2, __webpack_require__2) {
              "use strict";
              exports2._ = __webpack_require__2(1635).__decorate;
            },
            /***/
            8404(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var isCallable = __webpack_require__2(3746);
              var toStr = Object.prototype.toString;
              var hasOwnProperty = Object.prototype.hasOwnProperty;
              var forEachArray = function forEachArray2(array, iterator, receiver) {
                for (var i = 0, len = array.length; i < len; i++) {
                  if (hasOwnProperty.call(array, i)) {
                    if (receiver == null) {
                      iterator(array[i], i, array);
                    } else {
                      iterator.call(receiver, array[i], i, array);
                    }
                  }
                }
              };
              var forEachString = function forEachString2(string, iterator, receiver) {
                for (var i = 0, len = string.length; i < len; i++) {
                  if (receiver == null) {
                    iterator(string.charAt(i), i, string);
                  } else {
                    iterator.call(receiver, string.charAt(i), i, string);
                  }
                }
              };
              var forEachObject = function forEachObject2(object, iterator, receiver) {
                for (var k in object) {
                  if (hasOwnProperty.call(object, k)) {
                    if (receiver == null) {
                      iterator(object[k], k, object);
                    } else {
                      iterator.call(receiver, object[k], k, object);
                    }
                  }
                }
              };
              function isArray(x) {
                return toStr.call(x) === "[object Array]";
              }
              module2.exports = function forEach(list, iterator, thisArg) {
                if (!isCallable(iterator)) {
                  throw new TypeError("iterator must be a function");
                }
                var receiver;
                if (arguments.length >= 3) {
                  receiver = thisArg;
                }
                if (isArray(list)) {
                  forEachArray(list, iterator, receiver);
                } else if (typeof list === "string") {
                  forEachString(list, iterator, receiver);
                } else {
                  forEachObject(list, iterator, receiver);
                }
              };
            },
            /***/
            8420(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var uncurryThis = __webpack_require__2(1212);
              var toString = uncurryThis({}.toString);
              var stringSlice = uncurryThis("".slice);
              module2.exports = function(it) {
                return stringSlice(toString(it), 8, -1);
              };
            },
            /***/
            8461(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var keysShim;
              if (!Object.keys) {
                var has = Object.prototype.hasOwnProperty;
                var toStr = Object.prototype.toString;
                var isArgs = __webpack_require__2(6515);
                var isEnumerable = Object.prototype.propertyIsEnumerable;
                var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
                var hasProtoEnumBug = isEnumerable.call(function() {
                }, "prototype");
                var dontEnums = [
                  "toString",
                  "toLocaleString",
                  "valueOf",
                  "hasOwnProperty",
                  "isPrototypeOf",
                  "propertyIsEnumerable",
                  "constructor"
                ];
                var equalsConstructorPrototype = function(o) {
                  var ctor = o.constructor;
                  return ctor && ctor.prototype === o;
                };
                var excludedKeys = {
                  $applicationCache: true,
                  $console: true,
                  $external: true,
                  $frame: true,
                  $frameElement: true,
                  $frames: true,
                  $innerHeight: true,
                  $innerWidth: true,
                  $onmozfullscreenchange: true,
                  $onmozfullscreenerror: true,
                  $outerHeight: true,
                  $outerWidth: true,
                  $pageXOffset: true,
                  $pageYOffset: true,
                  $parent: true,
                  $scrollLeft: true,
                  $scrollTop: true,
                  $scrollX: true,
                  $scrollY: true,
                  $self: true,
                  $webkitIndexedDB: true,
                  $webkitStorageInfo: true,
                  $window: true
                };
                var hasAutomationEqualityBug = function() {
                  if (typeof window === "undefined") {
                    return false;
                  }
                  for (var k in window) {
                    try {
                      if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
                        try {
                          equalsConstructorPrototype(window[k]);
                        } catch (e) {
                          return true;
                        }
                      }
                    } catch (e) {
                      return true;
                    }
                  }
                  return false;
                }();
                var equalsConstructorPrototypeIfNotBuggy = function(o) {
                  if (typeof window === "undefined" || !hasAutomationEqualityBug) {
                    return equalsConstructorPrototype(o);
                  }
                  try {
                    return equalsConstructorPrototype(o);
                  } catch (e) {
                    return false;
                  }
                };
                keysShim = function keys(object) {
                  var isObject = object !== null && typeof object === "object";
                  var isFunction = toStr.call(object) === "[object Function]";
                  var isArguments = isArgs(object);
                  var isString = isObject && toStr.call(object) === "[object String]";
                  var theKeys = [];
                  if (!isObject && !isFunction && !isArguments) {
                    throw new TypeError("Object.keys called on a non-object");
                  }
                  var skipProto = hasProtoEnumBug && isFunction;
                  if (isString && object.length > 0 && !has.call(object, 0)) {
                    for (var i = 0; i < object.length; ++i) {
                      theKeys.push(String(i));
                    }
                  }
                  if (isArguments && object.length > 0) {
                    for (var j = 0; j < object.length; ++j) {
                      theKeys.push(String(j));
                    }
                  } else {
                    for (var name in object) {
                      if (!(skipProto && name === "prototype") && has.call(object, name)) {
                        theKeys.push(String(name));
                      }
                    }
                  }
                  if (hasDontEnumBug) {
                    var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                    for (var k = 0; k < dontEnums.length; ++k) {
                      if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
                        theKeys.push(dontEnums[k]);
                      }
                    }
                  }
                  return theKeys;
                };
              }
              module2.exports = keysShim;
            },
            /***/
            8468(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var classof = __webpack_require__2(8420);
              module2.exports = Array.isArray || function isArray(argument) {
                return classof(argument) === "Array";
              };
            },
            /***/
            8527(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var define2 = __webpack_require__2(5421);
              var callBind = __webpack_require__2(6601);
              var implementation = __webpack_require__2(3249);
              var getPolyfill = __webpack_require__2(9636);
              var shim = __webpack_require__2(3534);
              var polyfill = callBind(getPolyfill(), Object);
              define2(polyfill, {
                getPolyfill,
                implementation,
                shim
              });
              module2.exports = polyfill;
            },
            /***/
            8569(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              module2.exports = Transform;
              var _require$codes = __webpack_require__2(3797).F, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
              var Duplex = __webpack_require__2(4903);
              __webpack_require__2(9784)(Transform, Duplex);
              function afterTransform(er, data) {
                var ts = this._transformState;
                ts.transforming = false;
                var cb = ts.writecb;
                if (cb === null) {
                  return this.emit("error", new ERR_MULTIPLE_CALLBACK());
                }
                ts.writechunk = null;
                ts.writecb = null;
                if (data != null)
                  this.push(data);
                cb(er);
                var rs = this._readableState;
                rs.reading = false;
                if (rs.needReadable || rs.length < rs.highWaterMark) {
                  this._read(rs.highWaterMark);
                }
              }
              function Transform(options) {
                if (!(this instanceof Transform)) return new Transform(options);
                Duplex.call(this, options);
                this._transformState = {
                  afterTransform: afterTransform.bind(this),
                  needTransform: false,
                  transforming: false,
                  writecb: null,
                  writechunk: null,
                  writeencoding: null
                };
                this._readableState.needReadable = true;
                this._readableState.sync = false;
                if (options) {
                  if (typeof options.transform === "function") this._transform = options.transform;
                  if (typeof options.flush === "function") this._flush = options.flush;
                }
                this.on("prefinish", prefinish);
              }
              function prefinish() {
                var _this = this;
                if (typeof this._flush === "function" && !this._readableState.destroyed) {
                  this._flush(function(er, data) {
                    done(_this, er, data);
                  });
                } else {
                  done(this, null, null);
                }
              }
              Transform.prototype.push = function(chunk, encoding) {
                this._transformState.needTransform = false;
                return Duplex.prototype.push.call(this, chunk, encoding);
              };
              Transform.prototype._transform = function(chunk, encoding, cb) {
                cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
              };
              Transform.prototype._write = function(chunk, encoding, cb) {
                var ts = this._transformState;
                ts.writecb = cb;
                ts.writechunk = chunk;
                ts.writeencoding = encoding;
                if (!ts.transforming) {
                  var rs = this._readableState;
                  if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
                }
              };
              Transform.prototype._read = function(n) {
                var ts = this._transformState;
                if (ts.writechunk !== null && !ts.transforming) {
                  ts.transforming = true;
                  this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
                } else {
                  ts.needTransform = true;
                }
              };
              Transform.prototype._destroy = function(err, cb) {
                Duplex.prototype._destroy.call(this, err, function(err2) {
                  cb(err2);
                });
              };
              function done(stream, er, data) {
                if (er) return stream.emit("error", er);
                if (data != null)
                  stream.push(data);
                if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
                if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
                return stream.push(null);
              }
            },
            /***/
            8607(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var hasOwn = __webpack_require__2(6341);
              var isCallable = __webpack_require__2(8681);
              var toObject = __webpack_require__2(3297);
              var sharedKey = __webpack_require__2(7099);
              var CORRECT_PROTOTYPE_GETTER = __webpack_require__2(5071);
              var IE_PROTO = sharedKey("IE_PROTO");
              var $Object = Object;
              var ObjectPrototype = $Object.prototype;
              module2.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
                var object = toObject(O);
                if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
                var constructor = object.constructor;
                if (isCallable(constructor) && object instanceof constructor) {
                  return constructor.prototype;
                }
                return object instanceof $Object ? ObjectPrototype : null;
              };
            },
            /***/
            8619(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var bind = __webpack_require__2(5049);
              var $apply = __webpack_require__2(3036);
              var actualApply = __webpack_require__2(7802);
              module2.exports = function applyBind() {
                return actualApply(bind, $apply, arguments);
              };
            },
            /***/
            8651(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var undefined2;
              var $Object = __webpack_require__2(5846);
              var $Error = __webpack_require__2(5293);
              var $EvalError = __webpack_require__2(9055);
              var $RangeError = __webpack_require__2(8888);
              var $ReferenceError = __webpack_require__2(7900);
              var $SyntaxError = __webpack_require__2(7770);
              var $TypeError = __webpack_require__2(6785);
              var $URIError = __webpack_require__2(4055);
              var abs = __webpack_require__2(716);
              var floor = __webpack_require__2(7450);
              var max = __webpack_require__2(3774);
              var min = __webpack_require__2(7552);
              var pow = __webpack_require__2(5874);
              var round = __webpack_require__2(9292);
              var sign = __webpack_require__2(6071);
              var $Function = Function;
              var getEvalledConstructor = function(expressionSyntax) {
                try {
                  return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
                } catch (e) {
                }
              };
              var $gOPD = __webpack_require__2(8109);
              var $defineProperty = __webpack_require__2(6649);
              var throwTypeError = function() {
                throw new $TypeError();
              };
              var ThrowTypeError = $gOPD ? function() {
                try {
                  arguments.callee;
                  return throwTypeError;
                } catch (calleeThrows) {
                  try {
                    return $gOPD(arguments, "callee").get;
                  } catch (gOPDthrows) {
                    return throwTypeError;
                  }
                }
              }() : throwTypeError;
              var hasSymbols = __webpack_require__2(3257)();
              var getProto = __webpack_require__2(7106);
              var $ObjectGPO = __webpack_require__2(3766);
              var $ReflectGPO = __webpack_require__2(6822);
              var $apply = __webpack_require__2(3036);
              var $call = __webpack_require__2(78);
              var needsEval = {};
              var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
              var INTRINSICS = {
                __proto__: null,
                "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
                "%Array%": Array,
                "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
                "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
                "%AsyncFromSyncIteratorPrototype%": undefined2,
                "%AsyncFunction%": needsEval,
                "%AsyncGenerator%": needsEval,
                "%AsyncGeneratorFunction%": needsEval,
                "%AsyncIteratorPrototype%": needsEval,
                "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
                "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
                "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
                "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
                "%Boolean%": Boolean,
                "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
                "%Date%": Date,
                "%decodeURI%": decodeURI,
                "%decodeURIComponent%": decodeURIComponent,
                "%encodeURI%": encodeURI,
                "%encodeURIComponent%": encodeURIComponent,
                "%Error%": $Error,
                "%eval%": eval,
                // eslint-disable-line no-eval
                "%EvalError%": $EvalError,
                "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
                "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
                "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
                "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
                "%Function%": $Function,
                "%GeneratorFunction%": needsEval,
                "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
                "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
                "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
                "%isFinite%": isFinite,
                "%isNaN%": isNaN,
                "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
                "%JSON%": typeof JSON === "object" ? JSON : undefined2,
                "%Map%": typeof Map === "undefined" ? undefined2 : Map,
                "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
                "%Math%": Math,
                "%Number%": Number,
                "%Object%": $Object,
                "%Object.getOwnPropertyDescriptor%": $gOPD,
                "%parseFloat%": parseFloat,
                "%parseInt%": parseInt,
                "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
                "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
                "%RangeError%": $RangeError,
                "%ReferenceError%": $ReferenceError,
                "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
                "%RegExp%": RegExp,
                "%Set%": typeof Set === "undefined" ? undefined2 : Set,
                "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
                "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
                "%String%": String,
                "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
                "%Symbol%": hasSymbols ? Symbol : undefined2,
                "%SyntaxError%": $SyntaxError,
                "%ThrowTypeError%": ThrowTypeError,
                "%TypedArray%": TypedArray,
                "%TypeError%": $TypeError,
                "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
                "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
                "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
                "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
                "%URIError%": $URIError,
                "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
                "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
                "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
                "%Function.prototype.call%": $call,
                "%Function.prototype.apply%": $apply,
                "%Object.defineProperty%": $defineProperty,
                "%Object.getPrototypeOf%": $ObjectGPO,
                "%Math.abs%": abs,
                "%Math.floor%": floor,
                "%Math.max%": max,
                "%Math.min%": min,
                "%Math.pow%": pow,
                "%Math.round%": round,
                "%Math.sign%": sign,
                "%Reflect.getPrototypeOf%": $ReflectGPO
              };
              if (getProto) {
                try {
                  null.error;
                } catch (e) {
                  var errorProto = getProto(getProto(e));
                  INTRINSICS["%Error.prototype%"] = errorProto;
                }
              }
              var doEval = function doEval2(name) {
                var value;
                if (name === "%AsyncFunction%") {
                  value = getEvalledConstructor("async function () {}");
                } else if (name === "%GeneratorFunction%") {
                  value = getEvalledConstructor("function* () {}");
                } else if (name === "%AsyncGeneratorFunction%") {
                  value = getEvalledConstructor("async function* () {}");
                } else if (name === "%AsyncGenerator%") {
                  var fn = doEval2("%AsyncGeneratorFunction%");
                  if (fn) {
                    value = fn.prototype;
                  }
                } else if (name === "%AsyncIteratorPrototype%") {
                  var gen = doEval2("%AsyncGenerator%");
                  if (gen && getProto) {
                    value = getProto(gen.prototype);
                  }
                }
                INTRINSICS[name] = value;
                return value;
              };
              var LEGACY_ALIASES = {
                __proto__: null,
                "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
                "%ArrayPrototype%": ["Array", "prototype"],
                "%ArrayProto_entries%": ["Array", "prototype", "entries"],
                "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
                "%ArrayProto_keys%": ["Array", "prototype", "keys"],
                "%ArrayProto_values%": ["Array", "prototype", "values"],
                "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
                "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
                "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
                "%BooleanPrototype%": ["Boolean", "prototype"],
                "%DataViewPrototype%": ["DataView", "prototype"],
                "%DatePrototype%": ["Date", "prototype"],
                "%ErrorPrototype%": ["Error", "prototype"],
                "%EvalErrorPrototype%": ["EvalError", "prototype"],
                "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
                "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
                "%FunctionPrototype%": ["Function", "prototype"],
                "%Generator%": ["GeneratorFunction", "prototype"],
                "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
                "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
                "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
                "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
                "%JSONParse%": ["JSON", "parse"],
                "%JSONStringify%": ["JSON", "stringify"],
                "%MapPrototype%": ["Map", "prototype"],
                "%NumberPrototype%": ["Number", "prototype"],
                "%ObjectPrototype%": ["Object", "prototype"],
                "%ObjProto_toString%": ["Object", "prototype", "toString"],
                "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
                "%PromisePrototype%": ["Promise", "prototype"],
                "%PromiseProto_then%": ["Promise", "prototype", "then"],
                "%Promise_all%": ["Promise", "all"],
                "%Promise_reject%": ["Promise", "reject"],
                "%Promise_resolve%": ["Promise", "resolve"],
                "%RangeErrorPrototype%": ["RangeError", "prototype"],
                "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
                "%RegExpPrototype%": ["RegExp", "prototype"],
                "%SetPrototype%": ["Set", "prototype"],
                "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
                "%StringPrototype%": ["String", "prototype"],
                "%SymbolPrototype%": ["Symbol", "prototype"],
                "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
                "%TypedArrayPrototype%": ["TypedArray", "prototype"],
                "%TypeErrorPrototype%": ["TypeError", "prototype"],
                "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
                "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
                "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
                "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
                "%URIErrorPrototype%": ["URIError", "prototype"],
                "%WeakMapPrototype%": ["WeakMap", "prototype"],
                "%WeakSetPrototype%": ["WeakSet", "prototype"]
              };
              var bind = __webpack_require__2(5049);
              var hasOwn = __webpack_require__2(5215);
              var $concat = bind.call($call, Array.prototype.concat);
              var $spliceApply = bind.call($apply, Array.prototype.splice);
              var $replace = bind.call($call, String.prototype.replace);
              var $strSlice = bind.call($call, String.prototype.slice);
              var $exec = bind.call($call, RegExp.prototype.exec);
              var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
              var reEscapeChar = /\\(\\)?/g;
              var stringToPath = function stringToPath2(string) {
                var first = $strSlice(string, 0, 1);
                var last = $strSlice(string, -1);
                if (first === "%" && last !== "%") {
                  throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
                } else if (last === "%" && first !== "%") {
                  throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
                }
                var result = [];
                $replace(string, rePropName, function(match, number, quote, subString) {
                  result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
                });
                return result;
              };
              var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
                var intrinsicName = name;
                var alias;
                if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                  alias = LEGACY_ALIASES[intrinsicName];
                  intrinsicName = "%" + alias[0] + "%";
                }
                if (hasOwn(INTRINSICS, intrinsicName)) {
                  var value = INTRINSICS[intrinsicName];
                  if (value === needsEval) {
                    value = doEval(intrinsicName);
                  }
                  if (typeof value === "undefined" && !allowMissing) {
                    throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
                  }
                  return {
                    alias,
                    name: intrinsicName,
                    value
                  };
                }
                throw new $SyntaxError("intrinsic " + name + " does not exist!");
              };
              module2.exports = function GetIntrinsic(name, allowMissing) {
                if (typeof name !== "string" || name.length === 0) {
                  throw new $TypeError("intrinsic name must be a non-empty string");
                }
                if (arguments.length > 1 && typeof allowMissing !== "boolean") {
                  throw new $TypeError('"allowMissing" argument must be a boolean');
                }
                if ($exec(/^%?[^%]*%?$/, name) === null) {
                  throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
                }
                var parts = stringToPath(name);
                var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
                var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
                var intrinsicRealName = intrinsic.name;
                var value = intrinsic.value;
                var skipFurtherCaching = false;
                var alias = intrinsic.alias;
                if (alias) {
                  intrinsicBaseName = alias[0];
                  $spliceApply(parts, $concat([0, 1], alias));
                }
                for (var i = 1, isOwn = true; i < parts.length; i += 1) {
                  var part = parts[i];
                  var first = $strSlice(part, 0, 1);
                  var last = $strSlice(part, -1);
                  if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
                    throw new $SyntaxError("property names with quotes must have matching quotes");
                  }
                  if (part === "constructor" || !isOwn) {
                    skipFurtherCaching = true;
                  }
                  intrinsicBaseName += "." + part;
                  intrinsicRealName = "%" + intrinsicBaseName + "%";
                  if (hasOwn(INTRINSICS, intrinsicRealName)) {
                    value = INTRINSICS[intrinsicRealName];
                  } else if (value != null) {
                    if (!(part in value)) {
                      if (!allowMissing) {
                        throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
                      }
                      return void 0;
                    }
                    if ($gOPD && i + 1 >= parts.length) {
                      var desc = $gOPD(value, part);
                      isOwn = !!desc;
                      if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                        value = desc.get;
                      } else {
                        value = value[part];
                      }
                    } else {
                      isOwn = hasOwn(value, part);
                      value = value[part];
                    }
                    if (isOwn && !skipFurtherCaching) {
                      INTRINSICS[intrinsicRealName] = value;
                    }
                  }
                }
                return value;
              };
            },
            /***/
            8663(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var globalThis2 = __webpack_require__2(7756);
              var shared = __webpack_require__2(997);
              var hasOwn = __webpack_require__2(6341);
              var uid = __webpack_require__2(6044);
              var NATIVE_SYMBOL = __webpack_require__2(4483);
              var USE_SYMBOL_AS_UID = __webpack_require__2(8300);
              var Symbol2 = globalThis2.Symbol;
              var WellKnownSymbolsStore = shared("wks");
              var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
              module2.exports = function(name) {
                if (!hasOwn(WellKnownSymbolsStore, name)) {
                  WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
                }
                return WellKnownSymbolsStore[name];
              };
            },
            /***/
            8681(module2) {
              "use strict";
              var documentAll = typeof document == "object" && document.all;
              module2.exports = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
                return typeof argument == "function" || argument === documentAll;
              } : function(argument) {
                return typeof argument == "function";
              };
            },
            /***/
            8692(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(3144));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function() {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var Hasher = C_lib.Hasher;
                  var C_x64 = C.x64;
                  var X64Word = C_x64.Word;
                  var X64WordArray = C_x64.WordArray;
                  var C_algo = C.algo;
                  function X64Word_create() {
                    return X64Word.create.apply(X64Word, arguments);
                  }
                  var K = [X64Word_create(1116352408, 3609767458), X64Word_create(1899447441, 602891725), X64Word_create(3049323471, 3964484399), X64Word_create(3921009573, 2173295548), X64Word_create(961987163, 4081628472), X64Word_create(1508970993, 3053834265), X64Word_create(2453635748, 2937671579), X64Word_create(2870763221, 3664609560), X64Word_create(3624381080, 2734883394), X64Word_create(310598401, 1164996542), X64Word_create(607225278, 1323610764), X64Word_create(1426881987, 3590304994), X64Word_create(1925078388, 4068182383), X64Word_create(2162078206, 991336113), X64Word_create(2614888103, 633803317), X64Word_create(3248222580, 3479774868), X64Word_create(3835390401, 2666613458), X64Word_create(4022224774, 944711139), X64Word_create(264347078, 2341262773), X64Word_create(604807628, 2007800933), X64Word_create(770255983, 1495990901), X64Word_create(1249150122, 1856431235), X64Word_create(1555081692, 3175218132), X64Word_create(1996064986, 2198950837), X64Word_create(2554220882, 3999719339), X64Word_create(2821834349, 766784016), X64Word_create(2952996808, 2566594879), X64Word_create(3210313671, 3203337956), X64Word_create(3336571891, 1034457026), X64Word_create(3584528711, 2466948901), X64Word_create(113926993, 3758326383), X64Word_create(338241895, 168717936), X64Word_create(666307205, 1188179964), X64Word_create(773529912, 1546045734), X64Word_create(1294757372, 1522805485), X64Word_create(1396182291, 2643833823), X64Word_create(1695183700, 2343527390), X64Word_create(1986661051, 1014477480), X64Word_create(2177026350, 1206759142), X64Word_create(2456956037, 344077627), X64Word_create(2730485921, 1290863460), X64Word_create(2820302411, 3158454273), X64Word_create(3259730800, 3505952657), X64Word_create(3345764771, 106217008), X64Word_create(3516065817, 3606008344), X64Word_create(3600352804, 1432725776), X64Word_create(4094571909, 1467031594), X64Word_create(275423344, 851169720), X64Word_create(430227734, 3100823752), X64Word_create(506948616, 1363258195), X64Word_create(659060556, 3750685593), X64Word_create(883997877, 3785050280), X64Word_create(958139571, 3318307427), X64Word_create(1322822218, 3812723403), X64Word_create(1537002063, 2003034995), X64Word_create(1747873779, 3602036899), X64Word_create(1955562222, 1575990012), X64Word_create(2024104815, 1125592928), X64Word_create(2227730452, 2716904306), X64Word_create(2361852424, 442776044), X64Word_create(2428436474, 593698344), X64Word_create(2756734187, 3733110249), X64Word_create(3204031479, 2999351573), X64Word_create(3329325298, 3815920427), X64Word_create(3391569614, 3928383900), X64Word_create(3515267271, 566280711), X64Word_create(3940187606, 3454069534), X64Word_create(4118630271, 4000239992), X64Word_create(116418474, 1914138554), X64Word_create(174292421, 2731055270), X64Word_create(289380356, 3203993006), X64Word_create(460393269, 320620315), X64Word_create(685471733, 587496836), X64Word_create(852142971, 1086792851), X64Word_create(1017036298, 365543100), X64Word_create(1126000580, 2618297676), X64Word_create(1288033470, 3409855158), X64Word_create(1501505948, 4234509866), X64Word_create(1607167915, 987167468), X64Word_create(1816402316, 1246189591)];
                  var W = [];
                  (function() {
                    for (var i = 0; i < 80; i++) {
                      W[i] = X64Word_create();
                    }
                  })();
                  var SHA512 = C_algo.SHA512 = Hasher.extend({
                    _doReset: function() {
                      this._hash = new X64WordArray.init([new X64Word.init(1779033703, 4089235720), new X64Word.init(3144134277, 2227873595), new X64Word.init(1013904242, 4271175723), new X64Word.init(2773480762, 1595750129), new X64Word.init(1359893119, 2917565137), new X64Word.init(2600822924, 725511199), new X64Word.init(528734635, 4215389547), new X64Word.init(1541459225, 327033209)]);
                    },
                    _doProcessBlock: function(M, offset) {
                      var H = this._hash.words;
                      var H0 = H[0];
                      var H1 = H[1];
                      var H2 = H[2];
                      var H3 = H[3];
                      var H4 = H[4];
                      var H5 = H[5];
                      var H6 = H[6];
                      var H7 = H[7];
                      var H0h = H0.high;
                      var H0l = H0.low;
                      var H1h = H1.high;
                      var H1l = H1.low;
                      var H2h = H2.high;
                      var H2l = H2.low;
                      var H3h = H3.high;
                      var H3l = H3.low;
                      var H4h = H4.high;
                      var H4l = H4.low;
                      var H5h = H5.high;
                      var H5l = H5.low;
                      var H6h = H6.high;
                      var H6l = H6.low;
                      var H7h = H7.high;
                      var H7l = H7.low;
                      var ah = H0h;
                      var al = H0l;
                      var bh = H1h;
                      var bl = H1l;
                      var ch = H2h;
                      var cl = H2l;
                      var dh = H3h;
                      var dl = H3l;
                      var eh = H4h;
                      var el = H4l;
                      var fh = H5h;
                      var fl = H5l;
                      var gh = H6h;
                      var gl = H6l;
                      var hh = H7h;
                      var hl = H7l;
                      for (var i = 0; i < 80; i++) {
                        var Wil;
                        var Wih;
                        var Wi = W[i];
                        if (i < 16) {
                          Wih = Wi.high = M[offset + i * 2] | 0;
                          Wil = Wi.low = M[offset + i * 2 + 1] | 0;
                        } else {
                          var gamma0x = W[i - 15];
                          var gamma0xh = gamma0x.high;
                          var gamma0xl = gamma0x.low;
                          var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                          var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                          var gamma1x = W[i - 2];
                          var gamma1xh = gamma1x.high;
                          var gamma1xl = gamma1x.low;
                          var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                          var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                          var Wi7 = W[i - 7];
                          var Wi7h = Wi7.high;
                          var Wi7l = Wi7.low;
                          var Wi16 = W[i - 16];
                          var Wi16h = Wi16.high;
                          var Wi16l = Wi16.low;
                          Wil = gamma0l + Wi7l;
                          Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                          Wil = Wil + gamma1l;
                          Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                          Wil = Wil + Wi16l;
                          Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                          Wi.high = Wih;
                          Wi.low = Wil;
                        }
                        var chh = eh & fh ^ ~eh & gh;
                        var chl = el & fl ^ ~el & gl;
                        var majh = ah & bh ^ ah & ch ^ bh & ch;
                        var majl = al & bl ^ al & cl ^ bl & cl;
                        var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
                        var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
                        var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
                        var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
                        var Ki = K[i];
                        var Kih = Ki.high;
                        var Kil = Ki.low;
                        var t1l = hl + sigma1l;
                        var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
                        var t1l = t1l + chl;
                        var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
                        var t1l = t1l + Kil;
                        var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
                        var t1l = t1l + Wil;
                        var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
                        var t2l = sigma0l + majl;
                        var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
                        hh = gh;
                        hl = gl;
                        gh = fh;
                        gl = fl;
                        fh = eh;
                        fl = el;
                        el = dl + t1l | 0;
                        eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
                        dh = ch;
                        dl = cl;
                        ch = bh;
                        cl = bl;
                        bh = ah;
                        bl = al;
                        al = t1l + t2l | 0;
                        ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
                      }
                      H0l = H0.low = H0l + al;
                      H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
                      H1l = H1.low = H1l + bl;
                      H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
                      H2l = H2.low = H2l + cl;
                      H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
                      H3l = H3.low = H3l + dl;
                      H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
                      H4l = H4.low = H4l + el;
                      H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
                      H5l = H5.low = H5l + fl;
                      H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
                      H6l = H6.low = H6l + gl;
                      H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
                      H7l = H7.low = H7l + hl;
                      H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
                    },
                    _doFinalize: function() {
                      var data = this._data;
                      var dataWords = data.words;
                      var nBitsTotal = this._nDataBytes * 8;
                      var nBitsLeft = data.sigBytes * 8;
                      dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                      dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
                      dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
                      data.sigBytes = dataWords.length * 4;
                      this._process();
                      var hash = this._hash.toX32();
                      return hash;
                    },
                    clone: function() {
                      var clone = Hasher.clone.call(this);
                      clone._hash = this._hash.clone();
                      return clone;
                    },
                    blockSize: 1024 / 32
                  });
                  C.SHA512 = Hasher._createHelper(SHA512);
                  C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
                })();
                return CryptoJS.SHA512;
              });
            },
            /***/
            8819(module2) {
              "use strict";
              var $String = String;
              module2.exports = function(argument) {
                try {
                  return $String(argument);
                } catch (error) {
                  return "Object";
                }
              };
            },
            /***/
            8834(__unused_webpack_module, exports2, __webpack_require__2) {
              "use strict";
              var _fs = __webpack_require__2(2416);
              var _fs2 = _interopRequireDefault(_fs);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
              }
              var tags = __webpack_require__2(9240);
              var bytes = [0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8];
              var SOIMarkerLength = 2;
              var JPEGSOIMarker = 65496;
              var TIFFINTEL = 18761;
              var TIFFMOTOROLA = 19789;
              var APPMarkerLength = 2;
              var APPMarkerBegin = 65504;
              var APPMarkerEnd = 65519;
              var data = void 0;
              var isValid = function isValid2(buffer) {
                try {
                  var SOIMarker = buffer.readUInt16BE(0);
                  return SOIMarker === JPEGSOIMarker;
                } catch (e) {
                  throw new Error("Unsupport file format.");
                }
              };
              var isTiff = function isTiff2(buffer) {
                try {
                  var SOIMarker = buffer.readUInt16BE(0);
                  return SOIMarker === TIFFINTEL || SOIMarker === TIFFMOTOROLA;
                } catch (e) {
                  throw new Error("Unsupport file format.");
                }
              };
              var checkAPPn = function checkAPPn2(buffer) {
                try {
                  var APPMarkerTag = buffer.readUInt16BE(0);
                  var isInRange = APPMarkerTag >= APPMarkerBegin && APPMarkerTag <= APPMarkerEnd;
                  return isInRange ? APPMarkerTag - APPMarkerBegin : false;
                } catch (e) {
                  throw new Error("Invalid APP Tag.");
                }
              };
              var IFDHandler = function IFDHandler2(buffer, tagCollection, order, offset) {
                var entriesNumber = order ? buffer.readUInt16BE(0) : buffer.readUInt16LE(0);
                if (entriesNumber === 0) {
                  return {};
                }
                var entriesNumberLength = 2;
                var entries = buffer.slice(entriesNumberLength);
                var entryLength = 12;
                var exif = {};
                var entryCount = 0;
                for (entryCount; entryCount < entriesNumber; entryCount += 1) {
                  var entryBegin = entryCount * entryLength;
                  var entry = entries.slice(entryBegin, entryBegin + entryLength);
                  var tagBegin = 0;
                  var tagLength = 2;
                  var dataFormatBegin = tagBegin + tagLength;
                  var dataFormatLength = 2;
                  var componentsBegin = dataFormatBegin + dataFormatLength;
                  var componentsNumberLength = 4;
                  var dataValueBegin = componentsBegin + componentsNumberLength;
                  var dataValueLength = 4;
                  var tagAddress = entry.slice(tagBegin, dataFormatBegin);
                  var tagNumber = order ? tagAddress.toString("hex") : tagAddress.reverse().toString("hex");
                  var tagName = tagCollection[tagNumber];
                  var bigDataFormat = entry.readUInt16BE(dataFormatBegin);
                  var littleDataFormat = entry.readUInt16LE(dataFormatBegin);
                  var dataFormat = order ? bigDataFormat : littleDataFormat;
                  var componentsByte = bytes[dataFormat];
                  var bigComponentsNumber = entry.readUInt32BE(componentsBegin);
                  var littleComponentNumber = entry.readUInt32LE(componentsBegin);
                  var componentsNumber = order ? bigComponentsNumber : littleComponentNumber;
                  var dataLength = componentsNumber * componentsByte;
                  var dataValue = entry.slice(dataValueBegin, dataValueBegin + dataValueLength);
                  if (dataLength > 4) {
                    var dataOffset = (order ? dataValue.readUInt32BE(0) : dataValue.readUInt32LE(0)) - offset;
                    dataValue = buffer.slice(dataOffset, dataOffset + dataLength);
                  }
                  var tagValue = void 0;
                  if (tagName) {
                    switch (dataFormat) {
                      case 1:
                        tagValue = dataValue.readUInt8(0);
                        break;
                      case 2:
                        tagValue = dataValue.toString("ascii").replace(/\0+$/, "");
                        break;
                      case 3:
                        tagValue = order ? dataValue.readUInt16BE(0) : dataValue.readUInt16LE(0);
                        break;
                      case 4:
                        tagValue = order ? dataValue.readUInt32BE(0) : dataValue.readUInt32LE(0);
                        break;
                      case 5:
                        tagValue = [];
                        for (var i = 0; i < dataValue.length; i += 8) {
                          var bigTagValue = dataValue.readUInt32BE(i) / dataValue.readUInt32BE(i + 4);
                          var littleTagValue = dataValue.readUInt32LE(i) / dataValue.readUInt32LE(i + 4);
                          tagValue.push(order ? bigTagValue : littleTagValue);
                        }
                        break;
                      case 7:
                        switch (tagName) {
                          case "ExifVersion":
                            tagValue = dataValue.toString();
                            break;
                          case "FlashPixVersion":
                            tagValue = dataValue.toString();
                            break;
                          case "SceneType":
                            tagValue = dataValue.readUInt8(0);
                            break;
                          default:
                            tagValue = "0x" + dataValue.toString("hex", 0, 15);
                            break;
                        }
                        break;
                      case 10: {
                        var bigOrder = dataValue.readInt32BE(0) / dataValue.readInt32BE(4);
                        var littleOrder = dataValue.readInt32LE(0) / dataValue.readInt32LE(4);
                        tagValue = order ? bigOrder : littleOrder;
                        break;
                      }
                      default:
                        tagValue = "0x" + dataValue.toString("hex");
                        break;
                    }
                    exif[tagName] = tagValue;
                  }
                }
                return exif;
              };
              var EXIFHandler = function EXIFHandler2(buf) {
                var pad = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                var buffer = buf;
                if (pad) {
                  buffer = buf.slice(APPMarkerLength);
                  var length = buffer.readUInt16BE(0);
                  buffer = buffer.slice(0, length);
                  var lengthLength = 2;
                  buffer = buffer.slice(lengthLength);
                  var identifierLength = 5;
                  buffer = buffer.slice(identifierLength);
                  var padLength = 1;
                  buffer = buffer.slice(padLength);
                }
                var byteOrderLength = 2;
                var byteOrder = buffer.toString("ascii", 0, byteOrderLength) === "MM";
                var fortyTwoLength = 2;
                var fortyTwoEnd = byteOrderLength + fortyTwoLength;
                var big42 = buffer.readUInt32BE(fortyTwoEnd);
                var little42 = buffer.readUInt32LE(fortyTwoEnd);
                var offsetOfIFD = byteOrder ? big42 : little42;
                buffer = buffer.slice(offsetOfIFD);
                if (buffer.length > 0) {
                  data = IFDHandler(buffer, tags.ifd, byteOrder, offsetOfIFD);
                  if (data.ExifIFDPointer) {
                    buffer = buffer.slice(data.ExifIFDPointer - offsetOfIFD);
                    data.SubExif = IFDHandler(buffer, tags.ifd, byteOrder, data.ExifIFDPointer);
                  }
                  if (data.GPSInfoIFDPointer) {
                    var gps = data.GPSInfoIFDPointer;
                    buffer = buffer.slice(data.ExifIFDPointer ? gps - data.ExifIFDPointer : gps - offsetOfIFD);
                    data.GPSInfo = IFDHandler(buffer, tags.gps, byteOrder, gps);
                  }
                }
              };
              var APPnHandler = function APPnHandler2(buffer) {
                var APPMarkerTag = checkAPPn(buffer);
                if (APPMarkerTag !== false) {
                  var length = buffer.readUInt16BE(APPMarkerLength);
                  switch (APPMarkerTag) {
                    case 1:
                      EXIFHandler(buffer);
                      break;
                    default:
                      APPnHandler2(buffer.slice(APPMarkerLength + length));
                      break;
                  }
                }
              };
              var fromBuffer = function fromBuffer2(buffer) {
                if (!buffer) {
                  throw new Error("buffer not found");
                }
                data = void 0;
                if (isValid(buffer)) {
                  buffer = buffer.slice(SOIMarkerLength);
                  data = {};
                  APPnHandler(buffer);
                } else if (isTiff(buffer)) {
                  data = {};
                  EXIFHandler(buffer, false);
                }
                return data;
              };
              var sync = function sync2(file) {
                if (!file) {
                  throw new Error("File not found");
                }
                var buffer = _fs2.default.readFileSync(file);
                return fromBuffer(buffer);
              };
              var async = function async2(file, callback) {
                data = void 0;
                new Promise(function(resolve, reject) {
                  if (!file) {
                    reject(new Error("File not found."));
                  }
                  _fs2.default.readFile(file, function(err, buffer) {
                    if (err) {
                      reject(err);
                    } else {
                      try {
                        if (isValid(buffer)) {
                          var buf = buffer.slice(SOIMarkerLength);
                          data = {};
                          APPnHandler(buf);
                          resolve(data);
                        } else if (isTiff(buffer)) {
                          data = {};
                          EXIFHandler(buffer, false);
                          resolve(data);
                        } else {
                          reject(new Error("Unsupport file type."));
                        }
                      } catch (e) {
                        reject(e);
                      }
                    }
                  });
                }, function(error) {
                  callback(error, void 0);
                }).then(function(d) {
                  callback(void 0, d);
                }).catch(function(error) {
                  callback(error, void 0);
                });
              };
              exports2.fromBuffer = fromBuffer;
              exports2.parse = async;
              exports2.parseSync = sync;
            },
            /***/
            8843(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var callBound = __webpack_require__2(2774);
              var isRegex = __webpack_require__2(1689);
              var $exec = callBound("RegExp.prototype.exec");
              var $TypeError = __webpack_require__2(6785);
              module2.exports = function regexTester(regex) {
                if (!isRegex(regex)) {
                  throw new $TypeError("`regex` must be a RegExp");
                }
                return function test(s) {
                  return $exec(regex, s) !== null;
                };
              };
            },
            /***/
            8865(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function() {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var Base = C_lib.Base;
                  var C_enc = C.enc;
                  var Utf8 = C_enc.Utf8;
                  var C_algo = C.algo;
                  var HMAC = C_algo.HMAC = Base.extend({
                    /**
                     * Initializes a newly created HMAC.
                     *
                     * @param {Hasher} hasher The hash algorithm to use.
                     * @param {WordArray|string} key The secret key.
                     *
                     * @example
                     *
                     *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
                     */
                    init: function(hasher, key) {
                      hasher = this._hasher = new hasher.init();
                      if (typeof key == "string") {
                        key = Utf8.parse(key);
                      }
                      var hasherBlockSize = hasher.blockSize;
                      var hasherBlockSizeBytes = hasherBlockSize * 4;
                      if (key.sigBytes > hasherBlockSizeBytes) {
                        key = hasher.finalize(key);
                      }
                      key.clamp();
                      var oKey = this._oKey = key.clone();
                      var iKey = this._iKey = key.clone();
                      var oKeyWords = oKey.words;
                      var iKeyWords = iKey.words;
                      for (var i = 0; i < hasherBlockSize; i++) {
                        oKeyWords[i] ^= 1549556828;
                        iKeyWords[i] ^= 909522486;
                      }
                      oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
                      this.reset();
                    },
                    /**
                     * Resets this HMAC to its initial state.
                     *
                     * @example
                     *
                     *     hmacHasher.reset();
                     */
                    reset: function() {
                      var hasher = this._hasher;
                      hasher.reset();
                      hasher.update(this._iKey);
                    },
                    /**
                     * Updates this HMAC with a message.
                     *
                     * @param {WordArray|string} messageUpdate The message to append.
                     *
                     * @return {HMAC} This HMAC instance.
                     *
                     * @example
                     *
                     *     hmacHasher.update('message');
                     *     hmacHasher.update(wordArray);
                     */
                    update: function(messageUpdate) {
                      this._hasher.update(messageUpdate);
                      return this;
                    },
                    /**
                     * Finalizes the HMAC computation.
                     * Note that the finalize operation is effectively a destructive, read-once operation.
                     *
                     * @param {WordArray|string} messageUpdate (Optional) A final message update.
                     *
                     * @return {WordArray} The HMAC.
                     *
                     * @example
                     *
                     *     var hmac = hmacHasher.finalize();
                     *     var hmac = hmacHasher.finalize('message');
                     *     var hmac = hmacHasher.finalize(wordArray);
                     */
                    finalize: function(messageUpdate) {
                      var hasher = this._hasher;
                      var innerHash = hasher.finalize(messageUpdate);
                      hasher.reset();
                      var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
                      return hmac;
                    }
                  });
                })();
              });
            },
            /***/
            8888(module2) {
              "use strict";
              module2.exports = RangeError;
            },
            /***/
            8890(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var $defineProperty = __webpack_require__2(6649);
              var hasPropertyDescriptors = function hasPropertyDescriptors2() {
                return !!$defineProperty;
              };
              hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
                if (!$defineProperty) {
                  return null;
                }
                try {
                  return $defineProperty([], "length", { value: 1 }).length !== 1;
                } catch (e) {
                  return true;
                }
              };
              module2.exports = hasPropertyDescriptors;
            },
            /***/
            8993(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var NATIVE_BIND = __webpack_require__2(1676);
              var call = Function.prototype.call;
              module2.exports = NATIVE_BIND ? call.bind(call) : function() {
                return call.apply(call, arguments);
              };
            },
            /***/
            9018(module2, __unused_webpack_exports, __webpack_require__2) {
              module2.exports = __webpack_require__2(4785).EventEmitter;
            },
            /***/
            9029(__unused_webpack_module, exports2) {
              exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
                var e, m;
                var eLen = nBytes * 8 - mLen - 1;
                var eMax = (1 << eLen) - 1;
                var eBias = eMax >> 1;
                var nBits = -7;
                var i = isLE ? nBytes - 1 : 0;
                var d = isLE ? -1 : 1;
                var s = buffer[offset + i];
                i += d;
                e = s & (1 << -nBits) - 1;
                s >>= -nBits;
                nBits += eLen;
                for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
                }
                m = e & (1 << -nBits) - 1;
                e >>= -nBits;
                nBits += mLen;
                for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
                }
                if (e === 0) {
                  e = 1 - eBias;
                } else if (e === eMax) {
                  return m ? NaN : (s ? -1 : 1) * Infinity;
                } else {
                  m = m + Math.pow(2, mLen);
                  e = e - eBias;
                }
                return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
              };
              exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
                var e, m, c;
                var eLen = nBytes * 8 - mLen - 1;
                var eMax = (1 << eLen) - 1;
                var eBias = eMax >> 1;
                var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                var i = isLE ? 0 : nBytes - 1;
                var d = isLE ? 1 : -1;
                var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
                value = Math.abs(value);
                if (isNaN(value) || value === Infinity) {
                  m = isNaN(value) ? 1 : 0;
                  e = eMax;
                } else {
                  e = Math.floor(Math.log(value) / Math.LN2);
                  if (value * (c = Math.pow(2, -e)) < 1) {
                    e--;
                    c *= 2;
                  }
                  if (e + eBias >= 1) {
                    value += rt / c;
                  } else {
                    value += rt * Math.pow(2, 1 - eBias);
                  }
                  if (value * c >= 2) {
                    e++;
                    c /= 2;
                  }
                  if (e + eBias >= eMax) {
                    m = 0;
                    e = eMax;
                  } else if (e + eBias >= 1) {
                    m = (value * c - 1) * Math.pow(2, mLen);
                    e = e + eBias;
                  } else {
                    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                    e = 0;
                  }
                }
                for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
                }
                e = e << mLen | m;
                eLen += mLen;
                for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
                }
                buffer[offset + i - d] |= s * 128;
              };
            },
            /***/
            9049(module2) {
              "use strict";
              function makeTable() {
                var c, table = [];
                for (var n = 0; n < 256; n++) {
                  c = n;
                  for (var k = 0; k < 8; k++) {
                    c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
                  }
                  table[n] = c;
                }
                return table;
              }
              var crcTable = makeTable();
              function crc32(crc, buf, len, pos) {
                var t = crcTable, end = pos + len;
                crc ^= -1;
                for (var i = pos; i < end; i++) {
                  crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
                }
                return crc ^ -1;
              }
              module2.exports = crc32;
            },
            /***/
            9055(module2) {
              "use strict";
              module2.exports = EvalError;
            },
            /***/
            9064(module2, exports2, __webpack_require__2) {
              "use strict";
              __webpack_require__2(8376);
              __webpack_require__2(6401);
              __webpack_require__2(2017);
              ;
              (function(root, factory) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function() {
                  if (typeof ArrayBuffer != "function") {
                    return;
                  }
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var WordArray = C_lib.WordArray;
                  var superInit = WordArray.init;
                  var subInit = WordArray.init = function(typedArray) {
                    if (typedArray instanceof ArrayBuffer) {
                      typedArray = new Uint8Array(typedArray);
                    }
                    if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
                      typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
                    }
                    if (typedArray instanceof Uint8Array) {
                      var typedArrayByteLength = typedArray.byteLength;
                      var words = [];
                      for (var i = 0; i < typedArrayByteLength; i++) {
                        words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
                      }
                      superInit.call(this, words, typedArrayByteLength);
                    } else {
                      superInit.apply(this, arguments);
                    }
                  };
                  subInit.prototype = WordArray;
                })();
                return CryptoJS.lib.WordArray;
              });
            },
            /***/
            9240(module2) {
              "use strict";
              module2.exports = JSON.parse('{"ifd":{"8298":"Copyright","8769":"ExifIFDPointer","8822":"ExposureProgram","8824":"SpectralSensitivity","8825":"GPSInfoIFDPointer","8827":"PhotographicSensitivity","8828":"OECF","8830":"SensitivityType","8831":"StandardOutputSensitivity","8832":"RecommendedExposureIndex","8833":"ISOSpeed","8834":"ISOSpeedLatitudeyyy","8835":"ISOSpeedLatitudezzz","9000":"ExifVersion","9003":"DateTimeOriginal","9004":"DateTimeDigitized","9101":"ComponentsConfiguration","9102":"CompressedBitsPerPixel","9201":"ShutterSpeedValue","9202":"ApertureValue","9203":"BrightnessValue","9204":"ExposureBiasValue","9205":"MaxApertureValue","9206":"SubjectDistance","9207":"MeteringMode","9208":"LightSource","9209":"Flash","9214":"SubjectArea","9286":"UserComment","9290":"SubSecTime","9291":"SubSecTimeOriginal","9292":"SubSecTimeDigitized","010e":"ImageDescription","010f":"Make","011a":"XResolution","011b":"YResolution","011c":"PlanarConfiguration","012d":"TransferFunction","013b":"Artist","013e":"WhitePoint","013f":"PrimaryChromaticities","0100":"ImageWidth","0101":"ImageHeight","0102":"BitsPerSample","0103":"Compression","0106":"PhotometricInterpretation","0110":"Model","0111":"StripOffsets","0112":"Orientation","0115":"SamplesPerPixel","0116":"RowsPerStrip","0117":"StripByteCounts","0128":"ResolutionUnit","0131":"Software","0132":"DateTime","0201":"JPEGInterchangeFormat","0202":"JPEGInterchangeFormatLength","0211":"YCbCrCoefficients","0212":"YCbCrSubSampling","0213":"YCbCrPositioning","0214":"ReferenceBlackWhite","829a":"ExposureTime","829d":"FNumber","920a":"FocalLength","927c":"MakerNote","a000":"FlashpixVersion","a001":"ColorSpace","a002":"PixelXDimension","a003":"PixelYDimension","a004":"RelatedSoundFile","a005":"InteroperabilityIFDPointer","a20b":"FlashEnergy","a20c":"SpatialFrequencyResponse","a20e":"FocalPlaneXResolution","a20f":"FocalPlaneYResolution","a40a":"Sharpness","a40b":"DeviceSettingDescription","a40c":"SubjectDistanceRange","a210":"FocalPlaneResolutionUnit","a214":"SubjectLocation","a215":"ExposureIndex","a217":"SensingMethod","a300":"FileSource","a301":"SceneType","a302":"CFAPattern","a401":"CustomRendered","a402":"ExposureMode","a403":"WhiteBalance","a404":"DigitalZoomRatio","a405":"FocalLengthIn35mmFilm","a406":"SceneCaptureType","a407":"GainControl","a408":"Contrast","a409":"Saturation","a420":"ImageUniqueID","a430":"CameraOwnerName","a431":"BodySerialNumber","a432":"LensSpecification","a433":"LensMake","a434":"LensModel","a435":"LensSerialNumber","a500":"Gamma"},"gps":{"0000":"GPSVersionID","0001":"GPSLatitudeRef","0002":"GPSLatitude","0003":"GPSLongitudeRef","0004":"GPSLongitude","0005":"GPSAltitudeRef","0006":"GPSAltitude","0007":"GPSTimeStamp","0008":"GPSSatellites","0009":"GPSStatus","000a":"GPSMeasureMode","000b":"GPSDOP","000c":"GPSSpeedRef","000d":"GPSSpeed","000e":"GPSTrackRef","000f":"GPSTrack","0010":"GPSImgDirectionRef","0011":"GPSImgDirection","0012":"GPSMapDatum","0013":"GPSDestLatitudeRef","0014":"GPSDestLatitude","0015":"GPSDestLongitudeRef","0016":"GPSDestLongitude","0017":"GPSDestBearingRef","0018":"GPSDestBearing","0019":"GPSDestDistanceRef","001a":"GPSDestDistance","001b":"GPSProcessingMethod","001c":"GPSAreaInformation","001d":"GPSDateStamp","001e":"GPSDifferential","001f":"GPSHPositioningError"}}');
            },
            /***/
            9292(module2) {
              "use strict";
              module2.exports = Math.round;
            },
            /***/
            9295(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var $defineProperty = __webpack_require__2(6649);
              var $SyntaxError = __webpack_require__2(7770);
              var $TypeError = __webpack_require__2(6785);
              var gopd = __webpack_require__2(8109);
              module2.exports = function defineDataProperty(obj, property, value) {
                if (!obj || typeof obj !== "object" && typeof obj !== "function") {
                  throw new $TypeError("`obj` must be an object or a function`");
                }
                if (typeof property !== "string" && typeof property !== "symbol") {
                  throw new $TypeError("`property` must be a string or a symbol`");
                }
                if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
                  throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
                }
                if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
                  throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
                }
                if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
                  throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
                }
                if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
                  throw new $TypeError("`loose`, if provided, must be a boolean");
                }
                var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
                var nonWritable = arguments.length > 4 ? arguments[4] : null;
                var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
                var loose = arguments.length > 6 ? arguments[6] : false;
                var desc = !!gopd && gopd(obj, property);
                if ($defineProperty) {
                  $defineProperty(obj, property, {
                    configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
                    enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
                    value,
                    writable: nonWritable === null && desc ? desc.writable : !nonWritable
                  });
                } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
                  obj[property] = value;
                } else {
                  throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
                }
              };
            },
            /***/
            9302(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var callBind = __webpack_require__2(6688);
              var gOPD = __webpack_require__2(8109);
              var hasProtoAccessor;
              try {
                hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
                [].__proto__ === Array.prototype;
              } catch (e) {
                if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
                  throw e;
                }
              }
              var desc = !!hasProtoAccessor && gOPD && gOPD(
                Object.prototype,
                /** @type {keyof typeof Object.prototype} */
                "__proto__"
              );
              var $Object = Object;
              var $getPrototypeOf = $Object.getPrototypeOf;
              module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
                /** @type {import('./get')} */
                function getDunder(value) {
                  return $getPrototypeOf(value == null ? value : $Object(value));
                }
              ) : false;
            },
            /***/
            9391(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var TO_STRING_TAG_SUPPORT = __webpack_require__2(7920);
              var isCallable = __webpack_require__2(8681);
              var classofRaw = __webpack_require__2(8420);
              var wellKnownSymbol = __webpack_require__2(8663);
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              var $Object = Object;
              var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ function() {
                return arguments;
              }()) === "Arguments";
              var tryGet = function(it, key) {
                try {
                  return it[key];
                } catch (error) {
                }
              };
              module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
                var O, tag, result;
                return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === "Object" && isCallable(O.callee) ? "Arguments" : result;
              };
            },
            /***/
            9490(__unused_webpack_module, exports2, __webpack_require__2) {
              "use strict";
              var isArgumentsObject = __webpack_require__2(7906);
              var isGeneratorFunction = __webpack_require__2(4610);
              var whichTypedArray = __webpack_require__2(3381);
              var isTypedArray = __webpack_require__2(6094);
              function uncurryThis(f) {
                return f.call.bind(f);
              }
              var BigIntSupported = typeof BigInt !== "undefined";
              var SymbolSupported = typeof Symbol !== "undefined";
              var ObjectToString = uncurryThis(Object.prototype.toString);
              var numberValue = uncurryThis(Number.prototype.valueOf);
              var stringValue = uncurryThis(String.prototype.valueOf);
              var booleanValue = uncurryThis(Boolean.prototype.valueOf);
              if (BigIntSupported) {
                var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
              }
              if (SymbolSupported) {
                var symbolValue = uncurryThis(Symbol.prototype.valueOf);
              }
              function checkBoxedPrimitive(value, prototypeValueOf) {
                if (typeof value !== "object") {
                  return false;
                }
                try {
                  prototypeValueOf(value);
                  return true;
                } catch (e) {
                  return false;
                }
              }
              exports2.isArgumentsObject = isArgumentsObject;
              exports2.isGeneratorFunction = isGeneratorFunction;
              exports2.isTypedArray = isTypedArray;
              function isPromise(input) {
                return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
              }
              exports2.isPromise = isPromise;
              function isArrayBufferView(value) {
                if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
                  return ArrayBuffer.isView(value);
                }
                return isTypedArray(value) || isDataView(value);
              }
              exports2.isArrayBufferView = isArrayBufferView;
              function isUint8Array(value) {
                return whichTypedArray(value) === "Uint8Array";
              }
              exports2.isUint8Array = isUint8Array;
              function isUint8ClampedArray(value) {
                return whichTypedArray(value) === "Uint8ClampedArray";
              }
              exports2.isUint8ClampedArray = isUint8ClampedArray;
              function isUint16Array(value) {
                return whichTypedArray(value) === "Uint16Array";
              }
              exports2.isUint16Array = isUint16Array;
              function isUint32Array(value) {
                return whichTypedArray(value) === "Uint32Array";
              }
              exports2.isUint32Array = isUint32Array;
              function isInt8Array(value) {
                return whichTypedArray(value) === "Int8Array";
              }
              exports2.isInt8Array = isInt8Array;
              function isInt16Array(value) {
                return whichTypedArray(value) === "Int16Array";
              }
              exports2.isInt16Array = isInt16Array;
              function isInt32Array(value) {
                return whichTypedArray(value) === "Int32Array";
              }
              exports2.isInt32Array = isInt32Array;
              function isFloat32Array(value) {
                return whichTypedArray(value) === "Float32Array";
              }
              exports2.isFloat32Array = isFloat32Array;
              function isFloat64Array(value) {
                return whichTypedArray(value) === "Float64Array";
              }
              exports2.isFloat64Array = isFloat64Array;
              function isBigInt64Array(value) {
                return whichTypedArray(value) === "BigInt64Array";
              }
              exports2.isBigInt64Array = isBigInt64Array;
              function isBigUint64Array(value) {
                return whichTypedArray(value) === "BigUint64Array";
              }
              exports2.isBigUint64Array = isBigUint64Array;
              function isMapToString(value) {
                return ObjectToString(value) === "[object Map]";
              }
              isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
              function isMap(value) {
                if (typeof Map === "undefined") {
                  return false;
                }
                return isMapToString.working ? isMapToString(value) : value instanceof Map;
              }
              exports2.isMap = isMap;
              function isSetToString(value) {
                return ObjectToString(value) === "[object Set]";
              }
              isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
              function isSet(value) {
                if (typeof Set === "undefined") {
                  return false;
                }
                return isSetToString.working ? isSetToString(value) : value instanceof Set;
              }
              exports2.isSet = isSet;
              function isWeakMapToString(value) {
                return ObjectToString(value) === "[object WeakMap]";
              }
              isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
              function isWeakMap(value) {
                if (typeof WeakMap === "undefined") {
                  return false;
                }
                return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
              }
              exports2.isWeakMap = isWeakMap;
              function isWeakSetToString(value) {
                return ObjectToString(value) === "[object WeakSet]";
              }
              isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
              function isWeakSet(value) {
                return isWeakSetToString(value);
              }
              exports2.isWeakSet = isWeakSet;
              function isArrayBufferToString(value) {
                return ObjectToString(value) === "[object ArrayBuffer]";
              }
              isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
              function isArrayBuffer(value) {
                if (typeof ArrayBuffer === "undefined") {
                  return false;
                }
                return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
              }
              exports2.isArrayBuffer = isArrayBuffer;
              function isDataViewToString(value) {
                return ObjectToString(value) === "[object DataView]";
              }
              isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
              function isDataView(value) {
                if (typeof DataView === "undefined") {
                  return false;
                }
                return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
              }
              exports2.isDataView = isDataView;
              var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
              function isSharedArrayBufferToString(value) {
                return ObjectToString(value) === "[object SharedArrayBuffer]";
              }
              function isSharedArrayBuffer(value) {
                if (typeof SharedArrayBufferCopy === "undefined") {
                  return false;
                }
                if (typeof isSharedArrayBufferToString.working === "undefined") {
                  isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
                }
                return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
              }
              exports2.isSharedArrayBuffer = isSharedArrayBuffer;
              function isAsyncFunction(value) {
                return ObjectToString(value) === "[object AsyncFunction]";
              }
              exports2.isAsyncFunction = isAsyncFunction;
              function isMapIterator(value) {
                return ObjectToString(value) === "[object Map Iterator]";
              }
              exports2.isMapIterator = isMapIterator;
              function isSetIterator(value) {
                return ObjectToString(value) === "[object Set Iterator]";
              }
              exports2.isSetIterator = isSetIterator;
              function isGeneratorObject(value) {
                return ObjectToString(value) === "[object Generator]";
              }
              exports2.isGeneratorObject = isGeneratorObject;
              function isWebAssemblyCompiledModule(value) {
                return ObjectToString(value) === "[object WebAssembly.Module]";
              }
              exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
              function isNumberObject(value) {
                return checkBoxedPrimitive(value, numberValue);
              }
              exports2.isNumberObject = isNumberObject;
              function isStringObject(value) {
                return checkBoxedPrimitive(value, stringValue);
              }
              exports2.isStringObject = isStringObject;
              function isBooleanObject(value) {
                return checkBoxedPrimitive(value, booleanValue);
              }
              exports2.isBooleanObject = isBooleanObject;
              function isBigIntObject(value) {
                return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
              }
              exports2.isBigIntObject = isBigIntObject;
              function isSymbolObject(value) {
                return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
              }
              exports2.isSymbolObject = isSymbolObject;
              function isBoxedPrimitive(value) {
                return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
              }
              exports2.isBoxedPrimitive = isBoxedPrimitive;
              function isAnyArrayBuffer(value) {
                return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
              }
              exports2.isAnyArrayBuffer = isAnyArrayBuffer;
              ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
                Object.defineProperty(exports2, method, {
                  enumerable: false,
                  value: function() {
                    throw new Error(method + " is not supported in userland");
                  }
                });
              });
            },
            /***/
            9636(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var implementation = __webpack_require__2(3249);
              module2.exports = function getPolyfill() {
                return typeof Object.is === "function" ? Object.is : implementation;
              };
            },
            /***/
            9663(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function() {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var WordArray = C_lib.WordArray;
                  var Hasher = C_lib.Hasher;
                  var C_algo = C.algo;
                  var W = [];
                  var SHA1 = C_algo.SHA1 = Hasher.extend({
                    _doReset: function() {
                      this._hash = new WordArray.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
                    },
                    _doProcessBlock: function(M, offset) {
                      var H = this._hash.words;
                      var a = H[0];
                      var b = H[1];
                      var c = H[2];
                      var d = H[3];
                      var e = H[4];
                      for (var i = 0; i < 80; i++) {
                        if (i < 16) {
                          W[i] = M[offset + i] | 0;
                        } else {
                          var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                          W[i] = n << 1 | n >>> 31;
                        }
                        var t = (a << 5 | a >>> 27) + e + W[i];
                        if (i < 20) {
                          t += (b & c | ~b & d) + 1518500249;
                        } else if (i < 40) {
                          t += (b ^ c ^ d) + 1859775393;
                        } else if (i < 60) {
                          t += (b & c | b & d | c & d) - 1894007588;
                        } else {
                          t += (b ^ c ^ d) - 899497514;
                        }
                        e = d;
                        d = c;
                        c = b << 30 | b >>> 2;
                        b = a;
                        a = t;
                      }
                      H[0] = H[0] + a | 0;
                      H[1] = H[1] + b | 0;
                      H[2] = H[2] + c | 0;
                      H[3] = H[3] + d | 0;
                      H[4] = H[4] + e | 0;
                    },
                    _doFinalize: function() {
                      var data = this._data;
                      var dataWords = data.words;
                      var nBitsTotal = this._nDataBytes * 8;
                      var nBitsLeft = data.sigBytes * 8;
                      dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                      dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
                      dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                      data.sigBytes = dataWords.length * 4;
                      this._process();
                      return this._hash;
                    },
                    clone: function() {
                      var clone = Hasher.clone.call(this);
                      clone._hash = this._hash.clone();
                      return clone;
                    }
                  });
                  C.SHA1 = Hasher._createHelper(SHA1);
                  C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
                })();
                return CryptoJS.SHA1;
              });
            },
            /***/
            9676(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var process = __webpack_require__2(9964);
              var _Object$setPrototypeO;
              function _defineProperty(obj, key, value) {
                key = _toPropertyKey(key);
                if (key in obj) {
                  Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function _toPropertyKey(arg) {
                var key = _toPrimitive(arg, "string");
                return typeof key === "symbol" ? key : String(key);
              }
              function _toPrimitive(input, hint) {
                if (typeof input !== "object" || input === null) return input;
                var prim = input[Symbol.toPrimitive];
                if (prim !== void 0) {
                  var res = prim.call(input, hint || "default");
                  if (typeof res !== "object") return res;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return (hint === "string" ? String : Number)(input);
              }
              var finished = __webpack_require__2(2167);
              var kLastResolve = Symbol("lastResolve");
              var kLastReject = Symbol("lastReject");
              var kError = Symbol("error");
              var kEnded = Symbol("ended");
              var kLastPromise = Symbol("lastPromise");
              var kHandlePromise = Symbol("handlePromise");
              var kStream = Symbol("stream");
              function createIterResult(value, done) {
                return {
                  value,
                  done
                };
              }
              function readAndResolve(iter) {
                var resolve = iter[kLastResolve];
                if (resolve !== null) {
                  var data = iter[kStream].read();
                  if (data !== null) {
                    iter[kLastPromise] = null;
                    iter[kLastResolve] = null;
                    iter[kLastReject] = null;
                    resolve(createIterResult(data, false));
                  }
                }
              }
              function onReadable(iter) {
                process.nextTick(readAndResolve, iter);
              }
              function wrapForNext(lastPromise, iter) {
                return function(resolve, reject) {
                  lastPromise.then(function() {
                    if (iter[kEnded]) {
                      resolve(createIterResult(void 0, true));
                      return;
                    }
                    iter[kHandlePromise](resolve, reject);
                  }, reject);
                };
              }
              var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
              });
              var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
                get stream() {
                  return this[kStream];
                },
                next: function next() {
                  var _this = this;
                  var error = this[kError];
                  if (error !== null) {
                    return Promise.reject(error);
                  }
                  if (this[kEnded]) {
                    return Promise.resolve(createIterResult(void 0, true));
                  }
                  if (this[kStream].destroyed) {
                    return new Promise(function(resolve, reject) {
                      process.nextTick(function() {
                        if (_this[kError]) {
                          reject(_this[kError]);
                        } else {
                          resolve(createIterResult(void 0, true));
                        }
                      });
                    });
                  }
                  var lastPromise = this[kLastPromise];
                  var promise;
                  if (lastPromise) {
                    promise = new Promise(wrapForNext(lastPromise, this));
                  } else {
                    var data = this[kStream].read();
                    if (data !== null) {
                      return Promise.resolve(createIterResult(data, false));
                    }
                    promise = new Promise(this[kHandlePromise]);
                  }
                  this[kLastPromise] = promise;
                  return promise;
                }
              }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
                return this;
              }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
                var _this2 = this;
                return new Promise(function(resolve, reject) {
                  _this2[kStream].destroy(null, function(err) {
                    if (err) {
                      reject(err);
                      return;
                    }
                    resolve(createIterResult(void 0, true));
                  });
                });
              }), _Object$setPrototypeO), AsyncIteratorPrototype);
              var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
                var _Object$create;
                var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
                  value: stream,
                  writable: true
                }), _defineProperty(_Object$create, kLastResolve, {
                  value: null,
                  writable: true
                }), _defineProperty(_Object$create, kLastReject, {
                  value: null,
                  writable: true
                }), _defineProperty(_Object$create, kError, {
                  value: null,
                  writable: true
                }), _defineProperty(_Object$create, kEnded, {
                  value: stream._readableState.endEmitted,
                  writable: true
                }), _defineProperty(_Object$create, kHandlePromise, {
                  value: function value(resolve, reject) {
                    var data = iterator[kStream].read();
                    if (data) {
                      iterator[kLastPromise] = null;
                      iterator[kLastResolve] = null;
                      iterator[kLastReject] = null;
                      resolve(createIterResult(data, false));
                    } else {
                      iterator[kLastResolve] = resolve;
                      iterator[kLastReject] = reject;
                    }
                  },
                  writable: true
                }), _Object$create));
                iterator[kLastPromise] = null;
                finished(stream, function(err) {
                  if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                    var reject = iterator[kLastReject];
                    if (reject !== null) {
                      iterator[kLastPromise] = null;
                      iterator[kLastResolve] = null;
                      iterator[kLastReject] = null;
                      reject(err);
                    }
                    iterator[kError] = err;
                    return;
                  }
                  var resolve = iterator[kLastResolve];
                  if (resolve !== null) {
                    iterator[kLastPromise] = null;
                    iterator[kLastResolve] = null;
                    iterator[kLastReject] = null;
                    resolve(createIterResult(void 0, true));
                  }
                  iterator[kEnded] = true;
                });
                stream.on("readable", onReadable.bind(null, iterator));
                return iterator;
              };
              module2.exports = createReadableStreamAsyncIterator;
            },
            /***/
            9738(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var aCallable = __webpack_require__2(1078);
              var isNullOrUndefined = __webpack_require__2(6297);
              module2.exports = function(V, P) {
                var func = V[P];
                return isNullOrUndefined(func) ? void 0 : aCallable(func);
              };
            },
            /***/
            9760(module2, __unused_webpack_exports, __webpack_require__2) {
              module2.exports = Stream;
              var EE = __webpack_require__2(4785).EventEmitter;
              var inherits = __webpack_require__2(9784);
              inherits(Stream, EE);
              Stream.Readable = __webpack_require__2(8261);
              Stream.Writable = __webpack_require__2(9781);
              Stream.Duplex = __webpack_require__2(4903);
              Stream.Transform = __webpack_require__2(8569);
              Stream.PassThrough = __webpack_require__2(7723);
              Stream.finished = __webpack_require__2(2167);
              Stream.pipeline = __webpack_require__2(3765);
              Stream.Stream = Stream;
              function Stream() {
                EE.call(this);
              }
              Stream.prototype.pipe = function(dest, options) {
                var source = this;
                function ondata(chunk) {
                  if (dest.writable) {
                    if (false === dest.write(chunk) && source.pause) {
                      source.pause();
                    }
                  }
                }
                source.on("data", ondata);
                function ondrain() {
                  if (source.readable && source.resume) {
                    source.resume();
                  }
                }
                dest.on("drain", ondrain);
                if (!dest._isStdio && (!options || options.end !== false)) {
                  source.on("end", onend);
                  source.on("close", onclose);
                }
                var didOnEnd = false;
                function onend() {
                  if (didOnEnd) return;
                  didOnEnd = true;
                  dest.end();
                }
                function onclose() {
                  if (didOnEnd) return;
                  didOnEnd = true;
                  if (typeof dest.destroy === "function") dest.destroy();
                }
                function onerror(er) {
                  cleanup();
                  if (EE.listenerCount(this, "error") === 0) {
                    throw er;
                  }
                }
                source.on("error", onerror);
                dest.on("error", onerror);
                function cleanup() {
                  source.removeListener("data", ondata);
                  dest.removeListener("drain", ondrain);
                  source.removeListener("end", onend);
                  source.removeListener("close", onclose);
                  source.removeListener("error", onerror);
                  dest.removeListener("error", onerror);
                  source.removeListener("end", cleanup);
                  source.removeListener("close", cleanup);
                  dest.removeListener("close", cleanup);
                }
                source.on("end", cleanup);
                source.on("close", cleanup);
                dest.on("close", cleanup);
                dest.emit("pipe", source);
                return dest;
              };
            },
            /***/
            9781(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var process = __webpack_require__2(9964);
              module2.exports = Writable;
              function WriteReq(chunk, encoding, cb) {
                this.chunk = chunk;
                this.encoding = encoding;
                this.callback = cb;
                this.next = null;
              }
              function CorkedRequest(state) {
                var _this = this;
                this.next = null;
                this.entry = null;
                this.finish = function() {
                  onCorkedFinish(_this, state);
                };
              }
              var Duplex;
              Writable.WritableState = WritableState;
              var internalUtil = {
                deprecate: __webpack_require__2(6465)
              };
              var Stream = __webpack_require__2(9018);
              var Buffer = __webpack_require__2(783).Buffer;
              var OurUint8Array = (typeof __webpack_require__2.g !== "undefined" ? __webpack_require__2.g : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
              };
              function _uint8ArrayToBuffer(chunk) {
                return Buffer.from(chunk);
              }
              function _isUint8Array(obj) {
                return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
              }
              var destroyImpl = __webpack_require__2(7385);
              var _require = __webpack_require__2(8130), getHighWaterMark = _require.getHighWaterMark;
              var _require$codes = __webpack_require__2(3797).F, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
              var errorOrDestroy = destroyImpl.errorOrDestroy;
              __webpack_require__2(9784)(Writable, Stream);
              function nop() {
              }
              function WritableState(options, stream, isDuplex) {
                Duplex = Duplex || __webpack_require__2(4903);
                options = options || {};
                if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
                this.objectMode = !!options.objectMode;
                if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
                this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
                this.finalCalled = false;
                this.needDrain = false;
                this.ending = false;
                this.ended = false;
                this.finished = false;
                this.destroyed = false;
                var noDecode = options.decodeStrings === false;
                this.decodeStrings = !noDecode;
                this.defaultEncoding = options.defaultEncoding || "utf8";
                this.length = 0;
                this.writing = false;
                this.corked = 0;
                this.sync = true;
                this.bufferProcessing = false;
                this.onwrite = function(er) {
                  onwrite(stream, er);
                };
                this.writecb = null;
                this.writelen = 0;
                this.bufferedRequest = null;
                this.lastBufferedRequest = null;
                this.pendingcb = 0;
                this.prefinished = false;
                this.errorEmitted = false;
                this.emitClose = options.emitClose !== false;
                this.autoDestroy = !!options.autoDestroy;
                this.bufferedRequestCount = 0;
                this.corkedRequestsFree = new CorkedRequest(this);
              }
              WritableState.prototype.getBuffer = function getBuffer() {
                var current = this.bufferedRequest;
                var out = [];
                while (current) {
                  out.push(current);
                  current = current.next;
                }
                return out;
              };
              (function() {
                try {
                  Object.defineProperty(WritableState.prototype, "buffer", {
                    get: internalUtil.deprecate(function writableStateBufferGetter() {
                      return this.getBuffer();
                    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                  });
                } catch (_) {
                }
              })();
              var realHasInstance;
              if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
                realHasInstance = Function.prototype[Symbol.hasInstance];
                Object.defineProperty(Writable, Symbol.hasInstance, {
                  value: function value(object) {
                    if (realHasInstance.call(this, object)) return true;
                    if (this !== Writable) return false;
                    return object && object._writableState instanceof WritableState;
                  }
                });
              } else {
                realHasInstance = function realHasInstance2(object) {
                  return object instanceof this;
                };
              }
              function Writable(options) {
                Duplex = Duplex || __webpack_require__2(4903);
                var isDuplex = this instanceof Duplex;
                if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
                this._writableState = new WritableState(options, this, isDuplex);
                this.writable = true;
                if (options) {
                  if (typeof options.write === "function") this._write = options.write;
                  if (typeof options.writev === "function") this._writev = options.writev;
                  if (typeof options.destroy === "function") this._destroy = options.destroy;
                  if (typeof options.final === "function") this._final = options.final;
                }
                Stream.call(this);
              }
              Writable.prototype.pipe = function() {
                errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
              };
              function writeAfterEnd(stream, cb) {
                var er = new ERR_STREAM_WRITE_AFTER_END();
                errorOrDestroy(stream, er);
                process.nextTick(cb, er);
              }
              function validChunk(stream, state, chunk, cb) {
                var er;
                if (chunk === null) {
                  er = new ERR_STREAM_NULL_VALUES();
                } else if (typeof chunk !== "string" && !state.objectMode) {
                  er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
                }
                if (er) {
                  errorOrDestroy(stream, er);
                  process.nextTick(cb, er);
                  return false;
                }
                return true;
              }
              Writable.prototype.write = function(chunk, encoding, cb) {
                var state = this._writableState;
                var ret = false;
                var isBuf = !state.objectMode && _isUint8Array(chunk);
                if (isBuf && !Buffer.isBuffer(chunk)) {
                  chunk = _uint8ArrayToBuffer(chunk);
                }
                if (typeof encoding === "function") {
                  cb = encoding;
                  encoding = null;
                }
                if (isBuf) encoding = "buffer";
                else if (!encoding) encoding = state.defaultEncoding;
                if (typeof cb !== "function") cb = nop;
                if (state.ending) writeAfterEnd(this, cb);
                else if (isBuf || validChunk(this, state, chunk, cb)) {
                  state.pendingcb++;
                  ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
                }
                return ret;
              };
              Writable.prototype.cork = function() {
                this._writableState.corked++;
              };
              Writable.prototype.uncork = function() {
                var state = this._writableState;
                if (state.corked) {
                  state.corked--;
                  if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
                }
              };
              Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
                if (typeof encoding === "string") encoding = encoding.toLowerCase();
                if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
                this._writableState.defaultEncoding = encoding;
                return this;
              };
              Object.defineProperty(Writable.prototype, "writableBuffer", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._writableState && this._writableState.getBuffer();
                }
              });
              function decodeChunk(state, chunk, encoding) {
                if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
                  chunk = Buffer.from(chunk, encoding);
                }
                return chunk;
              }
              Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._writableState.highWaterMark;
                }
              });
              function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
                if (!isBuf) {
                  var newChunk = decodeChunk(state, chunk, encoding);
                  if (chunk !== newChunk) {
                    isBuf = true;
                    encoding = "buffer";
                    chunk = newChunk;
                  }
                }
                var len = state.objectMode ? 1 : chunk.length;
                state.length += len;
                var ret = state.length < state.highWaterMark;
                if (!ret) state.needDrain = true;
                if (state.writing || state.corked) {
                  var last = state.lastBufferedRequest;
                  state.lastBufferedRequest = {
                    chunk,
                    encoding,
                    isBuf,
                    callback: cb,
                    next: null
                  };
                  if (last) {
                    last.next = state.lastBufferedRequest;
                  } else {
                    state.bufferedRequest = state.lastBufferedRequest;
                  }
                  state.bufferedRequestCount += 1;
                } else {
                  doWrite(stream, state, false, len, chunk, encoding, cb);
                }
                return ret;
              }
              function doWrite(stream, state, writev, len, chunk, encoding, cb) {
                state.writelen = len;
                state.writecb = cb;
                state.writing = true;
                state.sync = true;
                if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
                else if (writev) stream._writev(chunk, state.onwrite);
                else stream._write(chunk, encoding, state.onwrite);
                state.sync = false;
              }
              function onwriteError(stream, state, sync, er, cb) {
                --state.pendingcb;
                if (sync) {
                  process.nextTick(cb, er);
                  process.nextTick(finishMaybe, stream, state);
                  stream._writableState.errorEmitted = true;
                  errorOrDestroy(stream, er);
                } else {
                  cb(er);
                  stream._writableState.errorEmitted = true;
                  errorOrDestroy(stream, er);
                  finishMaybe(stream, state);
                }
              }
              function onwriteStateUpdate(state) {
                state.writing = false;
                state.writecb = null;
                state.length -= state.writelen;
                state.writelen = 0;
              }
              function onwrite(stream, er) {
                var state = stream._writableState;
                var sync = state.sync;
                var cb = state.writecb;
                if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
                onwriteStateUpdate(state);
                if (er) onwriteError(stream, state, sync, er, cb);
                else {
                  var finished = needFinish(state) || stream.destroyed;
                  if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                    clearBuffer(stream, state);
                  }
                  if (sync) {
                    process.nextTick(afterWrite, stream, state, finished, cb);
                  } else {
                    afterWrite(stream, state, finished, cb);
                  }
                }
              }
              function afterWrite(stream, state, finished, cb) {
                if (!finished) onwriteDrain(stream, state);
                state.pendingcb--;
                cb();
                finishMaybe(stream, state);
              }
              function onwriteDrain(stream, state) {
                if (state.length === 0 && state.needDrain) {
                  state.needDrain = false;
                  stream.emit("drain");
                }
              }
              function clearBuffer(stream, state) {
                state.bufferProcessing = true;
                var entry = state.bufferedRequest;
                if (stream._writev && entry && entry.next) {
                  var l = state.bufferedRequestCount;
                  var buffer = new Array(l);
                  var holder = state.corkedRequestsFree;
                  holder.entry = entry;
                  var count = 0;
                  var allBuffers = true;
                  while (entry) {
                    buffer[count] = entry;
                    if (!entry.isBuf) allBuffers = false;
                    entry = entry.next;
                    count += 1;
                  }
                  buffer.allBuffers = allBuffers;
                  doWrite(stream, state, true, state.length, buffer, "", holder.finish);
                  state.pendingcb++;
                  state.lastBufferedRequest = null;
                  if (holder.next) {
                    state.corkedRequestsFree = holder.next;
                    holder.next = null;
                  } else {
                    state.corkedRequestsFree = new CorkedRequest(state);
                  }
                  state.bufferedRequestCount = 0;
                } else {
                  while (entry) {
                    var chunk = entry.chunk;
                    var encoding = entry.encoding;
                    var cb = entry.callback;
                    var len = state.objectMode ? 1 : chunk.length;
                    doWrite(stream, state, false, len, chunk, encoding, cb);
                    entry = entry.next;
                    state.bufferedRequestCount--;
                    if (state.writing) {
                      break;
                    }
                  }
                  if (entry === null) state.lastBufferedRequest = null;
                }
                state.bufferedRequest = entry;
                state.bufferProcessing = false;
              }
              Writable.prototype._write = function(chunk, encoding, cb) {
                cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
              };
              Writable.prototype._writev = null;
              Writable.prototype.end = function(chunk, encoding, cb) {
                var state = this._writableState;
                if (typeof chunk === "function") {
                  cb = chunk;
                  chunk = null;
                  encoding = null;
                } else if (typeof encoding === "function") {
                  cb = encoding;
                  encoding = null;
                }
                if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
                if (state.corked) {
                  state.corked = 1;
                  this.uncork();
                }
                if (!state.ending) endWritable(this, state, cb);
                return this;
              };
              Object.defineProperty(Writable.prototype, "writableLength", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._writableState.length;
                }
              });
              function needFinish(state) {
                return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
              }
              function callFinal(stream, state) {
                stream._final(function(err) {
                  state.pendingcb--;
                  if (err) {
                    errorOrDestroy(stream, err);
                  }
                  state.prefinished = true;
                  stream.emit("prefinish");
                  finishMaybe(stream, state);
                });
              }
              function prefinish(stream, state) {
                if (!state.prefinished && !state.finalCalled) {
                  if (typeof stream._final === "function" && !state.destroyed) {
                    state.pendingcb++;
                    state.finalCalled = true;
                    process.nextTick(callFinal, stream, state);
                  } else {
                    state.prefinished = true;
                    stream.emit("prefinish");
                  }
                }
              }
              function finishMaybe(stream, state) {
                var need = needFinish(state);
                if (need) {
                  prefinish(stream, state);
                  if (state.pendingcb === 0) {
                    state.finished = true;
                    stream.emit("finish");
                    if (state.autoDestroy) {
                      var rState = stream._readableState;
                      if (!rState || rState.autoDestroy && rState.endEmitted) {
                        stream.destroy();
                      }
                    }
                  }
                }
                return need;
              }
              function endWritable(stream, state, cb) {
                state.ending = true;
                finishMaybe(stream, state);
                if (cb) {
                  if (state.finished) process.nextTick(cb);
                  else stream.once("finish", cb);
                }
                state.ended = true;
                stream.writable = false;
              }
              function onCorkedFinish(corkReq, state, err) {
                var entry = corkReq.entry;
                corkReq.entry = null;
                while (entry) {
                  var cb = entry.callback;
                  state.pendingcb--;
                  cb(err);
                  entry = entry.next;
                }
                state.corkedRequestsFree.next = corkReq;
              }
              Object.defineProperty(Writable.prototype, "destroyed", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  if (this._writableState === void 0) {
                    return false;
                  }
                  return this._writableState.destroyed;
                },
                set: function set(value) {
                  if (!this._writableState) {
                    return;
                  }
                  this._writableState.destroyed = value;
                }
              });
              Writable.prototype.destroy = destroyImpl.destroy;
              Writable.prototype._undestroy = destroyImpl.undestroy;
              Writable.prototype._destroy = function(err, cb) {
                cb(err);
              };
            },
            /***/
            9784(module2) {
              if (typeof Object.create === "function") {
                module2.exports = function inherits(ctor, superCtor) {
                  if (superCtor) {
                    ctor.super_ = superCtor;
                    ctor.prototype = Object.create(superCtor.prototype, {
                      constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true
                      }
                    });
                  }
                };
              } else {
                module2.exports = function inherits(ctor, superCtor) {
                  if (superCtor) {
                    ctor.super_ = superCtor;
                    var TempCtor = function() {
                    };
                    TempCtor.prototype = superCtor.prototype;
                    ctor.prototype = new TempCtor();
                    ctor.prototype.constructor = ctor;
                  }
                };
              }
            },
            /***/
            9851(module2, exports2, __webpack_require__2) {
              "use strict";
              ;
              (function(root, factory, undef) {
                if (true) {
                  module2.exports = exports2 = factory(__webpack_require__2(6861), __webpack_require__2(4866), __webpack_require__2(3532), __webpack_require__2(6818), __webpack_require__2(2858));
                } else {
                }
              })(void 0, function(CryptoJS) {
                (function() {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var BlockCipher = C_lib.BlockCipher;
                  var C_algo = C.algo;
                  var SBOX = [];
                  var INV_SBOX = [];
                  var SUB_MIX_0 = [];
                  var SUB_MIX_1 = [];
                  var SUB_MIX_2 = [];
                  var SUB_MIX_3 = [];
                  var INV_SUB_MIX_0 = [];
                  var INV_SUB_MIX_1 = [];
                  var INV_SUB_MIX_2 = [];
                  var INV_SUB_MIX_3 = [];
                  (function() {
                    var d = [];
                    for (var i = 0; i < 256; i++) {
                      if (i < 128) {
                        d[i] = i << 1;
                      } else {
                        d[i] = i << 1 ^ 283;
                      }
                    }
                    var x = 0;
                    var xi = 0;
                    for (var i = 0; i < 256; i++) {
                      var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
                      sx = sx >>> 8 ^ sx & 255 ^ 99;
                      SBOX[x] = sx;
                      INV_SBOX[sx] = x;
                      var x2 = d[x];
                      var x4 = d[x2];
                      var x8 = d[x4];
                      var t = d[sx] * 257 ^ sx * 16843008;
                      SUB_MIX_0[x] = t << 24 | t >>> 8;
                      SUB_MIX_1[x] = t << 16 | t >>> 16;
                      SUB_MIX_2[x] = t << 8 | t >>> 24;
                      SUB_MIX_3[x] = t;
                      var t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
                      INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
                      INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
                      INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
                      INV_SUB_MIX_3[sx] = t;
                      if (!x) {
                        x = xi = 1;
                      } else {
                        x = x2 ^ d[d[d[x8 ^ x2]]];
                        xi ^= d[d[xi]];
                      }
                    }
                  })();
                  var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
                  var AES = C_algo.AES = BlockCipher.extend({
                    _doReset: function() {
                      var t;
                      if (this._nRounds && this._keyPriorReset === this._key) {
                        return;
                      }
                      var key = this._keyPriorReset = this._key;
                      var keyWords = key.words;
                      var keySize = key.sigBytes / 4;
                      var nRounds = this._nRounds = keySize + 6;
                      var ksRows = (nRounds + 1) * 4;
                      var keySchedule = this._keySchedule = [];
                      for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                        if (ksRow < keySize) {
                          keySchedule[ksRow] = keyWords[ksRow];
                        } else {
                          t = keySchedule[ksRow - 1];
                          if (!(ksRow % keySize)) {
                            t = t << 8 | t >>> 24;
                            t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                            t ^= RCON[ksRow / keySize | 0] << 24;
                          } else if (keySize > 6 && ksRow % keySize == 4) {
                            t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                          }
                          keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                        }
                      }
                      var invKeySchedule = this._invKeySchedule = [];
                      for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                        var ksRow = ksRows - invKsRow;
                        if (invKsRow % 4) {
                          var t = keySchedule[ksRow];
                        } else {
                          var t = keySchedule[ksRow - 4];
                        }
                        if (invKsRow < 4 || ksRow <= 4) {
                          invKeySchedule[invKsRow] = t;
                        } else {
                          invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
                        }
                      }
                    },
                    encryptBlock: function(M, offset) {
                      this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
                    },
                    decryptBlock: function(M, offset) {
                      var t = M[offset + 1];
                      M[offset + 1] = M[offset + 3];
                      M[offset + 3] = t;
                      this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
                      var t = M[offset + 1];
                      M[offset + 1] = M[offset + 3];
                      M[offset + 3] = t;
                    },
                    _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
                      var nRounds = this._nRounds;
                      var s0 = M[offset] ^ keySchedule[0];
                      var s1 = M[offset + 1] ^ keySchedule[1];
                      var s2 = M[offset + 2] ^ keySchedule[2];
                      var s3 = M[offset + 3] ^ keySchedule[3];
                      var ksRow = 4;
                      for (var round = 1; round < nRounds; round++) {
                        var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
                        var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
                        var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
                        var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
                        s0 = t0;
                        s1 = t1;
                        s2 = t2;
                        s3 = t3;
                      }
                      var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
                      var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
                      var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
                      var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
                      M[offset] = t0;
                      M[offset + 1] = t1;
                      M[offset + 2] = t2;
                      M[offset + 3] = t3;
                    },
                    keySize: 256 / 32
                  });
                  C.AES = BlockCipher._createHelper(AES);
                })();
                return CryptoJS.AES;
              });
            },
            /***/
            9877(module2, __unused_webpack_exports, __webpack_require__2) {
              "use strict";
              var uncurryThis = __webpack_require__2(1212);
              module2.exports = uncurryThis({}.isPrototypeOf);
            },
            /***/
            9964(module2) {
              var process = module2.exports = {};
              var cachedSetTimeout;
              var cachedClearTimeout;
              function defaultSetTimout() {
                throw new Error("setTimeout has not been defined");
              }
              function defaultClearTimeout() {
                throw new Error("clearTimeout has not been defined");
              }
              (function() {
                try {
                  if (typeof setTimeout === "function") {
                    cachedSetTimeout = setTimeout;
                  } else {
                    cachedSetTimeout = defaultSetTimout;
                  }
                } catch (e) {
                  cachedSetTimeout = defaultSetTimout;
                }
                try {
                  if (typeof clearTimeout === "function") {
                    cachedClearTimeout = clearTimeout;
                  } else {
                    cachedClearTimeout = defaultClearTimeout;
                  }
                } catch (e) {
                  cachedClearTimeout = defaultClearTimeout;
                }
              })();
              function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) {
                  return setTimeout(fun, 0);
                }
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                  cachedSetTimeout = setTimeout;
                  return setTimeout(fun, 0);
                }
                try {
                  return cachedSetTimeout(fun, 0);
                } catch (e) {
                  try {
                    return cachedSetTimeout.call(null, fun, 0);
                  } catch (e2) {
                    return cachedSetTimeout.call(this, fun, 0);
                  }
                }
              }
              function runClearTimeout(marker) {
                if (cachedClearTimeout === clearTimeout) {
                  return clearTimeout(marker);
                }
                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                  cachedClearTimeout = clearTimeout;
                  return clearTimeout(marker);
                }
                try {
                  return cachedClearTimeout(marker);
                } catch (e) {
                  try {
                    return cachedClearTimeout.call(null, marker);
                  } catch (e2) {
                    return cachedClearTimeout.call(this, marker);
                  }
                }
              }
              var queue = [];
              var draining = false;
              var currentQueue;
              var queueIndex = -1;
              function cleanUpNextTick() {
                if (!draining || !currentQueue) {
                  return;
                }
                draining = false;
                if (currentQueue.length) {
                  queue = currentQueue.concat(queue);
                } else {
                  queueIndex = -1;
                }
                if (queue.length) {
                  drainQueue();
                }
              }
              function drainQueue() {
                if (draining) {
                  return;
                }
                var timeout = runTimeout(cleanUpNextTick);
                draining = true;
                var len = queue.length;
                while (len) {
                  currentQueue = queue;
                  queue = [];
                  while (++queueIndex < len) {
                    if (currentQueue) {
                      currentQueue[queueIndex].run();
                    }
                  }
                  queueIndex = -1;
                  len = queue.length;
                }
                currentQueue = null;
                draining = false;
                runClearTimeout(timeout);
              }
              process.nextTick = function(fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                  for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                  }
                }
                queue.push(new Item(fun, args));
                if (queue.length === 1 && !draining) {
                  runTimeout(drainQueue);
                }
              };
              function Item(fun, array) {
                this.fun = fun;
                this.array = array;
              }
              Item.prototype.run = function() {
                this.fun.apply(null, this.array);
              };
              process.title = "browser";
              process.browser = true;
              process.env = {};
              process.argv = [];
              process.version = "";
              process.versions = {};
              function noop() {
              }
              process.on = noop;
              process.addListener = noop;
              process.once = noop;
              process.off = noop;
              process.removeListener = noop;
              process.removeAllListeners = noop;
              process.emit = noop;
              process.prependListener = noop;
              process.prependOnceListener = noop;
              process.listeners = function(name) {
                return [];
              };
              process.binding = function(name) {
                throw new Error("process.binding is not supported");
              };
              process.cwd = function() {
                return "/";
              };
              process.chdir = function(dir) {
                throw new Error("process.chdir is not supported");
              };
              process.umask = function() {
                return 0;
              };
            }
            /******/
          };
          var __webpack_module_cache__ = {};
          function __webpack_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              id: moduleId,
              /******/
              loaded: false,
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.loaded = true;
            return module2.exports;
          }
          (() => {
            __webpack_require__.n = (module2) => {
              var getter = module2 && module2.__esModule ? (
                /******/
                () => module2["default"]
              ) : (
                /******/
                () => module2
              );
              __webpack_require__.d(getter, { a: getter });
              return getter;
            };
          })();
          (() => {
            __webpack_require__.d = (exports2, definition) => {
              for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                  Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          })();
          (() => {
            __webpack_require__.g = function() {
              if (typeof globalThis === "object") return globalThis;
              try {
                return this || new Function("return this")();
              } catch (e) {
                if (typeof window === "object") return window;
              }
            }();
          })();
          (() => {
            __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
          })();
          (() => {
            __webpack_require__.nmd = (module2) => {
              module2.paths = [];
              if (!module2.children) module2.children = [];
              return module2;
            };
          })();
          var __webpack_exports__ = __webpack_require__(6092);
          return __webpack_exports__;
        })()
      );
    });
  }
});
export default require_pdfmake();
/*! Bundled license information:

pdfmake/build/pdfmake.js:
  (*! pdfmake v0.3.3, @license MIT, @link http://pdfmake.org *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)
  (** @preserve
  (c) 2012 by Cdric Mesnil. All rights reserved.
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=pdfmake_build_pdfmake.js.map
